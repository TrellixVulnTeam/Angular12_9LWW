import * as i0 from '@angular/core';
import { Injectable, Component, ChangeDetectionStrategy, Input, ViewEncapsulation, Inject, NgModule, Optional, Directive, EventEmitter, Self, Output, HostListener, ViewChildren, ContentChild, Pipe, ViewChild, InjectionToken, APP_INITIALIZER, Injector } from '@angular/core';
import * as i1$1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i9$1 from '@angular/material/badge';
import { MatBadgeModule } from '@angular/material/badge';
import * as i4 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import * as i1$3 from '@angular/material/list';
import { MatListModule } from '@angular/material/list';
import * as i3 from '@angular/material/tooltip';
import { MatTooltipModule } from '@angular/material/tooltip';
import * as i6 from '@igo2/common';
import { getEntityId, getEntityTitle, getEntityProperty, getEntityRevision, getEntityIcon, EntityStore, EntityStoreStrategy, EntityStoreWatcher, SecureImagePipe, IgoListModule, IgoCollapsibleModule, IgoImageModule, IgoPanelModule, IgoMatBadgeIconModule, IgoCustomHtmlModule, IgoEntityTableModule, IgoKeyValueModule, IgoFormModule, IgoFormFieldComponent, EntityStoreFilterSelectionStrategy, EntityTableColumnRenderer, IgoEntityModule, DragAndDropDirective, IgoSpinnerModule, IgoDrapDropModule, IgoConfirmDialogModule, getEntityTitleHtml, EntityStoreFilterCustomFuncStrategy, IgoStopPropagationModule, IgoFlexibleModule, WidgetService, Workspace, ActionStore, IgoWidgetModule } from '@igo2/common';
import * as i2 from '@angular/material/button';
import { MatButtonModule } from '@angular/material/button';
import * as i2$1 from '@igo2/core';
import { IgoLanguageModule, ConfigService, Media, StorageScope, LanguageService, StorageService } from '@igo2/core';
import * as i1 from '@angular/material/dialog';
import { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import * as i7 from '@ngx-translate/core';
import { BehaviorSubject, combineLatest, Observable, of, forkJoin, Subject, zip, EMPTY, ReplaySubject, timer, fromEvent, throwError } from 'rxjs';
import { first, map, concatMap, catchError, skipWhile, debounceTime, skip, distinctUntilChanged, take, mergeMap, debounce, takeUntil } from 'rxjs/operators';
import { Watcher, uuid, SubjectStatus, ObjectUtils, NumberUtils, userAgent, downloadContent, strEnum, Clipboard, ChangeUtils } from '@igo2/utils';
import olMap from 'ol/Map';
import olView from 'ol/View';
import OlFeature from 'ol/Feature';
import olGeolocation from 'ol/Geolocation';
import olAttribution from 'ol/control/Attribution';
import olControlScaleLine from 'ol/control/ScaleLine';
import * as olproj from 'ol/proj';
import { transform } from 'ol/proj';
import * as olproj4 from 'ol/proj/proj4';
import OlPoint from 'ol/geom/Point';
import * as olInteraction from 'ol/interaction';
import OlCircle from 'ol/geom/Circle';
import * as olstyle from 'ol/style';
import proj4 from 'proj4';
import * as olextent from 'ol/extent';
import { getCenter } from 'ol/extent';
import OlGeometryLayout from 'ol/geom/GeometryLayout';
import OlPolygon, { circular, fromCircle } from 'ol/geom/Polygon';
import OlLineString from 'ol/geom/LineString';
import OlGeoJSON from 'ol/format/GeoJSON';
import OlVectorLayer from 'ol/layer/Vector';
import * as olObservable from 'ol/Observable';
import { unByKey } from 'ol/Observable';
import * as oleasing from 'ol/easing';
import { easeOut } from 'ol/easing';
import { asArray } from 'ol/color';
import { getVectorContext, getRenderPixel } from 'ol/render';
import FormatType from 'ol/format/FormatType';
import olProjection from 'ol/proj/Projection';
import olSourceImageWMS from 'ol/source/ImageWMS';
import { Md5 } from 'ts-md5';
import * as olfilter from 'ol/format/filter';
import olWKT from 'ol/format/WKT';
import olFormatWFS from 'ol/format/WFS';
import * as moment_ from 'moment';
import * as olformat from 'ol/format';
import { WMSCapabilities, WMTSCapabilities, EsriJSON } from 'ol/format';
import olFormatGML2 from 'ol/format/GML2';
import olFormatGML3 from 'ol/format/GML3';
import olFormatGML32 from 'ol/format/GML32';
import olFormatOSMXML from 'ol/format/OSMXML';
import olSourceCluster from 'ol/source/Cluster';
import OlVectorSource from 'ol/source/Vector';
import { MAC } from 'ol/has';
import olSourceOSM from 'ol/source/OSM';
import olSourceXYZ from 'ol/source/XYZ';
import * as OlLoadingStrategy from 'ol/loadingstrategy';
import * as i1$2 from '@angular/common/http';
import { HttpParams, HttpClient, HttpHeaders } from '@angular/common/http';
import olSourceWMTS from 'ol/source/WMTS';
import olTileGridWMTS from 'ol/tilegrid/WMTS';
import { getWidth, getTopLeft } from 'ol/extent.js';
import olSourceCarto from 'ol/source/CartoDB';
import olFormatEsriJSON from 'ol/format/EsriJSON';
import ImageArcGISRest from 'ol/source/ImageArcGISRest';
import olSourceTileArcGISRest from 'ol/source/TileArcGISRest';
import TileDebug from 'ol/source/TileDebug';
import TileGrid from 'ol/tilegrid/TileGrid';
import olSourceVectorTile from 'ol/source/VectorTile';
import olFormatMVT from 'ol/format/MVT';
import { __decorate, __awaiter } from 'tslib';
import { Cacheable } from 'ts-cacheable';
import { optionsFromCapabilities } from 'ol/source/WMTS.js';
import * as i5 from '@igo2/auth';
import { AuthService } from '@igo2/auth';
import OlDragBoxInteraction from 'ol/interaction/DragBox';
import olLayerVectorTile from 'ol/layer/VectorTile';
import * as olgeom from 'ol/geom';
import olLayerImage from 'ol/layer/Image';
import olLayerTile from 'ol/layer/Tile';
import RenderFeature from 'ol/render/Feature';
import { trigger, state, style, transition, animate } from '@angular/animations';
import stylefunction from 'ol-mapbox-style/dist/stylefunction';
import * as striptags_ from 'striptags';
import * as i9 from '@angular/material/core';
import { MAT_DATE_LOCALE, MatOptionModule, MatNativeDateModule } from '@angular/material/core';
import * as i12 from '@angular/material/form-field';
import { MatFormFieldModule } from '@angular/material/form-field';
import * as i13 from '@angular/material/select';
import { MatSelectModule } from '@angular/material/select';
import * as i16 from '@angular/forms';
import { FormsModule, Validators, ReactiveFormsModule, FormControl } from '@angular/forms';
import * as i11 from '@angular/material/checkbox';
import { MatCheckboxModule } from '@angular/material/checkbox';
import * as i10 from '@angular/material/divider';
import { MatDividerModule } from '@angular/material/divider';
import * as i5$1 from '@angular/material/input';
import { MatInputModule } from '@angular/material/input';
import * as i5$2 from '@angular/material/menu';
import { MatMenuModule } from '@angular/material/menu';
import * as i22 from '@angular/material/slide-toggle';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import * as i13$1 from '@angular/material/slider';
import { MatSliderModule, MatSlider } from '@angular/material/slider';
import * as i6$1 from '@angular/material/autocomplete';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import * as i18 from '@angular/material/button-toggle';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import * as i12$1 from 'ngx-color-picker';
import { ColorPickerModule } from 'ngx-color-picker';
import * as i1$4 from '@angular/platform-browser';
import OlDraw from 'ol/interaction/Draw';
import OlModify from 'ol/interaction/Modify';
import OlSelect from 'ol/interaction/Select';
import * as olCondition from 'ol/events/condition';
import { doubleClick } from 'ol/events/condition';
import lineIntersect from '@turf/line-intersect';
import { lineString } from '@turf/helpers';
import { getLength, getArea, getDistance } from 'ol/sphere';
import OlOverlay from 'ol/Overlay';
import pointOnFeature from '@turf/point-on-feature';
import * as i25 from '@angular/material/datepicker';
import { MatDatepickerModule } from '@angular/material/datepicker';
import * as i19 from '@angular/material/radio';
import { MatRadioModule } from '@angular/material/radio';
import * as i23 from '@angular/material/table';
import { MatTableModule } from '@angular/material/table';
import * as i20 from '@angular/material/tabs';
import { MatTabsModule } from '@angular/material/tabs';
import * as i24 from '@angular/material/tree';
import { MatTreeNestedDataSource, MatTreeModule } from '@angular/material/tree';
import * as i4$1 from '@mat-datetimepicker/core';
import { MatDatetimepickerModule, MatNativeDatetimeModule } from '@mat-datetimepicker/core';
import OlStyle from 'ol/style/Style';
import OlTranslate from 'ol/interaction/Translate';
import OlLinearRing from 'ol/geom/LinearRing';
import { SelectionModel } from '@angular/cdk/collections';
import { NestedTreeControl } from '@angular/cdk/tree';
import { saveAs } from 'file-saver';
import jspdf from 'jspdf';
import html2canvas from 'html2canvas';
import * as JSZip from 'jszip';
import * as i2$2 from '@angular/cdk/drag-drop';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import Collection from 'ol/Collection';

class MetadataService {
    constructor() { }
    open(metadata) {
        if (metadata.extern) {
            window.open(metadata.url, '_blank');
        }
    }
}
MetadataService.ɵfac = function MetadataService_Factory(t) { return new (t || MetadataService)(); };
MetadataService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: MetadataService, factory: MetadataService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MetadataService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

function MetadataButtonComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 1);
    i0.ɵɵlistener("click", function MetadataButtonComponent_button_0_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r2); const ctx_r1 = i0.ɵɵnextContext(); return ctx_r1.openMetadata(ctx_r1.options.metadata); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 2, "igo.geo.metadata.show"))("color", ctx_r0.color);
} }
function MetadataAbstractComponent_mat_dialog_content_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-dialog-content", 3);
    i0.ɵɵelementStart(1, "h3");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r0.data.abstract);
} }
function MetadataAbstractComponent_mat_dialog_content_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-dialog-content", 3);
    i0.ɵɵelement(1, "h3", 4);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("innerHTML", ctx_r1.data.abstract, i0.ɵɵsanitizeHtml);
} }
class MetadataButtonComponent {
    constructor(metadataService, dialog) {
        this.metadataService = metadataService;
        this.dialog = dialog;
        this._color = 'primary';
    }
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    openMetadata(metadata) {
        if (metadata.extern) {
            this.metadataService.open(metadata);
        }
        else if (!metadata.extern && metadata.abstract) {
            this.dialog.open(MetadataAbstractComponent, {
                data: {
                    layerTitle: this.layer.title,
                    abstract: metadata.abstract,
                    type: metadata.type
                }
            });
        }
    }
    get options() {
        if (!this.layer) {
            return;
        }
        return this.layer.options;
    }
}
MetadataButtonComponent.ɵfac = function MetadataButtonComponent_Factory(t) { return new (t || MetadataButtonComponent)(i0.ɵɵdirectiveInject(MetadataService), i0.ɵɵdirectiveInject(i1.MatDialog)); };
MetadataButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MetadataButtonComponent, selectors: [["igo-metadata-button"]], inputs: { layer: "layer", color: "color" }, decls: 1, vars: 1, consts: [["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", "click", 4, "ngIf"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", "click"], ["svgIcon", "information-outline"]], template: function MetadataButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, MetadataButtonComponent_button_0_Template, 3, 4, "button", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.options && ctx.options.metadata && ctx.options.metadata.url || ctx.options && ctx.options.metadata && ctx.options.metadata.abstract);
    } }, directives: [i1$1.NgIf, i2.MatButton, i3.MatTooltip, i4.MatIcon], pipes: [i7.TranslatePipe], styles: [""], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MetadataButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-metadata-button',
                templateUrl: './metadata-button.component.html',
                styleUrls: ['./metadata-button.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: MetadataService }, { type: i1.MatDialog }]; }, { layer: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();
class MetadataAbstractComponent {
    constructor(data) {
        this.data = data;
    }
}
MetadataAbstractComponent.ɵfac = function MetadataAbstractComponent_Factory(t) { return new (t || MetadataAbstractComponent)(i0.ɵɵdirectiveInject(MAT_DIALOG_DATA)); };
MetadataAbstractComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MetadataAbstractComponent, selectors: [["igo-metadata-abstract"]], decls: 6, vars: 3, consts: [["mat-dialog-title", ""], ["mat-button", "", "mat-dialog-close", "", 1, "close-button"], ["class", "mat-typography", 4, "ngIf"], [1, "mat-typography"], [3, "innerHTML"]], template: function MetadataAbstractComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "h2", 0);
        i0.ɵɵtext(1);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(2, "button", 1);
        i0.ɵɵtext(3, "X");
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(4, MetadataAbstractComponent_mat_dialog_content_4_Template, 3, 1, "mat-dialog-content", 2);
        i0.ɵɵtemplate(5, MetadataAbstractComponent_mat_dialog_content_5_Template, 2, 1, "mat-dialog-content", 2);
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.data.layerTitle);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.data.type !== "arcgisrest");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.data.type === "arcgisrest");
    } }, directives: [i1.MatDialogTitle, i2.MatButton, i1.MatDialogClose, i1$1.NgIf, i1.MatDialogContent], styles: [".close-button{top:5px;right:5px;padding:7px;line-height:10px;position:absolute!important;min-width:auto}mat-dialog-container{position:relative}\n"], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MetadataAbstractComponent, [{
        type: Component,
        args: [{
                selector: 'igo-metadata-abstract',
                templateUrl: './metadata-abstract.component.html',
                styleUrls: ['./metadata-abstract.component.scss'],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [MAT_DIALOG_DATA]
            }] }]; }, null); })();

class IgoMetadataModule {
    static forRoot() {
        return {
            ngModule: IgoMetadataModule,
            providers: []
        };
    }
}
IgoMetadataModule.ɵfac = function IgoMetadataModule_Factory(t) { return new (t || IgoMetadataModule)(); };
IgoMetadataModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoMetadataModule });
IgoMetadataModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatIconModule,
            MatButtonModule,
            MatTooltipModule,
            IgoLanguageModule,
            MatDialogModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoMetadataModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatIconModule,
                    MatButtonModule,
                    MatTooltipModule,
                    IgoLanguageModule,
                    MatDialogModule
                ],
                exports: [
                    MetadataButtonComponent,
                    MetadataAbstractComponent
                ],
                declarations: [
                    MetadataButtonComponent,
                    MetadataAbstractComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoMetadataModule, { declarations: [MetadataButtonComponent,
        MetadataAbstractComponent], imports: [CommonModule,
        MatIconModule,
        MatButtonModule,
        MatTooltipModule,
        IgoLanguageModule,
        MatDialogModule], exports: [MetadataButtonComponent,
        MetadataAbstractComponent] }); })();

const FEATURE = 'Feature';
var FeatureMotion;
(function (FeatureMotion) {
    FeatureMotion[FeatureMotion["None"] = 0] = "None";
    FeatureMotion[FeatureMotion["Move"] = 1] = "Move";
    FeatureMotion[FeatureMotion["Zoom"] = 2] = "Zoom";
    FeatureMotion[FeatureMotion["Default"] = 3] = "Default";
})(FeatureMotion || (FeatureMotion = {}));

class ImageWatcher extends Watcher {
    constructor(layer, messageService, languageService) {
        super();
        this.loaded = 0;
        this.loading = 0;
        this.source = layer.options.source.ol;
        this.id = uuid();
        this.messageService = messageService;
        this.languageService = languageService;
    }
    watch() {
        this.source.on(`imageloadstart`, e => this.handleLoadStart(e));
        this.source.on(`imageloadend`, e => this.handleLoadEnd(e));
        this.source.on(`imageloaderror`, e => this.handleLoadEnd(e));
        this.source.on(`imageloaderror`, e => this.handleLoadError(e));
    }
    unwatch() {
        this.source.un(`imageloadstart`, e => this.handleLoadStart(e));
        this.source.un(`imageloadend`, e => this.handleLoadEnd(e));
        this.source.un(`imageloaderror`, e => this.handleLoadEnd(e));
        this.source.un(`imageloaderror`, e => this.handleLoadError(e));
    }
    handleLoadStart(event) {
        if (!event.image.__watchers__) {
            event.image.__watchers__ = [];
        }
        event.image.__watchers__.push(this.id);
        this.loading += 1;
        this.status = SubjectStatus.Working;
    }
    handleLoadEnd(event) {
        if (!event.image.__watchers__) {
            return;
        }
        const watcherIndex = event.image.__watchers__.indexOf(this.id);
        if (watcherIndex < 0) {
            return;
        }
        event.image.__watchers__.splice(watcherIndex, 1);
        this.loaded += 1;
        const loading = this.loading;
        if (this.loaded >= loading) {
            if (loading === this.loading) {
                this.status = SubjectStatus.Done;
                this.loaded = this.loading = 0;
            }
        }
    }
    handleLoadError(event) {
        if (!event.image.__watchers__) {
            return;
        }
        const title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
        const message = this.languageService.translate.instant('igo.geo.dataSource.unavailable', { value: event.target.params_.LAYERS });
        this.messageService.error(message, title);
        this.loaded = -1;
        this.loading = 0;
        this.status = SubjectStatus.Error;
    }
}

function computeMVTOptionsOnHover(layerOptions) {
    var _a, _b;
    const vectorTileLayerOptions = layerOptions;
    if (((_a = vectorTileLayerOptions.sourceOptions) === null || _a === void 0 ? void 0 : _a.type) === 'mvt' &&
        (((_b = vectorTileLayerOptions.styleByAttribute) === null || _b === void 0 ? void 0 : _b.hoverStyle) || vectorTileLayerOptions.hoverStyle)) {
        const fc = vectorTileLayerOptions.sourceOptions.featureClass;
        vectorTileLayerOptions.sourceOptions.featureClass = fc ? fc : 'feature';
    }
    return layerOptions;
}

var LinkedProperties;
(function (LinkedProperties) {
    LinkedProperties["OPACITY"] = "opacity";
    LinkedProperties["VISIBLE"] = "visible";
    LinkedProperties["OGCFILTERS"] = "ogcFilters";
    LinkedProperties["MINRESOLUTION"] = "minResolution";
    LinkedProperties["MAXRESOLUTION"] = "maxResolution";
    LinkedProperties["ZINDEX"] = "zIndex";
    LinkedProperties["TIMEFILTER"] = "timeFilter";
})(LinkedProperties || (LinkedProperties = {}));
var TooltipType;
(function (TooltipType) {
    TooltipType["TITLE"] = "title";
    TooltipType["ABSTRACT"] = "abstract";
    TooltipType["CUSTOM"] = "custom";
})(TooltipType || (TooltipType = {}));

/**
 * Generate a id from it's datasource options.
 * @param options Data source options
 * @returns A id
 */
function generateIdFromSourceOptions(options) {
    const generators = {
        wms: generateWMSIdFromSourceOptions,
        wmts: generateWMTSIdFromSourceOptions,
        xyz: generateXYZIdFromSourceOptions,
        feature: generateFeatureIdFromSourceOptions,
        wfs: generateWfsIdFromSourceOptions,
        arcgisrest: generateArcgisRestIdFromSourceOptions,
        imagearcgisrest: generateArcgisRestIdFromSourceOptions,
        tilearcgisrest: generateArcgisRestIdFromSourceOptions,
        osm: (_options) => 'OSM',
        tiledebug: (_options) => 'tiledebug'
    };
    const generator = generators[options.type] || generateId;
    return generator(options);
}
/**
 * Generate a id from WMS data source options
 * @param options WMS data source options
 * @returns A md5 hash of the the url and layers
 */
function generateWMSIdFromSourceOptions(options) {
    const layers = options.params.LAYERS;
    const url = standardizeUrl(options.url);
    const chain = 'wms' + url + layers;
    return Md5.hashStr(chain);
}
/**
 * Generate a id from WMTS data source options
 * @param options WMTS data source options
 * @returns A md5 hash of the the url and layer
 */
function generateWMTSIdFromSourceOptions(options) {
    const layer = options.layer;
    const url = standardizeUrl(options.url);
    const chain = 'wmts' + url + layer;
    return Md5.hashStr(chain);
}
/**
 * Generate a id from XYZ data source options
 * @param options XYZ data source options
 * @returns A md5 hash of the the url and layer
 */
function generateXYZIdFromSourceOptions(options) {
    const url = standardizeUrl(options.url);
    const chain = 'xyz' + url;
    return Md5.hashStr(chain);
}
/**
 * Generate a id from feature data source options
 * @param options XYZ data source options
 * @returns A md5 hash of the the url and layer
 */
function generateFeatureIdFromSourceOptions(options) {
    if (!options.url) {
        return generateId(options);
    }
    const url = standardizeUrl(options.url);
    const chain = 'feature' + url;
    return Md5.hashStr(chain);
}
/**
 * Generate a id from feature data source options
 * @param options XYZ data source options
 * @returns A md5 hash of the the url and layer
 */
function generateWfsIdFromSourceOptions(options) {
    if (!options.url || !options.params) {
        return generateId(options);
    }
    const url = standardizeUrl(options.url);
    const chain = 'wfs' + url + options.params.featureTypes;
    return Md5.hashStr(chain);
}
/**
 * Generate a id from ArcGIS Rest data source options
 * @param options ArcGIS Rest data source options
 * @returns A md5 hash of the url and layers
 */
function generateArcgisRestIdFromSourceOptions(options) {
    const layers = options.layer;
    const url = standardizeUrl(options.url);
    const chain = (options.type || 'arcgis') + url + layers;
    return Md5.hashStr(chain);
}
/**
 * Generate a unique id
 * @returns A uuid
 */
function generateId(_options) {
    return uuid();
}
function standardizeUrl(url) {
    const absUrl = url.charAt(0) === '/' ? window.location.origin + url : url;
    const urlDecomposed = absUrl.split(/[?&]/);
    let urlStandardized = urlDecomposed.shift();
    const paramsToKeep = urlDecomposed.filter(p => p.length !== 0 && p.charAt(0) !== '_');
    if (paramsToKeep.length) {
        urlStandardized += '?' + paramsToKeep.join('&');
    }
    return urlStandardized;
}

class DataSource {
    constructor(options = {}, dataService) {
        this.options = options;
        this.dataService = dataService;
        this.options = options;
        this.id = this.options.id || this.generateId();
        this.ol = this.createOlSource();
    }
    generateId() {
        return generateIdFromSourceOptions(this.options);
    }
    getLegend(style, view) {
        return this.legend ? this.legend : [];
    }
    setLegend(options) {
        if (options.url) {
            this.legend = [{ url: options.url }];
        }
        else if (options.html) {
            this.legend = [{ html: options.html }];
        }
        else {
            this.legend = [];
        }
        return this.legend;
    }
}

var OgcFilterOperatorType;
(function (OgcFilterOperatorType) {
    OgcFilterOperatorType["BasicNumericOperator"] = "basicnumericoperator";
    OgcFilterOperatorType["Basic"] = "basic";
    OgcFilterOperatorType["BasicAndSpatial"] = "basicandspatial";
    OgcFilterOperatorType["Spatial"] = "spatial";
    OgcFilterOperatorType["All"] = "all";
    OgcFilterOperatorType["Time"] = "time";
})(OgcFilterOperatorType || (OgcFilterOperatorType = {}));
var OgcFilterOperator;
(function (OgcFilterOperator) {
    OgcFilterOperator["BBOX"] = "BBox";
    OgcFilterOperator["PropertyIsBetween"] = "PropertyIsBetween";
    OgcFilterOperator["Contains"] = "Contains";
    OgcFilterOperator["During"] = "During";
    OgcFilterOperator["PropertyIsEqualTo"] = "PropertyIsEqualTo";
    OgcFilterOperator["PropertyIsGreaterThan"] = "PropertyIsGreaterThan";
    OgcFilterOperator["PropertyIsGreaterThanOrEqualTo"] = "PropertyIsGreaterThanOrEqualTo";
    OgcFilterOperator["Intersects"] = "Intersects";
    OgcFilterOperator["PropertyIsNull"] = "PropertyIsNull";
    OgcFilterOperator["PropertyIsLessThan"] = "PropertyIsLessThan";
    OgcFilterOperator["PropertyIsLessThanOrEqualTo"] = "PropertyIsLessThanOrEqualTo";
    OgcFilterOperator["PropertyIsLike"] = "PropertyIsLike";
    OgcFilterOperator["PropertyIsNotEqualTo"] = "PropertyIsNotEqualTo";
    OgcFilterOperator["Within"] = "Within";
    OgcFilterOperator["And"] = "And";
    OgcFilterOperator["Or"] = "Or";
    OgcFilterOperator["Not"] = "Not";
})(OgcFilterOperator || (OgcFilterOperator = {}));

const moment$3 = moment_;
class OgcFilterWriter {
    constructor() {
        this.filterSequence = [];
        this.operators = {
            [OgcFilterOperator.PropertyIsEqualTo]: {
                spatial: false,
                fieldRestrict: []
            },
            [OgcFilterOperator.PropertyIsNotEqualTo]: {
                spatial: false,
                fieldRestrict: []
            },
            [OgcFilterOperator.PropertyIsLike]: {
                spatial: false,
                fieldRestrict: ['string']
            },
            [OgcFilterOperator.PropertyIsGreaterThan]: {
                spatial: false,
                fieldRestrict: ['number']
            },
            [OgcFilterOperator.PropertyIsGreaterThanOrEqualTo]: {
                spatial: false,
                fieldRestrict: ['number']
            },
            [OgcFilterOperator.PropertyIsLessThan]: {
                spatial: false,
                fieldRestrict: ['number']
            },
            [OgcFilterOperator.PropertyIsLessThanOrEqualTo]: {
                spatial: false,
                fieldRestrict: ['number']
            },
            [OgcFilterOperator.PropertyIsBetween]: {
                spatial: false,
                fieldRestrict: ['number']
            },
            [OgcFilterOperator.During]: { spatial: false, fieldRestrict: [] },
            [OgcFilterOperator.PropertyIsNull]: {
                spatial: false,
                fieldRestrict: []
            },
            [OgcFilterOperator.Intersects]: {
                spatial: true,
                fieldRestrict: []
            },
            [OgcFilterOperator.Within]: { spatial: true, fieldRestrict: [] },
            [OgcFilterOperator.Contains]: { spatial: true, fieldRestrict: [] }
        };
    }
    defineOgcFiltersDefaultOptions(ogcFiltersOptions, fieldNameGeometry, srcType) {
        let ogcFiltersDefaultValue = true; // default values for wfs.
        if (srcType && srcType === 'wms') {
            ogcFiltersDefaultValue = false;
        }
        ogcFiltersOptions = ogcFiltersOptions || {};
        ogcFiltersOptions.enabled =
            ogcFiltersOptions.enabled === undefined
                ? ogcFiltersDefaultValue
                : ogcFiltersOptions.enabled;
        ogcFiltersOptions.editable =
            ogcFiltersOptions.editable === undefined
                ? ogcFiltersDefaultValue
                : ogcFiltersOptions.editable;
        ogcFiltersOptions.geometryName = fieldNameGeometry;
        ogcFiltersOptions.advancedOgcFilters = true;
        if (ogcFiltersOptions.enabled && (ogcFiltersOptions.pushButtons || ogcFiltersOptions.checkboxes
            || ogcFiltersOptions.radioButtons || ogcFiltersOptions.select)) {
            ogcFiltersOptions.advancedOgcFilters = false;
        }
        return ogcFiltersOptions;
    }
    buildFilter(filters, extent, proj, fieldNameGeometry, options) {
        let ourBboxFilter;
        let enableBbox;
        if (/intersects|contains|within/gi.test(JSON.stringify(filters))) {
            enableBbox = false;
        }
        else {
            enableBbox = true;
        }
        if (filters) {
            fieldNameGeometry =
                filters.geometryName !== undefined
                    ? filters.geometryName
                    : fieldNameGeometry;
        }
        if (extent && filters) {
            ourBboxFilter = olfilter.bbox(fieldNameGeometry, extent, proj.getCode());
        }
        let filterAssembly;
        if (filters) {
            filters = this.checkIgoFiltersProperties(filters, fieldNameGeometry, proj);
            if (extent && enableBbox) {
                filterAssembly = olfilter.and(ourBboxFilter, this.bundleFilter(filters, options));
            }
            else {
                filterAssembly = this.bundleFilter(filters, options);
            }
        }
        else {
            return 'bbox=' + extent.join(',') + ',' + proj.getCode();
        }
        const wfsOptions = {
            srsName: '',
            featureNS: '',
            featurePrefix: '',
            featureTypes: ['featureTypes'],
            filter: filterAssembly,
            outputFormat: '',
            geometryName: fieldNameGeometry
        };
        const query = new olFormatWFS().writeGetFeature(wfsOptions);
        const str = new XMLSerializer().serializeToString(query);
        const regexp1 = /typenames *=|typename *=\"featureTypes\" *>/gi;
        const regexp2 = /<\/Query><\/GetFeature>/gi;
        return 'filter=' + str.split(regexp1)[1].split(regexp2)[0];
    }
    bundleFilter(filterObject, options) {
        if (filterObject instanceof Array) {
            const logicalArray = [];
            filterObject.forEach((element) => {
                logicalArray.push(this.bundleFilter(element, options));
            });
            return logicalArray;
        }
        else {
            if (filterObject.hasOwnProperty('logical')) {
                return this.createFilter({
                    operator: filterObject.logical,
                    logicalArray: this.bundleFilter(filterObject.filters, options)
                }, options);
            }
            else if (filterObject.hasOwnProperty('operator')) {
                return this.createFilter(filterObject, options);
            }
        }
    }
    createFilter(filterOptions, options) {
        const operator = filterOptions.operator;
        const logicalArray = filterOptions.logicalArray;
        const wfsPropertyName = filterOptions.propertyName;
        const wfsPattern = filterOptions.pattern;
        const wfsMatchCase = filterOptions.matchCase
            ? filterOptions.matchCase
            : true;
        const wfsWildCard = filterOptions.wildCard ? filterOptions.wildCard : '*';
        const wfsSingleChar = filterOptions.singleChar
            ? filterOptions.singleChar
            : '.';
        const wfsEscapeChar = filterOptions.escapeChar
            ? filterOptions.escapeChar
            : '!';
        const wfsLowerBoundary = filterOptions.lowerBoundary;
        const wfsUpperBoundary = filterOptions.upperBoundary;
        const wfsGeometryName = filterOptions.geometryName;
        const wfsExtent = filterOptions.extent;
        const wfsWktGeometry = filterOptions.wkt_geometry;
        const wfsSrsName = filterOptions.srsName
            ? filterOptions.srsName
            : 'EPSG:3857';
        const wfsBegin = this.parseFilterOptionDate(filterOptions.begin, options ? options.minDate : undefined);
        const wfsEnd = this.parseFilterOptionDate(filterOptions.end, options ? options.maxDate : undefined);
        const wfsExpression = filterOptions.expression;
        let geometry;
        if (wfsWktGeometry) {
            const wkt = new olWKT();
            geometry = wkt.readGeometry(wfsWktGeometry, {
                dataProjection: wfsSrsName,
                featureProjection: wfsSrsName || 'EPSG:3857'
            });
        }
        switch (operator.toLowerCase()) {
            case OgcFilterOperator.BBOX.toLowerCase():
                return olfilter.bbox(wfsGeometryName, wfsExtent, wfsSrsName);
            case OgcFilterOperator.PropertyIsBetween.toLowerCase():
                return olfilter.between(wfsPropertyName, wfsLowerBoundary, wfsUpperBoundary);
            case OgcFilterOperator.Contains.toLowerCase():
                return olfilter.contains(wfsGeometryName, geometry, wfsSrsName);
            case OgcFilterOperator.During.toLowerCase():
                return olfilter.during(wfsPropertyName, wfsBegin, wfsEnd);
            case OgcFilterOperator.PropertyIsEqualTo.toLowerCase():
                return olfilter.equalTo(wfsPropertyName, wfsExpression, wfsMatchCase);
            case OgcFilterOperator.PropertyIsGreaterThan.toLowerCase():
                return olfilter.greaterThan(wfsPropertyName, wfsExpression);
            case OgcFilterOperator.PropertyIsGreaterThanOrEqualTo.toLowerCase():
                return olfilter.greaterThanOrEqualTo(wfsPropertyName, wfsExpression);
            case OgcFilterOperator.Intersects.toLowerCase():
                return olfilter.intersects(wfsGeometryName, geometry, wfsSrsName);
            case OgcFilterOperator.PropertyIsNull.toLowerCase():
                return olfilter.isNull(wfsPropertyName);
            case OgcFilterOperator.PropertyIsLessThan.toLowerCase():
                return olfilter.lessThan(wfsPropertyName, wfsExpression);
            case OgcFilterOperator.PropertyIsLessThanOrEqualTo.toLowerCase():
                return olfilter.lessThanOrEqualTo(wfsPropertyName, wfsExpression);
            case OgcFilterOperator.PropertyIsLike.toLowerCase():
                return olfilter.like(wfsPropertyName, wfsPattern.replace(/[()_]/gi, wfsSingleChar), wfsWildCard, wfsSingleChar, wfsEscapeChar, wfsMatchCase);
            case OgcFilterOperator.PropertyIsNotEqualTo.toLowerCase():
                return olfilter.notEqualTo(wfsPropertyName, wfsExpression, wfsMatchCase);
            case OgcFilterOperator.Within.toLowerCase():
                return olfilter.within(wfsGeometryName, geometry, wfsSrsName);
            // LOGICAL
            case OgcFilterOperator.And.toLowerCase():
                return olfilter.and.apply(null, logicalArray);
            case OgcFilterOperator.Or.toLowerCase():
                return olfilter.or.apply(null, logicalArray);
            case OgcFilterOperator.Not.toLowerCase():
                return olfilter.not.apply(null, logicalArray);
            default:
                return undefined;
        }
    }
    defineInterfaceFilterSequence(filterObject, geometryName, logical = '', level = -1) {
        if (filterObject instanceof Array) {
            filterObject.forEach((element) => {
                this.filterSequence.concat(this.defineInterfaceFilterSequence(element, geometryName, logical, level));
            });
        }
        else {
            if (filterObject.hasOwnProperty('logical')) {
                level = level + 1;
                this.filterSequence.concat(this.defineInterfaceFilterSequence(filterObject.filters, geometryName, filterObject.logical, level));
            }
            else if (filterObject.hasOwnProperty('operator')) {
                this.filterSequence.push(this.addInterfaceFilter(filterObject, geometryName, level, logical));
            }
        }
        return this.filterSequence;
    }
    computeAllowedOperators(fields, propertyName, defaultOperatorsType) {
        let effectiveOperators = {};
        let allowedOperators;
        let fieldsHasSpatialOperator;
        let includeContains;
        if (fields && propertyName) {
            const srcField = fields.find((field) => field.name === propertyName);
            allowedOperators =
                srcField && srcField.allowedOperatorsType
                    ? srcField.allowedOperatorsType
                    : defaultOperatorsType;
        }
        if (fields) {
            fields.map((field) => {
                if (!field.allowedOperatorsType) {
                    return;
                }
                const allowedOperatorsType = field.allowedOperatorsType.toLowerCase();
                if (allowedOperatorsType === OgcFilterOperatorType.All.toLowerCase() ||
                    allowedOperatorsType ===
                        OgcFilterOperatorType.Spatial.toLowerCase() ||
                    allowedOperatorsType ===
                        OgcFilterOperatorType.BasicAndSpatial.toLowerCase()) {
                    fieldsHasSpatialOperator = true;
                    if (allowedOperatorsType === OgcFilterOperatorType.All.toLowerCase()) {
                        includeContains = true;
                    }
                }
            });
        }
        allowedOperators = allowedOperators
            ? allowedOperators
            : OgcFilterOperatorType.BasicAndSpatial;
        switch (allowedOperators.toLowerCase()) {
            case OgcFilterOperatorType.All:
                effectiveOperators = this.operators;
                break;
            case OgcFilterOperatorType.Spatial:
                effectiveOperators = {
                    [OgcFilterOperator.Intersects]: { spatial: true, fieldRestrict: [] },
                    [OgcFilterOperator.Within]: { spatial: true, fieldRestrict: [] }
                };
                break;
            case OgcFilterOperatorType.BasicAndSpatial:
                effectiveOperators = {
                    [OgcFilterOperator.PropertyIsEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.PropertyIsNotEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.Intersects]: { spatial: true, fieldRestrict: [] },
                    [OgcFilterOperator.Within]: { spatial: true, fieldRestrict: [] }
                };
                break;
            case OgcFilterOperatorType.Basic:
                effectiveOperators = {
                    [OgcFilterOperator.PropertyIsEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.PropertyIsNotEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    }
                };
                break;
            case OgcFilterOperatorType.Time:
                effectiveOperators = {
                    [OgcFilterOperator.During]: { spatial: false, fieldRestrict: [] }
                };
                break;
            case OgcFilterOperatorType.BasicNumericOperator:
                effectiveOperators = {
                    [OgcFilterOperator.PropertyIsEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.PropertyIsNotEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.PropertyIsGreaterThan]: {
                        spatial: false,
                        fieldRestrict: ['number']
                    },
                    [OgcFilterOperator.PropertyIsGreaterThanOrEqualTo]: {
                        spatial: false,
                        fieldRestrict: ['number']
                    },
                    [OgcFilterOperator.PropertyIsLessThan]: {
                        spatial: false,
                        fieldRestrict: ['number']
                    },
                    [OgcFilterOperator.PropertyIsLessThanOrEqualTo]: {
                        spatial: false,
                        fieldRestrict: ['number']
                    }
                };
                break;
            default:
                effectiveOperators = {
                    [OgcFilterOperator.PropertyIsEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.PropertyIsNotEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.Intersects]: { spatial: true, fieldRestrict: [] },
                    [OgcFilterOperator.Within]: { spatial: true, fieldRestrict: [] }
                };
        }
        if (fieldsHasSpatialOperator) {
            effectiveOperators.Intersects = {
                spatial: true,
                fieldRestrict: []
            };
            effectiveOperators.Within = { spatial: true, fieldRestrict: [] };
            if (includeContains) {
                effectiveOperators.Contains = {
                    spatial: true,
                    fieldRestrict: []
                };
            }
        }
        return effectiveOperators;
    }
    addInterfaceFilter(igoOgcFilterObject, geometryName, level = 0, parentLogical = 'Or') {
        if (!igoOgcFilterObject) {
            igoOgcFilterObject = { operator: 'PropertyIsEqualTo' };
        }
        const f = {
            propertyName: '',
            operator: '',
            active: '',
            filterid: uuid(),
            step: '',
            begin: '',
            end: '',
            sliderOptions: {},
            lowerBoundary: '',
            upperBoundary: '',
            expression: '',
            pattern: '',
            wildCard: '*',
            singleChar: '.',
            escapeChar: '!',
            matchCase: true,
            igoSpatialSelector: '',
            igoSNRC: '',
            geometryName: '',
            geometry: '',
            wkt_geometry: '',
            extent: '',
            srsName: '',
            parentLogical: '',
            level: 0
        };
        return Object.assign(f, {
            parentLogical,
            level,
            geometryName
        }, igoOgcFilterObject);
    }
    checkIgoFiltersProperties(filterObject, fieldNameGeometry, proj, active = false) {
        const filterArray = [];
        if (filterObject instanceof Array) {
            filterObject.forEach((element) => {
                filterArray.push(this.checkIgoFiltersProperties(element, fieldNameGeometry, proj, active));
            });
            return filterArray;
        }
        else {
            if (filterObject.hasOwnProperty('logical')) {
                return Object.assign({}, {
                    logical: filterObject.logical,
                    filters: this.checkIgoFiltersProperties(filterObject.filters, fieldNameGeometry, proj, active)
                });
            }
            else if (filterObject.hasOwnProperty('operator')) {
                return this.addFilterProperties(filterObject, fieldNameGeometry, proj, active);
            }
        }
    }
    addFilterProperties(igoOgcFilterObject, fieldNameGeometry, proj, active = false) {
        const filterid = igoOgcFilterObject.hasOwnProperty('filterid')
            ? igoOgcFilterObject.filterid
            : uuid();
        const status = igoOgcFilterObject.hasOwnProperty('active')
            ? igoOgcFilterObject.active
            : active;
        const srsName = igoOgcFilterObject.hasOwnProperty('srsName')
            ? igoOgcFilterObject.srsName
            : proj
                ? proj.getCode()
                : 'EPSG:3857';
        return Object.assign({}, {
            filterid,
            active: status,
            igoSpatialSelector: 'fixedExtent',
            srsName
        }, igoOgcFilterObject, { geometryName: fieldNameGeometry });
    }
    rebuiltIgoOgcFilterObjectFromSequence(sequence) {
        if (sequence instanceof Array) {
            if (sequence.length >= 1) {
                let lastParentLogical = sequence[0].parentLogical;
                let nextElement;
                let logicalArray = [];
                let lastProcessedFilter;
                sequence.forEach((uiFilter) => {
                    const element = Object.assign({}, uiFilter);
                    const index = sequence.indexOf(uiFilter);
                    if (index >= 0 && index < sequence.length - 1) {
                        nextElement = sequence[index + 1];
                    }
                    else {
                        nextElement = element;
                    }
                    delete element.active;
                    delete element.filterid;
                    delete element.parentLogical;
                    logicalArray.push(element);
                    if (sequence.length === 1) {
                        lastProcessedFilter = element;
                    }
                    else if (lastParentLogical !== nextElement.parentLogical) {
                        if (logicalArray.length === 1) {
                            console.log('You must set at ' +
                                'least two operator in a logical (' +
                                lastParentLogical +
                                ')');
                        }
                        else {
                            lastProcessedFilter = Object.assign({}, { logical: lastParentLogical, filters: logicalArray });
                            logicalArray = [lastProcessedFilter];
                            lastParentLogical = nextElement.parentLogical;
                        }
                    }
                });
                return lastProcessedFilter;
            }
            else {
                return undefined;
            }
        }
        else {
            return undefined;
        }
    }
    computeIgoSelector(selectors) {
        if (selectors.groups.every((group) => group.computedSelectors !== undefined)) {
            return selectors;
        }
        let selector;
        if (selectors.groups && selectors.bundles) {
            if (!selectors.bundles.every((bundle) => bundle.id !== undefined)) {
                throw new Error('You must set an id for each of your bundles');
            }
            selector = ObjectUtils.copyDeep(selectors);
            selector.groups.forEach((group) => {
                group.title = group.title ? group.title : group.name;
                group.enabled = group.enabled ? group.enabled : false;
                group.computedSelectors = ObjectUtils.copyDeep(selector.bundles.filter((b) => group.ids.includes(b.id)));
            });
        }
        else if (!selectors.groups && selectors.bundles) {
            selector = ObjectUtils.copyDeep(selectors);
            selector.groups = [
                {
                    title: 'group1',
                    name: 'group1',
                    computedSelectors: ObjectUtils.copyDeep(selector.bundles)
                }
            ];
        }
        else {
            selector = {
                bundles: selectors,
                groups: [
                    {
                        title: 'group1',
                        name: 'group1',
                        computedSelectors: ObjectUtils.copyDeep(selectors)
                    }
                ],
                selectorType: selector.selectorType
            };
        }
        if (!selector.groups.find((selectorGroup) => selectorGroup.enabled)) {
            selector.groups[0].enabled = true;
        }
        return selector;
    }
    handleOgcFiltersAppliedValue(options, fieldNameGeometry, extent, proj) {
        const ogcFilters = options.ogcFilters;
        if (!ogcFilters) {
            return;
        }
        const conditions = [];
        let filterQueryStringSelector = '';
        let filterQueryStringAdvancedFilters = '';
        if (ogcFilters.enabled && (ogcFilters.pushButtons || ogcFilters.checkboxes || ogcFilters.radioButtons || ogcFilters.select)) {
            let selectors;
            if (ogcFilters.pushButtons) {
                selectors = ogcFilters.pushButtons;
                const pushConditions = this.formatGroupAndFilter(ogcFilters, selectors);
                for (const condition of pushConditions) {
                    conditions.push(condition);
                }
            }
            if (ogcFilters.checkboxes) {
                selectors = ogcFilters.checkboxes;
                const checkboxConditions = this.formatGroupAndFilter(ogcFilters, selectors);
                for (const condition of checkboxConditions) {
                    conditions.push(condition);
                }
            }
            if (ogcFilters.radioButtons) {
                selectors = ogcFilters.radioButtons;
                const selectorsCorr = this.verifyMultipleEnableds(selectors);
                const radioConditions = this.formatGroupAndFilter(ogcFilters, selectorsCorr);
                for (const condition of radioConditions) {
                    conditions.push(condition);
                }
            }
            if (ogcFilters.select) {
                selectors = ogcFilters.select;
                const selectorsCorr = this.verifyMultipleEnableds(selectors);
                const selectConditions = this.formatGroupAndFilter(ogcFilters, selectorsCorr);
                for (const condition of selectConditions) {
                    conditions.push(condition);
                }
            }
            if (conditions.length >= 1) {
                filterQueryStringSelector = this.buildFilter(conditions.length === 1
                    ? conditions[0]
                    : { logical: 'And', filters: conditions }, extent, proj, ogcFilters.geometryName);
            }
        }
        if (ogcFilters.enabled && ogcFilters.filters) {
            ogcFilters.geometryName = ogcFilters.geometryName || fieldNameGeometry;
            const igoFilters = ogcFilters.filters;
            filterQueryStringAdvancedFilters = this.buildFilter(igoFilters, extent, proj, ogcFilters.geometryName, options);
        }
        let filterQueryString = ogcFilters.advancedOgcFilters
            ? filterQueryStringAdvancedFilters
            : filterQueryStringSelector;
        if (options.type === 'wms') {
            filterQueryString = this.formatProcessedOgcFilter(filterQueryString, options.params.LAYERS);
        }
        if (options.type === 'wfs') {
            filterQueryString = this.formatProcessedOgcFilter(filterQueryString, options.params.featureTypes);
        }
        return filterQueryString;
    }
    verifyMultipleEnableds(selectors) {
        selectors.bundles.forEach(bundle => {
            if (!bundle.multiple) {
                const enableds = bundle.selectors.reduce((list, filter, index) => (filter.enabled) === true ? list.concat(index) : list, []);
                if (enableds.length > 1) {
                    enableds.splice(0, 1);
                    enableds.forEach(index => {
                        bundle.selectors[index].enabled = false;
                    });
                }
            }
        });
        return selectors;
    }
    formatGroupAndFilter(ogcFilters, selectors) {
        selectors = this.computeIgoSelector(selectors);
        const selectorBundle = selectors.groups.find((g) => g.enabled).computedSelectors;
        const conditions = [];
        selectorBundle.map((bundle) => {
            const bundleCondition = [];
            const selectorsType = bundle.selectors;
            if (!selectorsType) {
                return;
            }
            selectorsType
                .filter((ogcselector) => ogcselector.enabled === true)
                .forEach((enabledSelector) => bundleCondition.push(enabledSelector.filters));
            if (bundleCondition.length === 1) {
                conditions.push(bundleCondition[0]);
            }
            else if (bundleCondition.length > 1) {
                conditions.push({
                    logical: bundle.logical,
                    filters: bundleCondition
                });
            }
        });
        if (selectors.selectorType === 'pushButton') {
            ogcFilters.pushButtons = selectors;
        }
        else if (selectors.selectorType === 'checkbox') {
            ogcFilters.checkboxes = selectors;
        }
        else if (selectors.selectorType === 'radioButton') {
            ogcFilters.radioButtons = selectors;
        }
        else if (selectors.selectorType === 'select') {
            ogcFilters.select = selectors;
        }
        return conditions;
    }
    formatProcessedOgcFilter(processedFilter, layersOrTypenames) {
        if (!processedFilter) {
            return undefined;
        }
        ;
        let appliedFilter = '';
        if (processedFilter.length === 0 && layersOrTypenames.indexOf(',') === -1) {
            appliedFilter = processedFilter;
        }
        else {
            layersOrTypenames.split(',').forEach((layerOrTypenames) => {
                appliedFilter = `${appliedFilter}(${processedFilter.replace('filter=', '')})`;
            });
        }
        appliedFilter = appliedFilter.replace(/\(\)/g, '');
        const filterValue = appliedFilter.length > 0
            ? appliedFilter.replace('filter=', '')
            : undefined;
        return filterValue;
    }
    parseFilterOptionDate(value, defaultValue) {
        if (!value) {
            return defaultValue;
        }
        else if (value === 'today') {
            return undefined;
        }
        else if (moment$3(value).isValid()) {
            return value;
        }
        else {
            return undefined;
        }
    }
}

var QueryFormat;
(function (QueryFormat) {
    QueryFormat["GML2"] = "gml2";
    QueryFormat["GML3"] = "gml3";
    QueryFormat["JSON"] = "json";
    QueryFormat["GEOJSON"] = "geojson";
    QueryFormat["GEOJSON2"] = "geojson2";
    QueryFormat["ESRIJSON"] = "esrijson";
    QueryFormat["TEXT"] = "text";
    QueryFormat["HTML"] = "html";
    QueryFormat["HTMLGML2"] = "htmlgml2";
})(QueryFormat || (QueryFormat = {}));
var QueryFormatMimeType;
(function (QueryFormatMimeType) {
    QueryFormatMimeType["GML2"] = "application/vnd.ogc.gml";
    QueryFormatMimeType["GML3"] = "application/vnd.ogc.gml/3.1.1";
    QueryFormatMimeType["JSON"] = "application/json";
    QueryFormatMimeType["GEOJSON"] = "application/geojson";
    QueryFormatMimeType["GEOJSON2"] = "geojson";
    QueryFormatMimeType["ESRIJSON"] = "application/json";
    QueryFormatMimeType["TEXT"] = "text/plain";
    QueryFormatMimeType["HTML"] = "text/html";
    QueryFormatMimeType["HTMLGML2"] = "text/html";
})(QueryFormatMimeType || (QueryFormatMimeType = {}));
var QueryHtmlTarget;
(function (QueryHtmlTarget) {
    QueryHtmlTarget["IFRAME"] = "iframe";
    QueryHtmlTarget["BLANK"] = "_blank";
})(QueryHtmlTarget || (QueryHtmlTarget = {}));

const defaultEpsg = 'EPSG:3857';
const defaultMaxFeatures = 5000;
const defaultWfsVersion = '2.0.0';
const defaultFieldNameGeometry = 'geometry';
const gmlRegex = new RegExp(/(.*)?gml(.*)?/gi);
const jsonRegex = new RegExp(/(.*)?json(.*)?/gi);
/**
 * This method build the WFS URL based on the layer property.
 * @param options  WFSDataSourceOptions The common wfs datasource options interface
 * @param extent  An extent like array [number, number, number, number]
 * @param proj  olProjection
 * @param ogcFilters  OgcFiltersOptions
 * @returns A string representing the datasource options, based on filter and views
 */
function buildUrl(options, extent, proj, ogcFilters, randomParam) {
    const paramsWFS = options.paramsWFS;
    const queryStringValues = formatWFSQueryString(options, undefined, options.paramsWFS.srsName);
    let igoFilters;
    if (ogcFilters && ogcFilters.enabled) {
        igoFilters = ogcFilters.filters;
    }
    const ogcFilterWriter = new OgcFilterWriter();
    const filterOrBox = ogcFilterWriter.buildFilter(igoFilters, extent, proj, ogcFilters.geometryName, options);
    let filterOrPush = ogcFilterWriter.handleOgcFiltersAppliedValue(options, ogcFilters.geometryName, extent, proj);
    let prefix = 'filter';
    if (!filterOrPush) {
        prefix = 'bbox';
        filterOrPush = extent.join(',') + ',' + proj.getCode();
    }
    paramsWFS.xmlFilter = ogcFilters.advancedOgcFilters ? filterOrBox : `${prefix}=${filterOrPush}`;
    let baseUrl = queryStringValues.find(f => f.name === 'getfeature').value;
    const patternFilter = /(filter|bbox)=.*/gi;
    baseUrl = patternFilter.test(paramsWFS.xmlFilter) ? `${baseUrl}&${paramsWFS.xmlFilter}` : baseUrl;
    options.download = Object.assign({}, options.download, { dynamicUrl: baseUrl });
    if (randomParam) {
        baseUrl += `$&_t${new Date().getTime()}`;
    }
    return baseUrl.replace(/&&/g, '&');
}
/**
 * This method build/standardize WFS call query params based on the layer property.
 * @param wfsDataSourceOptions  WFSDataSourceOptions The common wfs datasource options interface
 * @param count  Number: Used to control the number of feature. Used to bypass whe wfs datasource options interface (maxFeatures)
 * @param epsg  String: Used to control the EPSG code (es: 'EPSG3857'). Used to bypass whe wfs datasource options interface (srsName)
 * @param properties  String: Used to control the queried fields  (WFS service).
 * @returns An array array of {name: '', value: ''} of predefined query params.
 */
function formatWFSQueryString(dataSourceOptions, count, epsg, properties, startIndex = 0, forceDefaultOutputFormat = false) {
    const versionWfs200 = '2.0.0'; // not the same usage as defaultWfsVersion.
    const url = dataSourceOptions.urlWfs;
    const paramsWFS = dataSourceOptions.paramsWFS;
    const effectiveCount = count || defaultMaxFeatures;
    const effectiveStartIndex = paramsWFS.version === versionWfs200 ? `startIndex=${startIndex}` : '';
    const epsgCode = epsg || defaultEpsg;
    let outputFormat = paramsWFS.outputFormat
        ? `outputFormat=${paramsWFS.outputFormat}`
        : '';
    let version = paramsWFS.version
        ? `version=${paramsWFS.version}`
        : `version=${defaultWfsVersion}`;
    const paramTypename = paramsWFS.version === versionWfs200 ? 'typenames' : 'typename';
    const featureTypes = `${paramTypename}=${paramsWFS.featureTypes}`;
    const paramMaxFeatures = paramsWFS.version === versionWfs200 ? 'count' : 'maxFeatures';
    let cnt = count
        ? `${paramMaxFeatures}=${effectiveCount}`
        : paramsWFS.maxFeatures
            ? `${paramMaxFeatures}=${paramsWFS.maxFeatures}`
            : `${paramMaxFeatures}=${effectiveCount}`;
    if (forceDefaultOutputFormat) {
        outputFormat = '';
        version = 'version=1.1.0';
        cnt = cnt.replace('count', 'maxFeatures');
    }
    const srs = epsg
        ? `srsname=${epsgCode}`
        : paramsWFS.srsName
            ? 'srsname=' + paramsWFS.srsName
            : `srsname=${epsgCode}`;
    let propertyName = '';
    let valueReference = '';
    if (properties) {
        propertyName = `propertyName=${properties}`;
        valueReference = `valueReference=${properties}`;
    }
    const sourceFields = dataSourceOptions.sourceFields;
    if (!propertyName && sourceFields && sourceFields.length > 0) {
        const fieldsNames = [];
        dataSourceOptions.sourceFields.forEach(sourcefield => {
            fieldsNames.push(sourcefield.name);
        });
        propertyName = `propertyName=${fieldsNames.join(',')},${paramsWFS.fieldNameGeometry}`;
    }
    const separator = url.indexOf('?') === -1 ? '?' : '&';
    const getCapabilities = `${url}${separator}service=WFS&request=GetCapabilities&${version}`;
    let getFeature = `${url}${separator}service=WFS&request=GetFeature&${version}&${featureTypes}&`;
    getFeature += `${outputFormat}&${srs}&${cnt}&${propertyName}&${effectiveStartIndex}`;
    let getpropertyvalue = `${url}?service=WFS&request=GetPropertyValue&version=${versionWfs200}&${featureTypes}&`;
    getpropertyvalue += `&${cnt}&${valueReference}`;
    return [
        { name: 'outputformat', value: outputFormat },
        { name: 'version', value: version },
        { name: 'typename', value: featureTypes },
        { name: 'count', value: cnt },
        { name: 'srsname', value: srs },
        { name: 'propertyname', value: propertyName },
        { name: 'valuereference', value: valueReference },
        { name: 'getcapabilities', value: getCapabilities.replace(/&&/g, '&') },
        { name: 'getfeature', value: getFeature.replace(/&&/g, '&') },
        { name: 'getpropertyvalue', value: getpropertyvalue.replace(/&&/g, '&') }
    ];
}
/**
 * Validate/Modify layer's wfs options based on :
 * 1- an Openlayers's issue with GML provided from WFS. Refer to
 * https://github.com/openlayers/openlayers/pull/6400
 * 2- Set default values for optionals parameters.
 * @param wfsDataSourceOptions  WFSDataSourceOptions The common wfs datasource options interface
 * @returns An array array of {name: '', value: ''} of predefined query params.
 */
function checkWfsParams(wfsDataSourceOptions, srcType) {
    if (srcType && srcType === 'wfs') {
        // reassignation of params to paramsWFS and url to urlWFS to have a common interface with wms-wfs datasources
        wfsDataSourceOptions.paramsWFS = wfsDataSourceOptions.params;
    }
    const paramsWFS = wfsDataSourceOptions.paramsWFS;
    wfsDataSourceOptions.urlWfs =
        wfsDataSourceOptions.urlWfs || wfsDataSourceOptions.url;
    paramsWFS.version = paramsWFS.version || defaultWfsVersion;
    paramsWFS.fieldNameGeometry =
        paramsWFS.fieldNameGeometry || defaultFieldNameGeometry;
    paramsWFS.maxFeatures = paramsWFS.maxFeatures || defaultMaxFeatures;
    let outputFormat;
    if (paramsWFS.outputFormat) {
        outputFormat = paramsWFS.outputFormat;
    }
    if (gmlRegex.test(outputFormat) || !outputFormat) {
        paramsWFS.version = '1.1.0';
    }
    return Object.assign({}, wfsDataSourceOptions);
}
function getFormatFromOptions(options) {
    const wfsOptions = options;
    let olFormatCls;
    const outputFormat = wfsOptions.paramsWFS.outputFormat
        ? wfsOptions.paramsWFS.outputFormat
        : undefined;
    if (!outputFormat) {
        olFormatCls = olformat.WFS;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    if (olformat[outputFormat]) {
        olFormatCls = olformat[outputFormat];
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('gml2')) {
        olFormatCls = olformat.WFS;
        return new olFormatCls(Object.assign(Object.assign({}, wfsOptions.formatOptions), { gmlFormat: olFormatGML2 }));
    }
    else if (outputFormat.toLowerCase().match('gml32')) {
        olFormatCls = olformat.WFS;
        return new olFormatCls(Object.assign(Object.assign({}, wfsOptions.formatOptions), { gmlFormat: olFormatGML32 }));
    }
    else if (outputFormat.toLowerCase().match('gml3')) {
        olFormatCls = olformat.WFS;
        return new olFormatCls(Object.assign(Object.assign({}, wfsOptions.formatOptions), { gmlFormat: olFormatGML3 }));
    }
    else if (outputFormat.toLowerCase().match('topojson')) {
        olFormatCls = olformat.TopoJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('geojson')) {
        olFormatCls = olformat.GeoJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('esrijson')) {
        olFormatCls = olformat.EsriJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('json')) {
        olFormatCls = olformat.GeoJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('gpx')) {
        olFormatCls = olformat.GPX;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('WKT')) {
        olFormatCls = olformat.WKT;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('osmxml')) {
        olFormatCls = olFormatOSMXML;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('kml')) {
        olFormatCls = olformat.KML;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    return new olFormatCls();
}

class WMSDataSource extends DataSource {
    constructor(options, wfsService) {
        super(options);
        this.options = options;
        this.wfsService = wfsService;
        this.ogcFilters$ = new BehaviorSubject(undefined);
        this.timeFilter$ = new BehaviorSubject(undefined);
        const sourceParams = options.params;
        const dpi = sourceParams.DPI || 96;
        sourceParams.DPI = dpi;
        sourceParams.MAP_RESOLUTION = dpi;
        sourceParams.FORMAT_OPTIONS = 'dpi:' + dpi;
        if (options.refreshIntervalSec && options.refreshIntervalSec > 0) {
            setInterval(() => {
                this.refresh();
            }, options.refreshIntervalSec * 1000); // Convert seconds to MS
        }
        let fieldNameGeometry = defaultFieldNameGeometry;
        // ####   START if paramsWFS
        if (options.paramsWFS) {
            const wfsCheckup = checkWfsParams(options, 'wms');
            ObjectUtils.mergeDeep(options.paramsWFS, wfsCheckup.paramsWFS);
            fieldNameGeometry =
                options.paramsWFS.fieldNameGeometry || fieldNameGeometry;
            options.download = Object.assign({}, options.download, {
                dynamicUrl: this.buildDynamicDownloadUrlFromParamsWFS(options)
            });
        } //  ####   END  if paramsWFS
        if (!options.sourceFields || options.sourceFields.length === 0) {
            options.sourceFields = [];
        }
        else {
            options.sourceFields.forEach(sourceField => {
                sourceField.alias = sourceField.alias
                    ? sourceField.alias
                    : sourceField.name;
                // to allow only a list of sourcefield with names
            });
        }
        const initOgcFilters = options
            .ogcFilters;
        const ogcFilterWriter = new OgcFilterWriter();
        if (!initOgcFilters) {
            options.ogcFilters = ogcFilterWriter.defineOgcFiltersDefaultOptions(initOgcFilters, fieldNameGeometry, 'wms');
        }
        else {
            initOgcFilters.advancedOgcFilters = (initOgcFilters.pushButtons || initOgcFilters.checkboxes
                || initOgcFilters.radioButtons || initOgcFilters.select)
                ? false
                : true;
            if (initOgcFilters.advancedOgcFilters && initOgcFilters.filters) {
                const filterDuring = initOgcFilters.filters;
                if (filterDuring.calendarModeYear) {
                    initOgcFilters.advancedOgcFilters = false;
                }
            }
            if (initOgcFilters.pushButtons) {
                initOgcFilters.pushButtons.selectorType = 'pushButton';
            }
            if (initOgcFilters.checkboxes) {
                initOgcFilters.checkboxes.selectorType = 'checkbox';
            }
            if (initOgcFilters.radioButtons) {
                initOgcFilters.radioButtons.selectorType = 'radioButton';
            }
            if (initOgcFilters.select) {
                initOgcFilters.select.selectorType = 'select';
            }
        }
        if (sourceParams.LAYERS.split(',').length > 1 &&
            initOgcFilters &&
            initOgcFilters.enabled) {
            console.log('*******************************');
            console.log('BE CAREFULL, YOUR WMS LAYERS (' +
                sourceParams.LAYERS +
                ') MUST SHARE THE SAME FIELDS TO ALLOW ogcFilters TO WORK !! ');
            console.log('*******************************');
        }
        if (options.paramsWFS &&
            initOgcFilters &&
            initOgcFilters.enabled &&
            initOgcFilters.editable &&
            (options.sourceFields || []).filter(sf => !sf.values).length > 0) {
            this.wfsService.getSourceFieldsFromWFS(options);
        }
        const filterQueryString = ogcFilterWriter.handleOgcFiltersAppliedValue(options, fieldNameGeometry);
        sourceParams.FILTER = filterQueryString;
        this.setOgcFilters(initOgcFilters, true);
        const timeFilterableDataSourceOptions = options;
        if ((timeFilterableDataSourceOptions === null || timeFilterableDataSourceOptions === void 0 ? void 0 : timeFilterableDataSourceOptions.timeFilterable) &&
            (timeFilterableDataSourceOptions === null || timeFilterableDataSourceOptions === void 0 ? void 0 : timeFilterableDataSourceOptions.timeFilter)) {
            this.setTimeFilter(timeFilterableDataSourceOptions.timeFilter, true);
        }
    }
    get params() {
        return this.options.params;
    }
    get queryTitle() {
        return this.options.queryTitle
            ? this.options.queryTitle
            : 'title';
    }
    get mapLabel() {
        return this.options.mapLabel;
    }
    get queryHtmlTarget() {
        return this.options.queryHtmlTarget
            ? this.options.queryHtmlTarget
            : QueryHtmlTarget.BLANK;
    }
    set ogcFilters(value) {
        this.options.ogcFilters = value;
    }
    get ogcFilters() {
        return this.options.ogcFilters;
    }
    set timeFilter(value) {
        this.options.timeFilter = value;
    }
    get timeFilter() {
        return this.options.timeFilter;
    }
    refresh() {
        this.ol.updateParams({ igoRefresh: Math.random() });
    }
    buildDynamicDownloadUrlFromParamsWFS(asWFSDataSourceOptions) {
        const queryStringValues = formatWFSQueryString(asWFSDataSourceOptions);
        const downloadUrl = queryStringValues.find(f => f.name === 'getfeature')
            .value;
        return downloadUrl;
    }
    createOlSource() {
        return new olSourceImageWMS(Object.assign({ ratio: 1 }, this.options));
    }
    setOgcFilters(ogcFilters, triggerEvent = false) {
        this.ogcFilters = ogcFilters;
        if (triggerEvent) {
            this.ogcFilters$.next(this.ogcFilters);
        }
    }
    setTimeFilter(timeFilter, triggerEvent = false) {
        this.timeFilter = timeFilter;
        if (triggerEvent) {
            this.timeFilter$.next(this.timeFilter);
        }
    }
    getLegend(style, view) {
        let legend = super.getLegend();
        if (legend.length > 0 && (style === undefined && !(view === null || view === void 0 ? void 0 : view.scale))) {
            return legend;
        }
        let contentDependent = false;
        let projParam;
        if ((view === null || view === void 0 ? void 0 : view.size) && (view === null || view === void 0 ? void 0 : view.extent) && (view === null || view === void 0 ? void 0 : view.projection) && this.options.contentDependentLegend) {
            projParam = this.params.VERSION === '1.3.0' || this.params.VERSION === undefined ? 'CRS' : 'SRS';
            contentDependent = true;
        }
        const sourceParams = this.params;
        let layers = [];
        if (sourceParams.LAYERS !== undefined) {
            layers = sourceParams.LAYERS.split(',');
        }
        const baseUrl = this.options.url.replace(/\?$/, '');
        const params = [
            'REQUEST=GetLegendGraphic',
            'SERVICE=WMS',
            'FORMAT=image/png',
            'SLD_VERSION=1.1.0',
            `VERSION=${sourceParams.VERSION || '1.3.0'}`
        ];
        if (style !== undefined) {
            params.push(`STYLE=${style}`);
        }
        if ((view === null || view === void 0 ? void 0 : view.scale) !== undefined) {
            params.push(`SCALE=${view.scale}`);
        }
        if (contentDependent) {
            params.push(`WIDTH=${view.size[0]}`);
            params.push(`HEIGHT=${view.size[1]}`);
            params.push(`BBOX=${view.extent.join(',')}`);
            params.push(`${projParam}=${view.projection}`);
        }
        legend = layers.map((layer) => {
            const separator = baseUrl.match(/\?/) ? '&' : '?';
            return {
                url: `${baseUrl}${separator}${params.join('&')}&LAYER=${layer}`,
                title: layers.length > 1 ? layer : undefined,
                currentStyle: style === undefined ? undefined : style
            };
        });
        return legend;
    }
    onUnwatch() { }
}

class LayerSyncWatcher extends Watcher {
    constructor(layer, map) {
        super();
        this.ol = layer.ol;
        this.layer = layer;
        this.dataSource = layer.options.source;
        this.map = map;
        this.ogcFilterWriter = new OgcFilterWriter();
    }
    watch() {
        this.ol.on('propertychange', evt => this.transferCommonProperties(evt));
        if (this.dataSource.ogcFilters$) {
            this.ogcFilters$$ = this.dataSource.ogcFilters$
                .subscribe(ogcFilters => this.transferOgcFiltersProperties(ogcFilters));
        }
        if (this.dataSource.timeFilter$) {
            this.timeFilter$$ = this.dataSource.timeFilter$
                .subscribe(timeFilter => this.transferTimeFilterProperties(timeFilter));
        }
        this.syncChildLayers();
    }
    unwatch() {
        this.ol.un('propertychange', evt => this.transferCommonProperties(evt));
        if (this.ogcFilters$$) {
            this.ogcFilters$$.unsubscribe();
        }
        if (this.timeFilter$$) {
            this.timeFilter$$.unsubscribe();
        }
    }
    syncChildLayers() {
        // Force the sync the child layers with parent on the first load.
        if (!this.map) {
            return;
        }
        this.map.status$
            .pipe(first())
            .subscribe(() => {
            this.map.layers
                .filter(layer => { var _a; return (_a = layer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.links; })
                .map(layer => {
                layer.options.linkedLayers.links.map(link => {
                    var _a, _b, _c, _d, _e, _f;
                    if (((_a = link.properties) === null || _a === void 0 ? void 0 : _a.indexOf(LinkedProperties.VISIBLE)) !== -1) {
                        layer.ol.set('visible', !(layer.visible), false);
                        layer.ol.set('visible', !(layer.visible), false);
                        layer.visible = layer.visible;
                    }
                    if (((_b = link.properties) === null || _b === void 0 ? void 0 : _b.indexOf(LinkedProperties.OPACITY)) !== -1) {
                        const baseOpacity = layer.ol.get('opacity');
                        layer.ol.set('opacity', 0, false);
                        layer.ol.set('opacity', baseOpacity, false);
                        layer.opacity = layer.opacity;
                    }
                    if (((_c = link.properties) === null || _c === void 0 ? void 0 : _c.indexOf(LinkedProperties.MINRESOLUTION)) !== -1) {
                        const baseMinResolution = layer.ol.get('minResolution');
                        layer.ol.set('minResolution', 0, false);
                        layer.ol.set('minResolution', baseMinResolution, false);
                        layer.minResolution = layer.minResolution;
                    }
                    if (((_d = link.properties) === null || _d === void 0 ? void 0 : _d.indexOf(LinkedProperties.MAXRESOLUTION)) !== -1) {
                        const baseMaxResolution = layer.ol.get('maxResolution');
                        layer.ol.set('maxResolution', 0, false);
                        layer.ol.set('maxResolution', baseMaxResolution, false);
                        layer.minResolution = layer.minResolution;
                    }
                    if (((_e = link.properties) === null || _e === void 0 ? void 0 : _e.indexOf(LinkedProperties.OGCFILTERS)) !== -1) {
                        const ogcFilters$ = layer.dataSource.ogcFilters$;
                        ogcFilters$.next(ogcFilters$.value);
                    }
                    if (((_f = link.properties) === null || _f === void 0 ? void 0 : _f.indexOf(LinkedProperties.TIMEFILTER)) !== -1) {
                        const timeFilter$ = layer.dataSource.timeFilter$;
                        timeFilter$.next(timeFilter$.value);
                    }
                });
            });
        });
    }
    transferCommonProperties(layerChange) {
        const key = layerChange.key;
        const layerChangeProperties = layerChange.target.getProperties();
        const newValue = layerChangeProperties[key];
        if (['visible', 'opacity', 'minResolution', 'maxResolution'].indexOf(key) === -1) {
            return;
        }
        const linkedLayers = layerChangeProperties.linkedLayers;
        if (!linkedLayers) {
            return;
        }
        const currentLinkedId = linkedLayers.linkId;
        const currentLinks = linkedLayers.links;
        const isParentLayer = currentLinks ? true : false;
        if (isParentLayer) {
            // search for child layers
            const silent = true;
            currentLinks.map(link => {
                if (!link.properties || link.properties.indexOf(key) === -1) {
                    return;
                }
                link.linkedIds.map(linkedId => {
                    const layerToApply = this.map.layers.find(layer => { var _a; return ((_a = layer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.linkId) === linkedId; });
                    if (layerToApply) {
                        layerToApply.ol.set(key, newValue, silent);
                        if (key === 'visible') {
                            layerToApply.visible$.next(newValue);
                        }
                    }
                });
            });
        }
        else {
            // search for parent layer
            const silent = false;
            this.map.layers.map(layer => {
                var _a;
                if ((_a = layer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.links) {
                    layer.options.linkedLayers.links.map(l => {
                        if (l.properties && l.properties.indexOf(key) !== -1 &&
                            l.bidirectionnal !== false && l.linkedIds.indexOf(currentLinkedId) !== -1) {
                            layer.ol.set(key, newValue, silent);
                            if (key === 'visible') {
                                layer.visible$.next(newValue);
                            }
                        }
                    });
                }
            });
        }
    }
    transferOgcFiltersProperties(ogcFilters) {
        const linkedLayers = this.ol.getProperties().linkedLayers;
        if (!linkedLayers) {
            return;
        }
        const currentLinkedId = linkedLayers.linkId;
        const currentLinks = linkedLayers.links;
        const isParentLayer = currentLinks ? true : false;
        if (isParentLayer) {
            // search for child layers
            currentLinks.map(link => {
                if (!link.properties || link.properties.indexOf(LinkedProperties.OGCFILTERS) === -1) {
                    return;
                }
                link.linkedIds.map(linkedId => {
                    const layerToApply = this.map.layers.find(layer => { var _a; return ((_a = layer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.linkId) === linkedId; });
                    if (layerToApply) {
                        const layerType = layerToApply.ol.getProperties().sourceOptions.type;
                        layerToApply.dataSource.setOgcFilters(ogcFilters, false);
                        if (layerType === 'wfs') {
                            layerToApply.ol.getSource().refresh();
                        }
                        if (layerType === 'wms') {
                            let appliedOgcFilter;
                            if (this.ol.getProperties().sourceOptions.type === 'wfs') {
                                appliedOgcFilter = this.ogcFilterWriter.handleOgcFiltersAppliedValue(this.layer.dataSource.options, this.dataSource.options.fieldNameGeometry, undefined, this.map.viewController.getOlProjection());
                            }
                            else if (this.ol.getProperties().sourceOptions.type === 'wms') {
                                appliedOgcFilter = this.dataSource.ol.getParams().FILTER;
                            }
                            layerToApply.dataSource.ol.updateParams({ FILTER: appliedOgcFilter });
                        }
                    }
                });
            });
        }
        else {
            // search for parent layer
            this.map.layers.map(layer => {
                var _a;
                if ((_a = layer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.links) {
                    layer.options.linkedLayers.links.map(l => {
                        if (l.properties && l.properties.indexOf(LinkedProperties.OGCFILTERS) !== -1 &&
                            l.bidirectionnal !== false && l.linkedIds.indexOf(currentLinkedId) !== -1) {
                            const layerType = layer.ol.getProperties().sourceOptions.type;
                            if (layerType === 'wfs') {
                                layer.dataSource.setOgcFilters(ogcFilters, true);
                                layer.ol.getSource().refresh();
                            }
                            if (layerType === 'wms') {
                                let appliedOgcFilter;
                                if (this.ol.getProperties().sourceOptions.type === 'wfs') {
                                    appliedOgcFilter = this.ogcFilterWriter.handleOgcFiltersAppliedValue(layer.dataSource.options, this.dataSource.options.fieldNameGeometry, undefined, this.map.viewController.getOlProjection());
                                }
                                else if (this.ol.getProperties().sourceOptions.type === 'wms') {
                                    appliedOgcFilter = this.dataSource.ol.getParams().FILTER;
                                }
                                layer.dataSource.ol.updateParams({ FILTER: appliedOgcFilter });
                                layer.dataSource.setOgcFilters(ogcFilters, true);
                            }
                        }
                    });
                }
            });
        }
    }
    transferTimeFilterProperties(timeFilter) {
        const linkedLayers = this.ol.getProperties().linkedLayers;
        if (!linkedLayers) {
            return;
        }
        const currentLinkedId = linkedLayers.linkId;
        const currentLinks = linkedLayers.links;
        const isParentLayer = currentLinks ? true : false;
        if (isParentLayer) {
            // search for child layers
            currentLinks.map(link => {
                if (!link.properties || link.properties.indexOf(LinkedProperties.TIMEFILTER) === -1) {
                    return;
                }
                link.linkedIds.map(linkedId => {
                    const childLayer = this.map.layers.find(layer => {
                        var _a;
                        return layer.dataSource instanceof WMSDataSource &&
                            ((_a = layer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.linkId) === linkedId;
                    });
                    if (childLayer) {
                        childLayer.dataSource.setTimeFilter(timeFilter, false);
                        const appliedTimeFilter = this.ol.getSource().getParams().TIME;
                        childLayer.dataSource.ol.updateParams({ TIME: appliedTimeFilter });
                    }
                });
            });
        }
        else {
            // search for parent layer
            this.map.layers
                .filter(layer => layer.dataSource instanceof WMSDataSource)
                .map(parentLayer => {
                var _a;
                if ((_a = parentLayer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.links) {
                    parentLayer.options.linkedLayers.links.map(l => {
                        if (l.properties && l.properties.indexOf(LinkedProperties.TIMEFILTER) !== -1 &&
                            l.bidirectionnal !== false && l.linkedIds.indexOf(currentLinkedId) !== -1) {
                            const appliedTimeFilter = this.ol.getSource().getParams().TIME;
                            parentLayer.dataSource.ol.updateParams({ TIME: appliedTimeFilter });
                            parentLayer.dataSource.setTimeFilter(timeFilter, true);
                        }
                    });
                }
            });
        }
    }
}

class TileWatcher extends Watcher {
    constructor(layer) {
        super();
        this.loaded = 0;
        this.loading = 0;
        this.source = layer.options.source.ol;
        this.id = uuid();
    }
    watch() {
        this.source.on(`tileloadstart`, e => this.handleLoadStart(e));
        this.source.on(`tileloadend`, e => this.handleLoadEnd(e));
        this.source.on(`tileloaderror`, e => this.handleLoadEnd(e));
    }
    unwatch() {
        this.source.un(`tileloadstart`, e => this.handleLoadStart(e));
        this.source.un(`tileloadend`, e => this.handleLoadEnd(e));
        this.source.un(`tileloaderror`, e => this.handleLoadEnd(e));
    }
    handleLoadStart(event) {
        // This is to avoid increasing
        // the number of loaded tiles if a tile was loading
        // before subscribing to this watcher
        if (!event.tile.__watchers__) {
            event.tile.__watchers__ = [];
        }
        event.tile.__watchers__.push(this.id);
        this.loading += 1;
        this.status = SubjectStatus.Working;
    }
    handleLoadEnd(event) {
        if (!event.tile.__watchers__) {
            return;
        }
        const watcherIndex = event.tile.__watchers__.indexOf(this.id);
        if (watcherIndex < 0) {
            return;
        }
        event.tile.__watchers__.splice(watcherIndex, 1);
        this.loaded += 1;
        const loading = this.loading;
        if (this.loaded >= loading) {
            if (loading === this.loading) {
                this.status = SubjectStatus.Done;
                this.loaded = this.loading = 0;
            }
        }
    }
}

/**
 * Get all the layers legend
 * @return Array of legend
 */
function getLayersLegends(layers, view) {
    const legends = [];
    for (const layer of layers) {
        if (layer.visible === false) {
            continue;
        }
        const legendUrls = layer.dataSource.getLegend(undefined, view) || [];
        for (const legendUrl of legendUrls) {
            if (legendUrl.url === undefined) {
                continue;
            }
            // Add legend info to the list
            legends.push({
                title: layer.title,
                url: legendUrl.url
            });
        }
    }
    return legends;
}

class FeatureDataSource extends DataSource {
    createOlSource() {
        const sourceOptions = {
            format: this.getSourceFormatFromOptions(this.options)
        };
        return new OlVectorSource(Object.assign(sourceOptions, this.options));
    }
    getSourceFormatFromOptions(options) {
        if (options.format) {
            return options.format;
        }
        let olFormatCls;
        const formatType = options.formatType;
        if (!formatType) {
            olFormatCls = olformat.GeoJSON;
        }
        else {
            olFormatCls = olformat[formatType];
            if (olFormatCls === undefined) {
                throw new Error('Invalid vector source format ${formatType}.');
            }
        }
        const formatOptions = options.formatOptions;
        let format;
        if (formatOptions) {
            format = new olFormatCls(formatOptions);
        }
        else {
            format = new olFormatCls();
        }
        return format;
    }
    onUnwatch() { }
    get queryTitle() {
        return this.options.queryTitle
            ? this.options.queryTitle
            : 'title';
    }
}

class ClusterDataSource extends FeatureDataSource {
    createOlSource() {
        this.options.format = this.getSourceFormatFromOptions(this.options);
        this.options.source = super.createOlSource();
        return new olSourceCluster(this.options);
    }
    generateId() {
        return uuid();
    }
    onUnwatch() { }
}

class VectorWatcher extends Watcher {
    constructor(layer) {
        super();
        this.loaded = 0;
        this.loading = 0;
        this.layer = layer;
        this.id = uuid();
    }
    watch() {
        let olSource = this.layer.options.source.ol;
        if (this.layer.dataSource instanceof ClusterDataSource) {
            olSource = this.layer.options.source.options.source;
        }
        if (olSource.getUrl()) {
            olSource.on(`featuresloadstart`, e => this.handleLoadStart(e));
            olSource.on(`featuresloadend`, e => this.handleLoadEnd(e));
            olSource.on(`featuresloaderror`, e => this.handleLoadEnd(e));
        }
    }
    unwatch() {
        let olSource = this.layer.options.source.ol;
        if (this.layer.dataSource instanceof ClusterDataSource) {
            olSource = this.layer.options.source.options.source;
        }
        if (olSource.getUrl()) {
            olSource.un(`featuresloadstart`, e => this.handleLoadStart(e));
            olSource.un(`featuresloadend`, e => this.handleLoadEnd(e));
            olSource.un(`featuresloaderror`, e => this.handleLoadEnd(e));
        }
    }
    handleLoadStart(event) {
        this.loading += 1;
        this.status = SubjectStatus.Working;
    }
    handleLoadEnd(event) {
        this.loaded += 1;
        const loading = this.loading;
        if (this.loaded >= loading) {
            if (loading === this.loading) {
                this.status = SubjectStatus.Done;
                this.loaded = this.loading = 0;
            }
        }
    }
}

/**
 * This method extracts a coordinate tuple from a string.
 * @param str Any string
 * @param mapProjection string Map Projection
 * @param opts.forceNA boolean Force North America Zone
 * @returns object:
 *             lonLat: Coordinate,
 *             message: Message of error,
 *             radius: radius of the confience of coordinate,
 *             conf: confidence of the coordinate}
 */
function stringToLonLat(str, mapProjection, opts = {}) {
    let lonLat;
    let coordStr;
    let negativeLon;
    let degreesLon;
    let minutesLon;
    let secondsLon;
    let directionLon;
    let decimalLon;
    let negativeLat;
    let degreesLat;
    let minutesLat;
    let secondsLat;
    let directionLat;
    let decimalLat;
    let zone;
    let radius;
    let conf;
    let lon;
    let lat;
    const projectionPattern = '(\\s*;\\s*[\\d]{4,6})';
    const toProjection = '4326';
    let projectionStr;
    const projectionRegex = new RegExp(projectionPattern, 'g');
    const lonlatCoord = '([-+])?([\\d]{1,3})([,.](\\d+))?';
    const lonLatPattern = `${lonlatCoord}[\\s,]+${lonlatCoord}`;
    const lonLatRegex = new RegExp(`^${lonLatPattern}$`, 'g');
    const dmsCoord = '([0-9]{1,2})[:|°]?\\s*([0-9]{1,2})?[:|\'|′|’]?\\s*([0-9]{1,2}(?:.[0-9]+){0,1})?\\s*["|″|”]?\\s*';
    const dmsCoordPattern = `${dmsCoord}([N|S|E|W|O]),?\\s*${dmsCoord}([N|S|E|W|O])`;
    const dmsRegex = new RegExp(`^${dmsCoordPattern}$`, 'gi');
    const patternUtm = '(UTM)-?(\\d{1,2})[\\s,]*(\\d+[.,]?\\d+)[\\s,]+(\\d+[.,]?\\d+)';
    const utmRegex = new RegExp(`^${patternUtm}`, 'gi');
    const patternMtm = '(MTM)-?(\\d{1,2})[\\s,]*(\\d+[.,]?\\d+)[\\s,]+(\\d+[.,]?\\d+)';
    const mtmRegex = new RegExp(`^${patternMtm}`, 'gi');
    const ddCoord = '([-+])?(\\d{1,3})[,.](\\d+)';
    const patternDd = `${ddCoord}\\s*[,]?\\s*${ddCoord}`;
    const ddRegex = new RegExp(`^${patternDd}`, 'g');
    const dmdCoord = '([-+])?(\\d{1,3})[\\s,.]{1}(\\d{1,2})[\\s,.]{1}(\\d{1,2})[.,]?(\\d{1,5})?';
    const patternDmd = `${dmdCoord}\\s*[,.]?\\s*${dmdCoord}`;
    const dmdRegex = new RegExp(`^${patternDmd}`, 'g');
    /* eslint-disable max-len */
    const patternBELL = 'LAT\\s*[\\s:]*\\s*([-+])?(\\d{1,2})[\\s.,]?(\\d+)?[\\s.,]?\\s*(\\d{1,2}([.,]\\d+)?)?\\s*(N|S|E|W)?\\s*LONG\\s*[\\s:]*\\s*([-+])?(\\d{1,3})[\\s.,]?(\\d+)?[\\s.,]?\\s*(\\d{1,2}([.,]\\d+)?)?\\s*(N|S|E|W)?\\s*UNC\\s*[\\s:]?\\s*(\\d+)\\s*CONF\\s*[\\s:]?\\s*(\\d{1,3})';
    const bellRegex = new RegExp(`^${patternBELL}?`, 'gi');
    const mmCoord = '([-+]?\\d+)[,.]?(\\d+)?';
    const mmPattern = `${mmCoord}[\\s,]+${mmCoord}`;
    const mmRegex = new RegExp(`^${mmPattern}$`, 'g');
    let isXYCoords = false;
    str = str.toLocaleUpperCase().trim();
    // Extract projection
    if (projectionRegex.test(str)) {
        [coordStr, projectionStr] = str.split(';').map(s => s.trim());
    }
    else {
        coordStr = str;
    }
    if (lonLatRegex.test(coordStr)) {
        [
            ,
            negativeLon,
            lon,
            ,
            decimalLon,
            negativeLat,
            lat,
            ,
            decimalLat
        ] = coordStr.match(lonLatPattern);
        lon = parseFloat((negativeLon ? negativeLon : '') + lon + '.' + decimalLon);
        lat = parseFloat((negativeLat ? negativeLat : '') + lat + '.' + decimalLat);
    }
    else if (dmsRegex.test(coordStr)) {
        [
            ,
            degreesLon,
            minutesLon,
            secondsLon,
            directionLon,
            degreesLat,
            minutesLat,
            secondsLat,
            directionLat
        ] = coordStr.match(dmsCoordPattern);
        if (directionLon === 'S' || directionLon === 'N') {
            degreesLon = [degreesLat, (degreesLat = degreesLon)][0];
            minutesLon = [minutesLat, (minutesLat = minutesLon)][0];
            secondsLon = [secondsLat, (secondsLat = secondsLon)][0];
            directionLon = [directionLat, (directionLat = directionLon)][0];
        }
        lon = convertDMSToDD(parseFloat(degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        lat = convertDMSToDD(parseFloat(degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
    }
    else if (utmRegex.test(coordStr)) {
        isXYCoords = true;
        [, , zone, lon, lat] = coordStr.match(patternUtm);
        const epsgUtm = Number(zone) < 10 ? `EPSG:3260${zone}` : `EPSG:326${zone}`;
        [lon, lat] = olproj.transform([parseFloat(lon), parseFloat(lat)], epsgUtm, 'EPSG:4326');
    }
    else if (mtmRegex.test(coordStr)) {
        isXYCoords = true;
        [, , zone, lon, lat] = coordStr.match(patternMtm);
        const epsgMtm = Number(zone) < 10 ? `EPSG:3218${zone}` : `EPSG:321${80 + Number(zone)}`;
        [lon, lat] = olproj.transform([parseFloat(lon), parseFloat(lat)], epsgMtm, 'EPSG:4326');
    }
    else if (dmdRegex.test(coordStr)) {
        [
            ,
            negativeLon,
            degreesLon,
            minutesLon,
            secondsLon,
            decimalLon,
            negativeLat,
            degreesLat,
            minutesLat,
            secondsLat,
            decimalLat
        ] = coordStr.match(patternDmd);
        lon = convertDMSToDD(parseFloat((negativeLon ? negativeLon : '') + degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        lat = convertDMSToDD(parseFloat((negativeLat ? negativeLat : '') + degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
    }
    else if (ddRegex.test(coordStr)) {
        [
            ,
            negativeLon,
            degreesLon,
            decimalLon,
            negativeLat,
            degreesLat,
            decimalLat
        ] = coordStr.match(patternDd);
        lon = convertDMSToDD(parseFloat((negativeLon ? negativeLon : '') + degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        lat = convertDMSToDD(parseFloat((negativeLat ? negativeLat : '') + degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
    }
    else if (bellRegex.test(coordStr)) {
        [
            ,
            negativeLat,
            degreesLat,
            minutesLat,
            secondsLat,
            ,
            directionLat,
            negativeLon,
            degreesLon,
            minutesLon,
            secondsLon,
            ,
            directionLon,
            radius,
            conf
        ] = coordStr.match(patternBELL);
        // Set default value for North America
        if (!directionLon) {
            directionLon = 'W';
        }
        // Check if real minutes or decimals
        if (minutesLon && minutesLon.length > 2) {
            lon = parseFloat((negativeLon ? negativeLon : '') + degreesLon + '.' + minutesLon);
        }
        else {
            lon = convertDMSToDD(parseFloat(degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        }
        if (minutesLat && minutesLat.length > 2) {
            lat = parseFloat((negativeLat ? negativeLat : '') + degreesLat + '.' + minutesLat);
        }
        else {
            lat = convertDMSToDD(parseFloat(degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
        }
    }
    else if (mmRegex.test(coordStr)) {
        isXYCoords = true;
        [, lon, decimalLon, lat, decimalLat] = coordStr.match(mmPattern);
        if (decimalLon) {
            lon = parseFloat(lon + '.' + decimalLon);
        }
        if (decimalLat) {
            lat = parseFloat(lat + '.' + decimalLat);
        }
    }
    else {
        return {
            lonLat: undefined,
            message: '',
            radius: undefined,
            conf: undefined
        };
    }
    if (opts.forceNA && !isXYCoords) {
        // Set a negative coordinate for North America zone
        if (lon > 0 && lat > 0) {
            if (lon > lat) {
                lon = -lon;
            }
            else {
                lat = -lat;
            }
        }
        // Reverse coordinate to respect lonLat convention
        if (lon > lat) {
            lon = [lat, (lat = lon)][0];
        }
    }
    lonLat = [Number(lon), Number(lat)];
    // Reproject the coordinate if projection parameter have been set and coord is not 4326
    if ((projectionStr !== undefined && projectionStr !== toProjection) ||
        (lonLat[0] > 180 || lonLat[0] < -180) ||
        (lonLat[1] > 90 || lonLat[1] < -90)) {
        const source = projectionStr ? 'EPSG:' + projectionStr : mapProjection;
        const dest = 'EPSG:' + toProjection;
        try {
            lonLat = olproj.transform(lonLat, source, dest);
        }
        catch (e) {
            return {
                lonLat: undefined,
                message: 'Projection ' + source + ' not supported',
                radius: undefined,
                conf: undefined
            };
        }
    }
    if (Math.abs(lonLat[0]) <= 180 && Math.abs(lonLat[1]) <= 90) {
        return {
            lonLat,
            message: '',
            radius: radius ? parseInt(radius, 10) : undefined,
            conf: conf ? parseInt(conf, 10) : undefined
        };
    }
    else {
        return {
            lonLat: undefined,
            message: 'Coordinate out of Longitude/Latitude bounds',
            radius: undefined,
            conf: undefined
        };
    }
}
/**
 * Convert degrees minutes seconds to dd
 * @param degrees Degrees
 * @param minutes Minutes
 * @param seconds Seconds
 * @param direction Direction
 */
function convertDMSToDD(degrees, minutes, seconds, direction) {
    minutes = minutes || 0;
    seconds = seconds || 0;
    const neg = degrees < 0;
    let dd = Math.abs(degrees) + minutes / 60 + seconds / 3600;
    if (neg || direction === 'S' || direction === 'W') {
        dd = -dd;
    } // Don't do anything for N or E
    return dd;
}
/**
 * Convert dd to degrees minutes seconds
 * @param lonLatDD longitude and latitude in dd
 * @param decimal number of decimals for seconds
 * @returns longitude and latitude in dms
 */
function convertDDToDMS(lonLatDD, decimal = 3) {
    const lonLatDMS = [];
    lonLatDD.forEach(dd => {
        const degrees = dd < 0 ? Math.ceil(dd) : Math.floor(dd);
        const int = dd < 0 ? (degrees - dd) * 60 : (dd - degrees) * 60;
        const minutes = Math.floor(int);
        const seconds = ((int - minutes) * 60).toFixed(decimal);
        lonLatDMS.push(`${degrees}° ${minutes}' ${seconds}"`);
    });
    return lonLatDMS;
}
/**
 * Return true of two view states are equal.
 * @param state1 View state
 * @param state2 View state
 * @returns True if the view states are equal
 */
function viewStatesAreEqual(state1, state2) {
    if (state1 === undefined || state2 === undefined) {
        return false;
    }
    const tolerance = 1 / 10000;
    return (state1.zoom === state2.zoom &&
        Math.trunc(state1.center[0] / tolerance) ===
            Math.trunc(state2.center[0] / tolerance) &&
        Math.trunc(state1.center[1] / tolerance) ===
            Math.trunc(state2.center[1] / tolerance));
}
/**
 * Format the scale to a human readable text
 * @param Scale of the map
 * @returns Human readable scale text
 */
function formatScale(scale) {
    scale = Math.round(scale);
    if (scale < 10000) {
        return scale + '';
    }
    scale = Math.round(scale / 1000);
    if (scale < 1000) {
        return scale + 'K';
    }
    scale = Math.round(scale / 1000);
    return scale + 'M';
}
/**
 * Return the resolution from a scale denom
 * @param scale Scale denom
 * @param dpi DPI
 * @returns Resolution
 */
function getResolutionFromScale(scale, dpi = 96) {
    const inchesPerMeter = 39.3701;
    return scale / (inchesPerMeter * dpi);
}
/**
 * Return the resolution from a scale denom
 * @param Scale denom
 * @returns Resolution
 */
function getScaleFromResolution(resolution, unit = 'm', dpi = 96) {
    const inchesPerMeter = 39.3701;
    return resolution * olproj.METERS_PER_UNIT[unit] * inchesPerMeter * dpi;
}
/**
 * Returns true if the CTRL key is pushed during an Ol MapBrowserPointerEvent
 * @param event OL MapBrowserPointerEvent
 * @returns Whether the CTRL key is pushed
 */
function ctrlKeyDown(event) {
    const originalEvent = event.originalEvent;
    return (!originalEvent.altKey &&
        (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&
        !originalEvent.shiftKey);
}
function roundCoordTo(coord, decimal = 3) {
    return [
        NumberUtils.roundToNDecimal(coord[0], decimal),
        NumberUtils.roundToNDecimal(coord[1], decimal)
    ];
}
/**
 * Returns an array of converted coordinates.
 * Conversion is done for every configured projections
 * and for the current UTM zone and MTM zone.
 * @param lonLat [number, number] array of the coordinate to transform.
 * @param projections  Projection[] Array of destination projection.
 * @returns Returns an array of converted coordinates.
 */
function lonLatConversion(lonLat, projections) {
    const rawCoord3857 = olproj.transform(lonLat, 'EPSG:4326', 'EPSG:3857');
    const convertedLonLat = [
        {
            code: 'EPSG:3857',
            alias: 'Web Mercator',
            coord: rawCoord3857,
            igo2CoordFormat: `${roundCoordTo(rawCoord3857).join(', ')} ; 3857`
        }
    ];
    // detect the current utm zone.
    const utmZone = utmZoneFromLonLat(lonLat);
    const epsgUtm = utmZone < 10 ? `EPSG:3260${utmZone}` : `EPSG:326${utmZone}`;
    const utmName = `UTM-${utmZone}`;
    const rawCoordUtm = olproj.transform(lonLat, 'EPSG:4326', epsgUtm);
    convertedLonLat.push({
        code: epsgUtm,
        alias: 'UTM',
        coord: rawCoordUtm,
        igo2CoordFormat: `${utmName} ${roundCoordTo(rawCoordUtm).join(', ')}`
    });
    // detect the current mtm zone.
    const mtmZone = mtmZoneFromLonLat(lonLat);
    if (mtmZone) {
        const epsgMtm = mtmZone < 10 ? `EPSG:3218${mtmZone}` : `EPSG:321${80 + mtmZone}`;
        const mtmName = `MTM-${mtmZone}`;
        const rawCoordMtm = olproj.transform(lonLat, 'EPSG:4326', epsgMtm);
        convertedLonLat.push({
            code: epsgMtm,
            alias: 'MTM',
            coord: rawCoordMtm,
            igo2CoordFormat: `${mtmName} ${roundCoordTo(rawCoordMtm).join(', ')}`
        });
    }
    projections.forEach(projection => {
        const rawCoord = olproj.transform(lonLat, 'EPSG:4326', projection.code);
        const numericEpsgCode = projection.code.split(':')[1];
        convertedLonLat.push({
            code: projection.code,
            alias: projection.alias || projection.code,
            coord: rawCoord,
            igo2CoordFormat: `${roundCoordTo(rawCoord).join(', ')} ; ${numericEpsgCode}`
        });
    });
    return convertedLonLat;
}
/**
 * Detect the current utm zone of the lon/lat coordinate.
 * @param lonLat [number, number] array of the coordinate to detect the UTM zone.
 * @returns number The UTM zone.
 */
function utmZoneFromLonLat(lonLat) {
    return Math.ceil((lonLat[0] + 180) / 6);
}
/**
 * Detect the current mtm zone of the lon/lat coordinate.
 * @param lonLat [number, number] array of the coordinate to detect the MTM zone.
 * @returns number The MTM zone. Undefined if outside of the mtm application zone.
 */
function mtmZoneFromLonLat(lonLat) {
    const long = lonLat[0];
    let mtmZone;
    if (long < -51 && long > -54) {
        mtmZone = 1;
    }
    if (long < -54 && long > -57) {
        mtmZone = 2;
    }
    if (long < -57 && long > -60) {
        mtmZone = 3;
    }
    if (long < -60 && long > -63) {
        mtmZone = 4;
    }
    if (long < -63 && long > -66) {
        mtmZone = 5;
    }
    if (long < -66 && long > -69) {
        mtmZone = 6;
    }
    if (long < -69 && long > -72) {
        mtmZone = 7;
    }
    if (long < -72 && long > -75) {
        mtmZone = 8;
    }
    if (long < -75 && long > -78) {
        mtmZone = 9;
    }
    if (long < -78 && long > -81) {
        mtmZone = 10;
    }
    return mtmZone;
}

class Layer {
    constructor(options, messageService, authInterceptor) {
        this.options = options;
        this.messageService = messageService;
        this.authInterceptor = authInterceptor;
        this.legendCollapsed = true;
        this.firstLoadComponent = true;
        this.olLoadingProblem = false;
        this.hasBeenVisible$ = new BehaviorSubject(undefined);
        this.isInResolutionsRange$ = new BehaviorSubject(false);
        this.visible$ = new BehaviorSubject(undefined);
        this.displayed$ = combineLatest([
            this.isInResolutionsRange$,
            this.visible$
        ]).pipe(map((bunch) => bunch[0] && bunch[1]));
        this.dataSource = options.source;
        this.ol = this.createOlLayer();
        if (options.zIndex !== undefined) {
            this.zIndex = options.zIndex;
        }
        if (options.baseLayer && options.visible === undefined) {
            options.visible = false;
        }
        this.maxResolution = options.maxResolution || getResolutionFromScale(Number(options.maxScaleDenom));
        this.minResolution = options.minResolution || getResolutionFromScale(Number(options.minScaleDenom));
        this.visible = options.visible === undefined ? true : options.visible;
        this.opacity = options.opacity === undefined ? 1 : options.opacity;
        if (options.legendOptions &&
            (options.legendOptions.url || options.legendOptions.html)) {
            this.legend = this.dataSource.setLegend(options.legendOptions);
        }
        this.legendCollapsed = options.legendOptions
            ? options.legendOptions.collapsed
                ? options.legendOptions.collapsed
                : true
            : true;
        this.ol.set('_layer', this, true);
    }
    /**
     * Define if a layer is generated by code OR defined by layer/context user layer.
     * Useful for filtering layers list in mapOffline.directive or in the sharemap...
     * return false by default.
     */
    get isIgoInternalLayer() {
        return this.options.isIgoInternalLayer || false;
    }
    get id() {
        return this.options.id || this.dataSource.id;
    }
    get alias() {
        return this.options.alias;
    }
    get title() {
        return this.options.title;
    }
    set title(title) {
        this.options.title = title;
    }
    get zIndex() {
        return this.ol.getZIndex();
    }
    set zIndex(zIndex) {
        this.ol.setZIndex(zIndex);
    }
    get baseLayer() {
        return this.options.baseLayer;
    }
    set baseLayer(baseLayer) {
        this.options.baseLayer = baseLayer;
    }
    get opacity() {
        return this.ol.get('opacity');
    }
    set opacity(opacity) {
        this.ol.setOpacity(opacity);
    }
    set isInResolutionsRange(value) {
        this.isInResolutionsRange$.next(value);
    }
    get isInResolutionsRange() {
        return this.isInResolutionsRange$.value;
    }
    set maxResolution(value) {
        this.ol.setMaxResolution(value || Infinity);
        this.updateInResolutionsRange();
    }
    get maxResolution() {
        return this.ol.getMaxResolution();
    }
    set minResolution(value) {
        this.ol.setMinResolution(value || 0);
        this.updateInResolutionsRange();
    }
    get minResolution() {
        return this.ol.getMinResolution();
    }
    set visible(value) {
        var _a, _b;
        this.ol.setVisible(value);
        this.visible$.next(value);
        if (!this.hasBeenVisible$.value && value) {
            this.hasBeenVisible$.next(value);
        }
        if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.messages) && value) {
            (_b = this.options) === null || _b === void 0 ? void 0 : _b.messages.filter(m => { var _a; return (_a = m.options) === null || _a === void 0 ? void 0 : _a.showOnEachLayerVisibility; }).map(message => this.showMessage(message));
        }
    }
    get visible() {
        return this.visible$.value;
    }
    get displayed() {
        return this.visible && this.isInResolutionsRange;
    }
    get showInLayerList() {
        return this.options.showInLayerList !== false;
    }
    setMap(igoMap) {
        this.map = igoMap;
        this.unobserveResolution();
        if (igoMap !== undefined) {
            this.observeResolution();
            this.layerSyncWatcher = new LayerSyncWatcher(this, this.map);
            this.layerSyncWatcher.subscribe(() => { });
            this.hasBeenVisible$$ = this.hasBeenVisible$.subscribe(() => {
                if (this.options.messages && this.visible) {
                    this.options.messages.map(message => {
                        this.showMessage(message);
                    });
                }
            });
        }
        else {
            this.layerSyncWatcher.unsubscribe();
        }
    }
    showMessage(message) {
        if (!this.messageService) {
            return;
        }
        message.title = message.title;
        message.text = message.text;
        this.messageService.message(message);
    }
    observeResolution() {
        this.resolution$$ = this.map.viewController.resolution$.subscribe(() => this.updateInResolutionsRange());
    }
    unobserveResolution() {
        if (this.resolution$$ !== undefined) {
            this.resolution$$.unsubscribe();
            this.resolution$$ = undefined;
        }
    }
    updateInResolutionsRange() {
        if (this.map !== undefined) {
            const resolution = this.map.viewController.getResolution();
            const minResolution = this.minResolution;
            const maxResolution = this.maxResolution === undefined ? Infinity : this.maxResolution;
            this.isInResolutionsRange = resolution >= minResolution && resolution <= maxResolution;
        }
        else {
            this.isInResolutionsRange = false;
        }
    }
}

class VectorLayer extends Layer {
    constructor(options, messageService, authInterceptor) {
        super(options, messageService, authInterceptor);
        this.messageService = messageService;
        this.authInterceptor = authInterceptor;
        this.watcher = new VectorWatcher(this);
        this.status$ = this.watcher.status$;
    }
    get browsable() {
        return this.options.browsable !== false;
    }
    get exportable() {
        return this.options.exportable !== false;
    }
    createOlLayer() {
        const olOptions = Object.assign({}, this.options, {
            source: this.options.source.ol
        });
        if (this.options.animation) {
            this.dataSource.ol.on('addfeature', function (e) {
                this.flash(e.feature);
            }.bind(this));
        }
        if (this.options.trackFeature) {
            this.enableTrackFeature(this.options.trackFeature);
        }
        const vector = new OlVectorLayer(olOptions);
        const vectorSource = vector.getSource();
        const url = vectorSource.getUrl();
        if (url) {
            let loader;
            const wfsOptions = olOptions.sourceOptions;
            if ((wfsOptions === null || wfsOptions === void 0 ? void 0 : wfsOptions.type) === 'wfs' && (wfsOptions.params || wfsOptions.paramsWFS)) {
                loader = (extent, resolution, proj, success, failure) => {
                    this.customWFSLoader(vectorSource, wfsOptions, this.authInterceptor, extent, resolution, proj, success, failure);
                };
            }
            else {
                loader = (extent, resolution, proj, success, failure) => {
                    this.customLoader(vectorSource, url, this.authInterceptor, extent, resolution, proj, success, failure);
                };
            }
            if (loader) {
                vectorSource.setLoader(loader);
            }
        }
        return vector;
    }
    flash(feature) {
        const start = new Date().getTime();
        const listenerKey = this.ol.on('postrender', animate.bind(this));
        function animate(event) {
            const vectorContext = getVectorContext(event);
            const frameState = event.frameState;
            const flashGeom = feature.getGeometry().clone();
            const elapsed = frameState.time - start;
            const elapsedRatio = elapsed / this.options.animation.duration;
            const opacity = easeOut(1 - elapsedRatio);
            const newColor = asArray(this.options.animation.color || 'red');
            newColor[3] = opacity;
            let style = this.ol
                .getStyleFunction()
                .call(this, feature)
                .find((style2) => {
                return style2.getImage();
            });
            if (!style) {
                style = this.ol.getStyleFunction().call(this, feature)[0];
            }
            const styleClone = style.clone();
            switch (feature.getGeometry().getType()) {
                case 'Point':
                    const radius = easeOut(elapsedRatio) * (styleClone.getImage().getRadius() * 3);
                    styleClone.getImage().setRadius(radius);
                    styleClone.getImage().setOpacity(opacity);
                    break;
                case 'LineString':
                    // TODO
                    if (styleClone.getImage()) {
                        styleClone.getImage().getStroke().setColor(newColor);
                        styleClone
                            .getImage()
                            .getStroke()
                            .setWidth(easeOut(elapsedRatio) *
                            (styleClone.getImage().getStroke().getWidth() * 3));
                    }
                    if (styleClone.getStroke()) {
                        styleClone.getStroke().setColor(newColor);
                        styleClone
                            .getStroke()
                            .setWidth(easeOut(elapsedRatio) * (styleClone.getStroke().getWidth() * 3));
                    }
                    break;
                case 'Polygon':
                    // TODO
                    if (styleClone.getImage()) {
                        styleClone.getImage().getFill().setColor(newColor);
                    }
                    if (styleClone.getFill()) {
                        styleClone.getFill().setColor(newColor);
                    }
                    break;
            }
            styleClone.setText('');
            vectorContext.setStyle(styleClone);
            vectorContext.drawGeometry(flashGeom);
            if (elapsed > this.options.animation.duration) {
                unByKey(listenerKey);
                // remove last geometry
                // there is a little flash before feature disappear, better solution ?
                this.map.ol.render();
                return;
            }
            // tell OpenLayers to continue postcompose animation
            this.map.ol.render();
        }
    }
    setMap(map) {
        if (map === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe(() => { });
        }
        super.setMap(map);
    }
    onUnwatch() {
        this.dataSource.onUnwatch();
        this.stopAnimation();
    }
    stopAnimation() {
        this.dataSource.ol.un('addfeature', function (e) {
            if (this.visible) {
                this.flash(e.feature);
            }
        }.bind(this));
    }
    enableTrackFeature(id) {
        this.trackFeatureListenerId = this.dataSource.ol.on('addfeature', this.trackFeature.bind(this, id));
    }
    centerMapOnFeature(id) {
        const feat = this.dataSource.ol.getFeatureById(id);
        if (feat) {
            this.map.ol.getView().setCenter(feat.getGeometry().getCoordinates());
        }
    }
    trackFeature(id, feat) {
        if (feat.feature.getId() === id && this.visible) {
            this.centerMapOnFeature(id);
        }
    }
    disableTrackFeature(id) {
        unByKey(this.trackFeatureListenerId);
    }
    /**
     * Custom loader for a WFS datasource
     * @internal
     * @param vectorSource the vector source to be created
     * @param options olOptions from source
     * @param interceptor the interceptor of the data
     * @param extent the extent of the requested data
     * @param resolution the current resolution
     * @param proj the projection to retrieve the data
     * @param success success callback
     * @param failure failure callback
     * @param randomParam random parameter to ensure cache is not causing problems in retrieving new data
     */
    customWFSLoader(vectorSource, options, interceptor, extent, resolution, proj, success, failure, randomParam) {
        {
            const paramsWFS = options.paramsWFS;
            const wfsProj = paramsWFS.srsName ? new olProjection({ code: paramsWFS.srsName }) : proj;
            const currentExtent = olproj.transformExtent(extent, proj, wfsProj);
            paramsWFS.srsName = paramsWFS.srsName || proj.getCode();
            const url = buildUrl(options, currentExtent, wfsProj, options.ogcFilters, randomParam);
            let startIndex = 0;
            if (paramsWFS.version === '2.0.0' && paramsWFS.maxFeatures > defaultMaxFeatures) {
                const nbOfFeature = 1000;
                while (startIndex < paramsWFS.maxFeatures) {
                    let alteredUrl = url.replace('count=' + paramsWFS.maxFeatures, 'count=' + nbOfFeature);
                    alteredUrl = alteredUrl.replace('startIndex=0', '0');
                    alteredUrl += '&startIndex=' + startIndex;
                    alteredUrl.replace(/&&/g, '&');
                    this.getFeatures(vectorSource, interceptor, currentExtent, wfsProj, proj, alteredUrl, nbOfFeature, success, failure);
                    startIndex += nbOfFeature;
                }
            }
            else {
                this.getFeatures(vectorSource, interceptor, currentExtent, wfsProj, proj, url, paramsWFS.maxFeatures, success, failure);
            }
        }
    }
    /**
     * Custom loader to get feature from a WFS datasource
     * @internal
     * @param vectorSource the vector source to be created
     * @param interceptor the interceptor of the data
     * @param extent the extent of the requested data
     * @param dataProjection the projection of the retrieved data
     * @param featureProjection the projection of the created features
     * @param url the url string to retrieve the data
     * @param threshold the threshold to manage "more features" (TODO)
     * @param success success callback
     * @param failure failure callback
     */
    getFeatures(vectorSource, interceptor, extent, dataProjection, featureProjection, url, threshold, success, failure) {
        const idAssociatedCall = this.dataSource.mostRecentIdCallOGCFilter;
        const xhr = new XMLHttpRequest();
        const alteredUrlWithKeyAuth = interceptor.alterUrlWithKeyAuth(url);
        let modifiedUrl = url;
        if (alteredUrlWithKeyAuth) {
            modifiedUrl = alteredUrlWithKeyAuth;
        }
        xhr.open('GET', modifiedUrl);
        if (interceptor) {
            interceptor.interceptXhr(xhr, modifiedUrl);
        }
        const onError = () => {
            vectorSource.removeLoadedExtent(extent);
            failure();
        };
        xhr.onerror = onError;
        xhr.onload = () => {
            if (xhr.status === 200 && xhr.responseText.length > 0) {
                const features = vectorSource
                    .getFormat()
                    .readFeatures(xhr.responseText, { dataProjection, featureProjection });
                // TODO Manage "More feature"
                /*if (features.length === 0 || features.length < threshold ) {
                  console.log('No more data to download at this resolution');
                }*/
                // Avoids retrieving an older call that took longer to be process
                if (idAssociatedCall === this.dataSource.mostRecentIdCallOGCFilter) {
                    vectorSource.addFeatures(features);
                    success(features);
                }
                else {
                    success([]);
                }
            }
            else {
                onError();
            }
        };
        xhr.send();
    }
    /**
     * Custom loader for vector layer.
     * @internal
     * @param vectorSource the vector source to be created
     * @param url the url string or function to retrieve the data
     * @param interceptor the interceptor of the data
     * @param extent the extent of the requested data
     * @param resolution the current resolution
     * @param projection the projection to retrieve the data
     */
    customLoader(vectorSource, url, interceptor, extent, resolution, projection, success, failure) {
        const xhr = new XMLHttpRequest();
        let modifiedUrl = url;
        if (typeof url !== 'function') {
            const alteredUrlWithKeyAuth = interceptor.alterUrlWithKeyAuth(url);
            if (alteredUrlWithKeyAuth) {
                modifiedUrl = alteredUrlWithKeyAuth;
            }
        }
        else {
            modifiedUrl = url(extent, resolution, projection);
        }
        xhr.open('GET', modifiedUrl);
        const format = vectorSource.getFormat();
        if (format.getType() === FormatType.ARRAY_BUFFER) {
            xhr.responseType = 'arraybuffer';
        }
        if (interceptor) {
            interceptor.interceptXhr(xhr, modifiedUrl);
        }
        const onError = () => {
            vectorSource.removeLoadedExtent(extent);
            failure();
        };
        xhr.onerror = onError;
        xhr.onload = () => {
            // status will be 0 for file:// urls
            if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {
                const type = format.getType();
                let source;
                if (type === FormatType.JSON || type === FormatType.TEXT) {
                    source = xhr.responseText;
                }
                else if (type === FormatType.XML) {
                    source = xhr.responseXML;
                    if (!source) {
                        source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
                    }
                }
                else if (type === FormatType.ARRAY_BUFFER) {
                    source = xhr.response;
                }
                if (source) {
                    const features = format.readFeatures(source, { extent, featureProjection: projection });
                    vectorSource.addFeatures(features, format.readProjection(source));
                    success(features);
                }
                else {
                    onError();
                }
            }
            else {
                onError();
            }
        };
        xhr.send();
    }
}

class DataService {
}

class OSMDataSource extends DataSource {
    createOlSource() {
        if (!this.options.url) {
            this.options.url = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
        }
        return new olSourceOSM(this.options);
    }
    onUnwatch() { }
}

class XYZDataSource extends DataSource {
    createOlSource() {
        return new olSourceXYZ(this.options);
    }
    onUnwatch() { }
}

class WFSDataSource extends DataSource {
    constructor(options, wfsService, authInterceptor) {
        super(checkWfsParams(options, 'wfs'));
        this.options = options;
        this.wfsService = wfsService;
        this.authInterceptor = authInterceptor;
        this.mostRecentIdCallOGCFilter = 0;
        this.ogcFilters$ = new BehaviorSubject(undefined);
        const ogcFilters = this.options.ogcFilters;
        const fieldNameGeometry = this.options.paramsWFS.fieldNameGeometry || defaultFieldNameGeometry;
        const ogcFilterWriter = new OgcFilterWriter();
        this.options.ogcFilters =
            ogcFilterWriter.defineOgcFiltersDefaultOptions(ogcFilters, fieldNameGeometry);
        if (this.options.ogcFilters.enabled &&
            this.options.ogcFilters.editable &&
            (options.sourceFields || []).filter(sf => !sf.values).length > 0) {
            this.wfsService.getSourceFieldsFromWFS(this.options);
        }
        if (ogcFilters === null || ogcFilters === void 0 ? void 0 : ogcFilters.pushButtons) {
            ogcFilters.pushButtons.selectorType = 'pushButton';
        }
        if (ogcFilters === null || ogcFilters === void 0 ? void 0 : ogcFilters.checkboxes) {
            ogcFilters.checkboxes.selectorType = 'checkbox';
        }
        if (ogcFilters === null || ogcFilters === void 0 ? void 0 : ogcFilters.radioButtons) {
            ogcFilters.radioButtons.selectorType = 'radioButton';
        }
        if (ogcFilters === null || ogcFilters === void 0 ? void 0 : ogcFilters.select) {
            ogcFilters.select.selectorType = 'select';
        }
        this.setOgcFilters(this.options.ogcFilters, true);
    }
    set ogcFilters(value) {
        this.options.ogcFilters = value;
    }
    get ogcFilters() {
        return this.options.ogcFilters;
    }
    createOlSource() {
        const vectorSource = new OlVectorSource({
            format: getFormatFromOptions(this.options),
            url: (extent, resolution, proj) => {
                const paramsWFS = this.options.paramsWFS;
                const wfsProj = paramsWFS.srsName ? new olProjection({ code: paramsWFS.srsName }) : proj;
                const ogcFilters = this.options.ogcFilters;
                const currentExtent = olproj.transformExtent(extent, proj, wfsProj);
                paramsWFS.srsName = paramsWFS.srsName || proj.getCode();
                return buildUrl(this.options, currentExtent, wfsProj, ogcFilters);
            },
            strategy: OlLoadingStrategy.bbox
        });
        return vectorSource;
    }
    setOgcFilters(ogcFilters, triggerEvent = false) {
        this.ogcFilters = ogcFilters;
        this.mostRecentIdCallOGCFilter += 1;
        if (triggerEvent) {
            this.ogcFilters$.next(this.ogcFilters);
        }
    }
    onUnwatch() { }
}

class WFSService extends DataService {
    constructor(http) {
        super();
        this.http = http;
    }
    getData() {
        console.log('This is defining a data service.');
        return 'This is defining a data service.';
    }
    getSourceFieldsFromWFS(dataSourceOptions) {
        if (!dataSourceOptions.sourceFields || dataSourceOptions.sourceFields.length === 0) {
            dataSourceOptions.sourceFields = [];
            this.defineFieldAndValuefromWFS(dataSourceOptions).subscribe(getfeatureSourceField => {
                dataSourceOptions.sourceFields = getfeatureSourceField;
            });
        }
        else {
            this.defineFieldAndValuefromWFS(dataSourceOptions).subscribe(getfeatureSourceField => {
                dataSourceOptions.sourceFields.forEach(sourcefield => {
                    if (sourcefield.alias === undefined) {
                        sourcefield.alias = sourcefield.name; // to allow only a list of sourcefield with names
                    }
                    if (sourcefield.values === undefined || sourcefield.values.length === 0) {
                        sourcefield.values = getfeatureSourceField.find(sf => sf.name === sourcefield.name).values;
                    }
                });
            });
        }
    }
    wfsGetFeature(dataSourceOptions, nb = defaultMaxFeatures, epsgCode = defaultEpsg, propertyName, startIndex = 0, forceDefaultOutputFormat = false) {
        const queryStringValues = formatWFSQueryString(dataSourceOptions, nb, epsgCode, propertyName, startIndex, forceDefaultOutputFormat);
        const baseUrl = queryStringValues.find(f => f.name === 'getfeature').value;
        const outputFormat = dataSourceOptions.paramsWFS.outputFormat;
        if (forceDefaultOutputFormat || gmlRegex.test(outputFormat) || !outputFormat) {
            return this.http.get(baseUrl, { responseType: 'text' });
        }
        else {
            return this.http.get(baseUrl);
        }
    }
    defineFieldAndValuefromWFS(dataSourceOptions) {
        return new Observable(d => {
            var _a;
            const sourceFields = [];
            let fieldList;
            let fieldListWoGeom;
            let fieldListWoGeomStr;
            let olFormats;
            let effectiveOlFormats;
            olFormats = getFormatFromOptions(dataSourceOptions);
            const gmlDataSourceOptions = JSON.parse(JSON.stringify(dataSourceOptions));
            delete gmlDataSourceOptions.paramsWFS.outputFormat;
            delete gmlDataSourceOptions.formatOptions;
            effectiveOlFormats = getFormatFromOptions(gmlDataSourceOptions);
            let sourceFieldsToRetrieveValues = (_a = dataSourceOptions.sourceFields) === null || _a === void 0 ? void 0 : _a.filter(f => !f.values).map(f => f.name);
            // Validate if the service manage no outputformat (wfs 1.0.0 and GML is the default return)
            this.wfsGetFeature(dataSourceOptions, 1, undefined, undefined, 0, true).pipe(concatMap(res => String(res).toLowerCase().includes('exception') ? of(false) : of(true)), concatMap(allowGml => {
                // If the service return GML (return no exception)
                return this.wfsGetFeature(dataSourceOptions, 1).pipe(concatMap(firstFeature => {
                    const features = olFormats.readFeatures(firstFeature);
                    fieldList = features[0].getKeys();
                    if (dataSourceOptions.sourceFields || dataSourceOptions.sourceFields.length === 0) {
                        sourceFieldsToRetrieveValues = fieldList;
                    }
                    fieldListWoGeom = fieldList.filter(field => sourceFieldsToRetrieveValues.includes(field) &&
                        field !== features[0].getGeometryName() &&
                        !field.match(/boundedby/gi));
                    fieldListWoGeomStr = fieldListWoGeom.join(',');
                    const processingArray = [];
                    let startIndex = 0;
                    // If the service do not allow gml return, dice the call in multiple
                    // calls by increment of chunkSize with the original outputFormat
                    if (!allowGml && dataSourceOptions.paramsWFS.version === '2.0.0' &&
                        dataSourceOptions.paramsWFS.maxFeatures > defaultMaxFeatures) {
                        const chunkSize = 1000;
                        while (startIndex < dataSourceOptions.paramsWFS.maxFeatures) {
                            processingArray.push(this.wfsGetFeature(dataSourceOptions, chunkSize, dataSourceOptions.paramsWFS.srsName, fieldListWoGeomStr, startIndex));
                            startIndex += chunkSize;
                        }
                        effectiveOlFormats = olFormats;
                    }
                    else {
                        processingArray.push(this.wfsGetFeature(dataSourceOptions, dataSourceOptions.paramsWFS.maxFeatures || defaultMaxFeatures, dataSourceOptions.paramsWFS.srsName, fieldListWoGeomStr, 0, true));
                    }
                    return combineLatest(processingArray);
                }));
            })).subscribe((results) => {
                let mfeatures = [];
                results.map((result) => {
                    const loopFeatures = effectiveOlFormats.readFeatures(result);
                    mfeatures = mfeatures.concat(loopFeatures);
                });
                this.built_properties_value(mfeatures).forEach(element => {
                    sourceFields.push(element);
                });
                d.next(sourceFields);
                d.complete();
            });
        });
    }
    built_properties_value(features) {
        if (features.length === 0) {
            return [];
        }
        const kv = Object.assign({}, features[0].getProperties());
        delete kv[features[0].getGeometryName()];
        delete kv.boundedBy;
        const sourceFields = [];
        for (const property in kv) {
            if (kv.hasOwnProperty(property)) {
                const fieldType = typeof features[0].get(property) === 'object'
                    ? undefined
                    : typeof features[0].get(property);
                sourceFields.push({
                    name: property,
                    alias: property,
                    type: fieldType,
                    values: [kv[property]]
                });
            }
        }
        features.every((element) => {
            const featureProperties = element.getProperties();
            for (const key in featureProperties) {
                if (featureProperties.hasOwnProperty(key) && key in kv) {
                    sourceFields.filter(f => f.name === key).forEach(v => {
                        if (v.values.indexOf(featureProperties[key]) === -1) {
                            v.values.push(featureProperties[key]);
                        }
                    });
                }
            }
            return true;
        });
        return sourceFields;
    }
}
WFSService.ɵfac = function WFSService_Factory(t) { return new (t || WFSService)(i0.ɵɵinject(i1$2.HttpClient)); };
WFSService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: WFSService, factory: WFSService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(WFSService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1$2.HttpClient }]; }, null); })();

function createDefaultTileGrid(epsg) {
    const projection = epsg ? olproj.get(epsg) : olproj.get('EPSG:3857');
    const projectionExtent = projection.getExtent();
    const size = getWidth(projectionExtent) / 256;
    const resolutions = new Array(20);
    const matrixIds = new Array(20);
    for (let z = 0; z < 20; ++z) {
        resolutions[z] = size / Math.pow(2, z);
        matrixIds[z] = z;
    }
    return new olTileGridWMTS({
        origin: getTopLeft(projectionExtent),
        resolutions,
        matrixIds
    });
}

class WMTSDataSource extends DataSource {
    constructor(options) {
        super(options);
    }
    createOlSource() {
        const sourceOptions = Object.assign({
            tileGrid: createDefaultTileGrid(this.options.projection)
        }, this.options);
        return new olSourceWMTS(sourceOptions);
    }
    onUnwatch() { }
}

class CartoDataSource extends DataSource {
    get params() {
        return this.options.params;
    }
    get queryTitle() {
        return this.options.queryTitle
            ? this.options.queryTitle
            : 'title';
    }
    get mapLabel() {
        return this.options.mapLabel;
    }
    get queryHtmlTarget() {
        return this.options.queryHtmlTarget
            ? this.options.queryHtmlTarget
            : QueryHtmlTarget.BLANK;
    }
    createOlSource() {
        const crossOrigin = this.options.crossOrigin
            ? this.options.crossOrigin
            : 'anonymous';
        const sourceOptions = Object.assign({
            crossOrigin
        }, this.options);
        return new olSourceCarto(sourceOptions);
    }
    getLegend() {
        const legend = super.getLegend();
        if (legend.length > 0) {
            return legend;
        }
        let htmlString = '<table>';
        if (this.options.config.layers[0].legend !== null) {
            this.options.config.layers[0].legend.items.forEach(f => {
                if (f.visible === true) {
                    htmlString +=
                        '<tr><td>' +
                            '<p><font size="5" color="' +
                            f.value +
                            '"> &#9679</font></p></td>' +
                            '<td>' +
                            f.name +
                            '</td></tr>';
                }
            });
            htmlString += '</table>';
            return [{ html: htmlString }];
        }
        else {
            // Try to build the legend from the cartocss options
            const layerOptions = this.options.config.layers[0].options;
            // All available cartocss style options
            const types = [
                'polygon-fill:',
                'marker-fill:',
                'shield-fill:',
                'building-fill:',
                'line-color:'
            ];
            for (const oneType of types) {
                if (layerOptions.cartocss.includes(oneType)) {
                    const type = layerOptions.cartocss.split(oneType).pop();
                    const color = type.substr(0, type.indexOf(';'));
                    if (color.includes('ramp')) {
                        const colors = color.split(', (')[1].split(',');
                        const data = color.split(', (')[2].split(',');
                        for (let j = 0; j < colors.length; j++) {
                            colors[j] = colors[j].replace(/("|\))/g, '');
                            data[j] = data[j].replace(/("|\))/g, '');
                            if (data[j].replace(/\s+/g, '') === '=') {
                                data[j] = 'Autres';
                            }
                            htmlString +=
                                '<tr><td>' +
                                    '<p><font size="5" color="' +
                                    colors[j] +
                                    '"> &#9679</font></p></td>' +
                                    '<td>' +
                                    data[j] +
                                    '</td></tr>';
                        }
                        break;
                    }
                    else {
                        const title = layerOptions.layer_name
                            ? layerOptions.layer_name
                            : '';
                        htmlString +=
                            '<tr><td>' +
                                '<p><font size="5" color="' +
                                color +
                                '"> &#9679</font></p>' +
                                '</td><td>' +
                                title +
                                '</td></tr>';
                        break;
                    }
                }
            }
            htmlString += '</table>';
            return [{ html: htmlString }];
        }
    }
    onUnwatch() { }
}

class ArcGISRestDataSource extends DataSource {
    createOlSource() {
        const esrijsonFormat = new olFormatEsriJSON();
        return new OlVectorSource({
            attributions: this.options.params.attributions,
            overlaps: false,
            format: esrijsonFormat,
            url: function (extent, resolution, proj) {
                const baseUrl = this.options.url + '/' + this.options.layer + '/query/';
                const geometry = encodeURIComponent('{"xmin":' +
                    extent[0] +
                    ',"ymin":' +
                    extent[1] +
                    ',"xmax":' +
                    extent[2] +
                    ',"ymax":' +
                    extent[3] +
                    ',"spatialReference":{"wkid":102100}}');
                const params = [
                    'f=json',
                    `geometry=${geometry}`,
                    'geometryType=esriGeometryEnvelope',
                    'inSR=102100',
                    'spatialRel=esriSpatialRelIntersects',
                    'outFields=*',
                    'returnGeometry=true',
                    'outSR=102100'
                ];
                if (this.options.params.time) {
                    const time = `time=${this.options.params.time}`;
                    params.push(time);
                }
                if (this.options.params.customParams) {
                    this.options.params.customParams.forEach(element => {
                        params.push(element);
                    });
                }
                return `${baseUrl}?${params.join('&')}`;
            }.bind(this),
            strategy: OlLoadingStrategy.bbox
        });
    }
    getLegend() {
        const legendInfo = this.options.legendInfo;
        const legend = super.getLegend();
        if (legendInfo === undefined || legend.length > 0) {
            return legend;
        }
        if (!legendInfo) {
            return;
        }
        let htmlString = '<table>';
        let src;
        let label;
        let svg;
        if (legendInfo.legend) {
            for (const legendElement of legendInfo.legend) {
                src = this.htmlImgSrc(legendElement.contentType, legendElement.imageData);
                label = legendElement.label ? legendElement.label.replace('<Null>', 'Null') : '';
                htmlString +=
                    `<tr><td align='left'><img src="` +
                        src +
                        `" alt ='' /></td><td class="mat-typography">` +
                        label +
                        '</td></tr>';
            }
        }
        else if (legendInfo.type === "uniqueValue") {
            for (const legendElement of legendInfo.uniqueValueInfos) {
                label = legendElement.label.replace('<Null>', 'Null');
                if (legendElement.symbol.type === 'esriPMS') {
                    src = this.htmlImgSrc(legendElement.symbol.contentType, legendElement.symbol.imageData);
                    htmlString +=
                        `<tr><td align='left'><img src="` +
                            src +
                            `" alt ='' /></td><td class="mat-typography">` +
                            label +
                            '</td></tr>';
                }
                else if (legendElement.symbol.type !== 'esriPMS') {
                    svg = this.createSVG(legendElement.symbol);
                    htmlString += `<tr><td align='left'>` + svg + `</td><td class="mat-typography">` + label + '</td></tr>';
                }
            }
        }
        else if (legendInfo.type === "simple") {
            label = legendInfo.label ? legendInfo.label.replace('<Null>', 'Null') : '';
            if (legendInfo.symbol.type === 'esriPMS') {
                src = this.htmlImgSrc(legendInfo.symbol.contentType, legendInfo.symbol.imageData);
                htmlString +=
                    `<tr><td align='left'><img src="` +
                        src +
                        `" alt ='' /></td><td class="mat-typography">` +
                        label +
                        '</td></tr>';
            }
            else if (legendInfo.symbol.type !== 'esriPMS') {
                svg = this.createSVG(legendInfo.symbol);
                htmlString += `<tr><td align='left'>` + svg + `</td><td class="mat-typography">` + label + '</td></tr>';
            }
        }
        htmlString += '</table>';
        return [{ html: htmlString }];
    }
    htmlImgSrc(contentType, imageData) {
        return `data:${contentType};base64,${imageData}`;
    }
    createSVG(symbol) {
        let svg = '';
        const color = symbol.color ? symbol.color : [0, 0, 0, 0];
        if (symbol.type === 'esriSLS') {
            const width = symbol.width ? symbol.width : 0;
            const stroke = `stroke:rgba(` + color[0] + ',' + color[1] + ',' + color[2] + ',' + color[3] + ')';
            const strokeWidth = `stroke-width:` + width;
            if (symbol.style === 'esriSLSSolid') {
                svg = `<svg height="30" width="30"><line x1="0" y1="15" x2="30" y2="15" style="` + stroke + ';' + strokeWidth + `"/></svg>`;
            }
            else if (symbol.style === 'esriSLSDash') {
                const strokeDashArray = `stroke-dasharray="5,5"`;
                svg = `<svg height="30" width="30"><line x1="0" y1="15" x2="30" y2="15" style="` + stroke + ';' + strokeWidth + `" ` + strokeDashArray + `/></svg>`;
            }
        }
        else if (symbol.style === 'esriSMSCircle' || symbol.style === 'esriSFSSolid') {
            const outlineColor = symbol.outline.color;
            const outlineWidth = symbol.outline.width;
            const size = symbol.size;
            const stroke = `stroke:rgba(` + outlineColor[0] + ',' + outlineColor[1] + ',' + outlineColor[2] + ',' + outlineColor[3] + ')';
            const strokeWidth = `stroke-width:` + outlineWidth;
            const fill = `fill:rgba(` + color[0] + ',' + color[1] + ',' + color[2] + ',' + color[3] + ')';
            if (symbol.style === 'esriSMSCircle') {
                svg = `<svg height="30" width="30"><circle cx="15" cy="15" r="` + size / 2 + `" style="` + stroke + ';' + strokeWidth + ';' + fill + `"/></svg>`;
            }
            else {
                svg = `<svg height="30" width="30"><rect x="5" y="5" width="20" height="20" style ="` + stroke + ';' + strokeWidth + ';' + fill + `"/></svg>`;
            }
        }
        return svg;
    }
    onUnwatch() { }
}

class ImageArcGISRestDataSource extends DataSource {
    get params() {
        return this.options.params;
    }
    get queryTitle() {
        return this.options.queryTitle
            ? this.options.queryTitle
            : 'title';
    }
    get mapLabel() {
        return this.options.mapLabel;
    }
    get queryHtmlTarget() {
        return this.options.queryHtmlTarget
            ? this.options.queryHtmlTarget
            : QueryHtmlTarget.BLANK;
    }
    createOlSource() {
        const params = this.options.layer === undefined ? this.options.params : Object.assign({ LAYERS: `show:${this.options.layer}` }, this.options.params);
        if (typeof params.renderingRule === 'object') {
            params.renderingRule = JSON.stringify(params.renderingRule);
        }
        return new ImageArcGISRest({
            ratio: 1,
            params,
            url: this.options.url
        });
    }
    getLegend() {
        const legendInfo = this.options.legendInfo;
        const legend = super.getLegend();
        if (legendInfo === undefined || this.options.layer === undefined || legend.length > 0) {
            return legend;
        }
        if (!legendInfo) {
            return;
        }
        let htmlString = '<table>';
        for (const legendElement of legendInfo.legend) {
            const src = `${this.options.url}/${legendInfo.layerId}/images/${legendElement.url}`;
            const label = legendElement.label.replace('<Null>', 'Null');
            htmlString +=
                `<tr><td align='left'><img src="` +
                    src +
                    `" alt ='' /></td><td class="mat-typography">` +
                    label +
                    '</td></tr>';
        }
        htmlString += '</table>';
        return [{ html: htmlString }];
    }
    onUnwatch() { }
}

class TileArcGISRestDataSource extends DataSource {
    get params() {
        return this.options.params;
    }
    get queryTitle() {
        return this.options.queryTitle
            ? this.options.queryTitle
            : 'title';
    }
    get mapLabel() {
        return this.options.mapLabel;
    }
    get queryHtmlTarget() {
        return this.options.queryHtmlTarget
            ? this.options.queryHtmlTarget
            : QueryHtmlTarget.BLANK;
    }
    createOlSource() {
        return new olSourceTileArcGISRest(this.options);
    }
    getLegend() {
        const legendInfo = this.options.legendInfo;
        const legend = super.getLegend();
        if (legendInfo === undefined || this.options.layer === undefined || legend.length > 0) {
            return legend;
        }
        if (!legendInfo) {
            return;
        }
        let htmlString = '<table>';
        for (const legendElement of legendInfo.legend) {
            const src = `${this.options.url}/${legendInfo.layerId}/images/${legendElement.url}`;
            const label = legendElement.label.replace('<Null>', 'Null');
            htmlString +=
                `<tr><td align='left'><img src="` +
                    src +
                    `" alt ='' /></td><td class="mat-typography">` +
                    label +
                    '</td></tr>';
        }
        htmlString += '</table>';
        return [{ html: htmlString }];
    }
    onUnwatch() { }
}

class TileDebugDataSource extends DataSource {
    createOlSource() {
        const baseOptions = JSON.parse(JSON.stringify(this.options)); // to avoid to alter the original options
        if (this.options.tileGrid) {
            delete baseOptions.tileGrid;
            baseOptions.tileGrid = new TileGrid(this.options.tileGrid);
        }
        return new TileDebug(baseOptions);
    }
    onUnwatch() { }
}

class WebSocketDataSource extends FeatureDataSource {
    createOlSource() {
        this.createWebSocket();
        this.options.format = this.getSourceFormatFromOptions(this.options);
        return super.createOlSource();
    }
    createWebSocket() {
        this.ws = new WebSocket(this.options.url);
        this.ws.onmessage = this.onMessage.bind(this);
        if (this.options.onclose) {
            this.ws.onclose = this.onClose.bind(this);
        }
        if (this.options.onerror) {
            this.ws.onerror = this.onError.bind(this);
        }
        if (this.options.onopen) {
            this.ws.onopen = this.onOpen.bind(this);
        }
    }
    onMessage(event) {
        const featureAdded = this.options.format.readFeature(event.data);
        switch (this.options.onmessage) {
            case 'update':
                // ol don't add if same ID
                const featureToRemove = this.ol.getFeatureById(featureAdded.getId());
                if (featureToRemove) {
                    this.ol.removeFeature(featureToRemove);
                }
                this.ol.addFeature(featureAdded);
                break;
            case 'delete':
                this.ol.clear(true);
                this.ol.addFeature(featureAdded);
                break;
            case 'add':
            default:
                this.ol.addFeature(featureAdded);
        }
    }
    onClose(event) {
        // thrown message to user
    }
    onError(event) {
        // thrown message to user
    }
    onOpen(event) {
        // thrown message to user ?
    }
    onUnwatch() {
        this.ws.close();
    }
}

class MVTDataSource extends DataSource {
    createOlSource() {
        let mvtFormat;
        if (this.options.featureClass === 'feature') {
            mvtFormat = new olFormatMVT({ featureClass: OlFeature });
        }
        else {
            mvtFormat = new olFormatMVT();
        }
        this.options.format = mvtFormat;
        return new olSourceVectorTile(this.options);
    }
    generateId() {
        if (!this.options.url) {
            return uuid();
        }
        const chain = 'mvt' + this.options.url;
        return Md5.hashStr(chain);
    }
    onUnwatch() { }
}

class EsriStyleGenerator {
    constructor() {
        this._converters = {};
        this._converters.esriPMS = EsriStyleGenerator._convertEsriPMS;
        this._converters.esriSFS = EsriStyleGenerator._convertEsriSFS;
        this._converters.esriSLS = EsriStyleGenerator._convertEsriSLS;
        this._converters.esriSMS = EsriStyleGenerator._convertEsriSMS;
        this._converters.esriTS = EsriStyleGenerator._convertEsriTS;
        this._renderers = {};
        this._renderers.uniqueValue = this._renderUniqueValue;
        this._renderers.simple = this._renderSimple;
        this._renderers.classBreaks = this._renderClassBreaks;
    }
    static _convertPointToPixel(point) {
        return point / 0.75;
    }
    static _transformColor(color) {
        // alpha channel is different, runs from 0-255 but in ol3 from 0-1
        return [color[0], color[1], color[2], color[3] / 255];
    }
    static _getResolutionForScale(scale, units) {
        const dpi = 96;
        const mpu = olproj.METERS_PER_UNIT[units];
        const inchesPerMeter = 39.3701;
        return parseFloat(scale) / (mpu * inchesPerMeter * dpi);
    }
    /* convert an Esri Text Symbol */
    static _convertEsriTS(symbol) {
        const rotation = EsriStyleGenerator._transformAngle(symbol.angle);
        const text = symbol.text !== undefined ? symbol.text : undefined;
        return new olstyle.Style({
            text: new olstyle.Text({
                fill: new olstyle.Fill({
                    color: EsriStyleGenerator._transformColor(symbol.color)
                }),
                font: symbol.font.style +
                    ' ' +
                    symbol.font.weight +
                    ' ' +
                    symbol.font.size +
                    ' px ' +
                    symbol.font.family,
                textBaseline: symbol.verticalAlignment,
                textAlign: symbol.horizontalAlignment,
                offsetX: EsriStyleGenerator._convertPointToPixel(symbol.xoffset),
                offsetY: EsriStyleGenerator._convertPointToPixel(symbol.yoffset),
                rotation,
                text
            })
        });
    }
    /* convert an Esri Picture Marker Symbol */
    static _convertEsriPMS(symbol) {
        const src = 'data:' + symbol.contentType + ';base64, ' + symbol.imageData;
        const rotation = EsriStyleGenerator._transformAngle(symbol.angle);
        return new olstyle.Style({
            image: new olstyle.Icon({
                src,
                rotation
            })
        });
    }
    /* convert an Esri Simple Fill Symbol */
    static _convertEsriSFS(symbol) {
        // there is no support in openlayers currently for fill patterns, so style is not interpreted
        const fill = new olstyle.Fill({
            color: EsriStyleGenerator._transformColor(symbol.color)
        });
        const stroke = symbol.outline
            ? EsriStyleGenerator._convertOutline(symbol.outline)
            : undefined;
        return new olstyle.Style({
            fill,
            stroke
        });
    }
    static _convertOutline(outline) {
        let lineDash;
        const color = EsriStyleGenerator._transformColor(outline.color);
        if (outline.style === 'esriSLSDash') {
            lineDash = [5];
        }
        else if (outline.style === 'esriSLSDashDot') {
            lineDash = [5, 5, 1, 2];
        }
        else if (outline.style === 'esriSLSDashDotDot') {
            lineDash = [5, 5, 1, 2, 1, 2];
        }
        else if (outline.style === 'esriSLSDot') {
            lineDash = [1, 2];
        }
        else if (outline.style === 'esriSLSNull') {
            // line not visible, make color fully transparent
            color[3] = 0;
        }
        return new olstyle.Stroke({
            color,
            lineDash,
            width: EsriStyleGenerator._convertPointToPixel(outline.width)
        });
    }
    /* convert an Esri Simple Line Symbol */
    static _convertEsriSLS(symbol) {
        return new olstyle.Style({
            stroke: EsriStyleGenerator._convertOutline(symbol)
        });
    }
    static _transformAngle(angle) {
        if (angle === 0 || angle === undefined) {
            return undefined;
        }
        const normalRad = (angle * Math.PI) / 180;
        const ol3Rad = -normalRad + Math.PI / 2;
        if (ol3Rad < 0) {
            return 2 * Math.PI + ol3Rad;
        }
        else {
            return ol3Rad;
        }
    }
    /* convert an Esri Simple Marker Symbol */
    static _convertEsriSMS(symbol) {
        const fill = new olstyle.Fill({
            color: EsriStyleGenerator._transformColor(symbol.color)
        });
        const stroke = symbol.outline
            ? EsriStyleGenerator._convertOutline(symbol.outline)
            : undefined;
        const radius = EsriStyleGenerator._convertPointToPixel(symbol.size) / 2;
        const rotation = EsriStyleGenerator._transformAngle(symbol.angle);
        if (symbol.style === 'esriSMSCircle') {
            return new olstyle.Style({
                image: new olstyle.Circle({
                    radius,
                    fill,
                    stroke
                })
            });
        }
        else if (symbol.style === 'esriSMSCross') {
            return new olstyle.Style({
                image: new olstyle.RegularShape({
                    fill,
                    stroke,
                    points: 4,
                    radius,
                    radius2: 0,
                    angle: 0,
                    rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSDiamond') {
            return new olstyle.Style({
                image: new olstyle.RegularShape({
                    fill,
                    stroke,
                    points: 4,
                    radius,
                    rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSSquare') {
            return new olstyle.Style({
                image: new olstyle.RegularShape({
                    fill,
                    stroke,
                    points: 4,
                    radius,
                    angle: Math.PI / 4,
                    rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSX') {
            return new olstyle.Style({
                image: new olstyle.RegularShape({
                    fill,
                    stroke,
                    points: 4,
                    radius,
                    radius2: 0,
                    angle: Math.PI / 4,
                    rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSTriangle') {
            return new olstyle.Style({
                image: new olstyle.RegularShape({
                    fill,
                    stroke,
                    points: 3,
                    radius,
                    angle: 0,
                    rotation
                })
            });
        }
    }
    _convertLabelingInfo(labelingInfo, mapUnits) {
        const styles = [];
        for (let i = 0, ii = labelingInfo.length; i < ii; ++i) {
            const labelExpression = labelingInfo[i].labelExpression;
            // only limited support for label expressions
            const field = labelExpression.substr(labelExpression.indexOf('[') + 1, labelExpression.indexOf(']') - 1);
            const symbol = labelingInfo[i].symbol;
            const maxScale = labelingInfo[i].maxScale;
            const minScale = labelingInfo[i].minScale;
            let minResolution = null;
            if (maxScale !== 0) {
                minResolution = EsriStyleGenerator._getResolutionForScale(maxScale, mapUnits);
            }
            let maxResolution = null;
            if (minScale !== 0) {
                maxResolution = EsriStyleGenerator._getResolutionForScale(minScale, mapUnits);
            }
            const style = this._converters[symbol.type].call(this, symbol);
            styles.push((() => {
                return function (feature, resolution) {
                    let visible = true;
                    if (this.minResolution !== null && this.maxResolution !== null) {
                        visible =
                            resolution < this.maxResolution &&
                                resolution >= this.minResolution;
                    }
                    else if (this.minResolution !== null) {
                        visible = resolution >= this.minResolution;
                    }
                    else if (this.maxResolution !== null) {
                        visible = resolution < this.maxResolution;
                    }
                    if (visible) {
                        const value = feature.get(this.field);
                        this.style.getText().setText(value);
                        return [this.style];
                    }
                };
            })().bind({
                minResolution,
                maxResolution,
                field,
                style
            }));
        }
        return styles;
    }
    _renderSimple(renderer) {
        const style = this._converters[renderer.symbol.type].call(this, renderer.symbol);
        return (() => {
            return () => {
                return [style];
            };
        })();
    }
    _renderClassBreaks(renderer) {
        const defaultSymbol = renderer.defaultSymbol;
        const defaultStyle = this._converters[defaultSymbol.type].call(this, defaultSymbol);
        const field = renderer.field;
        const classes = [];
        for (let i = 0, ii = renderer.classBreakInfos.length; i < ii; ++i) {
            const classBreakInfo = renderer.classBreakInfos[i];
            let min;
            if (classBreakInfo.classMinValue === null ||
                classBreakInfo.classMinValue === undefined) {
                if (i === 0) {
                    min = renderer.minValue;
                }
                else {
                    min = renderer.classBreakInfos[i - 1].classMaxValue;
                }
            }
            else {
                min = classBreakInfo.classMinValue;
            }
            const max = classBreakInfo.classMaxValue;
            const symbol = classBreakInfo.symbol;
            const style = this._converters[symbol.type].call(this, symbol);
            classes.push({ min, max, style });
        }
        return (() => {
            return (feature) => {
                const value = feature.get(field);
                for (let i = 0, ii = classes.length; i < ii; ++i) {
                    let condition;
                    if (i === 0) {
                        condition = value >= classes[i].min && value <= classes[i].max;
                    }
                    else {
                        condition = value > classes[i].min && value <= classes[i].max;
                    }
                    if (condition) {
                        return [classes[i].style];
                    }
                }
                return [defaultStyle];
            };
        })();
    }
    _renderUniqueValue(renderer) {
        const defaultSymbol = renderer.defaultSymbol;
        let defaultStyle = [];
        if (defaultSymbol) {
            defaultStyle = [
                this._converters[defaultSymbol.type].call(this, defaultSymbol)
            ];
        }
        const field = renderer.field1;
        const infos = renderer.uniqueValueInfos;
        const me = this;
        return (() => {
            const hash = {};
            for (let i = 0, ii = infos.length; i < ii; ++i) {
                const info = infos[i];
                const symbol = info.symbol;
                hash[info.value] = [me._converters[symbol.type].call(me, symbol)];
            }
            return (feature) => {
                const style = hash[feature.get(field)];
                return style ? style : defaultStyle;
            };
        })();
    }
    generateStyle(layerInfo, mapUnits) {
        const drawingInfo = layerInfo.drawingInfo;
        let styleFunctions = [];
        const drawingInfoStyle = this._renderers[drawingInfo.renderer.type].call(this, drawingInfo.renderer);
        if (drawingInfoStyle !== undefined) {
            styleFunctions.push(drawingInfoStyle);
        }
        if (layerInfo.labelingInfo) {
            const labelingInfoStyleFunctions = this._convertLabelingInfo(layerInfo.labelingInfo, mapUnits);
            styleFunctions = styleFunctions.concat(labelingInfoStyleFunctions);
        }
        if (styleFunctions.length === 1) {
            return styleFunctions[0];
        }
        else {
            return (() => {
                return (feature, resolution) => {
                    let styles = [];
                    for (let i = 0, ii = styleFunctions.length; i < ii; ++i) {
                        const result = styleFunctions[i].call(null, feature, resolution);
                        if (result) {
                            styles = styles.concat(result);
                        }
                    }
                    return styles;
                };
            })();
        }
    }
}

var TimeFilterType;
(function (TimeFilterType) {
    TimeFilterType["DATE"] = "date";
    TimeFilterType["TIME"] = "time";
    TimeFilterType["DATETIME"] = "datetime";
    TimeFilterType["YEAR"] = "year";
})(TimeFilterType || (TimeFilterType = {}));
var TimeFilterStyle;
(function (TimeFilterStyle) {
    TimeFilterStyle["CALENDAR"] = "calendar";
    TimeFilterStyle["SLIDER"] = "slider";
})(TimeFilterStyle || (TimeFilterStyle = {}));

/**
 * MapService
 *
 * This service tracks the IgoMap instance, if any.
 * Currently, only one map instance is supported
 * but support for multiple maps may be added in the future.
 * This will impact other services such as the OverlayService
 * because these maps won't be sharing overlayed features.
 */
class MapService {
    constructor() { }
    getMap() {
        return this.map;
    }
    setMap(map) {
        this.map = map;
    }
}
MapService.ɵfac = function MapService_Factory(t) { return new (t || MapService)(); };
MapService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: MapService, factory: MapService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MapService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

var TypeCapabilities;
(function (TypeCapabilities) {
    TypeCapabilities["wms"] = "wms";
    TypeCapabilities["wmts"] = "wmts";
    TypeCapabilities["arcgisrest"] = "esriJSON";
    TypeCapabilities["imagearcgisrest"] = "esriJSON";
    TypeCapabilities["tilearcgisrest"] = "esriJSON";
})(TypeCapabilities || (TypeCapabilities = {}));
class CapabilitiesService {
    constructor(http, mapService) {
        this.http = http;
        this.mapService = mapService;
        this.parsers = {
            wms: new WMSCapabilities(),
            wmts: new WMTSCapabilities(),
            esriJSON: new EsriJSON()
        };
    }
    getWMSOptions(baseOptions) {
        const url = baseOptions.url;
        const version = baseOptions.params.VERSION;
        return this.getCapabilities('wms', url, version).pipe(map((capabilities) => {
            return capabilities
                ? this.parseWMSOptions(baseOptions, capabilities)
                : undefined;
        }));
    }
    getWMTSOptions(baseOptions) {
        const url = baseOptions.url;
        const version = baseOptions.version;
        const options = this.getCapabilities('wmts', url, version).pipe(map((capabilities) => {
            return capabilities
                ? this.parseWMTSOptions(baseOptions, capabilities)
                : undefined;
        }));
        return options;
    }
    getCartoOptions(baseOptions) {
        const baseUrl = 'https://' +
            baseOptions.account +
            '.carto.com/api/v2/viz/' +
            baseOptions.mapId +
            '/viz.json';
        return this.http
            .jsonp(baseUrl, 'callback')
            .pipe(map((cartoOptions) => this.parseCartoOptions(baseOptions, cartoOptions)));
    }
    getArcgisOptions(baseOptions) {
        const baseUrl = baseOptions.url + '/' + baseOptions.layer + '?f=json';
        const modifiedUrl = baseOptions.url.replace('FeatureServer', 'MapServer');
        const legendUrl = modifiedUrl + '/legend?f=json';
        const serviceCapabilities = this.getCapabilities('arcgisrest', baseOptions.url);
        const arcgisOptions = this.http.get(baseUrl);
        const legend = this.http.get(legendUrl).pipe(map((res) => res), catchError((err) => {
            console.log('No legend associated with this Feature Service');
            return of(err);
        }));
        return forkJoin([arcgisOptions, legend, serviceCapabilities]).pipe(map((res) => {
            return this.parseArcgisOptions(baseOptions, res[0], res[1], res[2]);
        }));
    }
    getImageArcgisOptions(baseOptions) {
        const baseUrl = baseOptions.url + '/' + baseOptions.layer + '?f=json';
        const modifiedUrl = baseOptions.url.replace('FeatureServer', 'MapServer');
        const legendUrl = modifiedUrl + '/legend?f=json';
        const serviceCapabilities = this.getCapabilities('imagearcgisrest', baseOptions.url);
        const arcgisOptions = this.http.get(baseUrl);
        const legend = this.http.get(legendUrl).pipe(map((res) => res), catchError((err) => {
            console.log('No legend associated with this Image Service');
            return of(err);
        }));
        return forkJoin([arcgisOptions, legend, serviceCapabilities]).pipe(map((res) => {
            return this.parseTileOrImageArcgisOptions(baseOptions, res[0], res[1], res[2]);
        }));
    }
    getTileArcgisOptions(baseOptions) {
        const baseUrl = baseOptions.url + '/' + baseOptions.layer + '?f=json';
        const legendUrl = baseOptions.url + '/legend?f=json';
        const serviceCapabilities = this.getCapabilities('tilearcgisrest', baseOptions.url);
        const arcgisOptions = this.http.get(baseUrl);
        const legendInfo = this.http.get(legendUrl).pipe(map((res) => res), catchError((err) => {
            console.log('No legend associated with this Tile Service');
            return of(err);
        }));
        return forkJoin([arcgisOptions, legendInfo, serviceCapabilities]).pipe(map((res) => this.parseTileOrImageArcgisOptions(baseOptions, res[0], res[1], res[2])));
    }
    getCapabilities(service, baseUrl, version) {
        const params = new HttpParams({
            fromObject: {
                request: 'GetCapabilities',
                service: service.toUpperCase(),
                version: version || '1.3.0',
                _i: 'true'
            }
        });
        let request;
        if (TypeCapabilities[service] === 'esriJSON') {
            request = this.http.get(baseUrl + '?f=json');
        }
        else {
            request = this.http.get(baseUrl, {
                params,
                responseType: 'text'
            });
        }
        return request.pipe(map((res) => {
            if (TypeCapabilities[service] === 'esriJSON') {
                return res;
            }
            if (String(res).toLowerCase().includes('serviceexception') &&
                String(res).toLowerCase().includes('access denied')) {
                throw {
                    error: {
                        message: 'Service error getCapabilities: Access is denied'
                    }
                };
            }
            else {
                return this.parsers[service].read(res);
            }
        }), catchError((e) => {
            if (typeof e.error !== 'undefined') {
                e.error.caught = true;
            }
            throw e;
        }));
    }
    parseWMSOptions(baseOptions, capabilities) {
        const layers = baseOptions.params.LAYERS;
        const layer = this.findDataSourceInCapabilities(capabilities.Capability.Layer, layers);
        if (!layer) {
            throw {
                error: {
                    message: 'Layer not found'
                }
            };
        }
        const metadata = layer.DataURL ? layer.DataURL[0] : undefined;
        const abstract = layer.Abstract ? layer.Abstract : undefined;
        const keywordList = layer.KeywordList ? layer.KeywordList : undefined;
        let queryable = layer.queryable;
        const timeFilter = this.getTimeFilter(layer);
        const timeFilterable = timeFilter && Object.keys(timeFilter).length > 0;
        const legendOptions = layer.Style ? this.getStyle(layer.Style) : undefined;
        let isExtentInGeographic = true;
        if (layer.EX_GeographicBoundingBox) {
            layer.EX_GeographicBoundingBox.forEach((coord, index) => {
                if (index < 2 && (coord > 180 || coord < -180)) {
                    isExtentInGeographic = false;
                }
                if (index >= 2 && (coord > 90 || coord < -90)) {
                    isExtentInGeographic = false;
                }
            });
        }
        else {
            isExtentInGeographic = false;
        }
        const extent = isExtentInGeographic ?
            olproj.transformExtent(layer.EX_GeographicBoundingBox, 'EPSG:4326', this.mapService.getMap().projection) :
            undefined;
        let queryFormat;
        const queryFormatMimeTypePriority = [
            QueryFormatMimeType.GEOJSON,
            QueryFormatMimeType.GEOJSON2,
            QueryFormatMimeType.GML3,
            QueryFormatMimeType.GML2,
            QueryFormatMimeType.JSON,
            QueryFormatMimeType.HTML
        ];
        for (const mimeType of queryFormatMimeTypePriority) {
            if (capabilities.Capability.Request.GetFeatureInfo.Format.indexOf(mimeType) !== -1) {
                const keyEnum = Object.keys(QueryFormatMimeType).find((key) => QueryFormatMimeType[key] === mimeType);
                queryFormat = QueryFormat[keyEnum];
                break;
            }
        }
        if (!queryFormat) {
            queryable = false;
        }
        const options = ObjectUtils.removeUndefined({
            _layerOptionsFromSource: {
                title: layer.Title,
                maxResolution: getResolutionFromScale(layer.MaxScaleDenominator),
                minResolution: getResolutionFromScale(layer.MinScaleDenominator),
                extent,
                metadata: {
                    url: metadata ? metadata.OnlineResource : undefined,
                    extern: metadata ? true : undefined,
                    abstract,
                    keywordList
                },
                legendOptions
            },
            queryable,
            queryFormat,
            timeFilter: timeFilterable ? timeFilter : undefined,
            timeFilterable: timeFilterable ? true : undefined,
            minDate: timeFilterable ? timeFilter.min : undefined,
            maxDate: timeFilterable ? timeFilter.max : undefined,
            stepDate: timeFilterable ? timeFilter.step : undefined
        });
        return ObjectUtils.mergeDeep(options, baseOptions);
    }
    parseWMTSOptions(baseOptions, capabilities) {
        // Put Title source in _layerOptionsFromSource. (For source & catalog in _layerOptionsFromSource, if not already on config)
        const layer = capabilities.Contents.Layer.find((el) => el.Identifier === baseOptions.layer);
        const options = optionsFromCapabilities(capabilities, baseOptions);
        const ouputOptions = Object.assign(options, baseOptions);
        const sourceOptions = ObjectUtils.removeUndefined({
            _layerOptionsFromSource: {
                title: layer.Title
            }
        });
        return ObjectUtils.mergeDeep(sourceOptions, ouputOptions);
    }
    parseCartoOptions(baseOptions, cartoOptions) {
        const layers = [];
        const params = cartoOptions.layers[1].options.layer_definition;
        params.layers.forEach((element) => {
            layers.push({
                type: element.type.toLowerCase(),
                options: element.options,
                legend: element.legend
            });
        });
        const options = ObjectUtils.removeUndefined({
            config: {
                version: params.version,
                layers
            }
        });
        return ObjectUtils.mergeDeep(options, baseOptions);
    }
    parseArcgisOptions(baseOptions, arcgisOptions, legend, serviceCapabilities) {
        var _a;
        const title = arcgisOptions.name;
        let legendInfo;
        if (legend.layers) {
            legendInfo = legend.layers.find(x => x.layerName === title);
        }
        else if ((_a = arcgisOptions.drawingInfo) === null || _a === void 0 ? void 0 : _a.renderer) {
            legendInfo = arcgisOptions.drawingInfo.renderer;
        }
        else {
            legendInfo = undefined;
        }
        let style;
        if (arcgisOptions.drawingInfo) {
            const styleGenerator = new EsriStyleGenerator();
            const units = arcgisOptions.units === 'esriMeters' ? 'm' : 'degrees';
            style = styleGenerator.generateStyle(arcgisOptions, units);
        }
        const attributions = new olAttribution({
            target: arcgisOptions.copyrightText
        });
        let timeExtent;
        let timeFilter;
        if (arcgisOptions.timeInfo) {
            const time = arcgisOptions.timeInfo.timeExtent;
            timeExtent = time[0] + ',' + time[1];
            const min = new Date();
            min.setTime(time[0]);
            const max = new Date();
            max.setTime(time[1]);
            timeFilter = {
                min: min.toUTCString(),
                max: max.toUTCString(),
                range: true,
                type: TimeFilterType.DATETIME,
                style: TimeFilterStyle.CALENDAR
            };
        }
        const params = Object.assign({}, {
            style,
            LAYERS: baseOptions.layer ? 'show:' + baseOptions.layer : undefined,
            time: timeExtent
        });
        const options = ObjectUtils.removeUndefined({
            params,
            _layerOptionsFromSource: {
                title,
                minResolution: getResolutionFromScale(arcgisOptions.maxScale),
                maxResolution: getResolutionFromScale(arcgisOptions.minScale),
                metadata: {
                    extern: false,
                    abstract: arcgisOptions.description || serviceCapabilities.serviceDescription
                },
            },
            legendInfo,
            timeFilter,
            sourceFields: arcgisOptions.fields,
            queryTitle: arcgisOptions.displayField
        });
        options.attributions = attributions;
        return ObjectUtils.mergeDeep(options, baseOptions);
    }
    parseTileOrImageArcgisOptions(baseOptions, arcgisOptions, legend, serviceCapabilities) {
        const title = arcgisOptions.name;
        const legendInfo = legend.layers ? legend.layers.find(x => x.layerName === title) : undefined;
        const attributions = new olAttribution({
            target: arcgisOptions.copyrightText
        });
        let timeExtent;
        let timeFilter;
        if (arcgisOptions.timeInfo) {
            const time = arcgisOptions.timeInfo.timeExtent;
            timeExtent = time[0] + ',' + time[1];
            const min = new Date();
            min.setTime(time[0]);
            const max = new Date();
            max.setTime(time[1]);
            timeFilter = {
                min: min.toUTCString(),
                max: max.toUTCString(),
                range: true,
                type: TimeFilterType.DATETIME,
                style: TimeFilterStyle.CALENDAR
            };
        }
        const params = Object.assign({}, {
            LAYERS: baseOptions.layer ? 'show:' + baseOptions.layer : undefined,
            time: timeExtent
        });
        const options = ObjectUtils.removeUndefined({
            params,
            _layerOptionsFromSource: {
                title,
                minResolution: getResolutionFromScale(arcgisOptions.maxScale),
                maxResolution: getResolutionFromScale(arcgisOptions.minScale),
                metadata: {
                    extern: false,
                    abstract: arcgisOptions.description || serviceCapabilities.serviceDescription
                },
            },
            legendInfo,
            timeFilter,
            sourceFields: arcgisOptions.fields,
            queryTitle: arcgisOptions.displayField
        });
        options.attributions = attributions;
        return ObjectUtils.mergeDeep(options, baseOptions);
    }
    findDataSourceInCapabilities(layerArray, name) {
        if (Array.isArray(layerArray)) {
            let layer;
            layerArray.find((value) => {
                layer = this.findDataSourceInCapabilities(value, name);
                return layer !== undefined;
            }, this);
            return layer;
        }
        else if (layerArray.Layer) {
            return this.findDataSourceInCapabilities(layerArray.Layer, name);
        }
        else {
            if (layerArray.Name && layerArray.Name === name) {
                return layerArray;
            }
            return undefined;
        }
    }
    getTimeFilter(layer) {
        let dimension;
        if (layer.Dimension) {
            const timeFilter = {};
            dimension = layer.Dimension[0];
            if (dimension.values) {
                const minMaxDim = dimension.values.split('/');
                timeFilter.min = minMaxDim[0] !== undefined ? minMaxDim[0] : undefined;
                timeFilter.max = minMaxDim[1] !== undefined ? minMaxDim[1] : undefined;
                timeFilter.step = minMaxDim[2] !== undefined ? minMaxDim[2] : undefined;
            }
            if (dimension.default) {
                timeFilter.value = dimension.default;
            }
            return timeFilter;
        }
    }
    getStyle(Style) {
        const styleOptions = Style.map((style) => {
            return {
                name: style.Name,
                title: style.Title
            };
        })
            // Handle repeat the style "default" in output  (MapServer or OpenLayer)
            .filter((item, index, self) => self.findIndex((i) => i.name === item.name) ===
            index);
        const legendOptions = {
            stylesAvailable: styleOptions
        };
        return legendOptions;
    }
}
CapabilitiesService.ɵfac = function CapabilitiesService_Factory(t) { return new (t || CapabilitiesService)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(MapService)); };
CapabilitiesService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CapabilitiesService, factory: CapabilitiesService.ɵfac, providedIn: 'root' });
__decorate([
    Cacheable({
        maxCacheCount: 20
    })
], CapabilitiesService.prototype, "getCapabilities", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CapabilitiesService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1$2.HttpClient }, { type: MapService }]; }, { getCapabilities: [] }); })();

class OptionsService {
}

/**
 * When injected, this service automatically registers and
 * projection defined in the application config. A custom projection
 * needs to be registered to be usable by OL.
 */
class ProjectionService {
    constructor(config) {
        this.config = config;
        const projections = this.config.getConfig('projections') || [];
        projections.forEach((projection) => {
            projection.alias = projection.alias ? projection.alias : projection.code;
            this.registerProjection(projection);
        });
        // register all utm zones
        for (let utmZone = 1; utmZone < 61; utmZone++) {
            const code = utmZone < 10 ? `EPSG:3260${utmZone}` : `EPSG:326${utmZone}`;
            const def = `+proj=utm +zone=${utmZone} +datum=WGS84 +units=m +no_defs`;
            const proj = { code, def, extent: undefined };
            this.registerProjection(proj);
        }
        // register all mtm zones
        for (let mtmZone = 1; mtmZone < 11; mtmZone++) {
            const code = mtmZone < 10 ? `EPSG:3218${mtmZone}` : `EPSG:321${80 + mtmZone}`;
            let lon0;
            if (Number(mtmZone) <= 2) {
                lon0 = -50 - Number(mtmZone) * 3;
            }
            else if (Number(mtmZone) >= 12) {
                lon0 = -81 - (Number(mtmZone) - 12) * 3;
            }
            else {
                lon0 = -49.5 - Number(mtmZone) * 3;
            }
            const def = `+proj=tmerc +lat_0=0 +lon_0=${lon0} +k=0.9999 +x_0=304800 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"`;
            const proj = { code, def, extent: undefined };
            this.registerProjection(proj);
        }
    }
    /**
     * Define a proj4 projection and register it in OL
     * @param projection Projection
     */
    registerProjection(projection) {
        proj4.defs(projection.code, projection.def);
        olproj4.register(proj4);
        if (projection.extent) {
            olproj.get(projection.code).setExtent(projection.extent);
        }
    }
}
ProjectionService.ɵfac = function ProjectionService_Factory(t) { return new (t || ProjectionService)(i0.ɵɵinject(i2$1.ConfigService)); };
ProjectionService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ProjectionService, factory: ProjectionService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ProjectionService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i2$1.ConfigService }]; }, null); })();

class DataSourceService {
    constructor(capabilitiesService, optionsService, wfsDataSourceService, languageService, messageService, projectionService, authInterceptor) {
        this.capabilitiesService = capabilitiesService;
        this.optionsService = optionsService;
        this.wfsDataSourceService = wfsDataSourceService;
        this.languageService = languageService;
        this.messageService = messageService;
        this.projectionService = projectionService;
        this.authInterceptor = authInterceptor;
        this.datasources$ = new BehaviorSubject([]);
    }
    createAsyncDataSource(context, detailedContextUri) {
        if (!context.type) {
            console.error(context);
            throw new Error('Datasource needs a type');
        }
        let dataSource;
        switch (context.type.toLowerCase()) {
            case 'osm':
                dataSource = this.createOSMDataSource(context);
                break;
            case 'vector':
                dataSource = this.createFeatureDataSource(context);
                break;
            case 'wfs':
                dataSource = this.createWFSDataSource(context);
                break;
            case 'wms':
                const wmsContext = context;
                ObjectUtils.removeDuplicateCaseInsensitive(wmsContext.params);
                dataSource = this.createWMSDataSource(wmsContext, detailedContextUri);
                break;
            case 'wmts':
                dataSource = this.createWMTSDataSource(context);
                break;
            case 'xyz':
                dataSource = this.createXYZDataSource(context);
                break;
            case 'tiledebug':
                dataSource = this.createTileDebugDataSource(context);
                break;
            case 'carto':
                dataSource = this.createCartoDataSource(context);
                break;
            case 'arcgisrest':
                dataSource = this.createArcGISRestDataSource(context, detailedContextUri);
                break;
            case 'imagearcgisrest':
                dataSource = this.createArcGISRestImageDataSource(context, detailedContextUri);
                break;
            case 'websocket':
                dataSource = this.createWebSocketDataSource(context);
                break;
            case 'mvt':
                dataSource = this.createMVTDataSource(context);
                break;
            case 'tilearcgisrest':
                dataSource = this.createTileArcGISRestDataSource(context, detailedContextUri);
                break;
            case 'cluster':
                dataSource = this.createClusterDataSource(context);
                break;
            default:
                console.error(context);
                throw new Error('Invalid datasource type');
        }
        this.datasources$.next(this.datasources$.value.concat([dataSource]));
        return dataSource;
    }
    createOSMDataSource(context) {
        return new Observable(d => d.next(new OSMDataSource(context)));
    }
    createFeatureDataSource(context) {
        return new Observable(d => d.next(new FeatureDataSource(context)));
    }
    createWebSocketDataSource(context) {
        return new Observable(d => d.next(new WebSocketDataSource(context)));
    }
    createWFSDataSource(context) {
        return new Observable(d => d.next(new WFSDataSource(context, this.wfsDataSourceService, this.authInterceptor)));
    }
    createWMSDataSource(context, detailedContextUri) {
        const observables = [];
        if (context.optionsFromCapabilities) {
            observables.push(this.capabilitiesService.getWMSOptions(context).pipe(catchError(e => {
                const title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                const message = this.languageService.translate.instant('igo.geo.dataSource.unavailable', { value: context.params.LAYERS });
                this.messageService.error(message, title);
                throw e;
            })));
        }
        if (this.optionsService && context.optionsFromApi === true) {
            observables.push(this.optionsService.getWMSOptions(context, detailedContextUri).pipe(catchError(e => {
                e.error.toDisplay = true;
                e.error.title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                e.error.message = this.languageService.translate.instant('igo.geo.dataSource.optionsApiUnavailable');
                return of({});
            })));
        }
        observables.push(of(context));
        return forkJoin(observables).pipe(map((options) => {
            const optionsMerged = options.reduce((a, b) => ObjectUtils.mergeDeep(a, b));
            return new WMSDataSource(optionsMerged, this.wfsDataSourceService);
        }), catchError(() => {
            return of(undefined);
        }));
    }
    createWMTSDataSource(context) {
        if (context.optionsFromCapabilities) {
            return this.capabilitiesService.getWMTSOptions(context).pipe(map((options) => {
                return options ? new WMTSDataSource(options) : undefined;
            }), catchError(() => {
                const title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                const message = this.languageService.translate.instant('igo.geo.dataSource.unavailable', { value: context.layer });
                this.messageService.error(message, title);
                return of(undefined);
            }));
        }
        return new Observable(d => d.next(new WMTSDataSource(context)));
    }
    createXYZDataSource(context) {
        return new Observable(d => d.next(new XYZDataSource(context)));
    }
    createTileDebugDataSource(context) {
        return new Observable(d => d.next(new TileDebugDataSource(context)));
    }
    createCartoDataSource(context) {
        if (context.mapId) {
            return this.capabilitiesService
                .getCartoOptions(context)
                .pipe(map((options) => new CartoDataSource(options)));
        }
        return new Observable(d => d.next(new CartoDataSource(context)));
    }
    createArcGISRestDataSource(context, detailedContextUri) {
        const observables = [];
        observables.push(this.capabilitiesService.getArcgisOptions(context).pipe(catchError(e => {
            const title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
            const message = this.languageService.translate.instant('igo.geo.dataSource.unavailable', { value: context.layer });
            this.messageService.error(message, title);
            throw e;
        })));
        if (this.optionsService && context.optionsFromApi === true) {
            observables.push(this.optionsService.getArcgisRestOptions(context, detailedContextUri).pipe(catchError(e => {
                e.error.toDisplay = true;
                e.error.title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                e.error.message = this.languageService.translate.instant('igo.geo.dataSource.optionsApiUnavailable');
                return of({});
            })));
        }
        observables.push(of(context));
        return forkJoin(observables).pipe(map((options) => {
            const optionsMerged = options.reduce((a, b) => ObjectUtils.mergeDeep(a, b));
            return new ArcGISRestDataSource(optionsMerged);
        }), catchError(() => {
            return of(undefined);
        }));
    }
    createArcGISRestImageDataSource(context, detailedContextUri) {
        const observables = [];
        observables.push(this.capabilitiesService.getImageArcgisOptions(context).pipe(catchError(e => {
            const title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
            const message = this.languageService.translate.instant('igo.geo.dataSource.unavailable', { value: context.params.LAYERS });
            this.messageService.error(message, title);
            throw e;
        })));
        if (this.optionsService && context.optionsFromApi === true) {
            observables.push(this.optionsService.getArcgisRestOptions(context, detailedContextUri).pipe(catchError(e => {
                e.error.toDisplay = true;
                e.error.title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                e.error.message = this.languageService.translate.instant('igo.geo.dataSource.optionsApiUnavailable');
                return of({});
            })));
        }
        observables.push(of(context));
        return forkJoin(observables).pipe(map((options) => {
            const optionsMerged = options.reduce((a, b) => ObjectUtils.mergeDeep(a, b));
            return new ImageArcGISRestDataSource(optionsMerged);
        }), catchError(() => {
            return of(undefined);
        }));
    }
    createTileArcGISRestDataSource(context, detailedContextUri) {
        const observables = [];
        observables.push(this.capabilitiesService.getImageArcgisOptions(context).pipe(catchError(e => {
            const title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
            const message = this.languageService.translate.instant('igo.geo.dataSource.unavailable', { value: context.params.LAYERS });
            this.messageService.error(message, title);
            throw e;
        })));
        if (this.optionsService && context.optionsFromApi === true) {
            observables.push(this.optionsService.getArcgisRestOptions(context, detailedContextUri).pipe(catchError(e => {
                e.error.toDisplay = true;
                e.error.title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                e.error.message = this.languageService.translate.instant('igo.geo.dataSource.optionsApiUnavailable');
                return of({});
            })));
        }
        observables.push(of(context));
        return forkJoin(observables).pipe(map((options) => {
            const optionsMerged = options.reduce((a, b) => ObjectUtils.mergeDeep(a, b));
            return new TileArcGISRestDataSource(optionsMerged);
        }), catchError(() => {
            return of(undefined);
        }));
    }
    createMVTDataSource(context) {
        return new Observable(d => d.next(new MVTDataSource(context)));
    }
    createClusterDataSource(context) {
        return new Observable(d => d.next(new ClusterDataSource(context)));
    }
}
DataSourceService.ɵfac = function DataSourceService_Factory(t) { return new (t || DataSourceService)(i0.ɵɵinject(CapabilitiesService), i0.ɵɵinject(OptionsService, 8), i0.ɵɵinject(WFSService), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i2$1.MessageService), i0.ɵɵinject(ProjectionService), i0.ɵɵinject(i5.AuthInterceptor)); };
DataSourceService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DataSourceService, factory: DataSourceService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DataSourceService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: CapabilitiesService }, { type: OptionsService, decorators: [{
                type: Optional
            }] }, { type: WFSService }, { type: i2$1.LanguageService }, { type: i2$1.MessageService }, { type: ProjectionService }, { type: i5.AuthInterceptor }]; }, null); })();

class OptionsApiService extends OptionsService {
    constructor(http, options = {}) {
        super();
        this.http = http;
        this.urlApi = options.url || this.urlApi;
        this.provideContextUri = options.provideContextUri || this.provideContextUri;
    }
    getWMSOptions(baseOptions, detailedContextUri) {
        if (!this.urlApi) {
            return of({});
        }
        let params = new HttpParams({
            fromObject: {
                type: baseOptions.type,
                url: baseOptions.url,
                layers: baseOptions.params.LAYERS
            }
        });
        if (detailedContextUri && this.provideContextUri) {
            params = params.append('context', detailedContextUri);
        }
        const request = this.http.get(this.urlApi, {
            params
        });
        return request.pipe(map((res) => {
            if (!res || !res.sourceOptions) {
                return {};
            }
            if (res.layerOptions) {
                res.sourceOptions._layerOptionsFromSource = res.layerOptions;
            }
            return res.sourceOptions;
        }));
    }
    getArcgisRestOptions(baseOptions, detailedContextUri) {
        if (!this.urlApi) {
            return of({});
        }
        let params = new HttpParams({
            fromObject: {
                type: baseOptions.type,
                url: baseOptions.url,
                layers: baseOptions.layer
            }
        });
        if (detailedContextUri && this.provideContextUri) {
            params = params.append('context', detailedContextUri);
        }
        const request = this.http.get(this.urlApi, {
            params
        });
        return request.pipe(map((res) => {
            if (!res || !res.sourceOptions) {
                return {};
            }
            if (res.layerOptions) {
                res.sourceOptions._layerOptionsFromSource = res.layerOptions;
            }
            return res.sourceOptions;
        }));
    }
}
OptionsApiService.ɵfac = function OptionsApiService_Factory(t) { return new (t || OptionsApiService)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject('options')); };
OptionsApiService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: OptionsApiService, factory: OptionsApiService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OptionsApiService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1$2.HttpClient }, { type: undefined, decorators: [{
                type: Inject,
                args: ['options']
            }] }]; }, null); })();

function optionsApiFactory(http, configService) {
    return new OptionsApiService(http, configService.getConfig('optionsApi'));
}
function provideOptionsApi() {
    return {
        provide: OptionsService,
        useFactory: optionsApiFactory,
        deps: [HttpClient, ConfigService]
    };
}

/**
 * Create an Openlayers feature object out of a feature definition.
 * The output object has a reference to the feature id.
 * @param feature Feature definition
 * @param projectionOut Feature object projection
 * @returns OpenLayers feature object
 */
function featureToOl(feature, projectionOut, getId) {
    getId = getId ? getId : getEntityId;
    const olFormat = new OlGeoJSON();
    const olFeature = olFormat.readFeature(feature, {
        dataProjection: feature.projection,
        featureProjection: projectionOut
    });
    olFeature.setId(getId(feature));
    const title = getEntityTitle(feature);
    if (title !== undefined) {
        olFeature.set('_title', title, true);
    }
    if (feature.extent !== undefined) {
        olFeature.set('_extent', feature.extent, true);
    }
    if (feature.projection !== undefined) {
        olFeature.set('_projection', feature.projection, true);
    }
    const mapTitle = getEntityProperty(feature, 'meta.mapTitle');
    if (mapTitle !== undefined) {
        olFeature.set('_mapTitle', mapTitle, true);
    }
    olFeature.set('_entityRevision', getEntityRevision(feature), true);
    const icon = getEntityIcon(feature);
    if (icon !== undefined) {
        olFeature.set('_icon', icon, true);
    }
    if (feature.meta && feature.meta.style) {
        olFeature.set('_style', feature.meta.style, true);
    }
    if (feature.sourceId) {
        olFeature.set('_sourceId', feature.sourceId, true);
    }
    return olFeature;
}
function renderFeatureFromOl(olRenderFeature, projectionIn, olLayer, projectionOut = 'EPSG:4326') {
    let geom;
    let title;
    let exclude;
    let excludeOffline;
    if (olLayer) {
        title = olLayer.get('title');
        if (olLayer.get('sourceOptions')) {
            exclude = olLayer.get('sourceOptions').excludeAttribute;
            excludeOffline = olLayer.get('sourceOptions').excludeAttributeOffline;
        }
    }
    else {
        title = olRenderFeature.get('_title');
    }
    const olFormat = new OlGeoJSON();
    const properties = olRenderFeature.getProperties();
    const geometryType = olRenderFeature.getType();
    if (geometryType === 'Polygon') {
        const ends = olRenderFeature.getEnds();
        geom = new OlPolygon(olRenderFeature.getFlatCoordinates(), OlGeometryLayout.XY, ends);
    }
    else if (geometryType === 'Point') {
        geom = new OlPoint(olRenderFeature.getFlatCoordinates(), OlGeometryLayout.XY);
    }
    else if (geometryType === 'LineString') {
        geom = new OlLineString(olRenderFeature.getFlatCoordinates(), OlGeometryLayout.XY);
    }
    const geometry = olFormat.writeGeometryObject(geom, {
        dataProjection: projectionOut,
        featureProjection: projectionIn
    });
    const id = olRenderFeature.getId() ? olRenderFeature.getId() : uuid();
    const mapTitle = olRenderFeature.get('_mapTitle');
    const extent = olproj.transformExtent(olRenderFeature.getExtent(), projectionIn, projectionOut);
    return {
        type: FEATURE,
        projection: projectionOut,
        extent,
        meta: {
            id,
            title: title ? title : mapTitle ? mapTitle : id,
            mapTitle,
            excludeAttribute: exclude,
            excludeAttributeOffline: excludeOffline
        },
        properties,
        geometry,
        ol: olRenderFeature
    };
}
/**
 * Create a feature object out of an OL feature
 * The output object has a reference to the feature id.
 * @param olFeature OL Feature
 * @param projectionIn OL feature projection
 * @param olLayer OL Layer
 * @param projectionOut Feature projection
 * @returns Feature
 */
function featureFromOl(olFeature, projectionIn, olLayer, projectionOut = 'EPSG:4326') {
    let title;
    let exclude;
    let excludeOffline;
    let idColumn; // for arcgisrest and tilearcgisrest source
    const olFormat = new OlGeoJSON();
    const keys = olFeature.getKeys().filter((key) => {
        return !key.startsWith('_') && key !== 'geometry';
    });
    const properties = keys.reduce((acc, key) => {
        acc[key] = olFeature.get(key);
        return acc;
    }, {});
    const geometry = olFormat.writeGeometryObject(olFeature.getGeometry(), {
        dataProjection: projectionOut,
        featureProjection: projectionIn
    });
    if (olLayer) {
        title = olLayer.get('title');
        const sourceOptions = olLayer.get('sourceOptions');
        if (sourceOptions) {
            exclude = sourceOptions.excludeAttribute;
            excludeOffline = sourceOptions.excludeAttributeOffline;
            idColumn =
                sourceOptions.idColumn ||
                    ((sourceOptions.type === 'arcgisrest' || sourceOptions.type === 'tilearcgisrest') ? 'OBJECTID' : undefined);
        }
    }
    else {
        title = olFeature.get('_title');
    }
    const mapTitle = olFeature.get('_mapTitle');
    const id = olFeature.getId() ? olFeature.getId() : olFeature.get(idColumn) ? olFeature.get(idColumn) : uuid();
    const newFeature = olFeature.get('_newFeature');
    return {
        type: FEATURE,
        projection: projectionOut,
        extent: olFeature.get('_extent'),
        meta: {
            id,
            title: title ? title : mapTitle ? mapTitle : id,
            mapTitle,
            revision: olFeature.getRevision(),
            style: olFeature.get('_style'),
            excludeAttribute: exclude,
            excludeAttributeOffline: excludeOffline
        },
        properties,
        geometry,
        ol: olFeature
    };
}
/**
 * Compute an OL feature extent in it's map projection
 * @param map Map
 * @param olFeature OL feature
 * @returns Extent in the map projection
 */
function computeOlFeatureExtent(map, olFeature) {
    let olExtent = olextent.createEmpty();
    const olFeatureExtent = olFeature.get('_extent');
    const olFeatureProjection = olFeature.get('_projection');
    if (olFeatureExtent !== undefined && olFeatureProjection !== undefined) {
        olExtent = olproj.transformExtent(olFeatureExtent, olFeatureProjection, map.projection);
    }
    else {
        const olGeometry = olFeature.getGeometry();
        if (olGeometry !== null) {
            olExtent = olGeometry.getExtent();
        }
    }
    return olExtent;
}
/**
 * Compute a multiple OL features extent in their map projection
 * @param map Map
 * @param olFeatures OL features
 * @returns Extent in the map projection
 */
function computeOlFeaturesExtent(map, olFeatures) {
    const extent = olextent.createEmpty();
    olFeatures.forEach((olFeature) => {
        const featureExtent = computeOlFeatureExtent(map, olFeature);
        olextent.extend(extent, featureExtent);
    });
    return extent;
}
/**
 * Scale an extent.
 * @param extent Extent
 * @param Scaling factors for top, right, bottom and left directions, in that order
 * @returns Scaled extent
 */
function scaleExtent(extent, scale) {
    const [width, height] = olextent.getSize(extent);
    return [
        scale[3] ? extent[0] - width * scale[3] : extent[0],
        scale[2] ? extent[1] - height * scale[2] : extent[1],
        scale[1] ? extent[2] + width * scale[1] : extent[2],
        scale[0] ? extent[3] + height * scale[0] : extent[3]
    ];
}
/**
 * Return true if features are out of view.
 * If features are too close to the edge, they are considered out of view.
 * We define the edge as 5% of the extent size.
 * @param map Map
 * @param featuresExtent The features's extent
 * @returns Return true if features are out of view
 */
function featuresAreOutOfView(map, featuresExtent) {
    const mapExtent = map.viewController.getExtent();
    const edgeRatio = 0.05;
    const scale = [-1, -1, -1, -1].map(x => x * edgeRatio);
    const viewExtent = scaleExtent(mapExtent, scale);
    return !olextent.containsExtent(viewExtent, featuresExtent);
}
/**
 * Return true if features are too deep into the view. This results
 * in features being too small.
 * Features are considered too small if their extent occupies less than
 * 1% of the map extent.
 * @param map Map
 * @param featuresExtent The features's extent
 * @param areaRatio The features extent to view extent acceptable ratio
 * @returns Return true if features are too deep in the view
 */
function featuresAreTooDeepInView(map, featuresExtent, areaRatio) {
    // An area ratio of 0.004 means that the feature extent's width and height
    // should be about 1/16 of the map extent's width and height
    areaRatio = areaRatio ? areaRatio : 0.004;
    const mapExtent = map.viewController.getExtent();
    const mapExtentArea = olextent.getArea(mapExtent);
    const featuresExtentArea = olextent.getArea(featuresExtent);
    if (featuresExtentArea === 0 && map.viewController.getZoom() > 13) {
        // In case it's a point
        return false;
    }
    return featuresExtentArea / mapExtentArea < areaRatio;
}
/**
 * Fit view to include the features extent.
 * By default, this method will let the features occupy about 50% of the viewport.
 * @param map Map
 * @param olFeatures OL features
 * @param motion To motion to the new map view
 * @param scale If this is defined, the original view will be scaled
 *  by that factor before any logic is applied.
 */
function moveToOlFeatures(map, olFeatures, motion = FeatureMotion.Default, scale, areaRatio) {
    const featuresExtent = computeOlFeaturesExtent(map, olFeatures);
    let viewExtent = featuresExtent;
    if (scale !== undefined) {
        viewExtent = scaleExtent(viewExtent, scale);
    }
    if (motion === FeatureMotion.Zoom) {
        map.viewController.zoomToExtent(viewExtent);
    }
    else if (motion === FeatureMotion.Move) {
        map.viewController.moveToExtent(viewExtent);
    }
    else if (motion === FeatureMotion.Default) {
        if (featuresAreOutOfView(map, featuresExtent) ||
            featuresAreTooDeepInView(map, featuresExtent, areaRatio)) {
            map.viewController.zoomToExtent(viewExtent);
        }
    }
}
/**
 * Hide an OL feature
 * @param olFeature OL feature
 */
function hideOlFeature(olFeature) {
    olFeature.setStyle(new olstyle.Style({}));
}
/**
 * Try to bind a layer to a store if none is bound already.
 * The layer will also be added to the store's map.
 * If no layer is given to that function, a basic one will be created.
 * @param store The store to bind the layer
 * @param layer An optional VectorLayer
 */
function tryBindStoreLayer(store, layer) {
    if (store.layer !== undefined) {
        if (store.layer.map === undefined) {
            store.map.addLayer(store.layer);
        }
        return;
    }
    layer = layer
        ? layer
        : new VectorLayer({
            source: new FeatureDataSource()
        });
    store.bindLayer(layer);
    if (store.layer.map === undefined) {
        store.map.addLayer(store.layer);
    }
}
/**
 * Compute a diff between a source array of Ol features and a target array
 * @param source Source array of OL features
 * @param starget Target array of OL features
 * @returns Features to add and remove
 */
function computeOlFeaturesDiff(source, target) {
    const olFeaturesMap = new Map();
    target.forEach((olFeature) => {
        olFeaturesMap.set(olFeature.getId(), olFeature);
    });
    const olFeaturesToRemove = [];
    source.forEach((olFeature) => {
        const newOlFeature = olFeaturesMap.get(olFeature.getId());
        if (newOlFeature === undefined) {
            olFeaturesToRemove.push(olFeature);
        }
        else if (newOlFeature.get('_entityRevision') !== olFeature.get('_entityRevision')) {
            olFeaturesToRemove.push(olFeature);
        }
        else {
            olFeaturesMap.delete(newOlFeature.getId());
        }
    });
    const olFeaturesToAddIds = Array.from(olFeaturesMap.keys());
    const olFeaturesToAdd = target.filter((olFeature) => {
        return olFeaturesToAddIds.indexOf(olFeature.getId()) >= 0;
    });
    return {
        add: olFeaturesToAdd,
        remove: olFeaturesToRemove
    };
}

/**
 * The class is a specialized version of an EntityStore that stores
 * features and the map layer to display them on. Synchronization
 * between the store and the layer is handled by strategies.
 */
class FeatureStore extends EntityStore {
    constructor(entities, options) {
        super(entities, options);
        this.map = options.map;
    }
    /**
     * The layer's data source
     */
    get source() {
        return this.layer ? this.layer.dataSource : undefined;
    }
    /**
     * Bind this store to a vector layer
     * @param layer Vector layer
     * @returns Feature store
     */
    bindLayer(layer) {
        this.layer = layer;
        return this;
    }
    /**
     * Set the layer's features and perform a motion to make them visible. Strategies
     * make extensive use of that method.
     * @param features Features
     * @param motion Optional: The type of motion to perform
     */
    setLayerFeatures(features, motion = FeatureMotion.Default, viewScale, areaRatio, getId) {
        getId = getId ? getId : getEntityId;
        this.checkLayer();
        const olFeatures = features
            .map((feature) => featureToOl(feature, this.map.projection, getId));
        this.setLayerOlFeatures(olFeatures, motion, viewScale, areaRatio);
    }
    /**
     * Set the store's features from an array of OL features.
     * @param olFeatures Ol features
     */
    setStoreOlFeatures(olFeatures) {
        this.checkLayer();
        const features = olFeatures.map((olFeature) => {
            olFeature.set('_featureStore', this, true);
            return featureFromOl(olFeature, this.layer.map.projection);
        });
        this.load(features);
    }
    /**
     * Remove all features from the layer
     */
    clearLayer() {
        this.checkLayer();
        this.source.ol.clear();
    }
    /**
     * Check wether a layer is bound or not and throw an error if not.
     */
    checkLayer() {
        if (this.layer === undefined) {
            throw new Error('This FeatureStore is not bound to a layer.');
        }
    }
    /**
     * Set the layer's features and perform a motion to make them visible.
     * @param features Openlayers feature objects
     * @param motion Optional: The type of motion to perform
     */
    setLayerOlFeatures(olFeatures, motion = FeatureMotion.Default, viewScale, areaRatio) {
        const olSource = this.layer.ol.getSource();
        const diff = computeOlFeaturesDiff(olSource.getFeatures(), olFeatures);
        if (diff.remove.length > 0) {
            this.removeOlFeaturesFromLayer(diff.remove);
        }
        if (diff.add.length > 0) {
            this.addOlFeaturesToLayer(diff.add);
        }
        if (diff.add.length > 0) {
            // If features are added, do a motion toward the newly added features
            moveToOlFeatures(this.map, diff.add, motion, viewScale, areaRatio);
        }
        else if (diff.remove.length > 0) {
            // Else, do a motion toward all the features
            moveToOlFeatures(this.map, olFeatures, motion, viewScale, areaRatio);
        }
    }
    /**
     * Add features to the the layer
     * @param features Openlayers feature objects
     */
    addOlFeaturesToLayer(olFeatures) {
        olFeatures.forEach((olFeature) => {
            olFeature.set('_featureStore', this, true);
        });
        this.source.ol.addFeatures(olFeatures);
    }
    /**
     * Remove features from the the layer
     * @param features Openlayers feature objects
     */
    removeOlFeaturesFromLayer(olFeatures) {
        olFeatures.forEach((olFeature) => {
            this.source.ol.removeFeature(olFeature);
        });
    }
}

/**
 * This strategy maintain the store features updated while the map is moved.
 * The features's state inside the map are tagged inMapExtent = true;
 */
class FeatureStoreInMapExtentStrategy extends EntityStoreStrategy {
    constructor(options) {
        super(options);
        this.options = options;
        /**
         * Subscription to the store's OL source changes
         */
        this.stores$$ = new Map();
        this.states$$ = [];
    }
    /**
     * Bind this strategy to a store and start watching for Ol source changes
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            this.watchStore(store);
        }
        this.empty$$ = store.empty$
            .pipe(skipWhile((empty) => !empty))
            .subscribe(() => this.updateEntitiesInExtent(store));
    }
    /**
     * Unbind this strategy from a store and stop watching for Ol source changes
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    }
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    doActivate() {
        this.stores.forEach((store) => this.watchStore(store));
    }
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    doDeactivate() {
        this.unwatchAll();
    }
    /**
     * Watch for a store's  OL source changes
     * @param store Feature store
     */
    watchStore(store) {
        if (this.stores$$.has(store)) {
            return;
        }
        this.updateEntitiesInExtent(store);
        this.states$$.push(store.layer.map.viewController.state$.subscribe(() => {
            this.updateEntitiesInExtent(store);
        }));
    }
    updateEntitiesInExtent(store) {
        var _a, _b;
        if ((_b = (_a = store === null || store === void 0 ? void 0 : store.layer) === null || _a === void 0 ? void 0 : _a.map) === null || _b === void 0 ? void 0 : _b.viewController) {
            store.state.updateAll({ inMapExtent: false });
            const mapExtent = store.layer.map.viewController.getExtent();
            let entitiesInMapExtent = [];
            let entitiesWithNoGeom = [];
            for (const entity of store.entities$.value) {
                if (entity.ol) {
                    if (olextent.intersects(entity.ol.getGeometry().getExtent(), mapExtent)) {
                        entitiesInMapExtent.push(entity);
                    }
                }
                else {
                    entitiesWithNoGeom.push(entity);
                }
            }
            if (entitiesInMapExtent.length > 0) {
                store.state.updateMany(entitiesInMapExtent, { inMapExtent: true }, false);
            }
            if (entitiesWithNoGeom.length > 0) {
                store.state.updateMany(entitiesWithNoGeom, { inMapExtent: true }, false);
            }
        }
    }
    /**
     * Stop watching for a store's OL source changes
     * @param store Feature store
     */
    unwatchStore(store) {
        const key = this.stores$$.get(store);
        if (key !== undefined) {
            this.stores$$.delete(store);
        }
    }
    /**
     * Stop watching for OL source changes in all stores.
     */
    unwatchAll() {
        this.stores$$.clear();
        this.states$$.map(state => state.unsubscribe());
        if (this.empty$$) {
            this.empty$$.unsubscribe();
        }
    }
}

/**
 * This strategy maintain the store features updated while the map is scrolled.
 * The features's state inside the map's resolution are tagged inMapResolution = true;
 */
class FeatureStoreInMapResolutionStrategy extends EntityStoreStrategy {
    constructor(options) {
        super(options);
        this.options = options;
        /**
         * Subscription to the store's OL source changes
         */
        this.stores$$ = new Map();
        this.resolution$$ = [];
    }
    /**
     * Bind this strategy to a store and start watching for Ol source changes
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            this.watchStore(store);
        }
        this.empty$$ = store.empty$
            .subscribe(() => this.updateEntitiesInResolution(store, store.layer.map.viewController.getResolution()));
    }
    /**
     * Unbind this strategy from a store and stop watching for Ol source changes
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    }
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    doActivate() {
        this.stores.forEach((store) => this.watchStore(store));
    }
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    doDeactivate() {
        this.unwatchAll();
    }
    /**
     * Watch for a store's  OL source changes
     * @param store Feature store
     */
    watchStore(store) {
        if (this.stores$$.has(store)) {
            return;
        }
        this.updateEntitiesInResolution(store, store.layer.map.viewController.getResolution());
        this.resolution$$.push(store.layer.map.viewController.resolution$.subscribe((res) => {
            this.updateEntitiesInResolution(store, res);
        }));
    }
    updateEntitiesInResolution(store, mapResolution) {
        if (mapResolution > store.layer.minResolution && mapResolution < store.layer.maxResolution) {
            store.state.updateAll({ inMapResolution: true });
        }
        else {
            store.state.updateAll({ inMapResolution: false });
        }
    }
    /**
     * Stop watching for a store's OL source changes
     * @param store Feature store
     */
    unwatchStore(store) {
        const key = this.stores$$.get(store);
        if (key !== undefined) {
            this.stores$$.delete(store);
        }
    }
    /**
     * Stop watching for OL source changes in all stores.
     */
    unwatchAll() {
        this.stores$$.clear();
        this.resolution$$.map(state => state.unsubscribe());
        if (this.empty$$) {
            this.empty$$.unsubscribe();
        }
    }
}

/**
 * This strategy loads a store's features into it's layer counterpart.
 * The store -> layer binding is a one-way binding. That means any entity
 * added to the store will be added to the layer but the opposite is false.
 *
 * Important: This strategy observes filtered entities, not raw entities. This
 * is not configurable yet.
 */
class FeatureStoreLoadingStrategy extends EntityStoreStrategy {
    constructor(options) {
        super(options);
        this.options = options;
        /**
         * Subscription to the store's features
         */
        this.stores$$ = new Map();
        this.setMotion(options.motion);
    }
    /**
     * Bind this strategy to a store and start watching for entities changes
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            this.watchStore(store);
        }
    }
    /**
     * Unbind this strategy from a store and stop watching for entities changes
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    }
    /**
     * Define the motion to apply on load
     * @param motion Feature motion
     */
    setMotion(motion) {
        this.motion = motion;
    }
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    doActivate() {
        this.stores.forEach((store) => this.watchStore(store));
    }
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    doDeactivate() {
        this.unwatchAll();
    }
    /**
     * Watch for entities changes in a store.
     * Important: Never observe a store's sorted entities. It makes no sense
     * to display sorted entities (instead of unsorted) on a layer and it
     * would potentially result in a lot of useless computation.
     * @param store Feature store
     */
    watchStore(store) {
        if (this.stores$$.has(store)) {
            return;
        }
        const subscription = store.view.all$()
            .subscribe((features) => this.onFeaturesChange(features, store));
        this.stores$$.set(store, subscription);
    }
    /**
     * Stop watching for entities changes in a store.
     * @param store Feature store
     */
    unwatchStore(store) {
        const subscription = this.stores$$.get(store);
        if (subscription !== undefined) {
            subscription.unsubscribe();
            this.stores$$.delete(store);
        }
    }
    /**
     * Stop watching for entities changes in all stores.
     */
    unwatchAll() {
        Array.from(this.stores$$.entries()).forEach((entries) => {
            entries[1].unsubscribe();
        });
        this.stores$$.clear();
    }
    /**
     * Load features into a layer or clear the layer if the array of features is empty.
     * @param features Store filtered features
     * @param store Feature store
     */
    onFeaturesChange(features, store) {
        if (features.length === 0) {
            store.clearLayer();
        }
        else {
            store.setLayerFeatures(features, this.selectMotion(store), this.options.viewScale, this.options.areaRatio, this.options.getFeatureId);
        }
    }
    /**
     * Selects the best motion
     * @param store A FeatureStore to apply the motion
     * @returns The motion selected
     */
    selectMotion(store) {
        if (this.motion !== undefined) {
            return this.motion;
        }
        if (store.pristine === true) {
            // If features have just been loaded into the store, move/zoom on them
            return FeatureMotion.Default;
        }
        else if (store.count > store.view.count) {
            // If features have been filtered, move/zoom on the remaining ones
            return FeatureMotion.Default;
        }
        else {
            // On insert, update or delete, do nothing
            return FeatureMotion.None;
        }
    }
}

/**
 * This strategy loads a layer's features into it's store counterpart.
 * The layer -> store binding is a one-way binding. That means any OL feature
 * added to the layer will be added to the store but the opposite is false.
 *
 * Important: In it's current state, this strategy is to meant to be combined
 * with a standard Loading strategy and it would probably cause recursion issues.
 */
class FeatureStoreLoadingLayerStrategy extends EntityStoreStrategy {
    constructor(options) {
        super(options);
        this.options = options;
        /**
         * Subscription to the store's OL source changes
         */
        this.stores$$ = new Map();
    }
    /**
     * Bind this strategy to a store and start watching for Ol source changes
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            this.watchStore(store);
        }
    }
    /**
     * Unbind this strategy from a store and stop watching for Ol source changes
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    }
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    doActivate() {
        this.stores.forEach((store) => this.watchStore(store));
    }
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    doDeactivate() {
        this.unwatchAll();
    }
    /**
     * Watch for a store's  OL source changes
     * @param store Feature store
     */
    watchStore(store) {
        if (this.stores$$.has(store)) {
            return;
        }
        this.onSourceChanges(store);
        const olSource = store.layer.ol.getSource();
        olSource.on('change', (event) => {
            this.onSourceChanges(store);
        });
    }
    /**
     * Stop watching for a store's OL source changes
     * @param store Feature store
     */
    unwatchStore(store) {
        const key = this.stores$$.get(store);
        if (key !== undefined) {
            this.stores$$.delete(store);
        }
    }
    /**
     * Stop watching for OL source changes in all stores.
     */
    unwatchAll() {
        Array.from(this.stores$$.entries()).forEach((entries) => {
        });
        this.stores$$.clear();
    }
    /**
     * Load features from an OL source into a  store or clear the store if the source is empty
     * @param features Store filtered features
     * @param store Feature store
     */
    onSourceChanges(store) {
        let olFeatures = store.layer.ol.getSource().getFeatures();
        if (store.layer.dataSource instanceof ClusterDataSource) {
            olFeatures = olFeatures.flatMap((cluster) => cluster.get('features'));
        }
        if (olFeatures.length === 0) {
            store.clear();
        }
        else {
            store.setStoreOlFeatures(olFeatures);
        }
    }
}

class OlDragSelectInteraction extends OlDragBoxInteraction {
    constructor(options) {
        super(options);
    }
}
/**
 * This strategy synchronizes a store and a layer selected entities.
 * The store <-> layer binding is a two-way binding.
 *
 * In many cases, a single strategy bound to multiple stores
 * will yield better results that multiple strategies with each their
 * own store. In the latter scenario, a click on overlapping features
 * would trigger the strategy of each layer and they would cancel
 * each other as well as move the map view around needlessly.
 */
class FeatureStoreSelectionStrategy extends EntityStoreStrategy {
    constructor(options) {
        super(options);
        this.options = options;
        this.setMotion(options.motion);
        this._overlayStore = this.createOverlayStore();
    }
    /**
     * The map the layers belong to
     */
    get map() {
        return this.options.map;
    }
    /**
     * A feature store that'll contain the selected features. It has it's own
     * layer, shared by all the stores this staretgy is bound to.
     */
    get overlayStore() {
        return this._overlayStore;
    }
    /**
     * Bind this strategy to a store and force this strategy's
     * reactivation to properly setup watchers.
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            // Force reactivation
            this.activate();
        }
    }
    /**
     * Unbind this strategy from a store and force this strategy's
     * reactivation to properly setup watchers.
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            // Force reactivation
            this.activate();
        }
    }
    /**
     * Define the motion to apply on select
     * @param motion Feature motion
     */
    setMotion(motion) {
        this.motion = motion;
    }
    /**
     * Unselect all entities, from all stores
     */
    unselectAll() {
        this.stores.forEach((store) => {
            store.state.updateAll({ selected: false });
        });
    }
    /**
     * Clear the overlay
     */
    clear() {
        this.overlayStore.source.ol.clear();
        this.overlayStore.clear();
    }
    /**
     * Deactivate the selection without removing the selection
     * overlay.
     */
    deactivateSelection() {
        this.unlistenToMapClick();
        this.removeDragBoxInteraction();
        this.unwatchAll();
    }
    /**
     * Add the overlay layer, setup the map click lsitener and
     * start watching for stores selection
     * @internal
     */
    doActivate() {
        this.addOverlayLayer();
        this.listenToMapClick();
        if (this.options.dragBox === true) {
            this.addDragBoxInteraction();
        }
        this.watchAll();
    }
    /**
     * Remove the overlay layer, remove the map click lsitener and
     * stop watching for stores selection
     * @internal
     */
    doDeactivate() {
        this.deactivateSelection();
        this.removeOverlayLayer();
    }
    /**
     * Create a single observable of all the stores. With a single observable,
     * features can be added all at once to the overlay layer and a single
     * motion can be performed. Multiple observable would have
     * a cancelling effect on each other.
     */
    watchAll() {
        this.unwatchAll();
        const stores$ = this.stores.map((store) => {
            return store.stateView
                .manyBy$((record) => {
                return record.state.selected === true;
            })
                .pipe(map((records) => records.map((record) => record.entity)));
        });
        this.stores$$ = combineLatest(stores$)
            .pipe(debounceTime(5), skip(1), // Skip intial selection
        map((features) => features.reduce((a, b) => a.concat(b))))
            .subscribe((features) => this.onSelectFromStore(features));
    }
    /**
     * Stop watching for selection in all stores.
     */
    unwatchAll() {
        if (this.stores$$ !== undefined) {
            this.stores$$.unsubscribe();
        }
    }
    /**
     * Add a 'singleclick' listener to the map that'll allow selecting
     * features by clicking on the map. The selection will be performed
     * only on the layers bound to this strategy.
     */
    listenToMapClick() {
        this.mapClickListener = this.map.ol.on('singleclick', (event) => {
            this.onMapClick(event);
        });
    }
    /**
     * Remove the map click listener
     */
    unlistenToMapClick() {
        unByKey(this.mapClickListener);
    }
    /**
     * On map click, select feature at pixel
     * @param event OL MapBrowserPointerEvent
     */
    onMapClick(event) {
        const exclusive = !ctrlKeyDown(event);
        const reverse = !exclusive;
        const olFeatures = event.map.getFeaturesAtPixel(event.pixel, {
            hitTolerance: this.options.hitTolerance || 0,
            layerFilter: olLayer => {
                const storeOlLayer = this.stores.find((store) => {
                    return store.layer.ol === olLayer;
                });
                return storeOlLayer !== undefined;
            }
        });
        this.onSelectFromMap(olFeatures, exclusive, reverse);
    }
    /**
     * Add a drag box interaction and, on drag box end, select features
     */
    addDragBoxInteraction() {
        let olDragSelectInteraction;
        const olInteractions = this.map.ol.getInteractions().getArray();
        // There can only be one dragbox interaction, so find the current one, if any
        // Don't keep a reference to the current dragbox because we don't want
        // to remove it when this startegy is deactivated
        for (const olInteraction of olInteractions) {
            if (olInteraction instanceof OlDragSelectInteraction) {
                olDragSelectInteraction = olInteraction;
                break;
            }
        }
        // If no drag box interaction is found, create a new one and add it to the map
        if (olDragSelectInteraction === undefined) {
            olDragSelectInteraction = new OlDragSelectInteraction({
                condition: ctrlKeyDown
            });
            this.map.ol.addInteraction(olDragSelectInteraction);
            this.olDragSelectInteraction = olDragSelectInteraction;
        }
        this.olDragSelectInteractionEndKey = olDragSelectInteraction.on('boxend', (event) => this.onDragBoxEnd(event));
    }
    /**
     * Remove drag box interaction
     */
    removeDragBoxInteraction() {
        if (this.olDragSelectInteractionEndKey !== undefined) {
            unByKey(this.olDragSelectInteractionEndKey);
        }
        if (this.olDragSelectInteraction !== undefined) {
            this.map.ol.removeInteraction(this.olDragSelectInteraction);
        }
        this.olDragSelectInteraction = undefined;
    }
    /**
     * On dragbox end, select features in drag box
     * @param event OL MapBrowserPointerEvent
     */
    onDragBoxEnd(event) {
        const exclusive = !ctrlKeyDown(event.mapBrowserEvent);
        const target = event.target;
        const extent = target.getGeometry().getExtent();
        const olFeatures = this.stores.reduce((acc, store) => {
            const olSource = store.layer.ol.getSource();
            acc.push(...olSource.getFeaturesInExtent(extent));
            return acc;
        }, []);
        this.onSelectFromMap(olFeatures, exclusive, false);
    }
    /**
     * When features are selected from the store, add
     * them to this startegy's overlay layer (select on map)
     * @param features Store features
     */
    onSelectFromStore(features) {
        const motion = this.motion;
        const olOverlayFeatures = this.overlayStore.layer.ol
            .getSource()
            .getFeatures();
        const overlayFeaturesKeys = olOverlayFeatures.map((olFeature) => olFeature.getId());
        const featuresKeys = features.map(this.overlayStore.getKey);
        let doMotion;
        if (features.length === 0) {
            doMotion = false;
        }
        else {
            doMotion =
                overlayFeaturesKeys.length !== featuresKeys.length ||
                    !overlayFeaturesKeys.every((key) => featuresKeys.indexOf(key) >= 0);
        }
        this.overlayStore.setLayerFeatures(features, doMotion ? motion : FeatureMotion.None, this.options.viewScale, this.options.areaRatio, this.options.getFeatureId);
    }
    /**
     * When features are selected from the map, also select them
     * in their store.
     * @param olFeatures OL feature objects
     */
    onSelectFromMap(olFeatures, exclusive, reverse) {
        const groupedFeatures = this.groupFeaturesByStore(olFeatures);
        this.stores.forEach((store) => {
            const features = groupedFeatures.get(store);
            if (features === undefined && exclusive === true) {
                this.unselectAllFeaturesFromStore(store);
            }
            else if (features === undefined && exclusive === false) {
                // Do nothing
            }
            else {
                this.selectFeaturesFromStore(store, features, exclusive, reverse);
            }
        });
    }
    /**
     * Select features in store
     * @param store: Feature store
     * @param features Features
     */
    selectFeaturesFromStore(store, features, exclusive, reverse) {
        if (reverse === true) {
            store.state.reverseMany(features, ['selected']);
        }
        else {
            store.state.updateMany(features, { selected: true }, exclusive);
        }
    }
    /**
     * Unselect all features from store
     * @param store: Feature store
     */
    unselectAllFeaturesFromStore(store) {
        store.state.updateAll({ selected: false });
    }
    /**
     * This method returns a store -> features mapping from a list
     * of OL selected features. OL features keep a reference to the store
     * they are from.
     * @param olFeatures: OL feature objects
     * @returns Store -> features mapping
     */
    groupFeaturesByStore(olFeatures) {
        const groupedFeatures = new Map();
        if (olFeatures === null || olFeatures === undefined) {
            return groupedFeatures;
        }
        olFeatures.forEach((olFeature) => {
            const store = olFeature.get('_featureStore');
            if (store === undefined) {
                return;
            }
            let features = groupedFeatures.get(store);
            if (features === undefined) {
                features = [];
                groupedFeatures.set(store, features);
            }
            const feature = store.get(olFeature.getId());
            if (feature !== undefined) {
                features.push(feature);
            }
        });
        return groupedFeatures;
    }
    /**
     * Create an overlay store that'll contain the selected features.
     * @returns Overlay store
     */
    createOverlayStore() {
        const overlayLayer = this.options.layer
            ? this.options.layer
            : this.createOverlayLayer();
        return new FeatureStore([], { map: this.map }).bindLayer(overlayLayer);
    }
    /**
     * Create an overlay store that'll contain the selected features.
     * @returns Overlay layer
     */
    createOverlayLayer() {
        return new VectorLayer({
            zIndex: 300,
            source: new FeatureDataSource(),
            style: undefined,
            showInLayerList: false,
            exportable: false,
            browsable: false
        });
    }
    /**
     * Add the overlay store's layer to the map to display the selected
     * features.
     */
    addOverlayLayer() {
        if (this.overlayStore.layer.map === undefined) {
            this.map.addLayer(this.overlayStore.layer);
        }
    }
    /**
     * Remove the overlay layer from the map
     */
    removeOverlayLayer() {
        this.overlayStore.source.ol.clear();
        this.map.removeLayer(this.overlayStore.layer);
    }
}

/**
 * Try to add a loading strategy to a store and activate it.
 * If no strategy is given to that function, a basic one will be created.
 * @param store The store to bind the loading strategy
 * @param strategy An optional loading strategy
 */
function tryAddLoadingStrategy(store, strategy) {
    if (store.getStrategyOfType(FeatureStoreLoadingStrategy) !== undefined) {
        store.activateStrategyOfType(FeatureStoreLoadingStrategy);
        return;
    }
    strategy = strategy ? strategy : new FeatureStoreLoadingStrategy({});
    store.addStrategy(strategy);
    strategy.activate();
}
/**
 * Try to add a selection strategy to a store and activate it.
 * If no strategy is given to that function, a basic one will be created.
 * @param store The store to bind the selection strategy
 * @param [strategy] An optional selection strategy
 */
function tryAddSelectionStrategy(store, strategy) {
    if (store.getStrategyOfType(FeatureStoreSelectionStrategy) !== undefined) {
        store.activateStrategyOfType(FeatureStoreSelectionStrategy);
        return;
    }
    strategy = strategy
        ? strategy
        : new FeatureStoreSelectionStrategy({
            map: store.map
        });
    store.addStrategy(strategy);
    strategy.activate();
}

/**
 * Create a marker style for points
 * @returns Style
 */
function createOverlayMarkerStyle({ text, opacity = 1, markerColor = [0, 161, 222], markerOutlineColor = [255, 255, 255] } = {}) {
    let iconColor;
    let svgIconColor;
    let svgOutlineColor;
    let svg;
    const isIE = /msie\s|trident\/|edge\//i.test(window.navigator.userAgent); // To fix IE11 svg bug (temporarly)
    const newColor = asArray(markerColor).slice(0);
    const newOutlineColor = asArray(markerOutlineColor).slice(0);
    if (newColor.length === 4 && (typeof markerColor !== 'string' || /^#[0-9A-F]{8}$/i.test(markerColor))) {
        opacity = newColor[3];
    }
    svgIconColor = `"rgba(${newColor[0]},${newColor[1]},${newColor[2]},${opacity})"`;
    iconColor = markerColor;
    svgOutlineColor = `"rgb(${newOutlineColor[0]},${newOutlineColor[1]},${newOutlineColor[2]})"`;
    svg =
        'data:image/svg+xml;utf8,<svg version="1.1" xmlns="http://www.w3.org/2000/svg" height="36" width="36" viewBox="0 0 36 36">' +
            '<path fill=' +
            svgIconColor +
            ' stroke=' +
            svgOutlineColor +
            ` stroke-width="2" d="M 17.692635,32.565644 C 15.71852,30.330584 13.290925,27.058065 11.6766,24.455732 9.3398623,20.688851 7.8905694,17.205334 7.6297492,14.728733 7.5616025,14.081649 7.5739557,12.528552 7.6513363,12.014724 8.1013861,9.0262716 9.8047068,6.3655569 12.310675,4.7364878 c 1.113691,-0.7239832 2.508083,-1.2834131 3.776687,-1.5152052 0.242945,-0.044389 0.451656,-0.09393 0.463804,-0.1100911 0.01215,-0.016161 0.638282,-0.025502 1.391411,-0.02076 1.088235,0.00685 1.450932,0.024316 1.766871,0.085071 2.650763,0.5097353 4.947142,1.8701891 6.498786,3.8501033 0.628018,0.8013587 1.297046,2.0200608 1.640967,2.9891872 0.191065,0.538399 0.427644,1.447408 0.477391,1.834287 0.0164,0.127546 0.0434,0.231902 0.06,0.231902 0.0166,0 0.03122,0.626135 0.03249,1.391411 0.0013,0.765276 -0.011,1.391411 -0.02726,1.391411 -0.01626,0 -0.05449,0.154049 -0.08495,0.342331 -0.08815,0.544879 -0.387235,1.721449 -0.604837,2.379406 -1.209421,3.656888 -4.014463,8.349762 -7.849521,13.132357 -0.790496,0.985807 -1.795217,2.167992 -1.842543,2.167992 -0.01896,0 -0.161766,-0.144111 -0.317336,-0.320246 z m 1.066937,-15.36525 c 0.133519,-0.02121 0.248766,-0.05657 0.256105,-0.07859 0.0073,-0.02202 0.04918,-0.03066 0.09298,-0.0192 0.0438,0.01145 0.107628,-0.0072 0.141834,-0.04137 0.03421,-0.03421 0.08456,-0.05474 0.111888,-0.04563 0.02733,0.0091 0.07703,-0.01077 0.110429,-0.04417 0.03341,-0.03341 0.08416,-0.05293 0.112796,-0.04338 0.02863,0.0095 0.08974,-0.01867 0.135802,-0.06271 0.04606,-0.04403 0.111902,-0.08625 0.146319,-0.09381 0.204084,-0.04483 0.762371,-0.519108 1.079463,-0.917027 0.26749,-0.335672 0.570987,-0.878795 0.529019,-0.946701 -0.01496,-0.0242 -0.0067,-0.044 0.01835,-0.044 0.05645,0 0.196809,-0.467982 0.158801,-0.529481 -0.01521,-0.02461 -0.0043,-0.04475 0.02427,-0.04475 0.03157,0 0.04365,-0.04329 0.03082,-0.11043 -0.01161,-0.06074 -0.0066,-0.110429 0.01124,-0.110429 0.01779,0 0.03235,-0.258405 0.03235,-0.574233 0,-0.315829 -0.01545,-0.574234 -0.03434,-0.574234 -0.01889,0 -0.02437,-0.03811 -0.01219,-0.08469 0.04412,-0.168712 -0.336329,-1.152668 -0.481536,-1.245401 -0.02327,-0.01486 -0.04022,-0.03992 -0.03765,-0.05568 0.01222,-0.07498 -0.156557,-0.318365 -0.406379,-0.586027 -0.295921,-0.317054 -0.773059,-0.690104 -0.83427,-0.652274 -0.0206,0.01273 -0.03745,0.0024 -0.03745,-0.02289 0,-0.06107 -0.433076,-0.2789369 -0.487546,-0.245273 -0.02338,0.01445 -0.04251,0.0068 -0.04251,-0.01695 0,-0.056281 -0.393995,-0.1865457 -0.613804,-0.2029397 -0.0943,-0.00703 -0.188579,-0.023183 -0.209503,-0.035888 -0.02092,-0.012705 -0.276571,-0.023337 -0.568105,-0.023627 -0.534044,-5.301e-4 -1.12638,0.091025 -1.12638,0.1741017 0,0.023781 -0.01713,0.032648 -0.03808,0.019705 -0.05054,-0.031232 -0.403641,0.1088602 -0.403641,0.1601422 0,0.02204 -0.01988,0.02779 -0.04417,0.01278 -0.0243,-0.01501 -0.04417,-0.0051 -0.04417,0.02209 0,0.02716 -0.01988,0.0371 -0.04417,0.02209 -0.0243,-0.01501 -0.04417,-0.0051 -0.04417,0.02209 0,0.02716 -0.01915,0.03755 -0.04256,0.02308 -0.02341,-0.01447 -0.08138,0.01252 -0.128834,0.05997 -0.04745,0.04745 -0.0974,0.07515 -0.111001,0.06155 -0.0136,-0.0136 -0.03722,0.0078 -0.05248,0.0476 -0.01526,0.03978 -0.0411,0.06408 -0.0574,0.054 -0.03277,-0.02025 -0.462299,0.323995 -0.491977,0.394291 -0.01026,0.02429 -0.07454,0.0912 -0.142856,0.148686 -0.248033,0.208705 -0.730279,0.974169 -0.672565,1.067553 0.0145,0.02346 0.0059,0.04266 -0.01914,0.04266 -0.05907,0 -0.241471,0.599428 -0.208527,0.685278 0.01385,0.0361 0.0044,0.06564 -0.02098,0.06564 -0.02539,0 -0.04169,0.0646 -0.03622,0.143558 0.0055,0.07896 -0.0042,0.213129 -0.02144,0.29816 -0.04741,0.233576 0.0511,1.055502 0.167516,1.397721 0.126048,0.370516 0.310099,0.740163 0.426484,0.856548 0.04776,0.04776 0.07554,0.08684 0.06174,0.08684 -0.0138,0 0.01516,0.05653 0.06436,0.125632 0.131301,0.184396 0.499365,0.587266 0.518785,0.567846 0.0092,-0.0092 0.09821,0.06081 0.197812,0.155562 0.09961,0.09475 0.190589,0.162786 0.202187,0.151188 0.0116,-0.0116 0.05991,0.01774 0.107361,0.06519 0.04745,0.04745 0.105426,0.07444 0.128834,0.05997 0.02341,-0.01447 0.04256,-0.0057 0.04256,0.01958 0,0.06106 0.344664,0.23496 0.399061,0.201341 0.02346,-0.0145 0.04266,-0.0059 0.04266,0.01914 0,0.05907 0.599429,0.241471 0.685279,0.208527 0.0361,-0.01385 0.06564,-0.0065 0.06564,0.01645 0,0.05196 1.079115,0.04833 1.413314,-0.0048 z"></path>` +
            '</svg>';
    let src;
    if (isIE) {
        switch (markerColor) {
            case 'blue' || [0, 161, 222] || '#00a1de':
                iconColor = 'blue';
                break;
            case 'red' || '#f64139':
                iconColor = 'red';
                break;
            case 'yellow' || '#ffd700':
                iconColor = 'yellow';
                break;
            case 'green' || '#008000':
                iconColor = 'green';
                break;
            default:
                iconColor = 'blue';
                break;
        }
        src = './assets/igo2/geo/icons/place_' + iconColor + '_36px.svg';
    }
    else {
        src = svg;
    }
    return new olstyle.Style({
        image: new olstyle.Icon({
            src: svg,
            opacity,
            imgSize: [36, 36],
            anchor: [0.5, 0.92]
        }),
        text: new olstyle.Text({
            text,
            font: '12px Calibri,sans-serif',
            fill: new olstyle.Fill({ color: '#000' }),
            stroke: new olstyle.Stroke({ color: '#fff', width: 3 }),
            overflow: true
        })
    });
}

class StyleService {
    createStyle(options) {
        if (!options) {
            return createOverlayMarkerStyle();
        }
        if (typeof options === 'function' || options instanceof olstyle.Style) {
            return options;
        }
        return this.parseStyle('style', options);
    }
    parseStyle(key, value) {
        const styleOptions = {};
        const olCls = this.getOlCls(key);
        if (olCls && value instanceof Object) {
            Object.keys(value).forEach(_key => {
                const olKey = this.getOlKey(_key);
                styleOptions[olKey] = this.parseStyle(_key, value[_key]);
            });
            return new olCls(styleOptions);
        }
        else {
            return value;
        }
    }
    getOlKey(key) {
        let olKey;
        switch (key.toLowerCase()) {
            case 'circle':
            case 'regularshape':
            case 'icon':
                olKey = 'image';
                break;
            default:
                break;
        }
        return olKey || key;
    }
    getOlCls(key) {
        let olCls = olstyle[key.charAt(0).toUpperCase() + key.slice(1)];
        if (key === 'regularshape') {
            olCls = olstyle.RegularShape;
        }
        if (key === 'backgroundFill') {
            olCls = olstyle.Fill;
        }
        if (key === 'backgroundStroke') {
            olCls = olstyle.Stroke;
        }
        return olCls;
    }
    createStyleByAttribute(feature, styleByAttribute) {
        var _a;
        let style;
        const type = styleByAttribute.type ? styleByAttribute.type : this.guessTypeFeature(feature);
        const attribute = styleByAttribute.attribute;
        const data = styleByAttribute.data;
        const stroke = styleByAttribute.stroke;
        const width = styleByAttribute.width;
        const fill = styleByAttribute.fill;
        const anchor = styleByAttribute.anchor;
        const radius = styleByAttribute.radius;
        const icon = styleByAttribute.icon;
        const scale = styleByAttribute.scale;
        const size = data ? data.length : 0;
        const label = styleByAttribute.label ? styleByAttribute.label.attribute : undefined;
        let labelStyle = ((_a = styleByAttribute.label) === null || _a === void 0 ? void 0 : _a.style) ? this.parseStyle('text', styleByAttribute.label.style) : undefined;
        if (!labelStyle && label) {
            labelStyle = new olstyle.Text();
        }
        const baseStyle = styleByAttribute.baseStyle;
        if (labelStyle) {
            labelStyle.setText(this.getLabel(feature, label));
        }
        if (type === 'circle') {
            for (let i = 0; i < size; i++) {
                const val = typeof feature.get(attribute) !== 'undefined' && feature.get(attribute) !== null
                    ? feature.get(attribute)
                    : '';
                if (val === data[i] || val.toString().match(new RegExp(data[i], 'gmi'))) {
                    if (icon) {
                        style = [
                            new olstyle.Style({
                                image: new olstyle.Icon({
                                    color: fill ? fill[i] : undefined,
                                    src: icon[i],
                                    scale: scale ? scale[i] : 1,
                                    anchor: anchor ? anchor[i] : [0.5, 0.5]
                                }),
                                text: labelStyle instanceof olstyle.Text ? labelStyle : undefined
                            })
                        ];
                        return style;
                    }
                    style = [
                        new olstyle.Style({
                            image: new olstyle.Circle({
                                radius: radius ? radius[i] : 4,
                                stroke: new olstyle.Stroke({
                                    color: stroke ? stroke[i] : 'black',
                                    width: width ? width[i] : 1
                                }),
                                fill: new olstyle.Fill({
                                    color: fill ? fill[i] : 'black'
                                })
                            }),
                            text: labelStyle instanceof olstyle.Text ? labelStyle : undefined
                        })
                    ];
                    return style;
                }
            }
            if (!feature.getStyle()) {
                if (baseStyle) {
                    style = this.createStyle(baseStyle);
                    if (labelStyle) {
                        style.setText(labelStyle);
                    }
                    return style;
                }
                style = [
                    new olstyle.Style({
                        image: new olstyle.Circle({
                            radius: 4,
                            stroke: new olstyle.Stroke({
                                color: 'black'
                            }),
                            fill: new olstyle.Fill({
                                color: '#bbbbf2'
                            })
                        })
                    })
                ];
                return style;
            }
        }
        else if (type === 'regular') {
            for (let i = 0; i < size; i++) {
                const val = typeof feature.get(attribute) !== 'undefined' && feature.get(attribute) !== null
                    ? feature.get(attribute)
                    : '';
                if (val === data[i] || val.toString().match(new RegExp(data[i], 'gmi'))) {
                    style = [
                        new olstyle.Style({
                            stroke: new olstyle.Stroke({
                                color: stroke ? stroke[i] : 'black',
                                width: width ? width[i] : 1
                            }),
                            fill: new olstyle.Fill({
                                color: fill ? fill[i] : 'rgba(255,255,255,0.4)'
                            }),
                            text: labelStyle instanceof olstyle.Text ? labelStyle : undefined
                        })
                    ];
                    return style;
                }
            }
            if (feature instanceof OlFeature) {
                if (!feature.getStyle()) {
                    if (baseStyle) {
                        style = this.createStyle(baseStyle);
                        if (labelStyle) {
                            style.setText(labelStyle);
                        }
                        return style;
                    }
                    style = [
                        new olstyle.Style({
                            stroke: new olstyle.Stroke({
                                color: 'black'
                            }),
                            fill: new olstyle.Fill({
                                color: '#bbbbf2'
                            })
                        })
                    ];
                    return style;
                }
            }
        }
    }
    createClusterStyle(feature, clusterParam = {}, layerStyle) {
        let style;
        const size = feature.get('features').length;
        if (size !== 1) {
            if (clusterParam.clusterRanges) {
                for (const r of clusterParam.clusterRanges) {
                    if ((!r.minRadius || r.minRadius <= size) &&
                        (!r.maxRadius || r.maxRadius >= size)) {
                        style = this.createStyle(r.style);
                        if (r.showRange) {
                            const text = new olstyle.Text({
                                text: size.toString(),
                                fill: new olstyle.Fill({
                                    color: '#fff'
                                })
                            });
                            style.setText(text);
                        }
                        if (r.dynamicRadius) {
                            let clusterRadius;
                            const radiusMin = style.getRadius();
                            clusterRadius = 5 * Math.log(size);
                            if (clusterRadius < radiusMin) {
                                clusterRadius = radiusMin;
                            }
                            style.image_.setRadius(clusterRadius);
                        }
                        break;
                    }
                }
            }
            if (!style) {
                let clusterRadius;
                if (clusterParam.radiusCalc) {
                    clusterRadius = clusterParam.radiusCalc(size);
                }
                else {
                    const radiusMin = 6;
                    clusterRadius = 5 * Math.log(size);
                    if (clusterRadius < radiusMin) {
                        clusterRadius = radiusMin;
                    }
                }
                style = [
                    new olstyle.Style({
                        image: new olstyle.Circle({
                            radius: clusterRadius,
                            stroke: new olstyle.Stroke({
                                color: 'black'
                            }),
                            fill: new olstyle.Fill({
                                color: 'rgba(24, 134, 45, 0.5)'
                            })
                        }),
                        text: new olstyle.Text({
                            text: size.toString(),
                            fill: new olstyle.Fill({
                                color: '#fff'
                            })
                        })
                    })
                ];
            }
        }
        else {
            style = this.createStyle(layerStyle);
        }
        return style;
    }
    getLabel(feature, labelMatch) {
        let label = labelMatch;
        if (!label) {
            return;
        }
        const labelToGet = Array.from(labelMatch.matchAll(/\$\{([^\{\}]+)\}/g));
        labelToGet.forEach(v => {
            label = label.replace(v[0], feature.get(v[1]));
        });
        // Nothing done? check feature's attribute
        if (labelToGet.length === 0 && label === labelMatch) {
            label = feature.get(labelMatch) || labelMatch;
        }
        return label;
    }
    guessTypeFeature(feature) {
        switch (feature.getGeometry().getType()) {
            case 'Point':
            case 'MultiPoint':
            case 'Circle':
                return 'circle';
            default:
                return 'regular';
        }
    }
}
StyleService.ɵfac = function StyleService_Factory(t) { return new (t || StyleService)(); };
StyleService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: StyleService, factory: StyleService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(StyleService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();

/**
 * Create an overlay layer and it's source
 * @returns Overlay layer
 */
function createOverlayLayer() {
    const overlayDataSource = new FeatureDataSource();
    return new VectorLayer({
        title: 'Overlay',
        zIndex: 300,
        source: overlayDataSource,
        style: createOverlayLayerStyle()
    });
}
/**
 * Create an overlay style with markers for points and a basic stroke/fill
 * combination for lines and polygons
 * @returns Style function
 */
function createOverlayLayerStyle() {
    const defaultStyle = createOverlayDefaultStyle();
    const markerStyle = createOverlayMarkerStyle();
    let style;
    return (olFeature) => {
        if (olFeature.getId() === 'bufferFeature') {
            style = createBufferStyle(olFeature.get('bufferStroke'), 2, olFeature.get('bufferFill'), olFeature.get('bufferText'));
            return style;
        }
        else {
            const customStyle = olFeature.get('_style');
            if (customStyle) {
                const styleService = new StyleService();
                return styleService.createStyle(customStyle);
            }
            const geometryType = olFeature.getGeometry().getType();
            style = geometryType === 'Point' ? markerStyle : defaultStyle;
            style.getText().setText(olFeature.get('_mapTitle'));
            return style;
        }
    };
}
/**
 * Create a basic style for lines and polygons
 * @returns Style
 */
function createOverlayDefaultStyle({ text, strokeWidth = 2, fillColor = [0, 161, 222, 0.3], strokeColor = [0, 161, 222, 0.9], } = {}) {
    const fillWithOpacity = asArray(fillColor).slice(0);
    const strokeWithOpacity = asArray(strokeColor).slice(0);
    const stroke = new olstyle.Stroke({
        width: strokeWidth,
        color: strokeWithOpacity
    });
    const fill = new olstyle.Fill({
        color: fillWithOpacity
    });
    return new olstyle.Style({
        stroke,
        fill,
        image: new olstyle.Circle({
            radius: 5,
            stroke,
            fill
        }),
        text: new olstyle.Text({
            text,
            font: '12px Calibri,sans-serif',
            fill: new olstyle.Fill({ color: '#000' }),
            stroke: new olstyle.Stroke({ color: '#fff', width: 3 }),
            overflow: true
        })
    });
}
function createBufferStyle(strokeRGBA = [0, 161, 222, 1], strokeWidth = 2, fillRGBA = [0, 161, 222, 0.15], bufferRadius) {
    const stroke = new olstyle.Stroke({
        width: strokeWidth,
        color: strokeRGBA
    });
    const fill = new olstyle.Fill({
        color: fillRGBA
    });
    return new olstyle.Style({
        stroke,
        fill,
        image: new olstyle.Circle({
            radius: 5,
            stroke,
            fill
        }),
        text: new olstyle.Text({
            font: '12px Calibri,sans-serif',
            text: bufferRadius,
            fill: new olstyle.Fill({ color: '#000' }),
            stroke: new olstyle.Stroke({ color: '#fff', width: 3 }),
            overflow: true
        })
    });
}

/**
 * This class is simply a shortcut for adding features to a map.
 * It does nothing more than a standard layer but it's shipped with
 * a defautl style based on the geometry type of the features it contains.
 * @todo Enhance that by using a FeatureStore and strategies.
 */
class Overlay {
    constructor(map) {
        this.layer = createOverlayLayer();
        this.setMap(map);
    }
    /**
     * Overlay layer's data source
     */
    get dataSource() {
        return this.layer.dataSource;
    }
    /**
     * Bind this to a map and add the overlay layer to that map
     * @param map Map
     */
    setMap(map) {
        if (map === undefined) {
            if (this.map !== undefined) {
                this.map.ol.removeLayer(this.layer.ol);
            }
        }
        else {
            map.ol.addLayer(this.layer.ol);
        }
        this.map = map;
    }
    /**
     * Set the overlay features and, optionally, move to them
     * @param features Features
     * @param motion Optional: Apply this motion to the map view
     * @param sourceId Optional: Remove features of certain sourceId (ex: 'Map' for query features)
     */
    setFeatures(features, motion = FeatureMotion.Default, sourceId) {
        if (sourceId) {
            for (const olFeature of this.dataSource.ol.getFeatures()) {
                if (olFeature.get('_sourceId') === sourceId) {
                    this.removeOlFeature(olFeature);
                }
            }
        }
        else {
            this.clear();
        }
        this.addFeatures(features, motion);
    }
    /**
     * Add a feature to the  overlay and, optionally, move to it
     * @param feature Feature
     * @param motion Optional: Apply this motion to the map view
     */
    addFeature(feature, motion = FeatureMotion.Default) {
        this.addFeatures([feature], motion);
    }
    /**
     * Add features to the  overlay and, optionally, move to them
     * @param features Features
     * @param motion Optional: Apply this motion to the map view
     */
    addFeatures(features, motion = FeatureMotion.Default) {
        const olFeatures = [];
        features.forEach((feature) => {
            const olFeature = featureToOl(feature, this.map.projection);
            const olGeometry = olFeature.getGeometry();
            if (olGeometry === null) {
                return;
            }
            olFeatures.push(olFeature);
        });
        this.addOlFeatures(olFeatures, motion);
    }
    /**
     * Add a OpenLayers feature to the  overlay and, optionally, move to it
     * @param olFeature OpenLayers Feature
     * @param motion Optional: Apply this motion to the map view
     */
    addOlFeature(olFeature, motion = FeatureMotion.Default) {
        this.addOlFeatures([olFeature], motion);
    }
    /**
     * Add OpenLayers features to the overlay and, optionally, move to them
     * @param olFeatures OpenLayers Features
     * @param motion Optional: Apply this motion to the map view
     */
    addOlFeatures(olFeatures, motion = FeatureMotion.Default) {
        this.dataSource.ol.addFeatures(olFeatures);
        moveToOlFeatures(this.map, olFeatures, motion);
    }
    /**
     * Remove a feature from the overlay
     * @param feature Feature
     */
    removeFeature(feature) {
        this.removeFeatures([feature]);
    }
    /**
     * Remove features from the overlay
     * @param features Features
     */
    removeFeatures(features) {
        features.forEach((feature) => {
            if (feature.meta) {
                if (this.dataSource.ol.getFeatureById(feature.meta.id)) {
                    this.removeOlFeature(this.dataSource.ol.getFeatureById(feature.meta.id));
                }
            }
        });
    }
    /**
     * Remove an OpenLayers feature from the overlay
     * @param olFeature OpenLayers Feature
     */
    removeOlFeature(olFeature) {
        this.dataSource.ol.removeFeature(olFeature);
    }
    /**
     * Clear the overlay
     */
    clear() {
        this.dataSource.ol.clear();
    }
}

class LayerWatcher extends Watcher {
    constructor() {
        super();
        this.loaded = 0;
        this.loading = 0;
        this.layers = [];
        this.subscriptions = [];
    }
    watch() { }
    unwatch() {
        this.layers.forEach(layer => this.unwatchLayer(layer), this);
    }
    watchLayer(layer) {
        if (layer.status$ === undefined) {
            return;
        }
        this.layers.push(layer);
        const layer$$ = layer.status$
            .pipe(distinctUntilChanged())
            .subscribe(status => {
            if (status === SubjectStatus.Error) {
                this.loading = 0;
                this.loaded = -1;
            }
            if (status === SubjectStatus.Working) {
                this.loading += 1;
            }
            else if (status === SubjectStatus.Done) {
                this.loaded += 1;
            }
            if (this.loaded >= this.loading) {
                this.loading = this.loaded = 0;
                this.status = SubjectStatus.Done;
            }
            else if (this.loading > 0) {
                this.status = SubjectStatus.Working;
            }
        });
        this.subscriptions.push(layer$$);
    }
    unwatchLayer(layer) {
        layer.status$.next(SubjectStatus.Done);
        const index = this.layers.indexOf(layer);
        if (index >= 0) {
            const status = layer.watcher.status;
            if ([SubjectStatus.Working, SubjectStatus.Waiting].indexOf(status) !== -1) {
                this.loaded += 1;
            }
            this.subscriptions[index].unsubscribe();
            this.subscriptions.splice(index, 1);
            this.layers.splice(index, 1);
            layer.watcher.unwatch();
        }
    }
}

var MapViewAction;
(function (MapViewAction) {
    MapViewAction[MapViewAction["Move"] = 0] = "Move";
    MapViewAction[MapViewAction["Zoom"] = 1] = "Zoom";
})(MapViewAction || (MapViewAction = {}));

/**
 * Base map controller
 */
class MapController {
    constructor() {
        /**
         * Array of observer keys
         */
        this.observerKeys = [];
    }
    /**
     * Return the OL map this controller is bound to
     * @returns OL Map
     */
    getOlMap() {
        return this.olMap;
    }
    /**
     * Add or remove this controller to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap) {
        if (olMap !== undefined && this.getOlMap() !== undefined) {
            throw new Error('This controller is already bound to a map.');
        }
        if (olMap === undefined) {
            this.teardownObservers();
            this.olMap = olMap;
            return;
        }
        this.olMap = olMap;
    }
    /**
     * Teardown any observers
     */
    teardownObservers() {
        this.observerKeys.forEach((key) => unByKey(key));
        this.observerKeys = [];
    }
}

/**
 * Controller to handle map view interactions
 */
class MapViewController extends MapController {
    constructor(options) {
        super();
        this.options = options;
        /**
         * Observable of the current resolution
         */
        this.resolution$ = new BehaviorSubject(undefined);
        /**
         * Observable of the current state
         */
        this.state$ = new BehaviorSubject(undefined);
        /**
         * View Padding
         */
        this.padding = [0, 0, 0, 0];
        /**
         * Max zoom after set extent
         */
        this.maxZoomOnExtent = 19;
        /**
         * Extent stream
         */
        this.extent$ = new Subject();
        /**
         * History of states
         */
        this.states = [];
        /**
         * Current state index
         */
        this.stateIndex = 0;
    }
    /**
     * Whether the view controller should keep the view's state history
     */
    get stateHistory() {
        return this.options ? this.options.stateHistory === true : false;
    }
    /**
     * OL View
     */
    get olView() {
        return this.olMap.getView();
    }
    /**
     * Add or remove this controller to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap) {
        super.setOlMap(olMap);
        this.setupObservers();
    }
    /**
     * Observe move moveend and subscribe to the extent stream
     */
    setupObservers() {
        if (this.stateHistory === true) {
            this.observerKeys.push(this.olMap.on('moveend', (event) => this.onMoveEnd(event)));
        }
        this.extent$$ = this.extent$
            .pipe(debounceTime(25))
            .subscribe((value) => {
            this.setExtent(value.extent, value.action);
        });
    }
    /**
     * Teardown any observers
     */
    teardownObservers() {
        super.teardownObservers();
        if (this.extent$$ !== undefined) {
            this.extent$$.unsubscribe();
            this.extent$$ = undefined;
        }
    }
    /**
     * Get the view's OL projection
     * @returns OL projection
     */
    getOlProjection() {
        return this.olView.getProjection();
    }
    /**
     * Get the current map view center
     * @param projection Output projection
     * @returns Center
     */
    getCenter(projection) {
        let center = this.olView.getCenter();
        if (projection && center) {
            center = olproj.transform(center, this.getOlProjection(), projection);
        }
        return center;
    }
    /**
     * Get the current view extent
     * @param projection Output projection
     * @returns Extent
     */
    getExtent(projection) {
        let extent = this.olView.calculateExtent(this.olMap.getSize());
        if (projection && extent) {
            extent = olproj.transformExtent(extent, this.getOlProjection(), projection);
        }
        return extent;
    }
    /**
     * Get the current scale
     * @param dpi Dot per inches
     * @returns View scale
     */
    getScale(dpi = 96) {
        return getScaleFromResolution(this.getResolution(), this.getOlProjection().getUnits(), dpi);
    }
    /**
     * Get the current resolution
     * @returns Projection denominator
     */
    getResolution() {
        return this.olView.getResolution();
    }
    /**
     * Get the current zoom level
     * @returns Zoom level
     */
    getZoom() {
        return Math.round(this.olView.getZoom());
    }
    /**
     * Zoom in
     */
    zoomIn() {
        this.zoomTo(this.olView.getZoom() + 1);
    }
    /**
     * Zoom out
     */
    zoomOut() {
        this.zoomTo(this.olView.getZoom() - 1);
    }
    /**
     * Zoom to specific zoom level
     * @param zoom Zoom level
     */
    zoomTo(zoom) {
        this.olView.cancelAnimations();
        this.olView.animate({
            zoom,
            duration: 250,
            easing: oleasing.easeOut
        });
    }
    /**
     * Move to extent after a short delay (100ms) unless
     * a new movement gets registered in the meantime.
     * @param extent Extent to move to
     */
    moveToExtent(extent) {
        this.extent$.next({ extent, action: MapViewAction.Move });
    }
    /**
     * Zoom to extent after a short delay (100ms) unless
     * a new movement gets registered in the meantime.
     * @param extent Extent to zoom to
     */
    zoomToExtent(extent) {
        this.extent$.next({ extent, action: MapViewAction.Zoom });
    }
    /**
     * Return the current view rotation
     * @returns Rotation angle in degrees
     */
    getRotation() {
        return this.olView.getRotation();
    }
    /**
     * Reset the view rotation to 0
     */
    resetRotation() {
        this.olView.animate({ rotation: 0 });
    }
    /**
     * Whether the view has a previous state
     * @returns True if the view has a previous state
     */
    hasPreviousState() {
        return this.states.length > 1 && this.stateIndex > 0;
    }
    /**
     * Whether the view has a next state
     * @returns True if the view has a next state
     */
    hasNextState() {
        return this.states.length > 1 && this.stateIndex < this.states.length - 1;
    }
    /**
     * Restore the previous view state
     */
    previousState() {
        if (this.hasPreviousState()) {
            this.setStateIndex(this.stateIndex - 1);
        }
    }
    /**
     * Restore the next view state
     */
    nextState() {
        if (this.hasNextState()) {
            this.setStateIndex(this.stateIndex + 1);
        }
    }
    /**
     * Clear the state history
     */
    clearStateHistory() {
        this.states = [];
        this.stateIndex = 0;
    }
    /**
     * Update the the view to it's intial state
     */
    setInitialState() {
        if (this.states.length > 0) {
            this.setStateIndex(0);
        }
    }
    /**
     * Move to the extent retrieved from the stream
     * @param extent Extent
     * @param action Either zoom or move
     * @param animation With or without animation to the target extent.
     */
    setExtent(extent, action, animation = true) {
        const olView = this.olView;
        olView.cancelAnimations();
        const duration = animation ? 500 : 0;
        const zoom = olView.getZoom();
        const fromCenter = olView.getCenter();
        const toCenter = [
            extent[0] + (extent[2] - extent[0]) / 2,
            extent[1] + (extent[3] - extent[1]) / 2
        ];
        const distCenter = Math.sqrt(Math.pow(fromCenter[0] - toCenter[0], 2) +
            Math.pow(fromCenter[1] - toCenter[1], 2));
        const fromExtent = olView.calculateExtent();
        const fromSize = Math.sqrt(Math.pow(fromExtent[2] - fromExtent[0], 2) +
            Math.pow(fromExtent[3] - fromExtent[1], 2));
        const toSize = Math.sqrt(Math.pow(extent[2] - extent[0], 2) + Math.pow(extent[3] - extent[1], 2));
        const moySize = (toSize + fromSize) / 2;
        const xSize = distCenter / moySize;
        const maxZoom = action === MapViewAction.Move || zoom > this.maxZoomOnExtent
            ? zoom
            : this.maxZoomOnExtent;
        olView.fit(extent, {
            size: this.olMap.getSize(),
            maxZoom,
            padding: this.padding,
            duration: xSize > 4 ? 0 : duration,
            callback: (isFinished) => {
                if (!isFinished) {
                    olView.fit(extent, {
                        size: this.olMap.getSize(),
                        maxZoom,
                        padding: this.padding,
                        duration: xSize > 4 ? 0 : duration
                    });
                }
            }
        });
    }
    /**
     * Set the view state index
     * @param index State index
     */
    setStateIndex(index) {
        this.stateIndex = index;
        this.setState(this.states[index]);
    }
    /**
     * Set the view state
     * @param state View state
     */
    setState(state) {
        this.olView.animate({
            resolution: state.resolution,
            center: state.center,
            duration: 0
        });
    }
    /**
     * On move end, get the view state and record it.
     * @param event Map event
     */
    onMoveEnd(event) {
        const resolution = this.getResolution();
        if (this.resolution$.value !== resolution) {
            this.resolution$.next(resolution);
        }
        const state = {
            resolution,
            center: this.getCenter(),
            zoom: this.getZoom()
        };
        if (this.stateHistory === true) {
            const stateIndex = this.stateIndex;
            const stateAtIndex = this.states.length === 0 ? undefined : this.states[stateIndex];
            if (!viewStatesAreEqual(state, stateAtIndex)) {
                this.states = this.states.slice(0, stateIndex + 1).concat([state]);
                this.stateIndex = this.states.length - 1;
            }
        }
        this.state$.next(state);
    }
}

// TODO: This class is messy. Clearly define it's scope and the map browser's.
// Move some stuff into controllers.
class IgoMap {
    constructor(options) {
        this.offlineButtonToggle$ = new BehaviorSubject(false);
        this.layers$ = new BehaviorSubject([]);
        this.positionFollower = true;
        this.geolocation$ = new BehaviorSubject(undefined);
        this.swipeEnabled$ = new BehaviorSubject(false);
        this.mapCenter$ = new BehaviorSubject(false);
        this.selectedFeatures$ = new BehaviorSubject(null);
        this.defaultOptions = {
            controls: { attribution: false }
        };
        this.options = Object.assign({}, this.defaultOptions, options);
        this.layerWatcher = new LayerWatcher();
        this.status$ = this.layerWatcher.status$;
        olproj4.register(proj4);
        this.init();
    }
    get layers() {
        return this.layers$.value;
    }
    get projection() {
        return this.viewController.getOlProjection().getCode();
    }
    init() {
        const controls = [];
        if (this.options.controls) {
            if (this.options.controls.attribution) {
                const attributionOpt = (this.options.controls.attribution === true
                    ? {}
                    : this.options.controls.attribution);
                controls.push(new olAttribution(attributionOpt));
            }
            if (this.options.controls.scaleLine) {
                const scaleLineOpt = (this.options.controls.scaleLine === true
                    ? {}
                    : this.options.controls.scaleLine);
                controls.push(new olControlScaleLine(scaleLineOpt));
            }
        }
        let interactions = {};
        if (this.options.interactions === false) {
            interactions = {
                altShiftDragRotate: false,
                doubleClickZoom: false,
                keyboard: false,
                mouseWheelZoom: false,
                shiftDragZoom: false,
                dragPan: false,
                pinchRotate: false,
                pinchZoom: false
            };
        }
        this.ol = new olMap({
            interactions: olInteraction.defaults(interactions),
            controls
        });
        this.setView(this.options.view || {});
        this.viewController = new MapViewController({
            stateHistory: true
        });
        this.viewController.setOlMap(this.ol);
        this.overlay = new Overlay(this);
        this.queryResultsOverlay = new Overlay(this);
        this.searchResultsOverlay = new Overlay(this);
        this.buffer = new Overlay(this);
    }
    setTarget(id) {
        this.ol.setTarget(id);
        if (id !== undefined) {
            this.layerWatcher.subscribe(() => { }, null);
        }
        else {
            this.layerWatcher.unsubscribe();
        }
    }
    updateView(options) {
        const currentView = this.ol.getView();
        const viewOptions = Object.assign({
            zoom: currentView.getZoom()
        }, currentView.getProperties());
        this.setView(Object.assign(viewOptions, options));
        if (options.maxZoomOnExtent) {
            this.viewController.maxZoomOnExtent = options.maxZoomOnExtent;
        }
    }
    /**
     * Set the map view
     * @param options Map view options
     */
    setView(options) {
        if (this.viewController !== undefined) {
            this.viewController.clearStateHistory();
        }
        options = Object.assign({ constrainResolution: true }, options);
        const view = new olView(options);
        this.ol.setView(view);
        this.unsubscribeGeolocate();
        if (options) {
            if (options.maxLayerZoomExtent) {
                this.viewController.maxLayerZoomExtent = options.maxLayerZoomExtent;
            }
            if (options.center) {
                const projection = view.getProjection().getCode();
                const center = olproj.fromLonLat(options.center, projection);
                view.setCenter(center);
            }
            if (options.geolocate) {
                this.geolocate(true);
            }
            if (options.alwaysTracking) {
                this.alwaysTracking = true;
            }
        }
    }
    updateControls(value) {
        if (value === undefined) {
            return;
        }
        const controls = [];
        if (value.attribution) {
            const attributionOpt = (value.attribution === true
                ? {}
                : value.attribution);
            controls.push(new olAttribution(attributionOpt));
        }
        if (value.scaleLine) {
            const scaleLineOpt = (value.scaleLine === true
                ? {}
                : value.scaleLine);
            controls.push(new olControlScaleLine(scaleLineOpt));
        }
        const currentControls = Object.assign([], this.ol.getControls().getArray());
        currentControls.forEach(control => {
            this.ol.removeControl(control);
        });
        controls.forEach(control => {
            this.ol.addControl(control);
        });
    }
    /**
     * Deprecated
     * TODO: Move to ViewController and update every place it's used
     */
    getCenter(projection) {
        return this.viewController.getCenter(projection);
    }
    /**
     * Deprecated
     * TODO: Move to ViewController and update every place it's used
     */
    getExtent(projection) {
        return this.viewController.getExtent(projection);
    }
    // TODO: Move to ViewController and update every place it's used
    getZoom() {
        return this.viewController.getZoom();
    }
    changeBaseLayer(baseLayer) {
        if (!baseLayer) {
            return;
        }
        for (const bl of this.getBaseLayers()) {
            bl.visible = false;
        }
        baseLayer.visible = true;
        this.viewController.olView.setMinZoom(baseLayer.dataSource.options.minZoom || (this.options.view || {}).minZoom);
        this.viewController.olView.setMaxZoom(baseLayer.dataSource.options.maxZoom || (this.options.view || {}).maxZoom);
    }
    getBaseLayers() {
        return this.layers.filter((layer) => layer.baseLayer === true);
    }
    getLayerById(id) {
        return this.layers.find((layer) => layer.id && layer.id === id);
    }
    getLayerByAlias(alias) {
        return this.layers.find((layer) => layer.alias && layer.alias === alias);
    }
    getLayerByOlUId(olUId) {
        return this.layers.find((layer) => layer.ol.ol_uid && layer.ol.ol_uid === olUId);
    }
    /**
     * Add a single layer
     * @param layer Layer to add
     * @param push DEPRECATED
     */
    addLayer(layer, push = true) {
        this.addLayers([layer]);
    }
    /**
     * Add many layers
     * @param layers Layers to add
     * @param push DEPRECATED
     */
    addLayers(layers, push = true) {
        let offsetZIndex = 0;
        let offsetBaseLayerZIndex = 0;
        const addedLayers = layers
            .map((layer) => {
            if (!layer) {
                return;
            }
            const offset = layer.zIndex
                ? 0
                : layer.baseLayer
                    ? offsetBaseLayerZIndex++
                    : offsetZIndex++;
            return this.doAddLayer(layer, offset);
        })
            .filter((layer) => layer !== undefined);
        this.setLayers([].concat(this.layers, addedLayers));
    }
    /**
     * Remove a single layer
     * @param layer Layer to remove
     */
    removeLayer(layer) {
        this.removeLayers([layer]);
    }
    /**
     * Remove many layers
     * @param layers Layers to remove
     */
    removeLayers(layers) {
        const newLayers = this.layers$.value.slice(0);
        const layersToRemove = [];
        layers.forEach((layer) => {
            const index = newLayers.indexOf(layer);
            if (index >= 0) {
                layersToRemove.push(layer);
                newLayers.splice(index, 1);
                this.handleLinkedLayersDeletion(layer, layersToRemove);
                layersToRemove.map(linkedLayer => {
                    layersToRemove.push(linkedLayer);
                    const linkedIndex = newLayers.indexOf(linkedLayer);
                    if (linkedIndex >= 0) {
                        newLayers.splice(linkedIndex, 1);
                    }
                });
            }
        });
        layersToRemove.forEach((layer) => this.doRemoveLayer(layer));
        this.setLayers(newLayers);
    }
    /**
     * Build a list of linked layers to delete
     * @param srcLayer Layer that has triggered the deletion
     * @param layersToRemove list to append the layer to delete into
     */
    handleLinkedLayersDeletion(srcLayer, layersToRemove) {
        const linkedLayers = srcLayer.options.linkedLayers;
        if (!linkedLayers) {
            return;
        }
        const currentLinkedId = linkedLayers.linkId;
        const currentLinks = linkedLayers.links;
        const isParentLayer = currentLinks ? true : false;
        if (isParentLayer) {
            // search for child layers
            currentLinks.map(link => {
                if (!link.syncedDelete) {
                    return;
                }
                link.linkedIds.map(linkedId => {
                    const layerToApply = this.layers.find(layer => { var _a; return ((_a = layer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.linkId) === linkedId; });
                    if (layerToApply) {
                        layersToRemove.push(layerToApply);
                    }
                });
            });
        }
        else {
            // search for parent layer
            this.layers.map(layer => {
                var _a;
                if ((_a = layer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.links) {
                    layer.options.linkedLayers.links.map(l => {
                        if (l.syncedDelete && l.bidirectionnal !== false &&
                            l.linkedIds.indexOf(currentLinkedId) !== -1) {
                            layersToRemove.push(layer);
                            this.handleLinkedLayersDeletion(layer, layersToRemove);
                        }
                    });
                }
            });
        }
    }
    /**
     * Remove all layers
     */
    removeAllLayers() {
        this.layers.forEach((layer) => this.doRemoveLayer(layer));
        this.layers$.next([]);
    }
    raiseLayer(layer) {
        const index = this.getLayerIndex(layer);
        if (index > 1) {
            this.moveLayer(layer, index, index - 1);
        }
    }
    raiseLayers(layers) {
        for (const layer of layers) {
            this.raiseLayer(layer);
        }
    }
    lowerLayer(layer) {
        const index = this.getLayerIndex(layer);
        if (index < this.layers.length - 1) {
            this.moveLayer(layer, index, index + 1);
        }
    }
    lowerLayers(layers) {
        const reverseLayers = layers.reverse();
        for (const layer of reverseLayers) {
            this.lowerLayer(layer);
        }
    }
    moveLayer(layer, from, to) {
        const layerTo = this.layers[to];
        const zIndexTo = layerTo.zIndex;
        const zIndexFrom = layer.zIndex;
        if (layerTo.baseLayer || layer.baseLayer) {
            return;
        }
        layer.zIndex = zIndexTo;
        layerTo.zIndex = zIndexFrom;
        this.layers[to] = layer;
        this.layers[from] = layerTo;
        this.layers$.next(this.layers.slice(0));
    }
    /**
     * Add a layer to the OL map and start watching. If the layer is already
     * added to this map, make it visible but don't add it one again.
     * @param layer Layer
     * @returns The layer added, if any
     */
    doAddLayer(layer, offsetZIndex) {
        if (layer.baseLayer && layer.visible) {
            this.changeBaseLayer(layer);
        }
        const existingLayer = this.getLayerById(layer.id);
        if (existingLayer !== undefined) {
            existingLayer.visible = true;
            return;
        }
        if (!layer.baseLayer && layer.zIndex) {
            layer.zIndex += 10;
        }
        if (layer.zIndex === undefined || layer.zIndex === 0) {
            const maxZIndex = Math.max(layer.baseLayer ? 0 : 10, ...this.layers
                .filter((l) => l.baseLayer === layer.baseLayer && l.zIndex < 200 // zIndex > 200 = system layer
            )
                .map((l) => l.zIndex));
            layer.zIndex = maxZIndex + 1 + offsetZIndex;
        }
        if (layer.baseLayer && layer.zIndex > 9) {
            layer.zIndex = 10; // baselayer must have zIndex < 10
        }
        layer.setMap(this);
        this.layerWatcher.watchLayer(layer);
        this.ol.addLayer(layer.ol);
        return layer;
    }
    /**
     * Remove a layer from the OL map and stop watching
     * @param layer Layer
     */
    doRemoveLayer(layer) {
        this.layerWatcher.unwatchLayer(layer);
        this.ol.removeLayer(layer.ol);
        layer.setMap(undefined);
    }
    /**
     * Update the layers observable
     * @param layers Layers
     */
    setLayers(layers) {
        this.layers$.next(this.sortLayersByZIndex(layers).slice(0));
    }
    /**
     * Sort layers by descending zIndex
     * @param layers Array of layers
     * @returns The original array, sorted by zIndex
     */
    sortLayersByZIndex(layers) {
        // Sort by descending zIndex
        return layers.sort((layer1, layer2) => layer2.zIndex - layer1.zIndex);
    }
    /**
     * Get layer index in the map's inenr array of layers
     * @param layer Layer
     * @returns The layer index
     */
    getLayerIndex(layer) {
        return this.layers.findIndex((_layer) => _layer === layer);
    }
    // TODO: Create a GeolocationController with everything below
    geolocate(track = false) {
        let first = true;
        if (this.geolocation$$) {
            track = this.geolocation.getTracking();
            this.unsubscribeGeolocate();
        }
        this.startGeolocation();
        this.geolocation$$ = this.geolocation$.subscribe((geolocation) => {
            var _a;
            if (!geolocation) {
                return;
            }
            const accuracy = geolocation.getAccuracy();
            const coordinates = geolocation.getPosition();
            if (accuracy < 10000) {
                const positionGeometry = coordinates ? new OlPoint(coordinates) : null;
                const accuracyGeometry = geolocation.getAccuracyGeometry();
                const accuracyExtent = accuracyGeometry.getExtent();
                [this.geolocationPositionFeature, this.geolocationAccuracyFeature].map(feature => {
                    if (feature && this.overlay.dataSource.ol.getFeatureById(feature.getId())) {
                        this.overlay.dataSource.ol.removeFeature(feature);
                    }
                });
                if (this.bufferFeature) {
                    this.buffer.dataSource.ol.removeFeature(this.bufferFeature);
                }
                this.geolocationPositionFeature = new OlFeature({ geometry: positionGeometry });
                this.geolocationPositionFeature.setId('geolocationPositionFeature');
                this.geolocationPositionFeature.setStyle(new olstyle.Style({
                    image: new olstyle.Circle({
                        radius: 6,
                        fill: new olstyle.Fill({
                            color: '#3399CC',
                        }),
                        stroke: new olstyle.Stroke({
                            color: '#fff',
                            width: 2,
                        }),
                    }),
                }));
                this.geolocationAccuracyFeature = new OlFeature({ geometry: accuracyGeometry });
                this.geolocationAccuracyFeature.setId('geolocationAccuracyFeature');
                if (this.alwaysTracking) {
                    [this.geolocationPositionFeature, this.geolocationAccuracyFeature].map(feature => {
                        this.overlay.addOlFeature(feature, this.positionFollower ? FeatureMotion.Move : FeatureMotion.None);
                    });
                }
                else {
                    [this.geolocationPositionFeature, this.geolocationAccuracyFeature].map(feature => {
                        this.overlay.addOlFeature(feature);
                    });
                }
                if ((_a = this.ol.getView().get('options_')) === null || _a === void 0 ? void 0 : _a.buffer) {
                    const bufferRadius = this.ol.getView().get('options_').buffer.bufferRadius;
                    this.bufferGeom = new OlCircle(coordinates, bufferRadius);
                    const bufferStroke = this.ol.getView().get('options_').buffer.bufferStroke;
                    const bufferFill = this.ol.getView().get('options_').buffer.bufferFill;
                    let bufferText;
                    if (this.ol.getView().get('options_').buffer.showBufferRadius) {
                        bufferText = bufferRadius.toString() + 'm';
                    }
                    else {
                        bufferText = '';
                    }
                    this.bufferFeature = new OlFeature(this.bufferGeom);
                    this.bufferFeature.setId('bufferFeature');
                    this.bufferFeature.set('bufferStroke', bufferStroke);
                    this.bufferFeature.set('bufferFill', bufferFill);
                    this.bufferFeature.set('bufferText', bufferText);
                    this.buffer.addOlFeature(this.bufferFeature, FeatureMotion.None);
                }
                if (first) {
                    this.viewController.zoomToExtent(accuracyExtent);
                    this.positionFollower = !this.positionFollower;
                }
            }
            else if (first) {
                const view = this.ol.getView();
                view.setCenter(coordinates);
                view.setZoom(14);
            }
            if (track !== true && this.alwaysTracking !== true) {
                this.unsubscribeGeolocate();
            }
            first = false;
        });
    }
    unsubscribeGeolocate() {
        this.stopGeolocation();
        if (this.geolocation$$) {
            this.geolocation$$.unsubscribe();
            this.geolocation$$ = undefined;
        }
    }
    startGeolocation() {
        if (!this.geolocation) {
            this.geolocation = new olGeolocation({
                trackingOptions: {
                    enableHighAccuracy: true
                },
                projection: this.projection,
                tracking: true
            });
            this.geolocation.on('change', (evt) => {
                this.geolocation$.next(this.geolocation);
            });
        }
        else {
            this.geolocation.setTracking(true);
        }
    }
    stopGeolocation() {
        if (this.geolocation) {
            this.geolocation.setTracking(false);
        }
    }
    onOfflineToggle(offline) {
        this.offlineButtonToggle$.next(offline);
    }
}

const _c0$j = ["*"];
class MapBrowserComponent {
    constructor(activityService) {
        this.activityService = activityService;
        this.id = `igo-map-target-${new Date().getTime()}`;
    }
    get view() {
        return this._view;
    }
    set view(value) {
        this._view = value;
        if (this.map !== undefined) {
            this.map.updateView(value);
        }
    }
    get controls() {
        return this._controls;
    }
    set controls(value) {
        this._controls = value;
        if (this.map !== undefined) {
            this.map.updateControls(value);
        }
    }
    ngOnInit() {
        this.status$$ = this.map.status$.subscribe(status => this.handleStatusChange(status));
    }
    ngAfterViewInit() {
        this.map.setTarget(this.id);
    }
    ngOnDestroy() {
        this.map.setTarget(undefined);
        this.activityService.unregister(this.activityId);
        this.status$$.unsubscribe();
    }
    handleStatusChange(status) {
        if (status === SubjectStatus.Working && this.activityId === undefined) {
            this.activityId = this.activityService.register();
        }
        else if (status === SubjectStatus.Done && this.activityId !== undefined) {
            this.activityService.unregister(this.activityId);
            this.activityId = undefined;
        }
    }
}
MapBrowserComponent.ɵfac = function MapBrowserComponent_Factory(t) { return new (t || MapBrowserComponent)(i0.ɵɵdirectiveInject(i2$1.ActivityService)); };
MapBrowserComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MapBrowserComponent, selectors: [["igo-map-browser"]], inputs: { map: "map", view: "view" }, ngContentSelectors: _c0$j, decls: 2, vars: 1, consts: [[1, "igo-map-browser-target", 3, "id"]], template: function MapBrowserComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵelement(0, "div", 0);
        i0.ɵɵprojection(1);
    } if (rf & 2) {
        i0.ɵɵproperty("id", ctx.id);
    } }, styles: ["[_nghost-%COMP%]{position:relative;display:block}[_nghost-%COMP%], .igo-map-browser-target[_ngcontent-%COMP%]{width:100%;height:100%}[_nghost-%COMP%]     igo-zoom-button{position:absolute;bottom:calc(40px + 5px + 5px);right:5px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){[_nghost-%COMP%]     igo-zoom-button{display:none}}[_nghost-%COMP%]     igo-offline-button{position:absolute;bottom:15px;right:5px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){[_nghost-%COMP%]     igo-offline-button{bottom:5px}}[_nghost-%COMP%]     igo-geolocate-button{position:absolute;bottom:5px;right:5px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){[_nghost-%COMP%]     igo-geolocate-button{bottom:5px}}[_nghost-%COMP%]     igo-rotation-button{position:absolute;top:calc(40px + 5px + 5px);right:5px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){[_nghost-%COMP%]     igo-rotation-button{bottom:calc(40px + 5px + 5px)}}[_nghost-%COMP%]     igo-home-extent-button{position:absolute;bottom:calc((3 * 40px) + 5px + (2 * 5px));right:5px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){[_nghost-%COMP%]     igo-home-extent-button{bottom:5px;right:calc((2 * 40px) + (3 * 5px))}}[_nghost-%COMP%]     igo-user-button{position:absolute;bottom:5px;right:calc(5px + 50px)}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){[_nghost-%COMP%]     igo-user-button{right:calc((2 * 40px) + (2 * 5px))}}[_nghost-%COMP%]     igo-baselayers-switcher{position:absolute;bottom:5px;left:5px}[_nghost-%COMP%]     .ol-attribution{flex-flow:row;left:calc(40px + 5px + 5px);bottom:5px;text-align:left;padding:0;margin-right:90px;background-color:#fff0;width:calc(100% - 100px)}[_nghost-%COMP%]     .ol-attribution.ol-logo-only{height:inherit}[_nghost-%COMP%]     .ol-attribution.ol-collapsed{background:none}[_nghost-%COMP%]     .ol-attribution.ol-collapsed button{transform:none}[_nghost-%COMP%]     .ol-attribution button{transform:rotate(180deg);background-color:#fff;cursor:pointer;outline:none}[_nghost-%COMP%]     .ol-scale-line-inner{color:#000;border-color:#000;text-shadow:white -1px -1px 3px,white 1px -1px 3px,white -1px 1px 3px,white 1px 1px 4px;box-shadow:0 1px 0 1px #fff9}[_nghost-%COMP%]     .ol-scale-line{background-color:#fff0;bottom:4px;transform:translate(-50%);left:50%}[_nghost-%COMP%]     .ol-scale-bar{background-color:#fff0;bottom:4px;transform:translate(-50%);left:50%}[_nghost-%COMP%]     .ol-scale-text{text-shadow:white -1px -1px 3px,white 1px -1px 3px,white -1px 1px 3px,white 1px 1px 4px}[_nghost-%COMP%]     .ol-scale-step-text{text-shadow:white -1px -1px 3px,white 1px -1px 3px,white -1px 1px 3px,white 1px 1px 4px}[_nghost-%COMP%]     canvas{display:block}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MapBrowserComponent, [{
        type: Component,
        args: [{
                selector: 'igo-map-browser',
                templateUrl: './map-browser.component.html',
                styleUrls: ['./map-browser.component.scss']
            }]
    }], function () { return [{ type: i2$1.ActivityService }]; }, { map: [{
            type: Input
        }], view: [{
            type: Input
        }] }); })();

class MapOfflineDirective {
    constructor(component, networkService, messageService, languageService) {
        this.networkService = networkService;
        this.messageService = messageService;
        this.languageService = languageService;
        this.offlineButtonStatus = false;
        this.networkState = {
            connection: true
        };
        this.offlineButtonState = {
            connection: true
        };
        this.component = component;
    }
    get map() {
        return this.component.map;
    }
    ngAfterViewInit() {
        this.map.offlineButtonToggle$.subscribe((offlineButtonToggle) => {
            if (this.previousMessageId) {
                this.messageService.remove(this.previousMessageId);
            }
            this.offlineButtonStatus = offlineButtonToggle;
            const translate = this.languageService.translate;
            if (this.offlineButtonStatus && this.networkState.connection) {
                const message = translate.instant('igo.geo.network.offline.message');
                const title = translate.instant('igo.geo.network.offline.title');
                const messageObj = this.messageService.info(message, title);
                this.previousMessageId = messageObj.toastId;
                this.offlineButtonState.connection = false;
                this.changeLayer();
            }
            else if (!this.offlineButtonStatus && !this.networkState.connection) {
                const message = translate.instant('igo.geo.network.offline.message');
                const title = translate.instant('igo.geo.network.offline.title');
                const messageObj = this.messageService.info(message, title);
                this.previousMessageId = messageObj.toastId;
                this.offlineButtonState.connection = false;
                this.changeLayer();
            }
            else if (!this.offlineButtonStatus && this.networkState.connection) {
                let message;
                let title;
                const messageObs = translate.get('igo.geo.network.online.message');
                const titleObs = translate.get('igo.geo.network.online.title');
                messageObs.subscribe((message1) => {
                    message = message1;
                });
                titleObs.subscribe((title1) => {
                    title = title1;
                });
                if (message) {
                    const messageObj = this.messageService.info(message, title);
                    this.previousMessageId = messageObj.toastId;
                }
                this.offlineButtonState.connection = true;
                this.changeLayer();
            }
        });
        this.networkService.currentState().subscribe((state) => {
            this.networkState = state;
            if (!this.offlineButtonStatus) {
                this.changeLayer();
            }
        });
        this.map.layers$.subscribe((layers) => {
            this.changeLayer();
        });
    }
    changeLayer() {
        let sourceOptions;
        const layerList = this.map.layers$.value;
        layerList.forEach(layer => {
            if (layer.isIgoInternalLayer) {
                return;
            }
            if (layer.options.source instanceof MVTDataSource) {
                sourceOptions = layer.options.sourceOptions;
                layer.ol.getSource().refresh();
            }
            else if (layer.options.source instanceof XYZDataSource) {
                sourceOptions = layer.options.sourceOptions;
            }
            else if (layer.options.source instanceof ClusterDataSource) {
                sourceOptions = layer.options.sourceOptions;
            }
            else if (layer.options.source instanceof FeatureDataSource) {
                sourceOptions = layer.options.sourceOptions;
            }
            else {
                if (this.networkState.connection === false ||
                    this.offlineButtonState.connection === false) {
                    layer.ol.setMaxResolution(0);
                    return;
                }
                else if (this.networkState.connection === true ||
                    this.offlineButtonState.connection === true) {
                    layer.ol.setMaxResolution(Infinity);
                    return;
                }
            }
            if (sourceOptions) {
                if ((sourceOptions.pathOffline &&
                    this.networkState.connection === false) ||
                    (sourceOptions.pathOffline &&
                        this.offlineButtonState.connection === false)) {
                    if (sourceOptions.type === 'vector' ||
                        sourceOptions.type === 'cluster') {
                        return;
                    }
                    layer.ol.getSource().setUrl(sourceOptions.pathOffline);
                }
                else if ((sourceOptions.pathOffline &&
                    this.networkState.connection === false) ||
                    (sourceOptions.pathOffline &&
                        this.offlineButtonState.connection === true)) {
                    if (sourceOptions.type === 'vector' ||
                        sourceOptions.type === 'cluster') {
                        return;
                    }
                    layer.ol.getSource().setUrl(sourceOptions.url);
                }
                else {
                    if (this.networkState.connection === false ||
                        this.offlineButtonState.connection === false) {
                        layer.ol.setMaxResolution(0);
                    }
                    else if (this.networkState.connection === true ||
                        this.offlineButtonState.connection === true) {
                        layer.ol.setMaxResolution(Infinity);
                    }
                }
            }
            else {
                if (this.networkState.connection === false ||
                    this.offlineButtonState.connection === false) {
                    layer.ol.setMaxResolution(0);
                }
                else if (this.networkState.connection === true ||
                    this.offlineButtonState.connection === true) {
                    layer.ol.setMaxResolution(Infinity);
                }
            }
        });
    }
}
MapOfflineDirective.ɵfac = function MapOfflineDirective_Factory(t) { return new (t || MapOfflineDirective)(i0.ɵɵdirectiveInject(MapBrowserComponent), i0.ɵɵdirectiveInject(i2$1.NetworkService), i0.ɵɵdirectiveInject(i2$1.MessageService), i0.ɵɵdirectiveInject(i2$1.LanguageService)); };
MapOfflineDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: MapOfflineDirective, selectors: [["", "igoMapOffline", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MapOfflineDirective, [{
        type: Directive,
        args: [{
                selector: '[igoMapOffline]'
            }]
    }], function () { return [{ type: MapBrowserComponent }, { type: i2$1.NetworkService }, { type: i2$1.MessageService }, { type: i2$1.LanguageService }]; }, null); })();

/**
 * This directive return the pointer coordinate (on click or pointermove)
 * in [longitude, latitude], delayed by in input (pointerMoveDelay)
 * to avoid too many emitted values.
 */
class PointerPositionDirective {
    constructor(component, mediaService) {
        this.component = component;
        this.mediaService = mediaService;
        /**
         * Delay before emitting an event
         */
        this.pointerPositionDelay = 1000;
        /**
         * Event emitted when the pointer move, delayed by pointerMoveDelay
         */
        this.pointerPositionCoord = new EventEmitter();
    }
    /**
     * IGO map
     * @internal
     */
    get map() {
        return this.component.map;
    }
    get mapProjection() {
        return this.component.map.projection;
    }
    /**
     * Start listening to pointermove
     * @internal
     */
    ngOnInit() {
        this.listenToMapPointerMove();
        this.listenToMapClick();
    }
    /**
     * Stop listening to pointermove
     * @internal
     */
    ngOnDestroy() {
        this.unlistenToMapPointerMove();
        this.unlistenToMapClick();
    }
    /**
     * On map pointermove
     */
    listenToMapPointerMove() {
        this.pointerMoveListener = this.map.ol.on('pointermove', (event) => this.onPointerEvent(event, this.pointerPositionDelay));
    }
    /**
     * On map click
     */
    listenToMapClick() {
        this.mapClickListener = this.map.ol.on('singleclick', (event) => this.onPointerEvent(event, 0));
    }
    /**
     * Stop listening for map pointermove
     */
    unlistenToMapPointerMove() {
        unByKey(this.pointerMoveListener);
        this.pointerMoveListener = undefined;
    }
    /**
     * Stop listening for map clicks
     */
    unlistenToMapClick() {
        this.mapClickListener = undefined;
    }
    /**
     * emit delayed coordinate (longitude, latitude array) based on pointerMoveDelay or on click
     * @param event OL map browser pointer event
     */
    onPointerEvent(event, delay) {
        if (event.dragging || this.mediaService.isTouchScreen()) {
            return;
        }
        if (typeof this.lastTimeoutRequest !== 'undefined') { // cancel timeout when the mouse moves
            clearTimeout(this.lastTimeoutRequest);
        }
        const lonlat = transform(event.coordinate, this.mapProjection, 'EPSG:4326');
        this.lastTimeoutRequest = setTimeout(() => {
            this.pointerPositionCoord.emit(lonlat);
        }, delay);
    }
}
PointerPositionDirective.ɵfac = function PointerPositionDirective_Factory(t) { return new (t || PointerPositionDirective)(i0.ɵɵdirectiveInject(MapBrowserComponent, 2), i0.ɵɵdirectiveInject(i2$1.MediaService)); };
PointerPositionDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: PointerPositionDirective, selectors: [["", "igoPointerPosition", ""]], inputs: { pointerPositionDelay: "pointerPositionDelay" }, outputs: { pointerPositionCoord: "pointerPositionCoord" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PointerPositionDirective, [{
        type: Directive,
        args: [{
                selector: '[igoPointerPosition]'
            }]
    }], function () { return [{ type: MapBrowserComponent, decorators: [{
                type: Self
            }] }, { type: i2$1.MediaService }]; }, { pointerPositionDelay: [{
            type: Input
        }], pointerPositionCoord: [{
            type: Output
        }] }); })();

class ImageLayer extends Layer {
    constructor(options, messageService, languageService, authInterceptor) {
        super(options, messageService, authInterceptor);
        this.messageService = messageService;
        this.languageService = languageService;
        this.authInterceptor = authInterceptor;
        this.watcher = new ImageWatcher(this, this.messageService, this.languageService);
        this.status$ = this.watcher.status$;
        this.status$.subscribe(valStatus => {
            if (valStatus === 0) {
                this.olLoadingProblem = true;
            }
        });
    }
    createOlLayer() {
        const olOptions = Object.assign({}, this.options, {
            source: this.options.source.ol
        });
        const image = new olLayerImage(olOptions);
        if (this.authInterceptor) {
            image.getSource().setImageLoadFunction((tile, src) => {
                this.customLoader(tile, src, this.authInterceptor, this.messageService, this.languageService);
            });
        }
        return image;
    }
    setMap(map) {
        if (map === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe(() => { });
        }
        super.setMap(map);
    }
    customLoader(tile, src, interceptor, messageService, languageService) {
        const xhr = new XMLHttpRequest();
        const alteredUrlWithKeyAuth = interceptor.alterUrlWithKeyAuth(src);
        let url = src;
        if (alteredUrlWithKeyAuth) {
            url = alteredUrlWithKeyAuth;
        }
        xhr.open('GET', url);
        const intercepted = interceptor.interceptXhr(xhr, url);
        if (!intercepted) {
            xhr.abort();
            tile.getImage().src = url;
            return;
        }
        xhr.responseType = 'arraybuffer';
        xhr.onload = function () {
            const arrayBufferView = new Uint8Array(this.response);
            const responseString = new TextDecoder().decode(arrayBufferView);
            if (responseString.includes('ServiceExceptionReport')) {
                messageService.error(languageService.translate.instant('igo.geo.dataSource.optionsApiUnavailable'), languageService.translate.instant('igo.geo.dataSource.unavailableTitle'));
            }
            const blob = new Blob([arrayBufferView], { type: 'image/png' });
            const urlCreator = window.URL;
            const imageUrl = urlCreator.createObjectURL(blob);
            tile.getImage().src = imageUrl;
        };
        xhr.send();
    }
}

class TileLayer extends Layer {
    constructor(options, messageService, authInterceptor) {
        super(options, messageService);
        this.messageService = messageService;
        this.authInterceptor = authInterceptor;
        this.watcher = new TileWatcher(this);
        this.status$ = this.watcher.status$;
    }
    createOlLayer() {
        const olOptions = Object.assign({}, this.options, {
            source: this.options.source.ol
        });
        const tileLayer = new olLayerTile(olOptions);
        const tileSource = tileLayer.getSource();
        tileSource.setTileLoadFunction((tile, url) => {
            this.customLoader(tile, url, this.authInterceptor);
        });
        return tileLayer;
    }
    /**
     * Custom loader for tile layer.
     * @internal
     * @param tile the current tile
     * @param url the url string or function to retrieve the data
     */
    customLoader(tile, url, interceptor) {
        const alteredUrlWithKeyAuth = interceptor.alterUrlWithKeyAuth(url);
        let modifiedUrl = url;
        if (alteredUrlWithKeyAuth) {
            modifiedUrl = alteredUrlWithKeyAuth;
        }
        tile.getImage().src = modifiedUrl;
    }
    setMap(map) {
        if (map === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe(() => { });
        }
        super.setMap(map);
    }
}

class VectorTileLayer extends Layer {
    constructor(options, messageService, authInterceptor) {
        super(options, messageService, authInterceptor);
        this.messageService = messageService;
        this.authInterceptor = authInterceptor;
        this.watcher = new TileWatcher(this);
        this.status$ = this.watcher.status$;
    }
    createOlLayer() {
        const olOptions = Object.assign({}, this.options, {
            source: this.options.source.ol
        });
        const vectorTile = new olLayerVectorTile(olOptions);
        const vectorTileSource = vectorTile.getSource();
        vectorTileSource.setTileLoadFunction((tile, url) => {
            const loader = this.customLoader(url, tile.getFormat(), this.authInterceptor, tile.onLoad.bind(tile));
            if (loader) {
                tile.setLoader(loader);
            }
        });
        return vectorTile;
    }
    /**
     * Custom loader for vector tile layer. Modified from the loadFeaturesXhr function in ol\featureloader.js
     * @internal
     * @param url the url string or function to retrieve the data
     * @param format the format of the tile
     * @param interceptor the interceptor of the data
     * @param success On success event action to trigger
     * @param failure On failure event action to trigger TODO
     */
    customLoader(url, format, interceptor, success, failure) {
        return ((extent, resolution, projection) => {
            const xhr = new XMLHttpRequest();
            let modifiedUrl = url;
            if (typeof url !== 'function') {
                const alteredUrlWithKeyAuth = interceptor.alterUrlWithKeyAuth(url);
                if (alteredUrlWithKeyAuth) {
                    modifiedUrl = alteredUrlWithKeyAuth;
                }
            }
            else {
                modifiedUrl = url(extent, resolution, projection);
            }
            xhr.open('GET', modifiedUrl);
            if (interceptor) {
                interceptor.interceptXhr(xhr, modifiedUrl);
            }
            if (format.getType() === 'arraybuffer') {
                xhr.responseType = 'arraybuffer';
            }
            xhr.onload = (event) => {
                if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
                    const type = format.getType();
                    let source;
                    if (type === 'json' || type === 'text') {
                        source = xhr.responseText;
                    }
                    else if (type === 'xml') {
                        source = xhr.responseXML;
                        if (!source) {
                            source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
                        }
                    }
                    else if (type === 'arraybuffer') {
                        source = xhr.response;
                    }
                    if (source) {
                        success.call(this, format.readFeatures(source, {
                            extent,
                            featureProjection: projection
                        }), format.readProjection(source));
                    }
                    else {
                        // TODO
                        failure.call(this);
                    }
                }
                else {
                    // TODO
                    failure.call(this);
                }
            };
            xhr.onerror = () => {
                // TODO
                failure.call(this);
            };
            xhr.send();
        });
    }
    setMap(map) {
        if (map === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe(() => { });
        }
        super.setMap(map);
    }
}

/**
 * This directive makes the mouse coordinate trigger a reverse search on available search sources.
 * The search results are placed into a label, on a cross icon, representing the mouse coordinate.
 * By default, no search sources. Config in config file must be defined.
 * the layer level.
 */
class HoverFeatureDirective {
    constructor(component, mediaService, styleService) {
        this.component = component;
        this.mediaService = mediaService;
        this.styleService = styleService;
        this.pointerHoverFeatureStore = new EntityStore([]);
        this.selectionMVT = {};
        this.hoverFeatureId = 'hoverFeatureId';
        /**
         * The delay where the mouse must be motionless before trigger the reverse search
         */
        this.igoHoverFeatureDelay = 1000;
        /**
         * If the user has enabled or not the directive
         */
        this.igoHoverFeatureEnabled = false;
    }
    mouseout() {
        clearTimeout(this.lastTimeoutRequest);
        this.clearLayer();
    }
    /**
     * IGO map
     * @internal
     */
    get map() {
        return this.component.map;
    }
    get mapProjection() {
        return this.component.map.projection;
    }
    /**
     * Start listening to pointermove and reverse search results.
     * @internal
     */
    ngOnInit() {
        this.listenToMapPointerMove();
        this.subscribeToPointerStore();
        this.listenToMapClick();
        this.map.status$.pipe(take(1)).subscribe(() => {
            this.store = new FeatureStore([], { map: this.map });
            this.initStore();
        });
        // To handle context change without using the contextService.
        this.layers$$ = this.map.layers$.subscribe((layers) => {
            if (this.store && !layers.find(l => l.id === 'hoverFeatureId')) {
                this.initStore();
            }
        });
    }
    /**
     * Initialize the pointer position store
     * @internal
     */
    initStore() {
        const store = this.store;
        const layer = new VectorLayer({
            isIgoInternalLayer: true,
            id: 'hoverFeatureId',
            title: 'hoverFeature',
            zIndex: 900,
            source: new FeatureDataSource(),
            showInLayerList: false,
            exportable: false,
            browsable: false,
            style: hoverFeatureMarker
        });
        tryBindStoreLayer(store, layer);
        this.selectionLayer = new olLayerVectorTile({
            map: this.map.ol,
            zIndex: 901,
            renderMode: "vector",
            declutter: true,
            source: new olSourceVectorTile({}),
            style: (feature) => {
                if (this.mvtStyleOptions && feature.getId() in this.selectionMVT) {
                    return this.createHoverStyle(feature, this.mvtStyleOptions);
                }
            }
        });
    }
    createHoverStyle(feature, hoverStyle) {
        var _a;
        const localHoverStyle = Object.assign({}, hoverStyle);
        let label = hoverStyle.label ? hoverStyle.label.attribute : undefined;
        let hasLabelStyle = ((_a = hoverStyle.label) === null || _a === void 0 ? void 0 : _a.style) ? true : false;
        if (!feature.get('_isLabel')) {
            localHoverStyle.label = undefined;
            hasLabelStyle = false;
            label = undefined;
        }
        else {
            // clear the style for label....
            const size = localHoverStyle.data ? localHoverStyle.data.length : 0;
            const radius = [];
            const stroke = [];
            const width = [];
            const fill = [];
            for (let i = 0; i < size; i++) {
                radius.push(0);
                stroke.push('rgba(255, 255, 255, 0)');
                width.push(0);
                fill.push('rgba(255, 255, 255, 0)');
            }
            localHoverStyle.radius = radius;
            localHoverStyle.stroke = stroke;
            localHoverStyle.width = width;
            localHoverStyle.fill = fill;
        }
        if (!hasLabelStyle && label) {
            localHoverStyle.label.style =
                {
                    textAlign: 'left',
                    textBaseline: 'top',
                    font: '12px Calibri,sans-serif',
                    fill: { color: '#000' },
                    backgroundFill: { color: 'rgba(255, 255, 255, 0.5)' },
                    backgroundStroke: { color: 'rgba(200, 200, 200, 0.75)', width: 2 },
                    stroke: { color: '#fff', width: 3 },
                    overflow: true,
                    offsetX: 10,
                    offsetY: 20,
                    padding: [2.5, 2.5, 2.5, 2.5]
                };
        }
        return this.styleService.createStyleByAttribute(feature, localHoverStyle);
    }
    /**
     * Stop listening to pointermove and reverse search results.
     * @internal
     */
    ngOnDestroy() {
        this.unlistenToMapPointerMove();
        this.unsubscribeToPointerStore();
        this.unlistenToMapSingleClick();
        this.layers$$.unsubscribe();
    }
    /**
     * Subscribe to pointermove result store
     * @internal
     */
    subscribeToPointerStore() {
        this.store$$ = this.pointerHoverFeatureStore.entities$.subscribe(resultsUnderPointerPosition => {
            this.entitiesToPointerOverlay(resultsUnderPointerPosition);
        });
    }
    /**
     * convert store entities to a pointer position overlay with label summary on.
     * @param event OL map browser pointer event
     */
    entitiesToPointerOverlay(resultsUnderPointerPosition) {
        this.addFeatureOverlay(resultsUnderPointerPosition);
    }
    /**
     * On map pointermove
     */
    listenToMapPointerMove() {
        this.pointerMoveListener = this.map.ol.on('pointermove', (event) => this.onMapEvent(event));
    }
    /**
     * On map singleclick
     */
    listenToMapClick() {
        this.singleClickMapListener = this.map.ol.on('singleclick', (event) => this.onMapSingleClickEvent(event));
    }
    /**
     * Unsubscribe to pointer store.
     * @internal
     */
    unsubscribeToPointerStore() {
        this.store$$.unsubscribe();
    }
    /**
     * Stop listening for map pointermove
     * @internal
     */
    unlistenToMapPointerMove() {
        unByKey(this.pointerMoveListener);
        this.pointerMoveListener = undefined;
    }
    /**
     * Stop listening for map singleclick
     * @internal
     */
    unlistenToMapSingleClick() {
        unByKey(this.singleClickMapListener);
        this.singleClickMapListener = undefined;
    }
    /**
     * Trigger clear layer on singleclick.
     * @param event OL map browser singleclick event
     */
    onMapSingleClickEvent(event) {
        this.clearLayer();
    }
    /**
     * Trigger hover when the mouse is motionless during the defined delay (pointerMoveDelay).
     * @param event OL map browser pointer event
     */
    onMapEvent(event) {
        if (event.dragging || !this.igoHoverFeatureEnabled ||
            this.mediaService.isTouchScreen()) {
            this.clearLayer();
            return;
        }
        if (typeof this.lastTimeoutRequest !== 'undefined') { // cancel timeout when the mouse moves
            clearTimeout(this.lastTimeoutRequest);
        }
        this.clearLayer();
        let maximumZindex = -Infinity;
        let topMostOlLayer;
        const pixel = this.map.ol.getPixelFromCoordinate(event.coordinate);
        this.lastTimeoutRequest = setTimeout(() => {
            // retrieve the topmost layer with feature to only apply the hover on this layer.
            this.map.ol.forEachFeatureAtPixel(pixel, (mapFeature, layerOL) => {
                if (!layerOL) {
                    return;
                }
                const igoLayer = this.map.getLayerByOlUId(layerOL.ol_uid);
                if (!this.canProcessHover(igoLayer)) {
                    return;
                }
                if (igoLayer.zIndex <= maximumZindex) {
                    return;
                }
                maximumZindex = igoLayer.zIndex;
                topMostOlLayer = layerOL;
            }, {
                hitTolerance: 10, layerFilter: olLayer => olLayer instanceof OlVectorLayer || olLayer instanceof olLayerVectorTile
            });
            if (!topMostOlLayer) {
                return;
            }
            this.clearLayer();
            this.map.ol.forEachFeatureAtPixel(pixel, (mapFeature, layerOL) => {
                var _a, _b, _c;
                if (mapFeature.get('hoverSummary') === undefined) {
                    let igoLayer;
                    if (layerOL instanceof OlVectorLayer) {
                        igoLayer = this.map.getLayerByOlUId(layerOL.ol_uid);
                        if (!this.canProcessHover(igoLayer)) {
                            return;
                        }
                        let localOlFeature = this.handleRenderFeature(mapFeature);
                        this.setLayerStyleFromOptions(igoLayer, localOlFeature);
                        const featuresToLoad = [localOlFeature];
                        localOlFeature.set("_isLabel", false);
                        const myLabelOlFeature = new OlFeature();
                        myLabelOlFeature.setProperties(localOlFeature.getProperties());
                        const labelGeom = localOlFeature.getGeometry().getType() === 'Point' ? localOlFeature.getGeometry() : new olgeom.Point(event.coordinate);
                        myLabelOlFeature.setGeometry(labelGeom);
                        myLabelOlFeature.setId(localOlFeature.getId());
                        myLabelOlFeature.set("_isLabel", true);
                        this.setLayerStyleFromOptions(igoLayer, myLabelOlFeature);
                        featuresToLoad.push(myLabelOlFeature);
                        this.pointerHoverFeatureStore.load(featuresToLoad);
                        return true;
                    }
                    if (layerOL instanceof olLayerVectorTile) {
                        igoLayer = this.map.getLayerByOlUId(layerOL.ol_uid);
                        if (!this.canProcessHover(igoLayer)) {
                            return;
                        }
                        if ((_b = (_a = igoLayer === null || igoLayer === void 0 ? void 0 : igoLayer.options) === null || _a === void 0 ? void 0 : _a.styleByAttribute) === null || _b === void 0 ? void 0 : _b.hoverStyle) {
                            this.mvtStyleOptions = igoLayer.options.styleByAttribute.hoverStyle;
                        }
                        else if ((_c = igoLayer === null || igoLayer === void 0 ? void 0 : igoLayer.options) === null || _c === void 0 ? void 0 : _c.hoverStyle) {
                            this.mvtStyleOptions = igoLayer.options.hoverStyle;
                        }
                        this.selectionLayer.setSource(layerOL.getSource());
                        layerOL.getFeatures(event.pixel).then((mvtFeatures) => {
                            if (!mvtFeatures.length) {
                                this.selectionMVT = {};
                                this.selectionLayer.changed();
                                this.clearLayer();
                                return;
                            }
                            const feature = mvtFeatures[0];
                            if (!feature) {
                                this.clearLayer();
                                return;
                            }
                            let localOlFeature = this.handleRenderFeature(feature);
                            localOlFeature.set("_isLabel", false);
                            const myLabelOlFeature = new OlFeature();
                            myLabelOlFeature.setProperties(localOlFeature.getProperties());
                            const labelGeom = localOlFeature.getGeometry().getType() === 'Point' ? localOlFeature.getGeometry() : new olgeom.Point(event.coordinate);
                            myLabelOlFeature.setGeometry(labelGeom);
                            myLabelOlFeature.setId(localOlFeature.getId());
                            myLabelOlFeature.set("_isLabel", true);
                            this.setLayerStyleFromOptions(igoLayer, myLabelOlFeature);
                            this.pointerHoverFeatureStore.load([myLabelOlFeature]);
                            this.selectionMVT[feature.getId()] = localOlFeature;
                            this.selectionLayer.changed();
                        });
                    }
                }
                return true;
            }, {
                hitTolerance: 10, layerFilter: olLayer => olLayer === topMostOlLayer
            });
        }, this.igoHoverFeatureDelay);
    }
    canProcessHover(igoLayer) {
        if (!igoLayer) {
            return false;
        }
        if (!igoLayer.visible) {
            return false;
        }
        if (!igoLayer.options) {
            return false;
        }
        if (!igoLayer.options.styleByAttribute && !igoLayer.options.hoverStyle) {
            return false;
        }
        if ((igoLayer.options.styleByAttribute && !igoLayer.options.styleByAttribute.hoverStyle) &&
            !igoLayer.options.hoverStyle) {
            return false;
        }
        return true;
    }
    handleRenderFeature(feature) {
        let localFeature;
        if (feature instanceof RenderFeature) {
            localFeature = new OlFeature({
                geometry: this.getGeometry(feature)
            });
            localFeature.setId(feature.getId());
        }
        else if (feature instanceof OlFeature) {
            localFeature = feature;
        }
        return localFeature;
    }
    /**
     * Add a feature to the pointer store
     * @param text string
     */
    addFeatureOverlay(hoverEntity) {
        if (hoverEntity.length > 0) {
            const result = hoverEntity[0];
            this.clearLayer();
            const feature = new OlFeature({
                geometry: result.getGeometry(),
                meta: { id: this.hoverFeatureId },
                hoverSummary: this.getHoverSummary(result.getProperties())
            });
            this.store.setLayerOlFeatures([feature], FeatureMotion.None);
        }
    }
    setLayerStyleFromOptions(igoLayer, feature) {
        var _a, _b, _c;
        if ((_b = (_a = igoLayer === null || igoLayer === void 0 ? void 0 : igoLayer.options) === null || _a === void 0 ? void 0 : _a.styleByAttribute) === null || _b === void 0 ? void 0 : _b.hoverStyle) {
            this.store.layer.ol.setStyle(this.createHoverStyle(feature, igoLayer.options.styleByAttribute.hoverStyle));
            return;
        }
        if ((_c = igoLayer === null || igoLayer === void 0 ? void 0 : igoLayer.options) === null || _c === void 0 ? void 0 : _c.hoverStyle) {
            this.store.layer.ol.setStyle(this.createHoverStyle(feature, igoLayer.options.hoverStyle));
        }
    }
    getHoverSummary(properties) {
        let summary = '';
        for (const [key, value] of Object.entries(properties)) {
            if (!key.startsWith('_') && key !== 'geometry') {
                summary += `${key}: ${value}` + '\n';
            }
        }
        return summary.length >= 2 ? summary.slice(0, -2) : summary;
    }
    getGeometry(feature) {
        let geom;
        if (!feature.getOrientedFlatCoordinates) {
            geom = feature.getGeometry();
        }
        else {
            const coords = feature.getOrientedFlatCoordinates();
            const flatCoords = [];
            coords.forEach((c, idx) => {
                if (idx % 2 === 0) {
                    flatCoords.push([parseFloat(coords[idx]), parseFloat(coords[idx + 1])]);
                }
            });
            // TODO: test MultiX
            switch (feature.getType()) {
                case 'Point':
                    geom = new olgeom.Point(flatCoords);
                    break;
                case 'Polygon':
                    geom = new olgeom.Polygon([flatCoords]);
                    break;
                case 'LineString':
                    geom = new olgeom.LineString([flatCoords]);
                    break;
            }
        }
        return geom;
    }
    /**
     * Clear the pointer store features
     */
    clearLayer() {
        this.selectionMVT = {};
        if (this.selectionLayer) {
            this.selectionLayer.changed();
        }
        if (this.store) {
            this.store.clearLayer();
        }
    }
}
HoverFeatureDirective.ɵfac = function HoverFeatureDirective_Factory(t) { return new (t || HoverFeatureDirective)(i0.ɵɵdirectiveInject(MapBrowserComponent, 2), i0.ɵɵdirectiveInject(i2$1.MediaService), i0.ɵɵdirectiveInject(StyleService)); };
HoverFeatureDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: HoverFeatureDirective, selectors: [["", "igoHoverFeature", ""]], hostBindings: function HoverFeatureDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("mouseout", function HoverFeatureDirective_mouseout_HostBindingHandler() { return ctx.mouseout(); });
    } }, inputs: { igoHoverFeatureDelay: "igoHoverFeatureDelay", igoHoverFeatureEnabled: "igoHoverFeatureEnabled" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(HoverFeatureDirective, [{
        type: Directive,
        args: [{
                selector: '[igoHoverFeature]'
            }]
    }], function () { return [{ type: MapBrowserComponent, decorators: [{
                type: Self
            }] }, { type: i2$1.MediaService }, { type: StyleService }]; }, { igoHoverFeatureDelay: [{
            type: Input
        }], igoHoverFeatureEnabled: [{
            type: Input
        }], mouseout: [{
            type: HostListener,
            args: ['mouseout']
        }] }); })();
/**
 * Create a default style for the pointer position and it's label summary.
 * @param feature OlFeature
 * @returns OL style function
 */
function hoverFeatureMarker(feature, resolution) {
    const olStyleText = new olstyle.Style({
        text: new olstyle.Text({
            text: feature.get('hoverSummary'),
            textAlign: 'left',
            textBaseline: 'top',
            font: '12px Calibri,sans-serif',
            fill: new olstyle.Fill({ color: '#000' }),
            backgroundFill: new olstyle.Fill({ color: 'rgba(255, 255, 255, 0.5)' }),
            backgroundStroke: new olstyle.Stroke({ color: 'rgba(200, 200, 200, 0.75)', width: 2 }),
            stroke: new olstyle.Stroke({ color: '#fff', width: 3 }),
            overflow: true,
            offsetX: 10,
            offsetY: 20,
            padding: [2.5, 2.5, 2.5, 2.5]
        })
    });
    const olStyle = [olStyleText];
    switch (feature.getGeometry().getType()) {
        case 'Point':
            olStyle.push(new olstyle.Style({
                image: new olstyle.Circle({
                    radius: 10,
                    stroke: new olstyle.Stroke({
                        color: 'blue',
                        width: 3
                    })
                })
            }));
            break;
        default:
            olStyle.push(new olstyle.Style({
                stroke: new olstyle.Stroke({
                    color: 'white',
                    width: 5
                })
            }));
            olStyle.push(new olstyle.Style({
                stroke: new olstyle.Stroke({
                    color: 'blue',
                    width: 3
                })
            }));
    }
    return olStyle;
}

/**
 * Return a number of zone MTM for a longitude for province of Quebec only
 * @param lon number
 * @returns zone
 */
function zoneMtm(lon) {
    let lonMin = -54;
    const lonMax = -81;
    if (lon < lonMax || lon > lonMin) {
        return 0;
    }
    else {
        const deltaLon = 3;
        let zone = 2;
        while (Math.abs(lon - lonMin) > deltaLon) {
            lonMin = lonMin - deltaLon;
            zone++;
        }
        return zone;
    }
}
/**
 * Return a number of zone UTM for a longitude
 * @param lon number
 * @returns zone
 */
function zoneUtm(lon) {
    let lonMin = -180;
    const lonMax = 180;
    const deltaLon = 6;
    let zone = 1;
    while (Math.abs(lon - lonMin) > deltaLon) {
        lonMin = lonMin + deltaLon;
        zone++;
    }
    return zone;
}
/**
 * Compute the contraints of projections
 * @param projectionsLimitations: ProjectionsLimitationsOptions
 * @returns projectionsContraints: ProjectionsLimitationsOptions
 */
function computeProjectionsConstraints(projectionsLimitations) {
    const mtmZone = projectionsLimitations.mtmZone;
    const utmZone = projectionsLimitations.utmZone;
    const projectionsConstraints = {
        projFromConfig: projectionsLimitations.projFromConfig === false ? false : true,
        nad83: projectionsLimitations.nad83 === false ? false : true,
        wgs84: projectionsLimitations.wgs84 === false ? false : true,
        webMercator: projectionsLimitations.webMercator === false ? false : true,
        utm: projectionsLimitations.utm === false ? false : true,
        mtm: projectionsLimitations.mtm === false ? false : true,
        utmZone: {
            minZone: utmZone && utmZone.minZone ? utmZone.minZone : 17,
            maxZone: utmZone && utmZone.maxZone ? utmZone.maxZone : 21,
        },
        mtmZone: {
            minZone: mtmZone && mtmZone.minZone ? mtmZone.minZone : 2,
            maxZone: mtmZone && mtmZone.maxZone ? mtmZone.maxZone : 10,
        }
    };
    return projectionsConstraints;
}

const _c0$i = function (a0) { return { zoom: a0 }; };
class ZoomButtonComponent {
    constructor() { }
    get zoom() { return this.map.viewController.getZoom(); }
    get minZoom() { return this.map.viewController.olView.getMinZoom() || 1; }
    get maxZoom() { return this.map.viewController.olView.getMaxZoom(); }
}
ZoomButtonComponent.ɵfac = function ZoomButtonComponent_Factory(t) { return new (t || ZoomButtonComponent)(); };
ZoomButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ZoomButtonComponent, selectors: [["igo-zoom-button"]], inputs: { map: "map", color: "color" }, decls: 7, vars: 16, consts: [[1, "igo-zoom-button-container"], ["mat-icon-button", "", "matTooltipPosition", "left", 3, "matTooltip", "color", "disabled", "click"], ["svgIcon", "plus"], ["svgIcon", "minus"]], template: function ZoomButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelementStart(1, "button", 1);
        i0.ɵɵlistener("click", function ZoomButtonComponent_Template_button_click_1_listener() { return ctx.map.viewController.zoomIn(); });
        i0.ɵɵpipe(2, "translate");
        i0.ɵɵelement(3, "mat-icon", 2);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(4, "button", 1);
        i0.ɵɵlistener("click", function ZoomButtonComponent_Template_button_click_4_listener() { return ctx.map.viewController.zoomOut(); });
        i0.ɵɵpipe(5, "translate");
        i0.ɵɵelement(6, "mat-icon", 3);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind2(2, 6, "igo.geo.mapButtons.zoomIn", i0.ɵɵpureFunction1(12, _c0$i, ctx.zoom + 1)))("color", ctx.color)("disabled", ctx.zoom >= ctx.maxZoom);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind2(5, 9, "igo.geo.mapButtons.zoomOut", i0.ɵɵpureFunction1(14, _c0$i, ctx.zoom - 1)))("color", ctx.color)("disabled", ctx.zoom <= ctx.minZoom);
    } }, directives: [i2.MatButton, i3.MatTooltip, i4.MatIcon], pipes: [i7.TranslatePipe], styles: [".igo-zoom-button-container[_ngcontent-%COMP%]{width:40px}.igo-zoom-button-container[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{background-color:#fff}.igo-zoom-button-container[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover{background-color:#efefef}.igo-zoom-button-container[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:first-child{margin-bottom:2px}button[_ngcontent-%COMP%], [_nghost-%COMP%]     button .mat-button-ripple-round{border-radius:0}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ZoomButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-zoom-button',
                templateUrl: './zoom-button.component.html',
                styleUrls: ['./zoom-button.component.scss']
            }]
    }], function () { return []; }, { map: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

class MenuButtonComponent {
    constructor(configService) {
        this.configService = configService;
        this.openSidenav = new EventEmitter();
        this.menuButtonReverseColor = false;
        if (typeof this.configService.getConfig('menuButtonReverseColor') !==
            'undefined') {
            this.menuButtonReverseColor = this.configService.getConfig('menuButtonReverseColor');
        }
    }
    get sidenavOpened() {
        return this._sidenavOpenend;
    }
    set sidenavOpened(value) {
        this._sidenavOpenend = value;
        this.getClassMenuButton();
    }
    getClassMenuButton() {
        if (this.sidenavOpened) {
            this.menuButtonClass = {
                'menu-button': this.menuButtonReverseColor === false,
                'menu-button-reverse-color': this.menuButtonReverseColor === true
            };
        }
        else {
            this.menuButtonClass = {
                'menu-button': this.menuButtonReverseColor === false,
                'menu-button-reverse-color-close': this.menuButtonReverseColor === true
            };
        }
    }
    onToggleSidenavClick() {
        this.openSidenav.emit();
    }
}
MenuButtonComponent.ɵfac = function MenuButtonComponent_Factory(t) { return new (t || MenuButtonComponent)(i0.ɵɵdirectiveInject(i2$1.ConfigService)); };
MenuButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MenuButtonComponent, selectors: [["igo-menu-button"]], inputs: { sidenavOpened: "sidenavOpened" }, outputs: { openSidenav: "openSidenav" }, decls: 3, vars: 4, consts: [["mat-icon-button", "", "id", "menu-button", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "ngClass", "matTooltip", "click"], ["svgIcon", "menu"]], template: function MenuButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "button", 0);
        i0.ɵɵlistener("click", function MenuButtonComponent_Template_button_click_0_listener() { return ctx.onToggleSidenavClick(); });
        i0.ɵɵpipe(1, "translate");
        i0.ɵɵelement(2, "mat-icon", 1);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("ngClass", ctx.menuButtonClass)("matTooltip", i0.ɵɵpipeBind1(1, 2, ctx.sidenavOpened ? "menu.close" : "menu.open"));
    } }, directives: [i2.MatButton, i1$1.NgClass, i3.MatTooltip, i4.MatIcon], pipes: [i7.TranslatePipe], styles: ["#menu-button[_ngcontent-%COMP%]{background-color:#fff;border-radius:0;left:5px;top:5px}#menu-button.menu-button-reverse-color[_ngcontent-%COMP%]{height:40px;border-radius:0;height:45px;width:48px;left:0px;top:3px}#menu-button.menu-button-reverse-color-close[_ngcontent-%COMP%]{border-radius:0;left:5px;top:5px}mat-icon.disabled[_ngcontent-%COMP%]{color:#00000061}#menu-button[_ngcontent-%COMP%]     div.mat-button-ripple-round{border-radius:0}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MenuButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-menu-button',
                templateUrl: './menu-button.component.html',
                styleUrls: ['./menu-button.component.scss']
            }]
    }], function () { return [{ type: i2$1.ConfigService }]; }, { sidenavOpened: [{
            type: Input
        }], openSidenav: [{
            type: Output
        }] }); })();

class GeolocateButtonComponent {
    constructor() { }
    get map() {
        return this._map;
    }
    set map(value) {
        this._map = value;
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
}
GeolocateButtonComponent.ɵfac = function GeolocateButtonComponent_Factory(t) { return new (t || GeolocateButtonComponent)(); };
GeolocateButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: GeolocateButtonComponent, selectors: [["igo-geolocate-button"]], inputs: { map: "map", color: "color" }, decls: 4, vars: 4, consts: [[1, "igo-geolocate-button-container"], ["mat-icon-button", "", "matTooltipPosition", "left", 3, "matTooltip", "color", "click"], ["svgIcon", "crosshairs-gps"]], template: function GeolocateButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelementStart(1, "button", 1);
        i0.ɵɵlistener("click", function GeolocateButtonComponent_Template_button_click_1_listener() { return ctx.map.geolocate(); });
        i0.ɵɵpipe(2, "translate");
        i0.ɵɵelement(3, "mat-icon", 2);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(2, 2, "igo.geo.mapButtons.geolocate"))("color", ctx.color);
    } }, directives: [i2.MatButton, i3.MatTooltip, i4.MatIcon], pipes: [i7.TranslatePipe], styles: [".igo-geolocate-button-container[_ngcontent-%COMP%]{width:40px;background-color:#fff}.igo-geolocate-button-container[_ngcontent-%COMP%]:hover{background-color:#efefef}button[_ngcontent-%COMP%], [_nghost-%COMP%]     button .mat-button-ripple-round{border-radius:0}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(GeolocateButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-geolocate-button',
                templateUrl: './geolocate-button.component.html',
                styleUrls: ['./geolocate-button.component.scss']
            }]
    }], function () { return []; }, { map: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

/*
Button to center the map to the home extent
*/
class HomeExtentButtonComponent {
    constructor(configService) {
        this.configService = configService;
        this.computeHomeExtent();
    }
    computeHomeExtent() {
        this.homeExtentButtonExtent = this.extentOverride || this.configService.getConfig('homeExtentButton.homeExtButtonExtent');
        this.homeExtentButtonCenter = this.centerOverride || this.configService.getConfig('homeExtentButton.homeExtButtonCenter');
        this.homeExtentButtonZoom = this.zoomOverride || this.configService.getConfig('homeExtentButton.homeExtButtonZoom');
        // priority over extent if these 2 properties are defined;
        if (this.centerOverride && this.zoomOverride) {
            this.homeExtentButtonExtent = undefined;
        }
    }
    onToggleClick() {
        this.computeHomeExtent();
        if (this.homeExtentButtonExtent) {
            this.map.viewController.zoomToExtent(this.homeExtentButtonExtent);
        }
        else if (this.homeExtentButtonCenter && this.homeExtentButtonZoom) {
            const center = olproj.fromLonLat(this.homeExtentButtonCenter, this.map.viewController.olView.getProjection().getCode());
            this.map.viewController.olView.setCenter(center);
            this.map.viewController.zoomTo(this.homeExtentButtonZoom);
        }
    }
}
HomeExtentButtonComponent.ɵfac = function HomeExtentButtonComponent_Factory(t) { return new (t || HomeExtentButtonComponent)(i0.ɵɵdirectiveInject(i2$1.ConfigService)); };
HomeExtentButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: HomeExtentButtonComponent, selectors: [["igo-home-extent-button"]], inputs: { map: "map", color: "color", extentOverride: "extentOverride", centerOverride: "centerOverride", zoomOverride: "zoomOverride" }, decls: 4, vars: 4, consts: [[1, "igo-home-extent-button-container"], ["mat-icon-button", "", "matTooltipPosition", "left", 3, "matTooltip", "color", "click"], ["svgIcon", "home-map-marker"]], template: function HomeExtentButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelementStart(1, "button", 1);
        i0.ɵɵlistener("click", function HomeExtentButtonComponent_Template_button_click_1_listener() { return ctx.onToggleClick(); });
        i0.ɵɵpipe(2, "translate");
        i0.ɵɵelement(3, "mat-icon", 2);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(2, 2, "igo.geo.mapButtons.home-extent"))("color", ctx.color);
    } }, directives: [i2.MatButton, i3.MatTooltip, i4.MatIcon], pipes: [i7.TranslatePipe], styles: ["@charset \"UTF-8\";.igo-home-extent-button-container[_ngcontent-%COMP%]{width:40px;background-color:#fff}\\a0[_ngcontent-%COMP%]   .igo-home-extent-button-container[_ngcontent-%COMP%]:hover{background-color:#efefef}button[_ngcontent-%COMP%], [_nghost-%COMP%]     button .mat-button-ripple-round{border-radius:0}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(HomeExtentButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-home-extent-button',
                templateUrl: './home-extent-button.component.html',
                styleUrls: ['./home-extent-button.component.scss'],
            }]
    }], function () { return [{ type: i2$1.ConfigService }]; }, { map: [{
            type: Input
        }], color: [{
            type: Input
        }], extentOverride: [{
            type: Input
        }], centerOverride: [{
            type: Input
        }], zoomOverride: [{
            type: Input
        }] }); })();

const _c0$h = function (a0) { return [a0]; };
function OfflineButtonComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 1);
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵelementStart(2, "button", 2);
    i0.ɵɵlistener("click", function OfflineButtonComponent_div_0_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r2); const ctx_r1 = i0.ɵɵnextContext(); return ctx_r1.onToggle(); })("click", function OfflineButtonComponent_div_0_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r2); const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.map.onOfflineToggle(ctx_r3.check); });
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵelement(5, "mat-icon", 3);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTooltip", ctx_r0.checked ? i0.ɵɵpipeBind1(3, 3, "igo.geo.mapButtons.online") : i0.ɵɵpipeBind1(4, 5, "igo.geo.mapButtons.offline"))("ngClass", i0.ɵɵpureFunction1(7, _c0$h, ctx_r0.btnStyle))("color", ctx_r0.checked ? ctx_r0.color : i0.ɵɵpureFunction1(9, _c0$h, ctx_r0.colorOff));
} }
class OfflineButtonComponent {
    constructor(config) {
        this.config = config;
        this.btnStyle = 'baseStyle';
        this.colorOff = 'rgb(255,255,255)';
        this.change = new EventEmitter();
        this.check = false;
        this.visible = false;
        this.visible = this.config.getConfig('offlineButton') ? true : false;
    }
    get map() {
        return this._map;
    }
    set map(value) {
        this._map = value;
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    get checked() {
        return this.check;
    }
    onToggle() {
        this.check = !this.check;
        if (this.check) {
            this.btnStyle = 'toggleStyle';
        }
        else {
            this.btnStyle = 'baseStyle';
        }
    }
}
OfflineButtonComponent.ɵfac = function OfflineButtonComponent_Factory(t) { return new (t || OfflineButtonComponent)(i0.ɵɵdirectiveInject(i2$1.ConfigService)); };
OfflineButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OfflineButtonComponent, selectors: [["igo-offline-button"]], inputs: { map: "map", color: "color", check: "check" }, outputs: { change: "change" }, decls: 1, vars: 1, consts: [["class", "igo-user-button-container", 4, "ngIf"], [1, "igo-user-button-container"], ["mat-icon-button", "", "matTooltipPosition", "left", 3, "matTooltip", "ngClass", "color", "click"], ["svgIcon", "wifi-strength-off"]], template: function OfflineButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, OfflineButtonComponent_div_0_Template, 6, 11, "div", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.visible);
    } }, directives: [i1$1.NgIf, i2.MatButton, i3.MatTooltip, i1$1.NgClass, i4.MatIcon], pipes: [i7.TranslatePipe], styles: [".baseStyle[_ngcontent-%COMP%]{width:40px;background-color:#fff}.baseStyle[_ngcontent-%COMP%]:hover{background-color:#efefef}.toggleStyle[_ngcontent-%COMP%]{width:40px;background-color:#b9b9b9}button[_ngcontent-%COMP%], [_nghost-%COMP%]     button .mat-button-ripple-round{border-radius:0}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OfflineButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-offline-button',
                templateUrl: './offline-button.component.html',
                styleUrls: ['./offline-button.component.scss']
            }]
    }], function () { return [{ type: i2$1.ConfigService }]; }, { change: [{
            type: Output
        }], map: [{
            type: Input
        }], color: [{
            type: Input
        }], check: [{
            type: Input
        }] }); })();

function baseLayersSwitcherSlideInOut() {
    return trigger('baseLayerSwitcherState', [
        state('collapseIcon', style({
            height: '40px',
            width: '40px',
            overflow: 'hidden'
        })),
        state('collapseMap', style({
            height: '85px',
            overflow: 'hidden'
        })),
        state('expand', style({
            overflow: 'hidden'
        })),
        transition('collapse => expand', animate('200ms')),
        transition('expand => collapse', animate('200ms'))
    ]);
}

function BaseLayersSwitcherComponent_div_0_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 6);
    i0.ɵɵelementStart(1, "button", 7);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelement(3, "mat-icon", 8);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(2, 1, "igo.geo.mapButtons.baselayerSwitcher"));
} }
function BaseLayersSwitcherComponent_div_0_igo_mini_basemap_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-mini-basemap", 9);
    i0.ɵɵpipe(1, "translate");
} if (rf & 2) {
    const baseLayer_r3 = ctx.$implicit;
    const i_r4 = ctx.index;
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("map", ctx_r2.map)("baseLayer", baseLayer_r3)("title", ctx_r2.baseLayers.length > 2 && !ctx_r2.expand ? i0.ɵɵpipeBind1(1, 5, "igo.geo.baselayersSwitcher.title") : baseLayer_r3.title)("display", ctx_r2.expand || i_r4 === 0 && !ctx_r2.useStaticIcon)("disabled", !ctx_r2.expand && ctx_r2.baseLayers.length > 1);
} }
const _c0$g = function (a0) { return { "container-expand": a0 }; };
function BaseLayersSwitcherComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r6 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 1);
    i0.ɵɵlistener("@baseLayerSwitcherState.start", function BaseLayersSwitcherComponent_div_0_Template_div_animation_baseLayerSwitcherState_start_0_listener() { i0.ɵɵrestoreView(_r6); const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.showButton = false; })("@baseLayerSwitcherState.done", function BaseLayersSwitcherComponent_div_0_Template_div_animation_baseLayerSwitcherState_done_0_listener() { i0.ɵɵrestoreView(_r6); const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.showButton = true; })("click", function BaseLayersSwitcherComponent_div_0_Template_div_click_0_listener() { i0.ɵɵrestoreView(_r6); const ctx_r8 = i0.ɵɵnextContext(); return ctx_r8.collapseOrExpand(); });
    i0.ɵɵtemplate(1, BaseLayersSwitcherComponent_div_0_div_1_Template, 4, 3, "div", 2);
    i0.ɵɵtemplate(2, BaseLayersSwitcherComponent_div_0_igo_mini_basemap_2_Template, 2, 7, "igo-mini-basemap", 3);
    i0.ɵɵelementStart(3, "div", 4);
    i0.ɵɵelement(4, "mat-icon", 5);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(4, _c0$g, ctx_r0.expand))("@baseLayerSwitcherState", ctx_r0.expand ? "expand" : ctx_r0.useStaticIcon ? "collapseIcon" : "collapseMap");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.useStaticIcon && !ctx_r0.expand && ctx_r0.showButton);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r0.baseLayers);
} }
class BaseLayersSwitcherComponent {
    constructor(mediaService) {
        this.mediaService = mediaService;
        this._baseLayers = [];
        this.expand = false;
        this.showButton = true;
        const media = this.mediaService.media$.value;
        if (media === Media.Mobile && this.useStaticIcon === undefined) {
            this.useStaticIcon = true;
        }
    }
    ngAfterViewInit() {
        this.layers$$ = this.map.layers$.subscribe(arrayLayers => {
            this._baseLayers = arrayLayers.filter(l => l.baseLayer);
        });
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
    }
    collapseOrExpand() {
        if (this.baseLayers.length > 1 || this.useStaticIcon) {
            this.expand = !this.expand;
        }
        else {
            this.expand = false;
        }
    }
    get baseLayers() {
        const mapResolution = this.map.viewController.getResolution();
        const mapZoom = this.map.viewController.getZoom();
        const bl = this._baseLayers.filter(l => {
            return ((!l.options.maxResolution ||
                mapResolution <= l.options.maxResolution) &&
                (!l.options.minResolution || mapResolution >= l.options.minResolution) &&
                (!l.options.source.options.maxZoom || mapZoom <= l.options.source.options.maxZoom) &&
                (!l.options.source.options.minZoom || mapZoom >= l.options.source.options.minZoom));
        });
        const blHidden = bl.filter(l => !l.visible);
        return blHidden.length + 1 === bl.length ? blHidden : bl;
    }
}
BaseLayersSwitcherComponent.ɵfac = function BaseLayersSwitcherComponent_Factory(t) { return new (t || BaseLayersSwitcherComponent)(i0.ɵɵdirectiveInject(i2$1.MediaService)); };
BaseLayersSwitcherComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: BaseLayersSwitcherComponent, selectors: [["igo-baselayers-switcher"]], inputs: { map: "map", useStaticIcon: "useStaticIcon" }, decls: 1, vars: 1, consts: [["class", "igo-baselayers-switcher-container", 3, "ngClass", "click", 4, "ngIf"], [1, "igo-baselayers-switcher-container", 3, "ngClass", "click"], ["class", "igo-baselayers-switcher-button-container", 4, "ngIf"], ["class", "mat-typography", 3, "map", "baseLayer", "title", "display", "disabled", 4, "ngFor", "ngForOf"], [1, "more-baselayers"], ["color", "primary", "svgIcon", "menu-down", 1, "material-icons", "mat-icon", "mat-list-avatar"], [1, "igo-baselayers-switcher-button-container"], ["mat-icon-button", "", "matTooltipPosition", "right", "color", "primary", 3, "matTooltip"], ["svgIcon", "image-multiple"], [1, "mat-typography", 3, "map", "baseLayer", "title", "display", "disabled"]], template: function BaseLayersSwitcherComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, BaseLayersSwitcherComponent_div_0_Template, 5, 6, "div", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.baseLayers.length > 0);
    } }, styles: [".igo-baselayers-switcher-container[_ngcontent-%COMP%]{height:auto;position:relative}.container-expand[_ngcontent-%COMP%]{overflow:hidden;border-width:0}.more-baselayers[_ngcontent-%COMP%]{width:80px;height:20px;background-color:#fff;text-align:center;cursor:pointer}.more-baselayers[_ngcontent-%COMP%]:hover{background-color:#efefef}.igo-baselayers-switcher-button-container[_ngcontent-%COMP%]{width:40px;background-color:#fff}.igo-baselayers-switcher-button-container[_ngcontent-%COMP%]:hover{background-color:#efefef}button[_ngcontent-%COMP%], [_nghost-%COMP%]     button .mat-button-ripple-round{border-radius:0}"], data: { animation: [baseLayersSwitcherSlideInOut()] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(BaseLayersSwitcherComponent, [{
        type: Component,
        args: [{
                selector: 'igo-baselayers-switcher',
                templateUrl: './baselayers-switcher.component.html',
                styleUrls: ['./baselayers-switcher.component.scss'],
                animations: [baseLayersSwitcherSlideInOut()]
            }]
    }], function () { return [{ type: i2$1.MediaService }]; }, { map: [{
            type: Input
        }], useStaticIcon: [{
            type: Input
        }] }); })();

class LayerService {
    constructor(http, styleService, dataSourceService, messageService, languageService, authInterceptor) {
        this.http = http;
        this.styleService = styleService;
        this.dataSourceService = dataSourceService;
        this.messageService = messageService;
        this.languageService = languageService;
        this.authInterceptor = authInterceptor;
    }
    createLayer(layerOptions) {
        if (!layerOptions.source) {
            return;
        }
        if (layerOptions.source.options &&
            layerOptions.source.options._layerOptionsFromSource) {
            layerOptions = ObjectUtils.mergeDeep(layerOptions.source.options._layerOptionsFromSource, layerOptions || {});
        }
        let layer;
        switch (layerOptions.source.constructor) {
            case OSMDataSource:
            case WMTSDataSource:
            case XYZDataSource:
            case TileDebugDataSource:
            case CartoDataSource:
            case TileArcGISRestDataSource:
                layer = this.createTileLayer(layerOptions);
                break;
            case FeatureDataSource:
            case WFSDataSource:
            case ArcGISRestDataSource:
            case WebSocketDataSource:
            case ClusterDataSource:
                layer = this.createVectorLayer(layerOptions);
                break;
            case ImageArcGISRestDataSource:
            case WMSDataSource:
                layer = this.createImageLayer(layerOptions);
                break;
            case MVTDataSource:
                const _layerOptions = computeMVTOptionsOnHover(layerOptions);
                layer = this.createVectorTileLayer(_layerOptions);
                break;
            default:
                break;
        }
        return layer;
    }
    createAsyncLayer(_layerOptions, detailedContextUri) {
        const layerOptions = computeMVTOptionsOnHover(_layerOptions);
        if (layerOptions.source) {
            return new Observable(d => d.next(this.createLayer(layerOptions)));
        }
        return this.dataSourceService
            .createAsyncDataSource(layerOptions.sourceOptions, detailedContextUri)
            .pipe(map(source => {
            if (source === undefined) {
                return undefined;
            }
            return this.createLayer(Object.assign(layerOptions, { source }));
        }));
    }
    createImageLayer(layerOptions) {
        return new ImageLayer(layerOptions, this.messageService, this.languageService, this.authInterceptor);
    }
    createTileLayer(layerOptions) {
        return new TileLayer(layerOptions, this.messageService, this.authInterceptor);
    }
    createVectorLayer(layerOptions) {
        let style;
        let igoLayer;
        if (layerOptions.style !== undefined) {
            style = this.styleService.createStyle(layerOptions.style);
        }
        if (layerOptions.source instanceof ArcGISRestDataSource) {
            const source = layerOptions.source;
            style = source.options.params.style;
        }
        else if (layerOptions.styleByAttribute) {
            const serviceStyle = this.styleService;
            layerOptions.style = feature => {
                return serviceStyle.createStyleByAttribute(feature, layerOptions.styleByAttribute);
            };
            igoLayer = new VectorLayer(layerOptions, this.messageService, this.authInterceptor);
        }
        if (layerOptions.source instanceof ClusterDataSource) {
            const serviceStyle = this.styleService;
            const baseStyle = layerOptions.clusterBaseStyle;
            layerOptions.style = feature => {
                return serviceStyle.createClusterStyle(feature, layerOptions.clusterParam, baseStyle);
            };
            igoLayer = new VectorLayer(layerOptions, this.messageService, this.authInterceptor);
        }
        const layerOptionsOl = Object.assign({}, layerOptions, {
            style
        });
        if (!igoLayer) {
            igoLayer = new VectorLayer(layerOptionsOl, this.messageService, this.authInterceptor);
        }
        this.applyMapboxStyle(igoLayer, layerOptionsOl);
        return igoLayer;
    }
    createVectorTileLayer(layerOptions) {
        let style;
        let igoLayer;
        if (layerOptions.style !== undefined) {
            style = this.styleService.createStyle(layerOptions.style);
        }
        if (layerOptions.styleByAttribute) {
            const serviceStyle = this.styleService;
            layerOptions.style = feature => {
                return serviceStyle.createStyleByAttribute(feature, layerOptions.styleByAttribute);
            };
            igoLayer = new VectorTileLayer(layerOptions, this.messageService, this.authInterceptor);
        }
        const layerOptionsOl = Object.assign({}, layerOptions, {
            style
        });
        if (!igoLayer) {
            igoLayer = new VectorTileLayer(layerOptionsOl, this.messageService, this.authInterceptor);
        }
        this.applyMapboxStyle(igoLayer, layerOptionsOl);
        return igoLayer;
    }
    applyMapboxStyle(layer, layerOptions) {
        if (layerOptions.mapboxStyle) {
            this.getMapboxGlStyle(layerOptions.mapboxStyle.url).subscribe(res => {
                stylefunction(layer.ol, res, layerOptions.mapboxStyle.source);
            });
        }
    }
    getMapboxGlStyle(url) {
        return this.http.get(url).pipe(map((res) => res), catchError(err => {
            console.log('No style was found');
            return of(err);
        }));
    }
}
LayerService.ɵfac = function LayerService_Factory(t) { return new (t || LayerService)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(StyleService), i0.ɵɵinject(DataSourceService), i0.ɵɵinject(i2$1.MessageService), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i5.AuthInterceptor, 8)); };
LayerService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: LayerService, factory: LayerService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LayerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1$2.HttpClient }, { type: StyleService }, { type: DataSourceService }, { type: i2$1.MessageService }, { type: i2$1.LanguageService }, { type: i5.AuthInterceptor, decorators: [{
                type: Optional
            }] }]; }, null); })();

function MiniBaseMapComponent_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", ctx_r1.title, " ");
} }
function MiniBaseMapComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 2);
    i0.ɵɵlistener("click", function MiniBaseMapComponent_div_1_Template_div_click_0_listener() { i0.ɵɵrestoreView(_r3); const ctx_r2 = i0.ɵɵnextContext(); return ctx_r2.changeBaseLayer(ctx_r2.baseLayer); });
    i0.ɵɵelement(1, "igo-map-browser", 3);
    i0.ɵɵtemplate(2, MiniBaseMapComponent_div_1_div_2_Template, 2, 1, "div", 4);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("map", ctx_r0.basemap);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.title);
} }
class MiniBaseMapComponent {
    constructor(layerService, appRef) {
        this.layerService = layerService;
        this.appRef = appRef;
        this.basemap = new IgoMap({
            controls: {},
            interactions: false
        });
    }
    get baseLayer() {
        return this._baseLayer;
    }
    set baseLayer(value) {
        this._baseLayer = value;
        this.handleBaseLayerChanged(value);
    }
    ngAfterViewInit() {
        this.handleMainMapViewChange(this.map.ol.getView());
        this.map.viewController.olView.on('change', change => {
            this.handleMainMapViewChange(change.target);
        });
        this.map.ol.on('pointerdrag', change => {
            this.handleMainMapViewChange(change.target.getView());
        });
    }
    ngOnDestroy() {
        this.map.viewController.olView.un('change', change => {
            this.handleMainMapViewChange(change.target);
        });
        this.map.ol.un('pointerdrag', change => {
            this.handleMainMapViewChange(change.target.getView());
        });
    }
    changeBaseLayer(baseLayer) {
        if (this.disabled) {
            return;
        }
        this.map.changeBaseLayer(baseLayer);
        this.appRef.tick();
    }
    handleMainMapViewChange(mainMapView) {
        const mainMapViewProperties = mainMapView.getProperties();
        this.basemap.viewController.olView.setResolution(mainMapViewProperties.resolution);
        this.basemap.viewController.olView.setRotation(mainMapViewProperties.rotation);
        this.basemap.viewController.olView.setCenter(this.map.viewController.getCenter());
    }
    handleBaseLayerChanged(baselayer) {
        this.basemap.removeAllLayers();
        const options = Object.assign(Object.create(baselayer.options), baselayer.options, {
            visible: true,
            baseLayer: false
        });
        const layer = this.layerService.createLayer(options);
        this.basemap.addLayer(layer);
        this.handleLinkedBaseLayer(layer);
    }
    handleLinkedBaseLayer(baselayer) {
        const linkedLayers = baselayer.options.linkedLayers;
        if (!linkedLayers) {
            return;
        }
        const currentLinkedId = linkedLayers.linkId;
        const currentLinks = linkedLayers.links;
        const isParentLayer = currentLinks ? true : false;
        if (isParentLayer && currentLinkedId === baselayer.options.linkedLayers.linkId) {
            // search for child layers
            currentLinks.map(link => {
                link.linkedIds.map(linkedId => {
                    const layerToApply = this.map.layers.find(l => { var _a; return ((_a = l.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.linkId) === linkedId; });
                    if (layerToApply) {
                        const linkedLayerOptions = Object.assign(Object.create(layerToApply.options), layerToApply.options, {
                            zIndex: 9000,
                            visible: true,
                            baseLayer: false,
                        });
                        this.basemap.addLayer(this.layerService.createLayer(linkedLayerOptions));
                    }
                });
            });
        }
    }
}
MiniBaseMapComponent.ɵfac = function MiniBaseMapComponent_Factory(t) { return new (t || MiniBaseMapComponent)(i0.ɵɵdirectiveInject(LayerService), i0.ɵɵdirectiveInject(i0.ApplicationRef)); };
MiniBaseMapComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MiniBaseMapComponent, selectors: [["igo-mini-basemap"]], inputs: { map: "map", disabled: "disabled", display: "display", title: "title", baseLayer: "baseLayer" }, decls: 2, vars: 1, consts: [[1, "igo-mini-basemap-container"], [3, "click", 4, "ngIf"], [3, "click"], [3, "map"], ["class", "igo-mini-basemap-title", 4, "ngIf"], [1, "igo-mini-basemap-title"]], template: function MiniBaseMapComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtemplate(1, MiniBaseMapComponent_div_1_Template, 3, 2, "div", 1);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.display);
    } }, styles: [".igo-mini-basemap-container[_ngcontent-%COMP%]{width:calc(40px * 2);height:calc(40px * 2);background-color:#ffffff03;border:2px solid white;box-shadow:0 1px 4px #0000004d;cursor:pointer;margin-top:5px}.igo-mini-basemap-container[_ngcontent-%COMP%]:hover   .igo-mini-basemap-title[_ngcontent-%COMP%]{color:#000;text-shadow:0 0 5px white}.igo-mini-basemap-container[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{width:100%;height:100%}.igo-mini-basemap-title[_ngcontent-%COMP%]{position:relative;top:-76px;height:76px;width:76px;text-align:center;vertical-align:bottom;color:#fff;text-shadow:0 0 5px black;white-space:normal;display:flex;align-items:flex-end;justify-content:center}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MiniBaseMapComponent, [{
        type: Component,
        args: [{
                selector: 'igo-mini-basemap',
                templateUrl: './mini-basemap.component.html',
                styleUrls: ['./mini-basemap.component.scss']
            }]
    }], function () { return [{ type: LayerService }, { type: i0.ApplicationRef }]; }, { map: [{
            type: Input
        }], disabled: [{
            type: Input
        }], display: [{
            type: Input
        }], title: [{
            type: Input
        }], baseLayer: [{
            type: Input
        }] }); })();

function RotationButtonComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r3 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 1);
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementStart(3, "button", 2);
    i0.ɵɵlistener("click", function RotationButtonComponent_div_0_Template_button_click_3_listener() { i0.ɵɵrestoreView(_r3); const ctx_r2 = i0.ɵɵnextContext(); return ctx_r2.map.viewController.resetRotation(); });
    i0.ɵɵelement(4, "mat-icon", 3);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", ctx_r0.rotated ? i0.ɵɵpipeBind1(1, 4, "igo.geo.mapButtons.resetRotation") : i0.ɵɵpipeBind1(2, 6, "igo.geo.mapButtons.tipRotation"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("color", ctx_r0.color)("disabled", !ctx_r0.rotated);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngStyle", ctx_r0.rotationStyle(ctx_r0.map.viewController.getRotation()));
} }
function RotationButtonComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 1);
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementStart(3, "button", 2);
    i0.ɵɵlistener("click", function RotationButtonComponent_div_1_Template_button_click_3_listener() { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.map.viewController.resetRotation(); });
    i0.ɵɵelement(4, "mat-icon", 3);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", ctx_r1.rotated ? i0.ɵɵpipeBind1(1, 4, "igo.geo.mapButtons.resetRotation") : i0.ɵɵpipeBind1(2, 6, "igo.geo.mapButtons.tipRotation"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("color", ctx_r1.color)("disabled", !ctx_r1.rotated);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngStyle", ctx_r1.rotationStyle(ctx_r1.map.viewController.getRotation()));
} }
class RotationButtonComponent {
    constructor() { }
    get map() {
        return this._map;
    }
    set map(value) {
        this._map = value;
    }
    get showIfNoRotation() {
        return this._showIfNoRotation;
    }
    set showIfNoRotation(value) {
        this._showIfNoRotation = value;
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    get rotated() {
        return this.map.viewController.getRotation() !== 0;
    }
    rotationStyle(radians) {
        const rotation = 'rotate(' + radians + 'rad)';
        return {
            transform: rotation
        };
    }
}
RotationButtonComponent.ɵfac = function RotationButtonComponent_Factory(t) { return new (t || RotationButtonComponent)(); };
RotationButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: RotationButtonComponent, selectors: [["igo-rotation-button"]], inputs: { map: "map", showIfNoRotation: "showIfNoRotation", color: "color" }, decls: 2, vars: 2, consts: [["class", "igo-rotation-button-container", "matTooltipPosition", "left", 3, "matTooltip", 4, "ngIf"], ["matTooltipPosition", "left", 1, "igo-rotation-button-container", 3, "matTooltip"], ["mat-icon-button", "", "matTooltipPosition", "left", 3, "color", "disabled", "click"], ["svgIcon", "navigation", 3, "ngStyle"]], template: function RotationButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, RotationButtonComponent_div_0_Template, 5, 8, "div", 0);
        i0.ɵɵtemplate(1, RotationButtonComponent_div_1_Template, 5, 8, "div", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.rotated && !ctx.showIfNoRotation);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.showIfNoRotation);
    } }, directives: [i1$1.NgIf, i3.MatTooltip, i2.MatButton, i4.MatIcon, i1$1.NgStyle], pipes: [i7.TranslatePipe], styles: [".igo-rotation-button-container[_ngcontent-%COMP%]{width:40px;background-color:#fff}.igo-rotation-button-container[_ngcontent-%COMP%]:hover{background-color:#efefef}button[_ngcontent-%COMP%], [_nghost-%COMP%]     button .mat-button-ripple-round{border-radius:0}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){button[_ngcontent-%COMP%]:disabled, [_nghost-%COMP%]     button .mat-button-ripple-round:disabled{display:none}}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(RotationButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-rotation-button',
                templateUrl: './rotation-button.component.html',
                styleUrls: ['./rotation-button.component.scss']
            }]
    }], function () { return []; }, { map: [{
            type: Input
        }], showIfNoRotation: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

/**
 * Tool to swipe the layers
 */
class SwipeControlComponent {
    constructor() {
        /**
         * State of draggable action
         */
        this.inDragAction = false;
        /**
         * Binder of prerender on the same element
         */
        this.boundPrerender = this.prerender.bind(this);
    }
    /**
     * Get the list of layers for swipe and activate of deactivate the swipe
     * @internal
     */
    ngAfterViewInit() {
        this.getListOfLayers();
        this.swipeEnabled$$ = this.map.swipeEnabled$.subscribe(value => {
            value ? this.displaySwipe() : this.displaySwipeOff();
        });
        this.letZoom();
    }
    /**
     * Clear the overlay layer and any interaction added by this component.
     * @internal
     */
    ngOnDestroy() {
        this.swipeEnabled$$.unsubscribe();
        this.map.swipeEnabled$.unsubscribe();
        this.displaySwipeOff();
    }
    /**
     * Display a swipe-element and render the layers
     */
    displaySwipe() {
        this.swipeId.style.visibility = 'visible';
        this.layers.map(layer => layer.ol.on('prerender', this.boundPrerender));
        this.layers.map(layer => layer.ol.on('postrender', this.postrender));
        this.map.ol.render();
    }
    /**
     * Clear a swipe-element and render the layers on the initial state
     */
    displaySwipeOff() {
        this.swipeId.style.visibility = 'hidden';
        this.layers.map(layer => layer.ol.un('prerender', this.boundPrerender));
        this.layers.map(layer => layer.ol.un('postrender', this.postrender));
        this.map.ol.render();
        this.layers = [];
    }
    /**
     * Getter of element
     */
    get swipeId() {
        return document.getElementById('igo-layer-swipe');
    }
    /**
     * Get the list of layers for swipe
     */
    getListOfLayers() {
        this.map.selectedFeatures$.subscribe(layers => {
            this.layers = [];
            if (layers !== null) {
                for (const layer of layers) {
                    if (!this.layers.includes(layer)) {
                        this.layers.push(layer);
                    }
                }
            }
        });
    }
    /**
     * Get a position of click or touch
     */
    dragDown(event) {
        this.inDragAction = true;
        event.preventDefault();
        if (event.type === 'mousedown') {
            this.pos3 = event.clientX;
            this.mouseSwipe();
            document.onmouseup = this.closeDragMouseElement;
        }
        else if (event.type === 'touchstart') {
            document.getElementById('arrows').style.visibility = 'hidden';
            this.pos3 = event.touches[0].clientX;
            this.touchSwipe();
            document.ontouchend = this.closeDragTouchElement;
        }
    }
    /**
     * Moving a line with a mouse
     */
    mouseSwipe() {
        document.addEventListener('mousemove', event => {
            if (this.inDragAction) {
                event.preventDefault();
                this.pos1 = this.pos3 - event.clientX;
                this.pos3 = event.clientX;
                this.swipeId.style.left = (this.swipeId.offsetLeft - this.pos1) + 'px';
            }
            this.map.ol.render();
        });
    }
    /**
     * Moving a line with a touch
     */
    touchSwipe() {
        document.addEventListener('touchmove', event => {
            if (this.inDragAction) {
                event.preventDefault();
                document.getElementById('arrows').style.visibility = 'hidden';
                this.pos1 = this.pos3 - event.changedTouches[0].clientX;
                this.pos3 = event.changedTouches[0].clientX;
                this.swipeId.style.left = (this.swipeId.offsetLeft - this.pos1) + 'px';
            }
            this.map.ol.render();
        });
    }
    /**
     * Deactivate a listener of a mouse-action
     */
    closeDragMouseElement() {
        document.onmouseup = null;
        document.onmousemove = null;
        this.inDragAction = false;
    }
    /**
     * Deactivate a listener of a touch-action
     */
    closeDragTouchElement() {
        document.ontouchend = null;
        document.ontouchmove = null;
        document.getElementById('arrows').style.visibility = 'visible';
        this.inDragAction = false;
    }
    /**
     * Cut the image of a layer by the position of swiped-element
     */
    prerender(event) {
        const ctx = event.context;
        const mapSize = this.map.ol.getSize();
        const width = this.swipeId.offsetLeft;
        const tl = getRenderPixel(event, [width, 0]);
        const tr = getRenderPixel(event, [0, 0]);
        const bl = getRenderPixel(event, [width, mapSize[1]]);
        const br = getRenderPixel(event, [0, mapSize[1]]);
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(tl[0], tl[1]);
        ctx.lineTo(bl[0], bl[1]);
        ctx.lineTo(br[0], br[1]);
        ctx.lineTo(tr[0], tr[1]);
        ctx.closePath();
        ctx.clip();
    }
    /**
     * Save a current state of the context
     */
    postrender(event) {
        event.context.restore();
        event.context.save();
    }
    /**
     * Zoom on div
     */
    letZoom() {
        document.getElementById('igo-layer-swipe').addEventListener('wheel', event => {
            event.deltaY > 0 ? this.map.viewController.zoomOut() : this.map.viewController.zoomIn();
        }, true);
    }
}
SwipeControlComponent.ɵfac = function SwipeControlComponent_Factory(t) { return new (t || SwipeControlComponent)(); };
SwipeControlComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SwipeControlComponent, selectors: [["igo-swipe-control"]], inputs: { map: "map" }, decls: 5, vars: 0, consts: [["id", "igo-layer-swipe", 1, "igo-swipe-control-container", 3, "mousedown", "mouseup", "touchstart", "touchend"], [1, "igo-swipe-control-line"], ["id", "arrows", 1, "igo-swipe-control-arrows"], [1, "igo-arrow-left"], [1, "igo-arrow-right"]], template: function SwipeControlComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵlistener("mousedown", function SwipeControlComponent_Template_div_mousedown_0_listener($event) { return ctx.dragDown($event); })("mouseup", function SwipeControlComponent_Template_div_mouseup_0_listener() { return ctx.closeDragMouseElement(); })("touchstart", function SwipeControlComponent_Template_div_touchstart_0_listener($event) { return ctx.dragDown($event); })("touchend", function SwipeControlComponent_Template_div_touchend_0_listener() { return ctx.closeDragTouchElement(); });
        i0.ɵɵelement(1, "div", 1);
        i0.ɵɵelementStart(2, "div", 2);
        i0.ɵɵelement(3, "div", 3);
        i0.ɵɵelement(4, "div", 4);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } }, styles: [".igo-swipe-control-container[_ngcontent-%COMP%]{position:absolute;width:80px;height:100%;top:0%;left:50%;cursor:-webkit-grab;cursor:grab;z-index:1;transform:translate(-40px)}.igo-swipe-control-container[_ngcontent-%COMP%]:active{cursor:-webkit-grabbing;cursor:grabbing}.igo-swipe-control-line[_ngcontent-%COMP%]{position:absolute;width:4px;height:100%;top:50%;left:50%;transform:translate(-50%,-50%);background-color:#5e5a5a}.igo-swipe-control-arrows[_ngcontent-%COMP%]{position:absolute;width:32px;height:32px;left:50%;top:50%;transform:translate(-50%,-50%);margin-top:-16px;padding:5px 4px;background-color:#5e5a5a;z-index:2;-webkit-tap-highlight-color:rgba(0,0,0,0)}.igo-swipe-control-arrows[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{display:inline-block;width:0;height:0;border-top:10px solid transparent;border-bottom:10px solid transparent}.igo-swipe-control-arrows[_ngcontent-%COMP%]   .igo-arrow-right[_ngcontent-%COMP%]{margin-left:4px;border-left:10px solid white}.igo-swipe-control-arrows[_ngcontent-%COMP%]   .igo-arrow-left[_ngcontent-%COMP%]{border-right:10px solid white}.igo-swipe-control-arrows[_ngcontent-%COMP%]:active{display:none}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SwipeControlComponent, [{
        type: Component,
        args: [{
                selector: 'igo-swipe-control',
                templateUrl: './swipe-control.component.html',
                styleUrls: ['./swipe-control.component.scss']
            }]
    }], function () { return []; }, { map: [{
            type: Input
        }] }); })();

/**
 * Tool to display the center of the map
 */
class MapCenterComponent {
    constructor() { }
    /**
     * Set a visibility for cursor of the center of the map
     */
    ngAfterViewInit() {
        if (this.map) {
            this.displayCenter$$ = this.map.mapCenter$.subscribe(value => {
                value ?
                    document.getElementById('mapCenter').style.visibility = 'visible' :
                    document.getElementById('mapCenter').style.visibility = 'hidden';
            });
        }
        this.letZoom();
    }
    /**
     * Destroyer of a component
     */
    ngOnDestroy() {
        if (this.displayCenter$$) {
            this.displayCenter$$.unsubscribe();
        }
    }
    /**
     * Zoom on div
     */
    letZoom() {
        document.getElementById('mapCenter').addEventListener('wheel', event => {
            event.deltaY > 0 ? this.map.viewController.zoomOut() : this.map.viewController.zoomIn();
        }, true);
    }
}
MapCenterComponent.ɵfac = function MapCenterComponent_Factory(t) { return new (t || MapCenterComponent)(); };
MapCenterComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MapCenterComponent, selectors: [["igo-map-center"]], inputs: { map: "map" }, decls: 3, vars: 0, consts: [["id", "mapCenter", 1, "mapCenter"], [1, "vertical"], [1, "horizontal"]], template: function MapCenterComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelement(1, "div", 1);
        i0.ɵɵelement(2, "div", 2);
        i0.ɵɵelementEnd();
    } }, styles: [".mapCenter[_ngcontent-%COMP%]{width:30px;height:30px;position:absolute;top:50%;left:50%;transform:translate(-15px,-15px);pointer-events:none}.mapCenter[_ngcontent-%COMP%]   .vertical[_ngcontent-%COMP%], .mapCenter[_ngcontent-%COMP%]   .horizontal[_ngcontent-%COMP%]{width:4px;height:30px;position:absolute;left:13px;background-color:#000}.mapCenter[_ngcontent-%COMP%]   .horizontal[_ngcontent-%COMP%]{transform:rotate(90deg)}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MapCenterComponent, [{
        type: Component,
        args: [{
                selector: 'igo-map-center',
                templateUrl: './map-center.component.html',
                styleUrls: ['./map-center.component.scss']
            }]
    }], function () { return []; }, { map: [{
            type: Input
        }] }); })();

function InfoSectionComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 1);
    i0.ɵɵelementStart(1, "pre");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r0.infoContent);
} }
class InfoSectionComponent {
    constructor() {
        this.infoContent = '';
    }
}
InfoSectionComponent.ɵfac = function InfoSectionComponent_Factory(t) { return new (t || InfoSectionComponent)(); };
InfoSectionComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: InfoSectionComponent, selectors: [["igo-info-section"]], inputs: { infoContent: "infoContent" }, decls: 1, vars: 1, consts: [["class", "infoSection", 4, "ngIf"], [1, "infoSection"]], template: function InfoSectionComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, InfoSectionComponent_div_0_Template, 3, 1, "div", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.infoContent && ctx.infoContent.length);
    } }, directives: [i1$1.NgIf], styles: [".infoSection[_ngcontent-%COMP%]{border-radius:10px;background-color:#6e6e6e66;padding:calc(5px / 2);position:absolute;text-align:center;top:5px;left:50%;text-shadow:0 0 5px white,0 0 10px white,0 0 15px white}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.infoSection[_ngcontent-%COMP%]{top:calc(40px + 5px + 5px);left:10%}}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(InfoSectionComponent, [{
        type: Component,
        args: [{
                selector: 'igo-info-section',
                templateUrl: './info-section.component.html',
                styleUrls: ['./info-section.component.scss']
            }]
    }], function () { return []; }, { infoContent: [{
            type: Input
        }] }); })();

var CatalogItemType;
(function (CatalogItemType) {
    CatalogItemType["Layer"] = "layer";
    CatalogItemType["Group"] = "group";
})(CatalogItemType || (CatalogItemType = {}));
var TypeCatalog;
(function (TypeCatalog) {
    TypeCatalog[TypeCatalog["wms"] = 0] = "wms";
    TypeCatalog[TypeCatalog["wmts"] = 1] = "wmts";
    TypeCatalog[TypeCatalog["baselayers"] = 2] = "baselayers";
    TypeCatalog[TypeCatalog["arcgisrest"] = 3] = "arcgisrest";
    TypeCatalog[TypeCatalog["tilearcgisrest"] = 4] = "tilearcgisrest";
    TypeCatalog[TypeCatalog["imagearcgisrest"] = 5] = "imagearcgisrest";
    TypeCatalog[TypeCatalog["composite"] = 6] = "composite";
})(TypeCatalog || (TypeCatalog = {}));

class Catalog {
    constructor(options, service) {
        Object.assign(this, options);
        this.catalogService = service;
    }
}
class WMSCatalog extends Catalog {
    constructor(options, service) {
        super(options, service);
        const sType = TypeCatalog[TypeCatalog.wms];
        this.type = TypeCatalog[sType];
    }
    collectCatalogItems() {
        return this.catalogService.loadCatalogWMSLayerItems(this);
    }
}
class WMTSCatalog extends Catalog {
    constructor(options, service) {
        super(options, service);
        const sType = TypeCatalog[TypeCatalog.wmts];
        this.type = TypeCatalog[sType];
    }
    collectCatalogItems() {
        return this.catalogService.loadCatalogWMTSLayerItems(this);
    }
}
class BaselayersCatalog extends Catalog {
    constructor(options, service) {
        super(options, service);
        const sType = TypeCatalog[TypeCatalog.baselayers];
        this.type = TypeCatalog[sType];
    }
    collectCatalogItems() {
        return this.catalogService.loadCatalogBaseLayerItems(this);
    }
}
class ArcGISRestCatalog extends Catalog {
    constructor(options, service) {
        super(options, service);
        const sType = TypeCatalog[TypeCatalog.arcgisrest];
        this.type = TypeCatalog[sType];
    }
    collectCatalogItems() {
        return this.catalogService.loadCatalogArcGISRestItems(this);
    }
}
class TileOrImageArcGISRestCatalog extends Catalog {
    constructor(options, service, typeCatalog) {
        super(options, service);
        this.type = TypeCatalog[TypeCatalog[typeCatalog]];
    }
    collectCatalogItems() {
        return this.catalogService.loadCatalogArcGISRestItems(this);
    }
}
class CompositeCatalog extends Catalog {
    constructor(options, service) {
        super(options, service);
        const sType = TypeCatalog[TypeCatalog.composite];
        this.type = TypeCatalog[sType];
        this.url = null;
    }
    collectCatalogItems() {
        return this.catalogService.loadCatalogCompositeLayerItems(this);
    }
}
class CatalogFactory {
    static createInstanceCatalog(options, service) {
        let catalog;
        if (options.hasOwnProperty('composite')) {
            catalog = new CompositeCatalog(options, service);
        }
        else if (options.type === TypeCatalog[TypeCatalog.baselayers]) {
            catalog = new BaselayersCatalog(options, service);
        }
        else if (options.type === TypeCatalog[TypeCatalog.arcgisrest]) {
            catalog = new ArcGISRestCatalog(options, service);
        }
        else if (options.type === TypeCatalog[TypeCatalog.tilearcgisrest]) {
            catalog = new TileOrImageArcGISRestCatalog(options, service, TypeCatalog.tilearcgisrest);
        }
        else if (options.type === TypeCatalog[TypeCatalog.imagearcgisrest]) {
            catalog = new TileOrImageArcGISRestCatalog(options, service, TypeCatalog.imagearcgisrest);
        }
        else if (options.type === TypeCatalog[TypeCatalog.wmts]) {
            catalog = new WMTSCatalog(options, service);
        }
        else {
            catalog = new WMSCatalog(options, service);
        }
        return catalog;
    }
}

class QueryService {
    constructor(http) {
        this.http = http;
        this.queryEnabled = true;
    }
    query(layers, options) {
        return layers
            .filter((layer) => layer.visible && layer.isInResolutionsRange)
            .map((layer) => this.queryLayer(layer, options));
    }
    queryLayer(layer, options) {
        const url = this.getQueryUrl(layer.dataSource, options, false, layer.map.viewController.getExtent());
        if (!url) {
            return of([]);
        }
        if (layer.dataSource.options.queryFormat ===
            QueryFormat.HTMLGML2) {
            const urlGml = this.getQueryUrl(layer.dataSource, options, true);
            return this.http.get(urlGml, { responseType: 'text' }).pipe(mergeMap(gmlRes => {
                const mergedGML = this.mergeGML(gmlRes, url, layer);
                const imposedGeom = mergedGML[0];
                const imposedProperties = mergedGML[1];
                return this.http
                    .get(url, { responseType: 'text' })
                    .pipe(map(res => this.extractData(res, layer, options, url, imposedGeom, imposedProperties)));
            }));
        }
        const request = this.http.get(url, { responseType: 'text' });
        return request.pipe(map(res => this.extractData(res, layer, options, url)));
    }
    mergeGML(gmlRes, url, layer) {
        var _a, _b;
        const parser = new olFormatGML2();
        let features = parser.readFeatures(gmlRes);
        // Handle non standard GML output (MapServer)
        if (features.length === 0) {
            const wmsParser = new olformat.WMSGetFeatureInfo();
            features = wmsParser.readFeatures(gmlRes);
        }
        const olmline = new olgeom.MultiLineString([]);
        let pts;
        const ptsArray = [];
        let olmpoly = new olgeom.MultiPolygon([]);
        let firstFeatureType;
        const nbFeatures = features.length;
        // Check if geometry intersect bbox
        // for geoserver getfeatureinfo response in data projection, not call projection
        const searchParams = this.getQueryParams(url.toLowerCase());
        const bboxRaw = searchParams.bbox;
        const bbox = bboxRaw.split(',');
        const bboxExtent = olextent.createEmpty();
        olextent.extend(bboxExtent, bbox);
        const outBboxExtent = false;
        let titleContent;
        let queryTileField;
        if ((_b = (_a = layer.options) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b.options) {
            const dataSourceOptions = layer.options.source
                .options;
            if (dataSourceOptions.queryTitle) {
                queryTileField = dataSourceOptions.queryTitle;
            }
        }
        features.map(feature => {
            if (queryTileField) {
                let queryTitleContent = feature.getProperties()[queryTileField];
                if (queryTitleContent) {
                    titleContent = !titleContent ? queryTitleContent : `${titleContent},${queryTitleContent}`;
                }
            }
            /*  if (!feature.getGeometry().simplify(100).intersectsExtent(bboxExtent)) {
              outBboxExtent = true;
              // TODO: Check to project the geometry?
            }*/
            const featureGeometryCoordinates = feature.getGeometry().getCoordinates();
            const featureGeometryType = feature.getGeometry().getType();
            if (!firstFeatureType && !outBboxExtent) {
                firstFeatureType = featureGeometryType;
            }
            if (!outBboxExtent) {
                switch (featureGeometryType) {
                    case 'Point':
                        if (nbFeatures === 1) {
                            pts = new olgeom.Point(featureGeometryCoordinates, 'XY');
                        }
                        else {
                            ptsArray.push(featureGeometryCoordinates);
                        }
                        break;
                    case 'LineString':
                        olmline.appendLineString(new olgeom.LineString(featureGeometryCoordinates, 'XY'));
                        break;
                    case 'Polygon':
                        olmpoly.appendPolygon(new olgeom.Polygon(featureGeometryCoordinates, 'XY'));
                        break;
                    case 'MultiPolygon':
                        olmpoly = new olgeom.MultiPolygon(featureGeometryCoordinates, 'XY');
                        break;
                    default:
                        return;
                }
            }
        });
        let olmpts;
        if (ptsArray.length === 0 && pts) {
            olmpts = {
                type: pts.getType(),
                coordinates: pts.getCoordinates()
            };
        }
        else {
            olmpts = {
                type: 'Polygon',
                coordinates: [this.convexHull(ptsArray)]
            };
        }
        let returnGeometry;
        switch (firstFeatureType) {
            case 'LineString':
                returnGeometry = {
                    type: olmline.getType(),
                    coordinates: olmline.getCoordinates()
                };
            case 'Point':
                return olmpts;
            case 'Polygon':
                returnGeometry = {
                    type: olmpoly.getType(),
                    coordinates: olmpoly.getCoordinates()
                };
            case 'MultiPolygon':
                returnGeometry = {
                    type: olmpoly.getType(),
                    coordinates: olmpoly.getCoordinates()
                };
        }
        const imposedProperties = {};
        if (queryTileField) {
            imposedProperties[queryTileField] = titleContent;
        }
        return [returnGeometry, imposedProperties];
    }
    cross(a, b, o) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
    }
    /**
     * @param points An array of [X, Y] coordinates
     * This method is use instead of turf.js convexHull because Turf needs at least 3 point to make a hull.
     * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript
     */
    convexHull(points) {
        points.sort((a, b) => {
            return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
        });
        const lower = [];
        for (const point of points) {
            while (lower.length >= 2 &&
                this.cross(lower[lower.length - 2], lower[lower.length - 1], point) <= 0) {
                lower.pop();
            }
            lower.push(point);
        }
        const upper = [];
        for (let i = points.length - 1; i >= 0; i--) {
            while (upper.length >= 2 &&
                this.cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
                upper.pop();
            }
            upper.push(points[i]);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
    }
    extractData(res, layer, options, url, imposedGeometry, imposedProperties) {
        const queryDataSource = layer.dataSource;
        const allowedFieldsAndAlias = this.getAllowedFieldsAndAlias(layer);
        let features = [];
        switch (queryDataSource.options.queryFormat) {
            case QueryFormat.GML3:
                features = this.extractGML3Data(res, layer.zIndex, allowedFieldsAndAlias);
                break;
            case QueryFormat.JSON:
            case QueryFormat.GEOJSON:
            case QueryFormat.GEOJSON2:
                features = this.extractGeoJSONData(res, layer.zIndex, allowedFieldsAndAlias);
                break;
            case QueryFormat.ESRIJSON:
                features = this.extractEsriJSONData(res, layer.zIndex, allowedFieldsAndAlias);
                break;
            case QueryFormat.TEXT:
                features = this.extractTextData(res);
                break;
            case QueryFormat.HTML:
                features = this.extractHtmlData(res, queryDataSource.queryHtmlTarget, url);
                break;
            case QueryFormat.HTMLGML2:
                features = this.extractHtmlData(res, queryDataSource.queryHtmlTarget, url, imposedGeometry, imposedProperties);
                break;
            case QueryFormat.GML2:
            default:
                features = this.extractGML2Data(res, layer, allowedFieldsAndAlias);
                break;
        }
        if (features.length > 0 && features[0].geometry === null) {
            const geomToAdd = this.createGeometryFromUrlClick(url);
            for (const feature of features) {
                feature.geometry = geomToAdd;
            }
        }
        return features.map((feature, index) => {
            var _a;
            const mapLabel = feature.properties[queryDataSource.mapLabel];
            let exclude;
            if (((_a = layer.options.sourceOptions) === null || _a === void 0 ? void 0 : _a.type) === 'wms') {
                const sourceOptions = layer.options
                    .sourceOptions;
                exclude = sourceOptions ? sourceOptions.excludeAttribute : undefined;
            }
            let title = this.getQueryTitle(feature, layer);
            if (!title && features.length > 1) {
                title = `${layer.title} (${index + 1})`;
            }
            else if (!title) {
                title = layer.title;
            }
            const meta = Object.assign({}, feature.meta || {}, {
                id: uuid(),
                title,
                mapTitle: mapLabel,
                sourceTitle: layer.title,
                order: 1000 - layer.zIndex,
                excludeAttribute: exclude
            });
            return Object.assign(feature, {
                meta,
                projection: queryDataSource.options.type === 'carto'
                    ? 'EPSG:4326'
                    : options.projection
            });
        });
    }
    createGeometryFromUrlClick(url) {
        const searchParams = this.getQueryParams(url.toLowerCase());
        const bboxRaw = searchParams.bbox;
        const width = parseInt(searchParams.width, 10);
        const height = parseInt(searchParams.height, 10);
        const xPosition = parseInt(searchParams.i || searchParams.x, 10);
        const yPosition = parseInt(searchParams.j || searchParams.y, 10);
        const bbox = bboxRaw.split(',');
        let threshold = (Math.abs(parseFloat(bbox[0])) - Math.abs(parseFloat(bbox[2]))) * 0.05;
        // for context in degree (EPSG:4326,4269...)
        if (Math.abs(parseFloat(bbox[0])) < 180) {
            threshold = 0.045;
        }
        const clickx = parseFloat(bbox[0]) +
            (Math.abs(parseFloat(bbox[0]) - parseFloat(bbox[2])) * xPosition) /
                width -
            threshold;
        const clicky = parseFloat(bbox[1]) +
            (Math.abs(parseFloat(bbox[1]) - parseFloat(bbox[3])) * yPosition) /
                height -
            threshold;
        const clickx1 = clickx + threshold * 2;
        const clicky1 = clicky + threshold * 2;
        const wktPoly = 'POLYGON((' +
            clickx +
            ' ' +
            clicky +
            ', ' +
            clickx +
            ' ' +
            clicky1 +
            ', ' +
            clickx1 +
            ' ' +
            clicky1 +
            ', ' +
            clickx1 +
            ' ' +
            clicky +
            ', ' +
            clickx +
            ' ' +
            clicky +
            '))';
        const format = new olformat.WKT();
        const tenPercentWidthGeom = format.readFeature(wktPoly);
        const f = tenPercentWidthGeom.getGeometry();
        const newGeom = {
            type: f.getType(),
            coordinates: f.getCoordinates()
        };
        return newGeom;
    }
    extractGML2Data(res, zIndex, allowedFieldsAndAlias) {
        const parser = new olFormatGML2();
        let features = parser.readFeatures(res);
        // Handle non standard GML output (MapServer)
        if (features.length === 0) {
            const wmsParser = new olformat.WMSGetFeatureInfo();
            try {
                features = wmsParser.readFeatures(res);
            }
            catch (e) {
                console.warn('query.service: Multipolygons are badly managed in mapserver in GML2. Use another format.');
            }
        }
        return features.map(feature => this.featureToResult(feature, zIndex, allowedFieldsAndAlias));
    }
    extractGML3Data(res, zIndex, allowedFieldsAndAlias) {
        const parser = new olFormatGML3();
        let features = [];
        try {
            features = parser.readFeatures(res);
        }
        catch (e) {
            console.warn('query.service: GML3 is not well supported');
        }
        return features.map(feature => this.featureToResult(feature, zIndex, allowedFieldsAndAlias));
    }
    extractGeoJSONData(res, zIndex, allowedFieldsAndAlias) {
        let features = [];
        try {
            features = JSON.parse(res.replace(/(\r|\n)/g, ' ')).features;
        }
        catch (e) {
            console.warn('query.service: Unable to parse geojson', '\n', res);
        }
        features.map(feature => feature.meta = {
            id: uuid(),
            order: 1000 - zIndex,
            alias: allowedFieldsAndAlias
        });
        return features;
    }
    extractEsriJSONData(res, zIndex, allowedFieldsAndAlias) {
        if (res) {
            try {
                if (JSON.parse(res).error) {
                    return [];
                }
            }
            catch (e) { }
        }
        const parser = new olFormatEsriJSON();
        const features = parser.readFeatures(res);
        return features.map(feature => this.featureToResult(feature, zIndex, allowedFieldsAndAlias));
    }
    extractTextData(res) {
        // TODO
        return [];
    }
    extractHtmlData(res, htmlTarget, url, imposedGeometry, imposedProperties) {
        const searchParams = this.getQueryParams(url.toLowerCase());
        const projection = searchParams.crs || searchParams.srs || 'EPSG:3857';
        const geomToAdd = this.createGeometryFromUrlClick(url);
        if (htmlTarget !== QueryHtmlTarget.BLANK &&
            htmlTarget !== QueryHtmlTarget.IFRAME) {
            htmlTarget = QueryHtmlTarget.IFRAME;
        }
        const bodyTagStart = res.toLowerCase().indexOf('<body>');
        const bodyTagEnd = res.toLowerCase().lastIndexOf('</body>') + 7;
        // replace \r \n  and ' ' with '' to validate if the body is really empty. Clear all the html tags from body
        const striptags = striptags_;
        const body = striptags(res.slice(bodyTagStart, bodyTagEnd).replace(/(\r|\n|\s)/g, ''));
        if (body === '' || res === '') {
            return [];
        }
        return [
            {
                type: FEATURE,
                projection,
                properties: Object.assign({ target: htmlTarget, body: res, url }, imposedProperties),
                geometry: imposedGeometry || geomToAdd
            }
        ];
    }
    getQueryParams(url) {
        const queryString = url.split('?');
        if (!queryString[1]) {
            return;
        }
        const pairs = queryString[1].split('&');
        const result = {};
        pairs.forEach(pair => {
            pair = pair.split('=');
            result[pair[0]] = decodeURIComponent(pair[1] || '');
        });
        return result;
    }
    featureToResult(featureOL, zIndex, allowedFieldsAndAlias) {
        const featureGeometry = featureOL.getGeometry();
        const properties = Object.assign({}, featureOL.getProperties());
        delete properties.geometry;
        delete properties.GEOMETRIE;
        delete properties.boundedBy;
        delete properties.shape;
        delete properties.SHAPE;
        delete properties.the_geom;
        delete properties.geom;
        let geometry;
        if (featureGeometry) {
            geometry = {
                type: featureGeometry.getType(),
                coordinates: featureGeometry.getCoordinates()
            };
        }
        return {
            type: FEATURE,
            projection: undefined,
            properties,
            geometry,
            meta: {
                id: uuid(),
                order: 1000 - zIndex,
                alias: allowedFieldsAndAlias
            }
        };
    }
    getQueryUrl(datasource, options, forceGML2 = false, mapExtent) {
        let url;
        if (datasource.options.queryUrl) {
            return this.getCustomQueryUrl(datasource, options, mapExtent);
        }
        switch (datasource.constructor) {
            case WMSDataSource:
                const wmsDatasource = datasource;
                const WMSGetFeatureInfoOptions = {
                    INFO_FORMAT: wmsDatasource.params.INFO_FORMAT ||
                        this.getMimeInfoFormat(datasource.options.queryFormat),
                    QUERY_LAYERS: wmsDatasource.params.LAYERS,
                    FEATURE_COUNT: wmsDatasource.params.FEATURE_COUNT || '5'
                };
                if (forceGML2) {
                    WMSGetFeatureInfoOptions.INFO_FORMAT = this.getMimeInfoFormat(QueryFormat.GML2);
                }
                url = wmsDatasource.ol.getFeatureInfoUrl(options.coordinates, options.resolution, options.projection, WMSGetFeatureInfoOptions);
                // const wmsVersion =
                //   wmsDatasource.params.VERSION ||
                //   wmsDatasource.params.version ||
                //   '1.3.0';
                // if (wmsVersion !== '1.3.0') {
                //   url = url.replace('&I=', '&X=');
                //   url = url.replace('&J=', '&Y=');
                // }
                break;
            case CartoDataSource:
                const cartoDatasource = datasource;
                const baseUrl = 'https://' +
                    cartoDatasource.options.account +
                    '.carto.com/api/v2/sql?';
                const format = 'format=GeoJSON';
                const sql = '&q=' + cartoDatasource.options.config.layers[0].options.sql;
                const clause = ' WHERE ST_Intersects(the_geom_webmercator,ST_BUFFER(ST_SetSRID(ST_POINT(';
                const meters = cartoDatasource.options.queryPrecision
                    ? cartoDatasource.options.queryPrecision
                    : '1000';
                const coordinates = options.coordinates[0] +
                    ',' +
                    options.coordinates[1] +
                    '),3857),' +
                    meters +
                    '))';
                url = `${baseUrl}${format}${sql}${clause}${coordinates}`;
                break;
            case ImageArcGISRestDataSource:
            case TileArcGISRestDataSource:
                const tileArcGISRestDatasource = datasource;
                const deltaX = Math.abs(mapExtent[0] - mapExtent[2]);
                const deltaY = Math.abs(mapExtent[1] - mapExtent[3]);
                const maxDelta = deltaX > deltaY ? deltaX : deltaY;
                const clickBuffer = maxDelta * 0.005;
                const threshold = tileArcGISRestDatasource.options.queryPrecision ? tileArcGISRestDatasource.options.queryPrecision : clickBuffer;
                const extent = olextent.buffer(olextent.boundingExtent([options.coordinates]), threshold);
                const serviceUrl = tileArcGISRestDatasource.options.url +
                    '/' +
                    tileArcGISRestDatasource.options.layer +
                    '/query/';
                const geometry = encodeURIComponent('{"xmin":' +
                    extent[0] +
                    ',"ymin":' +
                    extent[1] +
                    ',"xmax":' +
                    extent[2] +
                    ',"ymax":' +
                    extent[3] +
                    ',"spatialReference":{"wkid":102100}}');
                const params = [
                    'f=json',
                    `geometry=${geometry}`,
                    'geometryType=esriGeometryEnvelope',
                    'inSR=102100',
                    'spatialRel=esriSpatialRelIntersects',
                    'outFields=*',
                    'returnGeometry=true',
                    'outSR=102100'
                ];
                url = `${serviceUrl}?${params.join('&')}`;
                break;
            default:
                break;
        }
        return url;
    }
    getMimeInfoFormat(queryFormat) {
        let mime = 'application/vnd.ogc.gml';
        const keyEnum = Object.keys(QueryFormat).find(key => QueryFormat[key] === queryFormat);
        if (keyEnum) {
            mime = QueryFormatMimeType[keyEnum];
        }
        return mime;
    }
    getAllowedFieldsAndAlias(layer) {
        var _a, _b, _c;
        let allowedFieldsAndAlias;
        if (((_c = (_b = (_a = layer.options) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.sourceFields) &&
            layer.options.source.options.sourceFields.length >= 1) {
            allowedFieldsAndAlias = {};
            layer.options.source.options.sourceFields.forEach(sourceField => {
                const alias = sourceField.alias ? sourceField.alias : sourceField.name;
                allowedFieldsAndAlias[sourceField.name] = alias;
            });
        }
        return allowedFieldsAndAlias;
    }
    getQueryTitle(feature, layer) {
        var _a, _b;
        let title;
        if ((_b = (_a = layer.options) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b.options) {
            const dataSourceOptions = layer.options.source
                .options;
            if (dataSourceOptions.queryTitle) {
                title = this.getLabelMatch(feature, dataSourceOptions.queryTitle);
            }
        }
        return title;
    }
    getLabelMatch(feature, labelMatch) {
        let label = labelMatch;
        const labelToGet = Array.from(labelMatch.matchAll(/\$\{([^\{\}]+)\}/g));
        labelToGet.forEach(v => {
            label = label.replace(v[0], feature.properties[v[1]]);
        });
        // Nothing done? check feature's attribute
        if (labelToGet.length === 0 && label === labelMatch) {
            label = feature.properties[labelMatch] || labelMatch;
        }
        return label;
    }
    /**
     * @param datasource QueryableDataSource
     * @param options QueryOptions
     * @mapExtent extent of the map when click event
     *
     */
    getCustomQueryUrl(datasource, options, mapExtent) {
        let url = datasource.options.queryUrl.replace(/\{xmin\}/g, mapExtent[0].toString())
            .replace(/\{ymin\}/g, mapExtent[1].toString())
            .replace(/\{xmax\}/g, mapExtent[2].toString())
            .replace(/\{ymax\}/g, mapExtent[3].toString())
            .replace(/\{x\}/g, options.coordinates[0].toString())
            .replace(/\{y\}/g, options.coordinates[1].toString())
            .replace(/\{resolution\}/g, options.resolution.toString())
            .replace(/\{srid\}/g, options.projection.replace('EPSG:', ''));
        return url;
    }
}
QueryService.ɵfac = function QueryService_Factory(t) { return new (t || QueryService)(i0.ɵɵinject(i1$2.HttpClient)); };
QueryService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: QueryService, factory: QueryService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(QueryService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1$2.HttpClient }]; }, null); })();

/**
 * Whether a layer is queryable
 * @param layer Layer
 * @returns True if the layer s squeryable
 */
function layerIsQueryable(layer) {
    const dataSource = layer.dataSource;
    return dataSource.options.queryable === true;
}
/**
 * Whether an OL layer is queryable
 * @param layer Layer
 * @returns True if the ol layer is queryable
 */
function olLayerIsQueryable(olLayer) {
    const layer = olLayer.get('_layer');
    return layer === undefined ? false : layerIsQueryable(layer);
}
/**
 * Whether a layer's feature is queryable
 * @param layer Layer
 * @returns True if the layer's feature is queryable
 */
function layerFeatureIsQueryable(layer) {
    const dataSource = layer.dataSource;
    return dataSource.options.queryLayerFeatures !== undefined ? (dataSource.options.queryLayerFeatures === true) : true;
}
/**
 * Whether an OL Vector layer is queryable
 * @param layer Layer
 * @returns True if the ol vector layer is queryable
 */
function olLayerFeatureIsQueryable(olLayer) {
    const layer = olLayer.get('_layer');
    return layer === undefined ? false : (layerIsQueryable(layer) && layerFeatureIsQueryable(layer));
}

/**
 * This directive makes a map queryable with a click of with a drag box.
 * By default, all layers are queryable but this can ben controlled at
 * the layer level.
 */
class QueryDirective {
    constructor(component, queryService) {
        this.component = component;
        this.queryService = queryService;
        /**
         * Subscriptions to ongoing queries
         */
        this.queries$$ = [];
        /**
         * Whter to query features or not
         */
        this.queryFeatures = false;
        /**
         * Feature query hit tolerance
         */
        this.queryFeaturesHitTolerance = 0;
        /**
         * Whether all query should complete before emitting an event
         */
        this.waitForAllQueries = true;
        /**
         * Event emitted when a query (or all queries) complete
         */
        this.query = new EventEmitter();
    }
    /**
     * IGO map
     * @internal
     */
    get map() {
        return this.component.map;
    }
    /**
     * Start listening to click and drag box events
     * @internal
     */
    ngAfterViewInit() {
        this.listenToMapClick();
        this.addDragBoxInteraction();
    }
    /**
     * Stop listening to click and drag box events and cancel ongoind requests
     * @internal
     */
    ngOnDestroy() {
        this.cancelOngoingQueries();
        this.unlistenToMapClick();
        this.removeDragBoxInteraction();
    }
    /**
     * On map click, issue queries
     */
    listenToMapClick() {
        this.mapClickListener = this.map.ol.on('singleclick', (event) => this.onMapEvent(event));
    }
    /**
     * Stop listening for map clicks
     */
    unlistenToMapClick() {
        unByKey(this.mapClickListener);
        this.mapClickListener = undefined;
    }
    /**
     * Issue queries from a map event and emit events with the results
     * @param event OL map browser pointer event
     */
    onMapEvent(event) {
        this.cancelOngoingQueries();
        if (!this.queryService.queryEnabled) {
            return;
        }
        const queries$ = [];
        if (this.queryFeatures) {
            queries$.push(this.doQueryFeatures(event));
        }
        const resolution = this.map.ol.getView().getResolution();
        const queryLayers = this.map.layers.filter(layerIsQueryable);
        queries$.push(...this.queryService.query(queryLayers, {
            coordinates: event.coordinate,
            projection: this.map.projection,
            resolution
        }));
        if (queries$.length === 0) {
            return;
        }
        if (this.waitForAllQueries) {
            this.queries$$.push(zip(...queries$).subscribe((results) => {
                const features = [].concat(...results);
                this.query.emit({ features, event });
            }));
        }
        else {
            this.queries$$ = queries$.map((query$) => {
                return query$.subscribe((features) => {
                    this.query.emit({ features, event });
                });
            });
        }
    }
    /**
     * Query features already present on the map
     * @param event OL map browser pointer event
     */
    doQueryFeatures(event) {
        const clickedFeatures = [];
        if (event.type === 'singleclick') {
            this.map.ol.forEachFeatureAtPixel(event.pixel, (featureOL, layerOL) => {
                const layer = this.map.getLayerById(layerOL.values_._layer.id);
                if (layer.dataSource.options.queryFormatAsWms) {
                    return;
                }
                if (featureOL) {
                    if (featureOL.get('features')) {
                        for (const feature of featureOL.get('features')) {
                            const newFeature = featureFromOl(feature, this.map.projection);
                            newFeature.meta = {
                                title: feature.values_.nom,
                                id: layerOL.values_._layer.id + '.' + feature.id_,
                                icon: feature.values_._icon,
                                sourceTitle: layerOL.values_.title,
                                alias: this.queryService.getAllowedFieldsAndAlias(layer),
                                // title: this.queryService.getQueryTitle(newFeature, layer) || newFeature.meta.title
                            };
                            clickedFeatures.push(newFeature);
                        }
                    }
                    else if (featureOL instanceof RenderFeature) {
                        const newFeature = renderFeatureFromOl(featureOL, this.map.projection, layerOL);
                        newFeature.meta = {
                            id: layerOL.values_._layer.id + '.' + newFeature.meta.id,
                            sourceTitle: layerOL.values_.title,
                            alias: this.queryService.getAllowedFieldsAndAlias(layer),
                            title: this.queryService.getQueryTitle(newFeature, layer) || newFeature.meta.title
                        };
                        clickedFeatures.push(newFeature);
                    }
                    else {
                        const newFeature = featureFromOl(featureOL, this.map.projection, layerOL);
                        newFeature.meta = {
                            id: layerOL.values_._layer.id + '.' + newFeature.meta.id,
                            sourceTitle: layerOL.values_.title,
                            alias: this.queryService.getAllowedFieldsAndAlias(layer),
                            title: this.queryService.getQueryTitle(newFeature, layer) || newFeature.meta.title
                        };
                        clickedFeatures.push(newFeature);
                    }
                }
            }, {
                hitTolerance: this.queryFeaturesHitTolerance || 0,
                layerFilter: this.queryFeaturesCondition
                    ? this.queryFeaturesCondition
                    : olLayerFeatureIsQueryable
            });
        }
        else if (event.type === 'boxend') {
            const target = event.target;
            const dragExtent = target.getGeometry().getExtent();
            this.map.layers
                .filter(layerIsQueryable)
                .filter(layer => layer instanceof VectorLayer && layer.visible)
                .map(layer => {
                const featuresOL = layer.dataSource.ol;
                featuresOL.forEachFeatureIntersectingExtent(dragExtent, (olFeature) => {
                    const newFeature = featureFromOl(olFeature, this.map.projection, layer.ol);
                    newFeature.meta = {
                        id: layer.id + '.' + olFeature.getId(),
                        icon: olFeature.values_._icon,
                        sourceTitle: layer.title,
                        alias: this.queryService.getAllowedFieldsAndAlias(layer),
                        title: this.queryService.getQueryTitle(newFeature, layer) || newFeature.meta.title
                    };
                    clickedFeatures.push(newFeature);
                });
            });
        }
        return of(clickedFeatures);
    }
    /**
     * Cancel ongoing requests, if any
     */
    cancelOngoingQueries() {
        this.queries$$.forEach((sub) => sub.unsubscribe());
        this.queries$$ = [];
    }
    /**
     * Add a drag box interaction and, on drag box end, select features
     */
    addDragBoxInteraction() {
        let olDragSelectInteractionOnQuery;
        const olInteractions = this.map.ol.getInteractions().getArray();
        // There can only be one dragbox interaction, so find the current one, if any
        // Don't keep a reference to the current dragbox because we don't want
        // to remove it when this startegy is deactivated
        for (const olInteraction of olInteractions) {
            if (olInteraction instanceof OlDragSelectInteraction) {
                olDragSelectInteractionOnQuery = olInteraction;
                break;
            }
        }
        // If no drag box interaction is found, create a new one and add it to the map
        if (olDragSelectInteractionOnQuery === undefined) {
            olDragSelectInteractionOnQuery = new OlDragSelectInteraction({
                condition: ctrlKeyDown
            });
            this.map.ol.addInteraction(olDragSelectInteractionOnQuery);
            this.olDragSelectInteraction = olDragSelectInteractionOnQuery;
        }
        this.olDragSelectInteractionEndKey = olDragSelectInteractionOnQuery.on('boxend', (event) => this.onMapEvent(event));
    }
    /**
     * Remove drag box interaction
     */
    removeDragBoxInteraction() {
        if (this.olDragSelectInteractionEndKey !== undefined) {
            unByKey(this.olDragSelectInteractionEndKey);
        }
        if (this.olDragSelectInteraction !== undefined) {
            this.map.ol.removeInteraction(this.olDragSelectInteraction);
        }
        this.olDragSelectInteraction = undefined;
    }
}
QueryDirective.ɵfac = function QueryDirective_Factory(t) { return new (t || QueryDirective)(i0.ɵɵdirectiveInject(MapBrowserComponent, 2), i0.ɵɵdirectiveInject(QueryService)); };
QueryDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: QueryDirective, selectors: [["", "igoQuery", ""]], inputs: { queryFeatures: "queryFeatures", queryFeaturesHitTolerance: "queryFeaturesHitTolerance", queryFeaturesCondition: "queryFeaturesCondition", waitForAllQueries: "waitForAllQueries" }, outputs: { query: "query" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(QueryDirective, [{
        type: Directive,
        args: [{
                selector: '[igoQuery]'
            }]
    }], function () { return [{ type: MapBrowserComponent, decorators: [{
                type: Self
            }] }, { type: QueryService }]; }, { queryFeatures: [{
            type: Input
        }], queryFeaturesHitTolerance: [{
            type: Input
        }], queryFeaturesCondition: [{
            type: Input
        }], waitForAllQueries: [{
            type: Input
        }], query: [{
            type: Output
        }] }); })();

/**
 * Base search source class
 */
class SearchSource {
    constructor(options, storageService) {
        this.storageService = storageService;
        this.options = options;
        if (this.storageService) {
            const storageOptions = this.storageService.get(this.getId() + '.options');
            if (storageOptions) {
                this.options = ObjectUtils.mergeDeep(this.options, storageOptions);
            }
        }
        this.options = ObjectUtils.mergeDeep(this.getDefaultOptions(), this.options);
        // Set Default Params from Settings
        this.settings.forEach(setting => {
            this.setParamFromSetting(setting, false);
        });
    }
    /**
     * Get search source's id
     * @returns Search source's id
     */
    getId() {
        throw new Error('You have to implement the method "getId".');
    }
    /**
     * Get search source's type
     * @returns Search source's type
     */
    getType() {
        throw new Error('You have to implement the method "getType".');
    }
    /**
     * Get search source's default options
     * @returns Search source default options
     */
    getDefaultOptions() {
        throw new Error('You have to implement the method "getDefaultOptions".');
    }
    /**
     * Search source's title
     */
    get title() {
        return this.options.title;
    }
    /**
     * Whether the search source is available
     */
    get available() {
        return this.options.available !== false;
    }
    /**
     * Whether the search source is enabled
     */
    set enabled(value) {
        this.options.enabled = value;
    }
    get enabled() {
        return this.available && this.options.enabled !== false;
    }
    get showInPointerSummary() {
        const showInPointerSummary = this.options.showInPointerSummary;
        return showInPointerSummary ? showInPointerSummary : false;
    }
    get showInSettings() {
        const showInSettings = this.options.showInSettings;
        return showInSettings === undefined ? true : showInSettings;
    }
    /**
     * Search url
     */
    get searchUrl() {
        return this.options.searchUrl;
    }
    /**
     * Search query params
     */
    get params() {
        return this.options.params === undefined ? {} : this.options.params;
    }
    /**
     * Search settings
     */
    get settings() {
        return this.options.settings === undefined ? [] : this.options.settings;
    }
    /**
     * Set params from selected settings
     */
    setParamFromSetting(setting, saveInStorage = true) {
        switch (setting.type) {
            case 'radiobutton':
                setting.values.forEach(conf => {
                    if (conf.enabled) {
                        this.options.params = Object.assign(this.options.params || {}, {
                            [setting.name]: conf.value
                        });
                    }
                });
                break;
            case 'checkbox':
                let confValue = '';
                setting.values
                    .filter(s => s.available !== false)
                    .forEach(conf => {
                    if (conf.enabled) {
                        confValue += conf.value + ',';
                    }
                });
                confValue = confValue.slice(0, -1);
                this.options.params = Object.assign(this.options.params || {}, {
                    [setting.name]: confValue
                });
                break;
        }
        if (saveInStorage && this.storageService) {
            this.storageService.set(this.getId() + '.options', { params: this.options.params });
        }
    }
    /**
     * Search results display order
     */
    get displayOrder() {
        return this.options.order === undefined ? 99 : this.options.order;
    }
    /**
     * Get hashtags valid
     * @param hashtag hashtag from query
     */
    getHashtagsValid(term, settingsName) {
        const hashtags = term.match(/(#[A-Za-z]+)/g);
        if (!hashtags) {
            return undefined;
        }
        const searchSourceSetting = this.getSettingsValues(settingsName);
        const hashtagsValid = [];
        hashtags.forEach(hashtag => {
            searchSourceSetting.values.forEach(conf => {
                const hashtagKey = hashtag.substring(1);
                if (typeof conf.value === 'string') {
                    const types = conf.value
                        .toLowerCase()
                        .normalize('NFD')
                        .replace(/[\u0300-\u036f]/g, '')
                        .split(',');
                    const index = types.indexOf(hashtagKey
                        .toLowerCase()
                        .normalize('NFD')
                        .replace(/[\u0300-\u036f]/g, ''));
                    if (index !== -1) {
                        hashtagsValid.push(types[index]);
                    }
                }
                if (conf.hashtags && conf.hashtags.indexOf(hashtagKey.toLowerCase()) !== -1) {
                    hashtagsValid.push(conf.value);
                }
            });
        });
        return hashtagsValid.filter((a, b) => hashtagsValid.indexOf(a) === b);
    }
    getSettingsValues(search) {
        return this.getDefaultOptions().settings.find((value) => {
            return value.name === search;
        });
    }
}
/**
 * Search source ID
 * @internal
 */
SearchSource.id = '';
/**
 * Search source type
 * @internal
 */
SearchSource.type = '';

/**
 * Map search source. For now it has no search capability. All it does
 * is act as a placeholder for the map query results' "search source".
 */
class QuerySearchSource extends SearchSource {
    constructor(options) {
        super(options);
    }
    getId() {
        return QuerySearchSource.id;
    }
    getType() {
        return QuerySearchSource.type;
    }
    getDefaultOptions() {
        return {
            title: 'Carte'
        };
    }
}
QuerySearchSource.id = 'map';
QuerySearchSource.type = FEATURE;
QuerySearchSource.ɵfac = function QuerySearchSource_Factory(t) { return new (t || QuerySearchSource)(i0.ɵɵinject('options')); };
QuerySearchSource.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: QuerySearchSource, factory: QuerySearchSource.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(QuerySearchSource, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: ['options']
            }] }]; }, null); })();

class GoogleLinks {
    static getGoogleMapsCoordLink(lon, lat) {
        return 'https://www.google.com/maps?q=' + lat + ',' + lon;
    }
    static getGoogleStreetViewLink(lon, lat) {
        return 'https://www.google.com/maps?q=&layer=c&cbll=' + lat + ',' + lon;
    }
    static getGoogleMapsNameLink(name) {
        const encodedName = encodeURI(name);
        return 'https://www.google.com/maps?q=' + encodedName;
    }
}

/**
 * Generate a style for selected features
 * @param feature The feature to generate the style
 * @returns A olStyle
 */
function getCommonVectorSelectedStyle({ feature, markerColor = [0, 161, 222], markerOpacity = 1, markerOutlineColor = [0, 255, 255], fillColor, fillOpacity = 0.15, strokeColor = [0, 255, 255], strokeOpacity = 0.5, strokeWidth = 4 }) {
    return getCommonVectorStyle({
        feature,
        markerColor,
        markerOpacity,
        markerOutlineColor,
        fillColor,
        fillOpacity,
        strokeColor,
        strokeOpacity,
        strokeWidth
    });
}
/**
 * Generate a basic style for features
 * @param feature The feature to generate the style
 * @returns A olStyle
 */
function getCommonVectorStyle({ feature, markerColor = [0, 161, 222], markerOpacity = 0.5, markerOutlineColor, fillColor = [0, 161, 222], fillOpacity = 0.15, strokeColor = [0, 161, 222], strokeOpacity = 0.5, strokeWidth = 2 }) {
    const isOlFeature = feature instanceof OlFeature;
    let geometry;
    let text;
    if (isOlFeature) {
        feature = feature;
        geometry = feature.getGeometry();
    }
    else {
        feature = feature;
        geometry = feature.geometry;
        text = feature.meta.mapTitle;
    }
    const geometryType = isOlFeature ? geometry.getType() : geometry.type;
    if (!geometry || geometryType === 'Point') {
        const markerColorAsArray = asArray(markerColor).slice(0);
        const markerColorRGB = markerColorAsArray.slice(0, 3);
        if (markerColorAsArray.length === 4 &&
            (typeof markerColor !== 'string' || /^#[0-9A-F]{8}$/i.test(markerColor))) {
            markerOpacity = markerColorAsArray[3];
        }
        return createOverlayMarkerStyle({
            text,
            opacity: markerOpacity,
            markerOutlineColor,
            markerColor: markerColorRGB
        });
    }
    else {
        const fillWithOpacity = asArray(fillColor).slice(0);
        const strokeWithOpacity = asArray(strokeColor).slice(0);
        if (!(fillWithOpacity.length === 4 &&
            (typeof fillColor !== 'string' || /^#[0-9A-F]{8}$/i.test(fillColor)))) {
            fillWithOpacity[3] = fillOpacity;
        }
        if (!(strokeWithOpacity.length === 4 &&
            (typeof strokeColor !== 'string' || /^#[0-9A-F]{8}$/i.test(strokeColor)))) {
            strokeWithOpacity[3] = strokeOpacity;
        }
        return createOverlayDefaultStyle({
            text,
            strokeWidth,
            strokeColor: strokeWithOpacity,
            fillColor: fillWithOpacity
        });
    }
}

class OsmLinks {
    static getOpenStreetMapLink(lon, lat, zoom = 17) {
        // return 'https://www.google.com/maps?q=' + lat + ',' + lon;
        return `https://www.openstreetmap.org/?mlat=${lat}&mlon=${lon}#map=${zoom}/${lat}/${lon}`;
    }
    static getOpenStreetCamLink(lon, lat, zoom = 17) {
        return `https://openstreetcam.org/map/@${lat},${lon},${zoom}z`;
    }
}

class CatalogService {
    constructor(http, config, languageService, messageService, capabilitiesService) {
        this.http = http;
        this.config = config;
        this.languageService = languageService;
        this.messageService = messageService;
        this.capabilitiesService = capabilitiesService;
    }
    loadCatalogs() {
        const contextConfig = this.config.getConfig('context') || {};
        const catalogConfig = this.config.getConfig('catalog') || {};
        const apiUrl = catalogConfig.url || contextConfig.url;
        const catalogsFromConfig = catalogConfig.sources || [];
        const observables$ = [];
        if (apiUrl) {
            // Base layers catalog
            if (catalogConfig.baseLayers) {
                const translate = this.languageService.translate;
                const title = translate.instant('igo.geo.catalog.baseLayers');
                const baseLayersCatalog = [
                    {
                        id: 'catalog.baselayers',
                        title,
                        url: `${apiUrl}/baselayers`,
                        type: 'baselayers'
                    }
                ];
                observables$.push(of(baseLayersCatalog));
            }
            // Catalogs from API
            const catalogsFromApi$ = this.http
                .get(`${apiUrl}/catalogs`)
                .pipe(map((catalogs) => catalogs.map((c) => Object.assign(c, c.options))), catchError((_response) => EMPTY));
            observables$.push(catalogsFromApi$);
        }
        // Catalogs from config
        if (catalogsFromConfig.length > 0) {
            observables$.push(of(catalogsFromConfig).pipe(map((catalogs) => catalogs.map((c) => {
                if (!c.id) {
                    c.id = uuid();
                }
                return c;
            }))));
        }
        return zip(...observables$).pipe(map((catalogs) => [].concat.apply([], catalogs)));
    }
    loadCatalogItems(catalog) {
        let newCatalog;
        newCatalog = CatalogFactory.createInstanceCatalog(catalog, this);
        return newCatalog.collectCatalogItems();
    }
    loadCatalogBaseLayerItems(catalog) {
        return this.getCatalogBaseLayersOptions(catalog).pipe(map((layersOptions) => {
            const items = layersOptions.map((layerOptions) => {
                return {
                    id: generateIdFromSourceOptions(layerOptions.sourceOptions),
                    title: layerOptions.title,
                    type: CatalogItemType.Layer,
                    externalProvider: catalog.externalProvider,
                    options: layerOptions
                };
            });
            return [
                {
                    id: 'catalog.group.baselayers',
                    type: CatalogItemType.Group,
                    externalProvider: catalog.externalProvider,
                    title: catalog.title,
                    items
                }
            ];
        }));
    }
    getCatalogBaseLayersOptions(catalog) {
        return this.http.get(catalog.url);
    }
    loadCatalogWMSLayerItems(catalog) {
        return this.getCatalogCapabilities(catalog).pipe(map((capabilities) => {
            const items = [];
            if (!capabilities) {
                return items;
            }
            if (capabilities.Service && capabilities.Service.Abstract && capabilities.Service.Abstract.length) {
                catalog.abstract = capabilities.Service.Abstract;
            }
            const finalLayers = [];
            this.flattenWmsCapabilities(capabilities.Capability.Layer, 0, finalLayers, catalog.groupSeparator);
            const capabilitiesCapabilityLayer = Object.assign({}, capabilities.Capability.Layer);
            capabilitiesCapabilityLayer.Layer = finalLayers.filter(f => f.Layer.length !== 0);
            this.includeRecursiveItems(catalog, capabilitiesCapabilityLayer, items);
            return items;
        }));
    }
    flattenWmsCapabilities(parent, level = 0, finalLayers, separator = ' / ') {
        if (!finalLayers.includes(parent.Title)) {
            const modifiedParent = Object.assign({}, parent);
            modifiedParent.Layer = [];
            finalLayers.push(modifiedParent);
        }
        for (const layer of parent.Layer) {
            const modifiedLayer = Object.assign({}, layer);
            if (level > 0) {
                modifiedLayer.Title = parent.Title + separator + layer.Title;
            }
            if (layer.Layer) {
                this.flattenWmsCapabilities(modifiedLayer, level + 1, finalLayers, separator);
            }
            else {
                finalLayers.find(ff => ff.Title === parent.Title).Layer.push(layer);
            }
        }
    }
    loadCatalogWMTSLayerItems(catalog) {
        return this.getCatalogCapabilities(catalog).pipe(map((capabilities) => this.getWMTSItems(catalog, capabilities)));
    }
    loadCatalogArcGISRestItems(catalog) {
        return this.getCatalogCapabilities(catalog).pipe(map((capabilities) => {
            return this.getArcGISRESTItems(catalog, capabilities);
        }));
    }
    loadCatalogCompositeLayerItems(catalog) {
        const compositeCatalog = catalog.composite;
        const catalogsFromInstance = [];
        compositeCatalog.map((component) => {
            component.sortDirection = catalog.sortDirection; // propagate sortDirection with parent value
            catalogsFromInstance.push(CatalogFactory.createInstanceCatalog(component, this));
        });
        // get CatalogItems for each original Catalog-----------------------------------------------------
        const request1$ = [];
        catalogsFromInstance.map((component) => request1$.push(component.collectCatalogItems()));
        // integrate imposed group -----------------------------------------------------
        let request2$ = [];
        function flatDeepLayer(arr) {
            return arr.reduce((acc, val) => acc.concat(val.type === CatalogItemType.Group ? flatDeepLayer(val.items) : val), []);
        }
        if (Object.keys(compositeCatalog).find((k) => compositeCatalog[k].groupImpose)) {
            const pushImposeGroup = (item, index) => {
                const c = catalogsFromInstance[index];
                const outGroupImpose = Object.assign({}, c.groupImpose);
                outGroupImpose.address = c.id;
                outGroupImpose.type = CatalogItemType.Group;
                outGroupImpose.externalProvider = c.externalProvider;
                if (outGroupImpose.sortDirection === undefined) {
                    outGroupImpose.sortDirection = c.sortDirection;
                }
                outGroupImpose.items = [];
                const flatLayer = flatDeepLayer(item);
                flatLayer.map((v) => (v.address = `${outGroupImpose.address}.${outGroupImpose.id}`));
                outGroupImpose.items = flatLayer;
                return outGroupImpose;
            };
            request2$ = request1$.map((obs, idx) => obs.pipe(map((items) => compositeCatalog[idx].groupImpose
                ? pushImposeGroup(items, idx)
                : items)));
        }
        else {
            request2$ = request1$;
        }
        // concat Group -----------------------------------------------------
        const request3$ = zip(...request2$).pipe(map((output) => [].concat(...output) // [].concat.apply([], result1
        ));
        // merge Group (first level only) -----------------------------------------------------
        const groupByGroupId = (data, keyFn) => data.reduce((acc, group) => {
            const groupId = keyFn(group);
            const ind = acc.find((x) => x.id === groupId);
            if (!ind) {
                acc[acc.length] = group;
            }
            else {
                const ix = acc.indexOf(ind);
                if (acc[ix].address.split('|').indexOf(group.address) === -1) {
                    acc[ix].address = `${acc[ix].address}|${group.address}`;
                }
                acc[ix].items.push(...group.items);
            }
            return acc;
        }, []);
        // merge Layer for each Level (catalog, group(recursive))
        const recursiveGroupByLayerAddress = (items, keyFn) => items.reduce((acc, item, idx, arr) => {
            const layerTitle = keyFn(item);
            const outItem = Object.assign({}, item);
            if (item.type === CatalogItemType.Layer) {
                // same title, same address => result: only one item is keep
                // same title, address diff
                const indicesMatchTitle = [];
                const diffAddress = arr.filter((x, i) => {
                    let bInd = false;
                    if (x.title === layerTitle && x.type === CatalogItemType.Layer) {
                        if (i !== idx && x.address !== item.address) {
                            bInd = true;
                        }
                        indicesMatchTitle.push(i);
                    }
                    return bInd;
                }); // $& i !== idx
                if (diffAddress.length > 0) {
                    const nPosition = indicesMatchTitle.findIndex((x) => x === idx) + 1;
                    outItem.title = `${item.title} (${nPosition})`; // source: ${item.address.split('.')[0]}
                }
                const exist = acc.find((x) => x.title === outItem.title && x.type === CatalogItemType.Layer);
                if (!exist) {
                    acc[acc.length] = outItem;
                }
            }
            else if (item.type === CatalogItemType.Group) {
                outItem.items = recursiveGroupByLayerAddress(item.items, (layer) => layer.title);
                acc[acc.length] = outItem;
            }
            return acc;
        }, []);
        const request4$ = request3$.pipe(map((output) => groupByGroupId(output, (group) => group.id)), map((output) => [].concat(...output)), map((data) => recursiveGroupByLayerAddress(data, (layer) => layer.title)));
        return request4$;
    }
    getCatalogCapabilities(catalog) {
        const sType = TypeCatalog[catalog.type];
        return this.capabilitiesService
            .getCapabilities(sType, catalog.url, catalog.version)
            .pipe(catchError((e) => {
            const title = this.languageService.translate.instant('igo.geo.catalog.unavailableTitle');
            const message = catalog.title ? this.languageService.translate.instant('igo.geo.catalog.unavailable', { value: catalog.title }) : this.languageService.translate.instant('igo.geo.catalog.someUnavailable');
            this.messageService.error(message, title);
            console.error(e);
            return of(undefined);
        }));
    }
    prepareCatalogItemLayer(layer, idParent, layersQueryFormat, catalog) {
        const configuredQueryFormat = this.retrieveLayerInfoFormat(layer.Name, layersQueryFormat);
        const metadata = layer.DataURL ? layer.DataURL[0] : undefined;
        const legendOptions = catalog.showLegend && layer.Style
            ? this.capabilitiesService.getStyle(layer.Style)
            : undefined;
        const params = Object.assign({}, catalog.queryParams, {
            LAYERS: layer.Name,
            VERSION: catalog.version
        });
        const baseSourceOptions = {
            type: 'wms',
            url: catalog.url,
            crossOrigin: catalog.setCrossOriginAnonymous ? 'anonymous' : undefined,
            queryFormat: configuredQueryFormat,
            queryHtmlTarget: configuredQueryFormat === QueryFormat.HTML ||
                configuredQueryFormat === QueryFormat.HTMLGML2
                ? 'iframe'
                : undefined,
            optionsFromCapabilities: true
        };
        const sourceOptions = Object.assign({}, baseSourceOptions, catalog.sourceOptions, { params });
        let layerTitle;
        if (catalog.forcedProperties) {
            for (const property of catalog.forcedProperties) {
                if (layer.Name === property.layerName && property.title) {
                    layerTitle = property.title;
                }
            }
        }
        let abstract;
        if (layer.Abstract) {
            abstract = layer.Abstract;
        }
        else if (!layer.Abstract && catalog.abstract) {
            abstract = catalog.abstract;
        }
        const layerPrepare = {
            id: generateIdFromSourceOptions(sourceOptions),
            type: CatalogItemType.Layer,
            title: layerTitle !== undefined ? layerTitle : layer.Title,
            address: idParent,
            externalProvider: catalog.externalProvider || false,
            options: {
                maxResolution: getResolutionFromScale(layer.MaxScaleDenominator),
                minResolution: getResolutionFromScale(layer.MinScaleDenominator),
                metadata: {
                    url: metadata ? metadata.OnlineResource : undefined,
                    extern: metadata ? true : undefined,
                    abstract,
                    type: baseSourceOptions.type
                },
                legendOptions,
                tooltip: { type: catalog.tooltipType },
                sourceOptions
            }
        };
        return ObjectUtils.removeUndefined(layerPrepare);
    }
    prepareCatalogItemGroup(itemListIn, regexes, idGroup, layersQueryFormat, catalog) {
        const groupPrepare = {
            id: idGroup,
            type: CatalogItemType.Group,
            title: itemListIn.Title,
            address: catalog.id,
            externalProvider: catalog.externalProvider || false,
            sortDirection: catalog.sortDirection,
            items: itemListIn.Layer.reduce((items, layer) => {
                if (layer.Layer !== undefined) {
                    // recursive, check next level
                    const idGroupItemNextLevel = idGroup + `.group.${layer.Name || layer.Layer[0].Name}`;
                    const groupItem = this.prepareCatalogItemGroup(layer, regexes, idGroupItemNextLevel, layersQueryFormat, catalog);
                    items.push(groupItem);
                }
                else {
                    if (this.testLayerRegexes(layer.Name, regexes) === false) {
                        return items;
                    }
                    const layerItem = this.prepareCatalogItemLayer(layer, idGroup, layersQueryFormat, catalog);
                    items.push(layerItem);
                }
                return items;
            }, [])
        };
        return groupPrepare;
    }
    includeRecursiveItems(catalog, itemListIn, itemsPrepare, loopLevel = 0) {
        // Dig all levels until last level (layer object are not defined on last level)
        const regexes = (catalog.regFilters || []).map((pattern) => new RegExp(pattern));
        if (!itemListIn.Layer) {
            return;
        }
        for (const item of itemListIn.Layer) {
            if (item.Layer !== undefined) {
                // recursive, check next level
                this.includeRecursiveItems(catalog, item, itemsPrepare, loopLevel + 1);
                continue;
            }
            const layersQueryFormat = this.findCatalogInfoFormat(catalog);
            // group(with layers) and layer(without group) level 1
            if (loopLevel !== 0) {
                // TODO: Slice that into multiple methods
                // Define object of group layer
                const idGroupItem = `catalog.group.${itemListIn.Name || item.Name}`;
                const groupItem = this.prepareCatalogItemGroup(itemListIn, regexes, idGroupItem, layersQueryFormat, catalog);
                if (groupItem.items.length !== 0) {
                    itemsPrepare.push(groupItem);
                }
                // Break the group (don't add a group of layer for each of their layer!)
                break;
            }
            else {
                // layer without group
                if (this.testLayerRegexes(item.Name, regexes) !== false) {
                    const layerItem = this.prepareCatalogItemLayer(item, catalog.id, layersQueryFormat, catalog);
                    itemsPrepare.push(layerItem);
                }
            }
        }
    }
    getWMTSItems(catalog, capabilities) {
        if (!capabilities) {
            return [];
        }
        const layers = capabilities.Contents.Layer;
        const regexes = (catalog.regFilters || []).map((pattern) => new RegExp(pattern));
        if (capabilities.ServiceIdentification &&
            capabilities.ServiceIdentification.Abstract &&
            capabilities.ServiceIdentification.Abstract.length) {
            catalog.abstract = capabilities.ServiceIdentification.Abstract;
        }
        return layers
            .map((layer) => {
            let forcedTitle;
            if (catalog.forcedProperties) {
                for (const property of catalog.forcedProperties) {
                    if (layer.Title === property.layerName && property.title) {
                        forcedTitle = property.title;
                    }
                }
            }
            if (this.testLayerRegexes(layer.Identifier, regexes) === false) {
                return undefined;
            }
            const params = Object.assign({}, catalog.queryParams, {
                version: '1.0.0'
            });
            const baseSourceOptions = {
                type: 'wmts',
                url: catalog.url,
                crossOrigin: catalog.setCrossOriginAnonymous
                    ? 'anonymous'
                    : undefined,
                layer: layer.Identifier,
                matrixSet: catalog.matrixSet,
                optionsFromCapabilities: true,
                requestEncoding: catalog.requestEncoding || 'KVP',
                style: 'default'
            };
            const sourceOptions = Object.assign({}, baseSourceOptions, catalog.sourceOptions, { params });
            return ObjectUtils.removeUndefined({
                id: generateIdFromSourceOptions(sourceOptions),
                type: CatalogItemType.Layer,
                title: forcedTitle !== undefined ? forcedTitle : layer.Title,
                address: catalog.id,
                externalProvider: catalog.externalProvider,
                options: {
                    sourceOptions,
                    metadata: {
                        url: undefined,
                        extern: undefined,
                        abstract: catalog.abstract,
                        type: baseSourceOptions.type
                    }
                }
            });
        })
            .filter((item) => item !== undefined);
    }
    getArcGISRESTItems(catalog, capabilities) {
        if (!capabilities) {
            return [];
        }
        const layers = !capabilities.layers ? [] : capabilities.layers.filter(layer => !layer.type || layer.type === 'Feature Layer');
        if (!capabilities.layers) {
            this.messageService.error(this.languageService.translate.instant('igo.geo.catalog.someUnavailable'), this.languageService.translate.instant('igo.geo.catalog.unavailableTitle'));
        }
        const regexes = (catalog.regFilters || []).map((pattern) => new RegExp(pattern));
        let abstract;
        if (capabilities.serviceDescription && capabilities.serviceDescription.length) {
            const regex = /(<([^>]+)>)/ig;
            abstract = capabilities.serviceDescription.replace(regex, '');
        }
        return layers
            .map((layer) => {
            let forcedTitle;
            if (catalog.forcedProperties) {
                for (const property of catalog.forcedProperties) {
                    if (layer.name === property.layerName && property.title) {
                        forcedTitle = property.title;
                    }
                }
            }
            if (this.testLayerRegexes(layer.id, regexes) === false) {
                return undefined;
            }
            const baseSourceOptions = {
                type: TypeCatalog[catalog.type],
                url: catalog.url,
                crossOrigin: catalog.setCrossOriginAnonymous
                    ? 'anonymous'
                    : undefined,
                layer: layer.id,
                queryable: true,
                queryFormat: 'esrijson',
                matrixSet: catalog.matrixSet,
                optionsFromCapabilities: true,
                style: 'default'
            };
            const sourceOptions = Object.assign({}, baseSourceOptions, catalog.sourceOptions);
            return ObjectUtils.removeUndefined({
                id: generateIdFromSourceOptions(sourceOptions),
                type: CatalogItemType.Layer,
                title: forcedTitle !== undefined ? forcedTitle : layer.name,
                externalProvider: catalog.externalProvider,
                address: catalog.id,
                options: {
                    sourceOptions,
                    minResolution: getResolutionFromScale(layer.maxScale),
                    maxResolution: getResolutionFromScale(layer.minScale),
                    metadata: {
                        url: undefined,
                        extern: undefined,
                        abstract,
                        type: baseSourceOptions.type
                    },
                    title: forcedTitle !== undefined ? forcedTitle : layer.name
                }
            });
        })
            .filter((item) => item !== undefined);
    }
    testLayerRegexes(layerName, regexes) {
        if (regexes.length === 0) {
            return true;
        }
        return regexes.find((regex) => regex.test(layerName)) !== undefined;
    }
    retrieveLayerInfoFormat(layerNameFromCatalog, layersQueryFormat) {
        const currentLayerInfoFormat = layersQueryFormat.find((f) => f.layer === layerNameFromCatalog);
        const baseInfoFormat = layersQueryFormat.find((f) => f.layer === '*');
        let queryFormat;
        if (currentLayerInfoFormat) {
            queryFormat = currentLayerInfoFormat.queryFormat;
        }
        else if (baseInfoFormat) {
            queryFormat = baseInfoFormat.queryFormat;
        }
        return queryFormat;
    }
    findCatalogInfoFormat(catalog) {
        const layersQueryFormat = [];
        if (!catalog.queryFormat) {
            return layersQueryFormat;
        }
        Object.keys(catalog.queryFormat).forEach((configuredInfoFormat) => {
            if (catalog.queryFormat[configuredInfoFormat] instanceof Array) {
                catalog.queryFormat[configuredInfoFormat].forEach((layerName) => {
                    if (!layersQueryFormat.find((specific) => specific.layer === layerName)) {
                        layersQueryFormat.push({
                            layer: layerName,
                            queryFormat: configuredInfoFormat
                        });
                    }
                });
            }
            else {
                if (!layersQueryFormat.find((specific) => specific.layer === catalog.queryFormat[configuredInfoFormat])) {
                    layersQueryFormat.push({
                        layer: catalog.queryFormat[configuredInfoFormat],
                        queryFormat: configuredInfoFormat
                    });
                }
            }
        });
        return layersQueryFormat;
    }
}
CatalogService.ɵfac = function CatalogService_Factory(t) { return new (t || CatalogService)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.ConfigService), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i2$1.MessageService), i0.ɵɵinject(CapabilitiesService)); };
CatalogService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CatalogService, factory: CatalogService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CatalogService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.ConfigService }, { type: i2$1.LanguageService }, { type: i2$1.MessageService }, { type: CapabilitiesService }]; }, null); })();

function CatalogBrowserComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "igo-catalog-browser-group", 3);
    i0.ɵɵlistener("addedChange", function CatalogBrowserComponent_ng_template_1_ng_container_0_Template_igo_catalog_browser_group_addedChange_1_listener($event) { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(2); return ctx_r4.onGroupAddedChange($event); })("layerAddedChange", function CatalogBrowserComponent_ng_template_1_ng_container_0_Template_igo_catalog_browser_group_layerAddedChange_1_listener($event) { i0.ɵɵrestoreView(_r5); const ctx_r6 = i0.ɵɵnextContext(2); return ctx_r6.onLayerAddedChange($event); });
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = i0.ɵɵnextContext().$implicit;
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("catalog", ctx_r2.catalog)("group", item_r1)("state", ctx_r2.store.state)("resolution", i0.ɵɵpipeBind1(2, 7, ctx_r2.resolution$))("catalogAllowLegend", ctx_r2.catalogAllowLegend)("collapsed", ctx_r2.store.count === 1 ? false : true)("toggleCollapsed", ctx_r2.toggleCollapsedGroup);
} }
function CatalogBrowserComponent_ng_template_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "igo-catalog-browser-layer", 4);
    i0.ɵɵlistener("addedChange", function CatalogBrowserComponent_ng_template_1_ng_container_1_Template_igo_catalog_browser_layer_addedChange_1_listener($event) { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(2); return ctx_r8.onLayerAddedChange($event); });
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = i0.ɵɵnextContext().$implicit;
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("layer", item_r1)("resolution", i0.ɵɵpipeBind1(2, 4, ctx_r3.resolution$))("catalogAllowLegend", ctx_r3.catalogAllowLegend)("added", ctx_r3.store.state.get(item_r1).added);
} }
function CatalogBrowserComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, CatalogBrowserComponent_ng_template_1_ng_container_0_Template, 3, 9, "ng-container", 2);
    i0.ɵɵtemplate(1, CatalogBrowserComponent_ng_template_1_ng_container_1_Template, 3, 6, "ng-container", 2);
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngIf", ctx_r0.isGroup(item_r1));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.isLayer(item_r1));
} }
/**
 * Component to browse a catalog's groups and layers and display them on a map.
 */
class CatalogBrowserComponent {
    constructor(layerService, cdRef) {
        this.layerService = layerService;
        this.cdRef = cdRef;
        this.catalogAllowLegend = false;
        /**
         * Whether a group can be toggled when it's collapsed
         */
        this.toggleCollapsedGroup = true;
    }
    // private resolution$$: Subscription;
    get resolution$() { return this.map.viewController.resolution$; }
    /**
     * @internal
     */
    ngOnInit() {
        const currentItems = this.map.layers.map((layer) => {
            return {
                id: layer.options.source.id,
                title: layer.title,
                type: CatalogItemType.Layer
            };
        });
        this.store.state.updateMany(currentItems, { added: true }, true);
        if (this.catalog && this.catalog.sortDirection !== undefined) {
            this.store.view.sort({
                direction: this.catalog.sortDirection,
                valueAccessor: (item) => item.title
            });
        }
        const catalogShowLegend = this.catalog ? this.catalog.showLegend : false;
        this.catalogAllowLegend = catalogShowLegend ? catalogShowLegend : this.catalogAllowLegend;
        this.watcher = new EntityStoreWatcher(this.store, this.cdRef);
    }
    ngOnDestroy() {
        this.watcher.destroy();
    }
    /**
     * @internal
     */
    isGroup(item) {
        return item.type === CatalogItemType.Group;
    }
    /**
     * @internal
     */
    isLayer(item) {
        return item.type === CatalogItemType.Layer;
    }
    /**
     * When a layer is added or removed, add or remove it from the map
     * @internal
     * @param event Layer added event
     */
    onLayerAddedChange(event) {
        const layer = event.layer;
        this.store.state.update(layer, { added: event.added }, false);
        event.added ? this.addLayerToMap(layer) : this.removeLayerFromMap(layer);
    }
    /**
     * When a froup is added or removed, add or remove it from the map
     * @internal
     * @param event Group added event
     */
    onGroupAddedChange(event) {
        const group = event.group;
        this.store.state.update(group, { added: event.added }, false);
        event.added ? this.addGroupToMap(group) : this.removeGroupFromMap(group);
    }
    /**
     * Add layer to map
     * @param layer Catalog layer
     */
    addLayerToMap(layer) {
        this.addLayersToMap([layer]);
    }
    /**
     * Remove layer from map
     * @param layer Catalog layer
     */
    removeLayerFromMap(layer) {
        this.removeLayersFromMap([layer]);
    }
    /**
     * Add multiple layers to map
     * @param layers Catalog layers
     */
    addLayersToMap(layers) {
        const layers$ = layers.map((layer) => {
            if (!layer.options.sourceOptions.optionsFromApi) {
                layer.options.sourceOptions.optionsFromApi = true;
            }
            return this.layerService.createAsyncLayer(layer.options);
        });
        zip(...layers$).subscribe((oLayers) => {
            this.store.state.updateMany(layers, { added: true });
            this.map.addLayers(oLayers);
        });
    }
    /**
     * Remove multiple layers from map
     * @param layers Catalog layers
     */
    removeLayersFromMap(layers) {
        layers.forEach((layer) => {
            this.store.state.update(layer, { added: false });
            if (layer.options.baseLayer === true) {
                const oLayer = this.map.getLayerById(layer.options.id);
                if (oLayer !== undefined) {
                    this.map.removeLayer(oLayer);
                }
            }
            else {
                const oLayer = this.map.getLayerById(layer.id);
                if (oLayer !== undefined) {
                    this.map.removeLayer(oLayer);
                }
            }
        });
    }
    /**
     * Sort the layers by title. asc or desc.
     * @internal
     */
    sortCatalogItemsByTitle(items, direction) {
        const returnItem = items.sort((a, b) => {
            const titleA = a.title.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            const titleB = b.title.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            if (titleA < titleB) {
                return -1;
            }
            if (titleA > titleB) {
                return 1;
            }
            return 0;
        });
        switch (direction) {
            case 'asc':
                return returnItem;
            case 'desc':
                return returnItem.reverse();
            default:
                return items;
        }
    }
    /**
     * Add all the layers of a group to map
     * @param group Catalog group
     */
    addGroupToMap(group) {
        let layers = group.items.filter((item) => {
            const added = this.store.state.get(item).added || false;
            return this.isLayer(item) && added === false;
        });
        if (group.sortDirection !== undefined) {
            layers = this.sortCatalogItemsByTitle(layers, group.sortDirection);
        }
        this.addLayersToMap(layers.reverse());
    }
    /**
     * Remove all the layers of a group from map
     * @param group Catalog group
     */
    removeGroupFromMap(group) {
        const layers = group.items.filter((item) => {
            const added = this.store.state.get(item).added || false;
            return this.isLayer(item) && added === true;
        });
        this.removeLayersFromMap(layers);
    }
}
CatalogBrowserComponent.ɵfac = function CatalogBrowserComponent_Factory(t) { return new (t || CatalogBrowserComponent)(i0.ɵɵdirectiveInject(LayerService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
CatalogBrowserComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: CatalogBrowserComponent, selectors: [["igo-catalog-browser"]], inputs: { catalogAllowLegend: "catalogAllowLegend", catalog: "catalog", store: "store", map: "map", toggleCollapsedGroup: "toggleCollapsedGroup" }, decls: 3, vars: 5, consts: [[3, "navigation", "selection"], ["ngFor", "", 3, "ngForOf"], [4, "ngIf"], [3, "catalog", "group", "state", "resolution", "catalogAllowLegend", "collapsed", "toggleCollapsed", "addedChange", "layerAddedChange"], ["igoListItem", "", 3, "layer", "resolution", "catalogAllowLegend", "added", "addedChange"]], template: function CatalogBrowserComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "igo-list", 0);
        i0.ɵɵtemplate(1, CatalogBrowserComponent_ng_template_1_Template, 2, 2, "ng-template", 1);
        i0.ɵɵpipe(2, "async");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("navigation", false)("selection", false);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(2, 3, ctx.store.view.all$()));
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CatalogBrowserComponent, [{
        type: Component,
        args: [{
                selector: 'igo-catalog-browser',
                templateUrl: './catalog-browser.component.html',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: LayerService }, { type: i0.ChangeDetectorRef }]; }, { catalogAllowLegend: [{
            type: Input
        }], catalog: [{
            type: Input
        }], store: [{
            type: Input
        }], map: [{
            type: Input
        }], toggleCollapsedGroup: [{
            type: Input
        }] }); })();

const _c0$f = ["renderedLegend"];
function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_mat_list_item_1_Template(rf, ctx) { if (rf & 1) {
    const _r15 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-list-item");
    i0.ɵɵelementStart(1, "mat-icon", 7);
    i0.ɵɵlistener("toggle", function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_mat_list_item_1_Template_mat_icon_toggle_1_listener($event) { i0.ɵɵrestoreView(_r15); const item_r6 = i0.ɵɵnextContext(2).$implicit; const ctx_r13 = i0.ɵɵnextContext(3); return ctx_r13.toggleLegendItem($event, item_r6); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(2, "h4", 8);
    i0.ɵɵtext(3);
    i0.ɵɵpipe(4, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r10 = i0.ɵɵreference(3);
    const item_r6 = i0.ɵɵnextContext().$implicit;
    const ctx_r9 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("target", _r10)("collapsed", item_r6.collapsed);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("", i0.ɵɵpipeBind1(4, 3, ctx_r9.computeItemTitle(item_r6)), " ");
} }
function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_4_mat_option_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 11);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const style_r18 = ctx.$implicit;
    i0.ɵɵproperty("value", style_r18.name);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(style_r18.title);
} }
function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r20 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelementStart(1, "mat-form-field");
    i0.ɵɵelementStart(2, "mat-select", 9);
    i0.ɵɵlistener("ngModelChange", function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_4_Template_mat_select_ngModelChange_2_listener($event) { i0.ɵɵrestoreView(_r20); const ctx_r19 = i0.ɵɵnextContext(5); return ctx_r19.currentStyle = $event; })("selectionChange", function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_4_Template_mat_select_selectionChange_2_listener() { i0.ɵɵrestoreView(_r20); const ctx_r21 = i0.ɵɵnextContext(5); return ctx_r21.onChangeStyle(); });
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵtemplate(4, LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_4_mat_option_4_Template, 2, 2, "mat-option", 10);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext(5);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(3, 3, "igo.geo.layer.legend.selectStyle"))("ngModel", ctx_r11.currentStyle);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r11.styles);
} }
function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_5_div_1_small_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "small");
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 1, "igo.geo.layer.legend.noLegendScale"), " ");
} }
const _c1$c = function (a0) { return [a0]; };
function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_5_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r28 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelementStart(1, "img", 13, 14);
    i0.ɵɵlistener("load", function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_5_div_1_Template_img_load_1_listener() { i0.ɵɵrestoreView(_r28); const item_r6 = i0.ɵɵnextContext(3).$implicit; const ctx_r26 = i0.ɵɵnextContext(3); return ctx_r26.onLoadImage(item_r6.title); });
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(4, LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_5_div_1_small_4_Template, 3, 3, "small", 0);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r6 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r22 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("id", item_r6.title);
    i0.ɵɵpropertyInterpolate("src", i0.ɵɵpureFunction1(6, _c1$c, item_r6.imgGraphValue), i0.ɵɵsanitizeUrl);
    i0.ɵɵpropertyInterpolate("alt", i0.ɵɵpipeBind1(3, 4, "igo.geo.layer.legend.loadingLegendText"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r22.imagesHeight[item_r6.title] < 16);
} }
function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_5_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 15);
    i0.ɵɵpipe(1, "sanitizeHtml");
} if (rf & 2) {
    const item_r6 = i0.ɵɵnextContext(3).$implicit;
    i0.ɵɵproperty("ngStyle", item_r6.style)("innerHTML", i0.ɵɵpipeBind1(1, 2, item_r6.html), i0.ɵɵsanitizeHtml);
} }
function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtemplate(1, LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_5_div_1_Template, 5, 8, "div", 0);
    i0.ɵɵtemplate(2, LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_5_div_2_Template, 2, 4, "div", 12);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r6 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", item_r6.url);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", item_r6.html);
} }
const _c2$6 = function (a0) { return { "with-title": a0 }; };
function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtemplate(1, LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_mat_list_item_1_Template, 5, 5, "mat-list-item", 0);
    i0.ɵɵelementStart(2, "div", 5, 6);
    i0.ɵɵtemplate(4, LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_4_Template, 5, 5, "div", 0);
    i0.ɵɵtemplate(5, LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_div_5_Template, 3, 2, "div", 0);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r6 = i0.ɵɵnextContext().$implicit;
    const ctx_r8 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", item_r6.title);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(4, _c2$6, item_r6.title));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r8.currentStyle !== undefined);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !item_r6.collapsed);
} }
function LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0, null, 4);
    i0.ɵɵtemplate(2, LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_div_2_Template, 6, 6, "div", 1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(2);
    const _r3 = i0.ɵɵreference(3);
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.getLegend)("ngIfElse", _r3);
} }
function LayerLegendComponent_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, LayerLegendComponent_ng_container_0_ng_container_1_ng_container_1_Template, 3, 2, "ng-container", 3);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const items_r1 = i0.ɵɵnextContext().ngIf;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", items_r1.slice().reverse());
} }
function LayerLegendComponent_ng_container_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "small");
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 1, "igo.geo.layer.legend.noLegendText"), " ");
} }
function LayerLegendComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, LayerLegendComponent_ng_container_0_ng_container_1_Template, 2, 1, "ng-container", 1);
    i0.ɵɵtemplate(2, LayerLegendComponent_ng_container_0_ng_template_2_Template, 3, 3, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const items_r1 = ctx.ngIf;
    const _r3 = i0.ɵɵreference(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", items_r1.length)("ngIfElse", _r3);
} }
class LayerLegendComponent {
    /**
     * activeLegend
     */
    constructor(capabilitiesService, languageService, http, cdRef) {
        this.capabilitiesService = capabilitiesService;
        this.languageService = languageService;
        this.http = http;
        this.cdRef = cdRef;
        this.updateLegendOnResolutionChange = false;
        /**
         * Observable of the legend items
         */
        this.legendItems$ = new BehaviorSubject([]);
        /**
         * The scale used to make the legend
         */
        this.scale = undefined;
        /**
         * The extent used to make the legend
         */
        this.view = undefined;
        /**
         * List of size of images displayed
         */
        this.imagesHeight = {};
        /**
         * if getLegendGraphic is authorized
         */
        this.getLegend = true;
    }
    /**
     * On init, subscribe to the map's resolution and update the legend accordingly
     */
    ngOnInit() {
        let lastlLegend = this.layer.legend;
        this.styles = this.listStyles();
        const sourceOptions = this.layer.options.source.options;
        if (sourceOptions && sourceOptions.params && sourceOptions.params.STYLES) {
            // if a styles is provided into the layers wms params
            this.currentStyle = this.styles.find(style => style.name === sourceOptions.params.STYLES).name;
        }
        else if (!lastlLegend) {
            // if no legend is manually provided
            if (this.styles && this.styles.length > 1) {
                this.currentStyle = this.styles[0].name;
            }
        }
        else if (this.styles && this.styles.length > 1) {
            this.currentStyle = lastlLegend[0].currentStyle;
        }
        if (typeof this.layer.options.legendOptions !== 'undefined' && this.layer.options.legendOptions.display === false) {
            lastlLegend = [];
        }
        else {
            lastlLegend = this.layer.dataSource.getLegend(this.currentStyle, this.view);
        }
        if (this.updateLegendOnResolutionChange || sourceOptions.contentDependentLegend) {
            const state$ = this.layer.map.viewController.state$;
            this.state$$ = state$.subscribe(() => this.onViewControllerStateChange());
        }
        else if (lastlLegend && lastlLegend.length !== 0) {
            this.legendItems$.next(lastlLegend);
            for (const legend of lastlLegend) {
                this.getLegendGraphic(legend);
            }
        }
    }
    /**
     * On destroy, unsubscribe to the map's view state
     */
    ngOnDestroy() {
        if (this.state$$ !== undefined) {
            this.state$$.unsubscribe();
        }
    }
    getLegendGraphic(item) {
        if (item.url) {
            const secureIMG = new SecureImagePipe(this.http);
            secureIMG.transform(item.url).pipe(catchError((err) => {
                if (err.error) {
                    err.error.caught = true;
                    this.getLegend = false;
                    this.cdRef.detectChanges();
                    return err;
                }
            })).subscribe(obsLegGraph => {
                const idx = this.legendItems$.value.findIndex(leg => leg.title === item.title);
                const legendGraph = obsLegGraph;
                this.legendItems$.value[idx].imgGraphValue = legendGraph;
                this.cdRef.detectChanges();
            });
        }
    }
    toggleLegendItem(collapsed, item) {
        item.collapsed = collapsed;
    }
    transfertToggleLegendItem(newLegends) {
        const outLegends = newLegends;
        const lastLegends = this.layer.legend;
        for (let i = 0; i < lastLegends.length; i++) {
            outLegends[i].collapsed = lastLegends[i].collapsed;
        }
        return outLegends;
    }
    computeItemTitle(layerLegend) {
        const layerOptions = this.layer.dataSource.options;
        if (layerOptions.type !== 'wms') {
            return of(layerLegend.title);
        }
        const layers = layerOptions.params.LAYERS.split(',');
        const localLayerOptions = JSON.parse(JSON.stringify(layerOptions)); // to avoid to alter the original options.
        localLayerOptions.params.LAYERS = layers.find(layer => layer === layerLegend.title);
        return this.capabilitiesService
            .getWMSOptions(localLayerOptions)
            .pipe(map(wmsDataSourceOptions => {
            return wmsDataSourceOptions._layerOptionsFromSource.title;
        }));
    }
    /**
     * On resolution change, compute the effective scale level and update the
     * legend accordingly.
     * @param resolution Map resolution
     */
    onViewControllerStateChange() {
        this.view = {
            resolution: this.layer.map.viewController.getResolution(),
            extent: this.layer.map.viewController.getExtent(),
            projection: this.layer.map.viewController.getOlProjection().getCode(),
            scale: this.layer.map.viewController.getScale(),
            size: this.layer.map.ol.getSize()
        };
        this.updateLegend();
    }
    /**
     * Update the legend with scale level and style define
     */
    updateLegend() {
        let legendItems = this.layer.dataSource.getLegend(this.currentStyle, this.view);
        if (this.layer.legend && this.layer.legend.length > 1) {
            legendItems = this.transfertToggleLegendItem(legendItems);
        }
        this.layer.legend = legendItems;
        if (legendItems.length === 0 && this.legendItems$.value.length === 0) {
            return;
        }
        this.legendItems$.next(legendItems);
        for (const legend of this.legendItems$.value) {
            this.getLegendGraphic(legend);
        }
    }
    listStyles() {
        const layerOptions = this.layer.options;
        if (layerOptions && layerOptions.legendOptions) {
            const translate = this.languageService.translate;
            const title = translate.instant('igo.geo.layer.legend.default');
            let stylesAvailable = [{ name: '', title }];
            if (layerOptions.legendOptions.stylesAvailable) {
                stylesAvailable = stylesAvailable.concat(layerOptions.legendOptions.stylesAvailable.filter(sA => (sA.name.normalize('NFD').replace(/[\u0300-\u036f]/gi, '') !== 'default' &&
                    sA.name.normalize('NFD').replace(/[\u0300-\u036f]/gi, '') !== 'defaut')));
            }
            stylesAvailable.filter(sa => !sa.title).map((sa) => sa.title = sa.name);
            stylesAvailable.map(s => s.title = s.title.charAt(0).toUpperCase() + s.title.slice(1).replace(/_/g, ' '));
            return stylesAvailable;
        }
        return;
    }
    onChangeStyle() {
        this.updateLegend();
        let STYLES = '';
        if (this.layer.dataSource instanceof WMSDataSource) {
            this.layer.dataSource.ol.getParams().LAYERS.split(',').map(layer => STYLES += this.currentStyle + ',');
            STYLES = STYLES.slice(0, -1);
            this.layer.dataSource.ol.updateParams({ STYLES });
        }
    }
    onLoadImage(id) {
        let elemRef;
        if (this.renderedLegends.length === 1) {
            elemRef = this.renderedLegends.first.nativeElement;
        }
        else {
            elemRef = this.renderedLegends.find(renderedLegend => renderedLegend.nativeElement.id === id).nativeElement;
        }
        this.imagesHeight[id] = elemRef.height;
    }
}
LayerLegendComponent.ɵfac = function LayerLegendComponent_Factory(t) { return new (t || LayerLegendComponent)(i0.ɵɵdirectiveInject(CapabilitiesService), i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(i1$2.HttpClient), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
LayerLegendComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: LayerLegendComponent, selectors: [["igo-layer-legend"]], viewQuery: function LayerLegendComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$f, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.renderedLegends = _t);
    } }, inputs: { updateLegendOnResolutionChange: "updateLegendOnResolutionChange", layer: "layer" }, decls: 2, vars: 3, consts: [[4, "ngIf"], [4, "ngIf", "ngIfElse"], ["noItems", ""], [4, "ngFor", "ngForOf"], ["renderedLegends", ""], [1, "igo-layer-legend", 3, "ngClass"], ["legend", ""], ["id", "legend-toggle", "mat-list-avatar", "", "igoCollapse", "", "svgIcon", "chevron-up", 1, "igo-chevron", 3, "target", "collapsed", "toggle"], ["matLine", ""], ["tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "ngModel", "ngModelChange", "selectionChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [3, "ngStyle", "innerHTML", 4, "ngIf"], [3, "id", "src", "alt", "load"], ["renderedLegend", ""], [3, "ngStyle", "innerHTML"]], template: function LayerLegendComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, LayerLegendComponent_ng_container_0_Template, 4, 2, "ng-container", 0);
        i0.ɵɵpipe(1, "async");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(1, 1, ctx.legendItems$));
    } }, directives: [i1$1.NgIf, i1$1.NgForOf, i1$1.NgClass, i1$3.MatListItem, i4.MatIcon, i1$3.MatListAvatarCssMatStyler, i6.CollapseDirective, i9.MatLine, i12.MatFormField, i13.MatSelect, i3.MatTooltip, i16.NgControlStatus, i16.NgModel, i9.MatOption, i1$1.NgStyle], pipes: [i1$1.AsyncPipe, i7.TranslatePipe, i6.SanitizeHtmlPipe], styles: [".igo-layer-legend.with-title[_ngcontent-%COMP%]{padding-left:18px}img[_ngcontent-%COMP%]:after{content:\" \";position:relative;height:17px;float:left;width:17px;top:-3px;right:19px;background-color:#fff;border:3px solid #f3f3f3;border-radius:50%;-webkit-animation:2s linear infinite spin;animation:2s linear infinite spin}@-moz-document url-prefix(){img:after{margin-left:19px}}@-webkit-keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LayerLegendComponent, [{
        type: Component,
        args: [{
                selector: 'igo-layer-legend',
                templateUrl: './layer-legend.component.html',
                styleUrls: ['./layer-legend.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: CapabilitiesService }, { type: i2$1.LanguageService }, { type: i1$2.HttpClient }, { type: i0.ChangeDetectorRef }]; }, { updateLegendOnResolutionChange: [{
            type: Input
        }], renderedLegends: [{
            type: ViewChildren,
            args: ['renderedLegend']
        }], layer: [{
            type: Input
        }] }); })();

function CatalogBrowserLayerComponent_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-icon", 9);
} }
function CatalogBrowserLayerComponent_button_4_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-icon", 12);
    i0.ɵɵlistener("click", function CatalogBrowserLayerComponent_button_4_mat_icon_1_Template_mat_icon_click_0_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.catalog.externalProvider.layer"));
} }
function CatalogBrowserLayerComponent_button_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 10);
    i0.ɵɵtemplate(1, CatalogBrowserLayerComponent_button_4_mat_icon_1_Template, 2, 3, "mat-icon", 11);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r1.layer.externalProvider);
} }
function CatalogBrowserLayerComponent_igo_layer_legend_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-layer-legend", 3);
    i0.ɵɵpipe(1, "async");
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("layer", i0.ɵɵpipeBind1(1, 1, ctx_r3.igoLayer$));
} }
/**
 * Catalog browser layer item
 */
class CatalogBrowserLayerComponent {
    constructor(layerService) {
        this.layerService = layerService;
        this.inRange$ = new BehaviorSubject(true);
        this.isPreview$ = new BehaviorSubject(false);
        this.layerLegendShown$ = new BehaviorSubject(false);
        this.igoLayer$ = new BehaviorSubject(undefined);
        this.mouseInsideAdd = false;
        this.catalogAllowLegend = false;
        /**
         * Whether the layer is already added to the map
         */
        this.added = false;
        /**
         * Event emitted when the add/remove button is clicked
         */
        this.addedChange = new EventEmitter();
        this.addedLayerIsPreview = new EventEmitter();
    }
    /**
     * @internal
     */
    get title() {
        return getEntityTitle(this.layer);
    }
    /**
     * @internal
     */
    get icon() {
        return getEntityIcon(this.layer) || 'layers';
    }
    ngOnInit() {
        this.isInResolutionsRange();
        this.isPreview$$ = this.isPreview$.subscribe(value => this.addedLayerIsPreview.emit(value));
    }
    ngOnDestroy() {
        this.isPreview$$.unsubscribe();
    }
    computeTitleTooltip() {
        const layerOptions = this.layer.options;
        if (!layerOptions.tooltip) {
            return getEntityTitle(this.layer);
        }
        const layerTooltip = layerOptions.tooltip;
        const layerMetadata = layerOptions.metadata;
        switch (layerOptions.tooltip.type) {
            case TooltipType.TITLE:
                return this.layer.title;
            case TooltipType.ABSTRACT:
                if (layerMetadata && layerMetadata.abstract) {
                    return layerMetadata.abstract;
                }
                else {
                    return this.layer.title;
                }
            case TooltipType.CUSTOM:
                if (layerTooltip && layerTooltip.text) {
                    return layerTooltip.text;
                }
                else {
                    return this.layer.title;
                }
            default:
                return this.layer.title;
        }
    }
    /**
     * On mouse event, mouseenter /mouseleave
     * @internal
     */
    onMouseEvent(event) {
        this.onToggleClick(event);
    }
    askForLegend(event) {
        this.layerLegendShown$.next(!this.layerLegendShown$.value);
        this.layerService.createAsyncLayer(this.layer.options).pipe(first())
            .subscribe(layer => this.igoLayer$.next(layer));
    }
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    onToggleClick(event) {
        if (typeof this.lastTimeoutRequest !== 'undefined') {
            clearTimeout(this.lastTimeoutRequest);
        }
        if (event.type === 'mouseenter' && this.mouseInsideAdd) {
            return;
        }
        switch (event.type) {
            case 'click':
                if (!this.isPreview$.value) {
                    if (this.added) {
                        this.remove();
                    }
                    else {
                        this.add();
                    }
                }
                this.isPreview$.next(false);
                break;
            case 'mouseenter':
                if (!this.isPreview$.value && !this.added) {
                    this.lastTimeoutRequest = setTimeout(() => {
                        this.add();
                        this.isPreview$.next(true);
                    }, 500);
                }
                this.mouseInsideAdd = true;
                break;
            case 'mouseleave':
                if (this.isPreview$.value) {
                    this.remove();
                    this.isPreview$.next(false);
                }
                this.mouseInsideAdd = false;
                break;
            default:
                break;
        }
    }
    /**
     * Emit added change event with added = true
     */
    add() {
        if (!this.added) {
            this.added = true;
            this.addedChange.emit({ added: true, layer: this.layer });
        }
    }
    /**
     * Emit added change event with added = false
     */
    remove() {
        if (this.added) {
            this.added = false;
            this.addedChange.emit({ added: false, layer: this.layer });
        }
    }
    haveGroup() {
        return !(!this.layer.address || this.layer.address.split('.').length === 1);
    }
    isInResolutionsRange() {
        const minResolution = this.layer.options.minResolution || 0;
        const maxResolution = this.layer.options.maxResolution || Infinity;
        this.inRange$.next(this.resolution >= minResolution && this.resolution <= maxResolution);
        return this.inRange$.value;
    }
    computeTooltip() {
        if (this.added) {
            return this.isPreview$.value
                ? 'igo.geo.catalog.layer.addToMap'
                : this.inRange$.value
                    ? 'igo.geo.catalog.layer.removeFromMap'
                    : 'igo.geo.catalog.layer.removeFromMapOutRange';
        }
        else {
            return this.inRange$.value
                ? 'igo.geo.catalog.layer.addToMap'
                : 'igo.geo.catalog.layer.addToMapOutRange';
        }
    }
}
CatalogBrowserLayerComponent.ɵfac = function CatalogBrowserLayerComponent_Factory(t) { return new (t || CatalogBrowserLayerComponent)(i0.ɵɵdirectiveInject(LayerService)); };
CatalogBrowserLayerComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: CatalogBrowserLayerComponent, selectors: [["igo-catalog-browser-layer"]], inputs: { resolution: "resolution", catalogAllowLegend: "catalogAllowLegend", layer: "layer", added: "added" }, outputs: { addedChange: "addedChange", addedLayerIsPreview: "addedLayerIsPreview" }, decls: 16, vars: 21, consts: [["mat-list-avatar", "", "svgIcon", "blank", 4, "ngIf"], ["mat-line", "", "matTooltipShowDelay", "500", 3, "ngClass", "matTooltip", "click"], ["disabled", "true", "mat-icon-button", "", 4, "ngIf"], [3, "layer"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", "mouseenter", "mouseleave", "click"], ["matBadge", "icon", "igoMatBadgeIcon", "eye-off", "igoMatBadgeInverseColor", "true", "matBadgeDisabled", "true", "matBadgeSize", "small", "matBadgePosition", "after", 3, "matBadgeHidden", "svgIcon"], [1, "igo-cataloglayer-legend-container"], ["legend", ""], [3, "layer", 4, "ngIf"], ["mat-list-avatar", "", "svgIcon", "blank"], ["disabled", "true", "mat-icon-button", ""], ["class", "igo-cataloglayer-external-icon", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "primary", "svgIcon", "earth-arrow-right", 3, "matTooltip", "click", 4, "ngIf"], ["tooltip-position", "below", "matTooltipShowDelay", "500", "color", "primary", "svgIcon", "earth-arrow-right", 1, "igo-cataloglayer-external-icon", 3, "matTooltip", "click"]], template: function CatalogBrowserLayerComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-list-item");
        i0.ɵɵtemplate(1, CatalogBrowserLayerComponent_mat_icon_1_Template, 1, 0, "mat-icon", 0);
        i0.ɵɵelementStart(2, "h4", 1);
        i0.ɵɵlistener("click", function CatalogBrowserLayerComponent_Template_h4_click_2_listener($event) { return ctx.askForLegend($event); });
        i0.ɵɵtext(3);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(4, CatalogBrowserLayerComponent_button_4_Template, 2, 1, "button", 2);
        i0.ɵɵelement(5, "igo-metadata-button", 3);
        i0.ɵɵelementStart(6, "button", 4);
        i0.ɵɵlistener("mouseenter", function CatalogBrowserLayerComponent_Template_button_mouseenter_6_listener($event) { return ctx.onMouseEvent($event); })("mouseleave", function CatalogBrowserLayerComponent_Template_button_mouseleave_6_listener($event) { return ctx.onMouseEvent($event); })("click", function CatalogBrowserLayerComponent_Template_button_click_6_listener($event) { return ctx.onToggleClick($event); });
        i0.ɵɵpipe(7, "translate");
        i0.ɵɵpipe(8, "async");
        i0.ɵɵelement(9, "mat-icon", 5);
        i0.ɵɵpipe(10, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(11, "div", 6, 7);
        i0.ɵɵtemplate(13, CatalogBrowserLayerComponent_igo_layer_legend_13_Template, 2, 3, "igo-layer-legend", 8);
        i0.ɵɵpipe(14, "async");
        i0.ɵɵpipe(15, "async");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.haveGroup());
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", ctx.catalogAllowLegend ? "igo-cataloglayer-title" : "")("matTooltip", ctx.computeTitleTooltip());
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.title);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.layer.externalProvider);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("layer", ctx.layer);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(7, 11, ctx.computeTooltip()))("color", i0.ɵɵpipeBind1(8, 13, ctx.isPreview$) ? "" : ctx.added ? "warn" : "");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("matBadgeHidden", ctx.isInResolutionsRange())("svgIcon", i0.ɵɵpipeBind1(10, 15, ctx.isPreview$) ? "plus" : ctx.added ? "delete" : "plus");
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(14, 17, ctx.layerLegendShown$) && i0.ɵɵpipeBind1(15, 19, ctx.igoLayer$) && ctx.catalogAllowLegend);
    } }, directives: [i1$3.MatListItem, i1$1.NgIf, i9.MatLine, i1$1.NgClass, i3.MatTooltip, MetadataButtonComponent, i2.MatButton, i4.MatIcon, i9$1.MatBadge, i6.IgoBadgeIconDirective, i1$3.MatListAvatarCssMatStyler, LayerLegendComponent], pipes: [i7.TranslatePipe, i1$1.AsyncPipe], styles: [".igo-cataloglayer-title[_ngcontent-%COMP%]{cursor:pointer}.igo-cataloglayer-legend-container[_ngcontent-%COMP%]{padding-left:18px;width:calc(100% - 18px);margin-left:40px}.igo-cataloglayer-external-icon[_ngcontent-%COMP%]{cursor:help}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CatalogBrowserLayerComponent, [{
        type: Component,
        args: [{
                selector: 'igo-catalog-browser-layer',
                templateUrl: './catalog-browser-layer.component.html',
                styleUrls: ['./catalog-browser-layer.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: LayerService }]; }, { resolution: [{
            type: Input
        }], catalogAllowLegend: [{
            type: Input
        }], layer: [{
            type: Input
        }], added: [{
            type: Input
        }], addedChange: [{
            type: Output
        }], addedLayerIsPreview: [{
            type: Output
        }] }); })();

function CatalogBrowserGroupComponent_button_4_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-icon", 9);
    i0.ɵɵlistener("click", function CatalogBrowserGroupComponent_button_4_mat_icon_1_Template_mat_icon_click_0_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.catalog.externalProvider.group"));
} }
function CatalogBrowserGroupComponent_button_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 7);
    i0.ɵɵtemplate(1, CatalogBrowserGroupComponent_button_4_mat_icon_1_Template, 2, 3, "mat-icon", 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.group.externalProvider);
} }
function CatalogBrowserGroupComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "button", 10);
    i0.ɵɵlistener("click", function CatalogBrowserGroupComponent_ng_container_5_Template_button_click_1_listener() { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(); return ctx_r8.onToggleClick(); });
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelement(4, "mat-icon", 11);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(2, 2, "igo.geo.catalog.group.removeFromMap"))("disabled", i0.ɵɵpipeBind1(3, 4, ctx_r1.disabled$));
} }
function CatalogBrowserGroupComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 12);
    i0.ɵɵlistener("click", function CatalogBrowserGroupComponent_ng_template_8_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.onToggleClick(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelement(3, "mat-icon", 13);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 2, "igo.geo.catalog.group.addToMap"))("disabled", i0.ɵɵpipeBind1(2, 4, ctx_r3.disabled$));
} }
function CatalogBrowserGroupComponent_ng_template_12_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function CatalogBrowserGroupComponent_ng_template_12_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "igo-catalog-browser-layer", 15);
    i0.ɵɵlistener("addedLayerIsPreview", function CatalogBrowserGroupComponent_ng_template_12_ng_container_1_Template_igo_catalog_browser_layer_addedLayerIsPreview_1_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(2); return ctx_r15.onLayerPreview($event); })("addedChange", function CatalogBrowserGroupComponent_ng_template_12_ng_container_1_Template_igo_catalog_browser_layer_addedChange_1_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r17 = i0.ɵɵnextContext(2); return ctx_r17.onLayerAddedChange($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r12 = i0.ɵɵnextContext().$implicit;
    const ctx_r14 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("layer", item_r12)("resolution", ctx_r14.resolution)("catalogAllowLegend", ctx_r14.catalogAllowLegend)("added", ctx_r14.state.get(item_r12).added);
} }
function CatalogBrowserGroupComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, CatalogBrowserGroupComponent_ng_template_12_ng_container_0_Template, 1, 0, "ng-container", 14);
    i0.ɵɵtemplate(1, CatalogBrowserGroupComponent_ng_template_12_ng_container_1_Template, 2, 4, "ng-container", 14);
} if (rf & 2) {
    const item_r12 = ctx.$implicit;
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngIf", ctx_r5.isGroup(item_r12));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r5.isLayer(item_r12));
} }
/**
 * Catalog browser group item
 */
class CatalogBrowserGroupComponent {
    constructor() {
        /**
         * Group's items store
         * @internal
         */
        this.store = new EntityStore([]);
        /**
         * Whether all the layers of the group are added
         * @internal
         */
        this.added$ = new BehaviorSubject(false);
        this.preview$ = new BehaviorSubject(false);
        /**
         * Whether the toggle button is disabled
         * @internal
         */
        this.disabled$ = new BehaviorSubject(false);
        /**
         * Whether the group is collapsed
         */
        this.collapsed = true;
        this.catalogAllowLegend = false;
        /**
         * Whether the group can be toggled when it's collapsed
         */
        this.toggleCollapsed = true;
        /**
         * Event emitted when the add/remove button of the group is clicked
         */
        this.addedChange = new EventEmitter();
        /**
         * Event emitted when the add/remove button of a layer is clicked
         */
        this.layerAddedChange = new EventEmitter();
    }
    /**
     * @internal
     */
    get title() {
        return this.group.title;
    }
    /**
     * @internal
     */
    ngOnInit() {
        this.store.load(this.group.items);
        this.evaluateAdded();
        this.evaluateDisabled(this.collapsed);
        if (this.group.sortDirection !== undefined) {
            this.store.view.sort({
                direction: this.group.sortDirection,
                valueAccessor: (item) => item.title
            });
        }
    }
    ngOnDestroy() {
        this.store.destroy();
    }
    /**
     * @internal
     */
    isGroup(item) {
        return item.type === CatalogItemType.Group;
    }
    /**
     * @internal
     */
    isLayer(item) {
        return item.type === CatalogItemType.Layer;
    }
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    onToggleClick() {
        this.added$.value ? this.remove() : this.add();
    }
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    onToggleCollapsed(collapsed) {
        this.evaluateDisabled(collapsed);
    }
    /**
     * When a layer is added or removed, evaluate if all the layers of the group
     * are now added or removed. If so, consider that the group itself is added
     * or removed.
     * @internal
     * @param event Layer added change event
     */
    onLayerAddedChange(event) {
        this.layerAddedChange.emit(event);
        this.tryToggleGroup(event);
    }
    /**
     * Emit added change event with added = true
     */
    add() {
        this.added$.next(true);
        this.addedChange.emit({
            added: true,
            group: this.group
        });
    }
    /**
     * Emit added change event with added = true
     */
    remove() {
        this.added$.next(false);
        this.addedChange.emit({
            added: false,
            group: this.group
        });
    }
    onLayerPreview(event) {
        this.preview$.next(event);
    }
    /**
     * If all the layers of the group added or removed, add or remove the group itself.
     * @param event The last layer added change event to occur
     */
    tryToggleGroup(event) {
        const added = event.added;
        const layer = event.layer;
        const layersAdded = this.store.view
            .all()
            .filter((item) => item.id !== layer.id)
            .map((item) => this.state.get(item).added || false);
        if (layersAdded.every(value => value === added)) {
            added ? this.add() : this.remove();
        }
        else if (this.added$.value === true) {
            this.added$.next(false);
        }
    }
    evaluateAdded() {
        const added = this.store.all().every((item) => {
            return (this.state.get(item).added || false) === true;
        });
        this.added$.next(added);
    }
    evaluateDisabled(collapsed) {
        let disabled = false;
        if (this.toggleCollapsed === false) {
            disabled = collapsed;
        }
        this.disabled$.next(disabled);
    }
    onTitleClick() {
        this.collapsed = !this.collapsed;
    }
}
CatalogBrowserGroupComponent.ɵfac = function CatalogBrowserGroupComponent_Factory(t) { return new (t || CatalogBrowserGroupComponent)(); };
CatalogBrowserGroupComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: CatalogBrowserGroupComponent, selectors: [["igo-catalog-browser-group"]], inputs: { catalog: "catalog", group: "group", collapsed: "collapsed", resolution: "resolution", catalogAllowLegend: "catalogAllowLegend", toggleCollapsed: "toggleCollapsed", state: "state" }, outputs: { addedChange: "addedChange", layerAddedChange: "layerAddedChange" }, decls: 14, vars: 14, consts: [["mat-list-avatar", "", "svgIcon", "chevron-up", "igoCollapse", "", 1, "igo-chevron", 3, "target", "collapsed", "toggle"], ["id", "catalog-group-title", "mat-line", "", "matTooltipShowDelay", "500", 1, "igo-catalog-group-title", 3, "matTooltip", "click"], ["disabled", "true", "mat-icon-button", "", 4, "ngIf"], [4, "ngIf", "ngIfElse"], ["notadded", ""], ["items", ""], ["ngFor", "", 3, "ngForOf"], ["disabled", "true", "mat-icon-button", ""], ["class", "igo-cataloggroup-external-icon", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "primary", "svgIcon", "earth-arrow-right", 3, "matTooltip", "click", 4, "ngIf"], ["tooltip-position", "below", "matTooltipShowDelay", "500", "color", "primary", "svgIcon", "earth-arrow-right", 1, "igo-cataloggroup-external-icon", 3, "matTooltip", "click"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "warn", 3, "matTooltip", "disabled", "click"], ["svgIcon", "delete"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "disabled", "click"], ["svgIcon", "plus"], [4, "ngIf"], ["igoListItem", "", 3, "layer", "resolution", "catalogAllowLegend", "added", "addedLayerIsPreview", "addedChange"]], template: function CatalogBrowserGroupComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-list-item");
        i0.ɵɵelementStart(1, "mat-icon", 0);
        i0.ɵɵlistener("toggle", function CatalogBrowserGroupComponent_Template_mat_icon_toggle_1_listener($event) { return ctx.onToggleCollapsed($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(2, "h4", 1);
        i0.ɵɵlistener("click", function CatalogBrowserGroupComponent_Template_h4_click_2_listener() { return ctx.onTitleClick(); });
        i0.ɵɵtext(3);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(4, CatalogBrowserGroupComponent_button_4_Template, 2, 1, "button", 2);
        i0.ɵɵtemplate(5, CatalogBrowserGroupComponent_ng_container_5_Template, 5, 6, "ng-container", 3);
        i0.ɵɵpipe(6, "async");
        i0.ɵɵpipe(7, "async");
        i0.ɵɵtemplate(8, CatalogBrowserGroupComponent_ng_template_8_Template, 4, 6, "ng-template", null, 4, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(10, "div", null, 5);
        i0.ɵɵtemplate(12, CatalogBrowserGroupComponent_ng_template_12_Template, 2, 2, "ng-template", 6);
        i0.ɵɵpipe(13, "async");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r2 = i0.ɵɵreference(9);
        const _r4 = i0.ɵɵreference(11);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("target", _r4)("collapsed", ctx.collapsed);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", ctx.title);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.title);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.group.externalProvider);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(6, 8, ctx.added$) && i0.ɵɵpipeBind1(7, 10, ctx.preview$) === false)("ngIfElse", _r2);
        i0.ɵɵadvance(7);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(13, 12, ctx.store.view.all$()));
    } }, directives: [i1$3.MatListItem, i4.MatIcon, i1$3.MatListAvatarCssMatStyler, i6.CollapseDirective, i9.MatLine, i3.MatTooltip, i1$1.NgIf, i1$1.NgForOf, i2.MatButton, CatalogBrowserLayerComponent, i6.ListItemDirective], pipes: [i1$1.AsyncPipe, i7.TranslatePipe], styles: [".igo-catalog-group-title[_ngcontent-%COMP%]{cursor:pointer;opacity:.9}#catalog-group-title[_ngcontent-%COMP%]{font-weight:bold}.igo-cataloggroup-external-icon[_ngcontent-%COMP%]{cursor:help}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CatalogBrowserGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igo-catalog-browser-group',
                templateUrl: './catalog-browser-group.component.html',
                styleUrls: ['./catalog-browser-group.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { catalog: [{
            type: Input
        }], group: [{
            type: Input
        }], collapsed: [{
            type: Input
        }], resolution: [{
            type: Input
        }], catalogAllowLegend: [{
            type: Input
        }], toggleCollapsed: [{
            type: Input
        }], state: [{
            type: Input
        }], addedChange: [{
            type: Output
        }], layerAddedChange: [{
            type: Output
        }] }); })();

class LayerListToolService {
    constructor() {
        this.sortAlpha = false;
        this.onlyVisible = false;
        this.onlyInRange = false;
        this.keywordInitialized = false;
        this.sortedAlphaInitialized = false;
        this.onlyVisibleInitialized = false;
        this.onlyInRangeInitialized = false;
    }
}
LayerListToolService.ɵfac = function LayerListToolService_Factory(t) { return new (t || LayerListToolService)(); };
LayerListToolService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: LayerListToolService, factory: LayerListToolService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LayerListToolService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

function LayerItemComponent_mat_checkbox_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-checkbox", 9);
    i0.ɵɵlistener("change", function LayerItemComponent_mat_checkbox_1_Template_mat_checkbox_change_0_listener() { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.check(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("checked", ctx_r0.layerCheck);
} }
const _c0$e = function (a0) { return { disabled: a0 }; };
function LayerItemComponent_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 10);
    i0.ɵɵlistener("click", function LayerItemComponent_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(); return ctx_r8.toggleVisibility(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelement(3, "mat-icon", 11);
    i0.ɵɵpipe(4, "async");
    i0.ɵɵpipe(5, "async");
    i0.ɵɵpipe(6, "async");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("color", ctx_r1.layer.visible ? "primary" : "default")("matTooltip", ctx_r1.layer.visible ? i0.ɵɵpipeBind1(1, 5, "igo.geo.layer.hideLayer") : i0.ɵɵpipeBind1(2, 7, "igo.geo.layer.showLayer"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("matBadgeHidden", i0.ɵɵpipeBind1(4, 9, ctx_r1.queryBadgeHidden$))("ngClass", i0.ɵɵpureFunction1(15, _c0$e, i0.ɵɵpipeBind1(5, 11, ctx_r1.inResolutionRange$) === false))("svgIcon", i0.ɵɵpipeBind1(6, 13, ctx_r1.layer.visible$) ? "eye" : "eye-off");
} }
function LayerItemComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 12);
    i0.ɵɵlistener("click", function LayerItemComponent_button_5_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.toggleVisibility(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelement(3, "mat-icon", 11);
    i0.ɵɵpipe(4, "async");
    i0.ɵɵpipe(5, "async");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("color", ctx_r2.layer.visible ? "primary" : "default")("matTooltip", ctx_r2.layer.visible ? i0.ɵɵpipeBind1(1, 5, "igo.geo.layer.hideLayer") : i0.ɵɵpipeBind1(2, 7, "igo.geo.layer.showLayer"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("matBadgeHidden", i0.ɵɵpipeBind1(4, 9, ctx_r2.queryBadgeHidden$))("ngClass", i0.ɵɵpureFunction1(13, _c0$e, i0.ɵɵpipeBind1(5, 11, ctx_r2.inResolutionRange$) === false))("svgIcon", ctx_r2.layer.visible ? "eye" : "eye-off");
} }
function LayerItemComponent_button_6_Template(rf, ctx) { if (rf & 1) {
    const _r13 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 13);
    i0.ɵɵlistener("click", function LayerItemComponent_button_6_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r13); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.toggleLayerTool(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 14);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.layer.moreOptions"));
} }
function LayerItemComponent_igo_layer_legend_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-layer-legend", 15);
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("layer", ctx_r5.layer)("updateLegendOnResolutionChange", ctx_r5.updateLegendOnResolutionChange);
} }
class LayerItemComponent {
    constructor(networkService, renderer, elRef, cdRef) {
        this.networkService = networkService;
        this.renderer = renderer;
        this.elRef = elRef;
        this.cdRef = cdRef;
        this.focusedCls = 'igo-layer-item-focused';
        this.layerTool$ = new BehaviorSubject(false);
        this.showLegend$ = new BehaviorSubject(true);
        this.inResolutionRange$ = new BehaviorSubject(true);
        this.queryBadgeHidden$ = new BehaviorSubject(true);
        this._selectAll = false;
        this.layers$ = new BehaviorSubject(undefined);
        this.toggleLegendOnVisibilityChange = false;
        this.expandLegendIfVisible = false;
        this.updateLegendOnResolutionChange = false;
        this.orderable = true;
        this.lowerDisabled = false;
        this.raiseDisabled = false;
        this.queryBadge = false;
        this.action = new EventEmitter(undefined);
        this.checkbox = new EventEmitter();
    }
    get activeLayer() {
        return this._activeLayer;
    }
    set activeLayer(value) {
        if (value && this.layer && value.id === this.layer.id && !this.selectionMode) {
            this.layerTool$.next(true);
            this.renderer.addClass(this.elRef.nativeElement, this.focusedCls);
        }
        else {
            this.renderer.removeClass(this.elRef.nativeElement, this.focusedCls);
        }
    }
    get selectAll() {
        return this._selectAll;
    }
    set selectAll(value) {
        this._selectAll = value;
        if (value === true) {
            this.layerCheck = true;
        }
    }
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
        this.layers$.next(value);
    }
    get opacity() {
        return this.layer.opacity * 100;
    }
    set opacity(opacity) {
        this.layer.opacity = opacity / 100;
    }
    ngOnInit() {
        if (this.layer.visible &&
            this.expandLegendIfVisible &&
            this.layer.firstLoadComponent === true) {
            this.layer.firstLoadComponent = false;
            this.layer.legendCollapsed = false;
        }
        this.toggleLegend(this.layer.legendCollapsed);
        this.updateQueryBadge();
        const resolution$ = this.layer.map.viewController.resolution$;
        this.resolution$$ = resolution$.subscribe(() => {
            this.onResolutionChange();
        });
        this.tooltipText = this.computeTooltip();
        this.network$$ = this.networkService.currentState().subscribe((state) => {
            this.state = state;
            this.onResolutionChange();
        });
        this.layers$$ = this.layers$.subscribe(() => {
            if (this.layer && this.layer.options.active) {
                this.layerTool$.next(true);
                this.renderer.addClass(this.elRef.nativeElement, this.focusedCls);
            }
        });
        if (this.changeDetection) {
            this.changeDetection.subscribe(() => this.cdRef.detectChanges());
        }
    }
    ngOnDestroy() {
        this.resolution$$.unsubscribe();
        this.network$$.unsubscribe();
        this.layers$$.unsubscribe();
    }
    toggleLegend(collapsed) {
        this.layer.legendCollapsed = collapsed;
        this.showLegend$.next(!collapsed);
    }
    toggleLegendOnClick() {
        this.toggleLegend(this.showLegend$.value);
    }
    toggleVisibility() {
        this.layer.visible = !this.layer.visible;
        if (this.toggleLegendOnVisibilityChange) {
            this.toggleLegend(!this.layer.visible);
        }
        this.updateQueryBadge();
    }
    computeTooltip() {
        const layerOptions = this.layer.options;
        if (!layerOptions.tooltip) {
            return this.layer.title;
        }
        const layerTooltip = layerOptions.tooltip;
        const layerMetadata = layerOptions.metadata;
        switch (layerOptions.tooltip.type) {
            case TooltipType.TITLE:
                return this.layer.title;
            case TooltipType.ABSTRACT:
                if (layerMetadata && layerMetadata.abstract) {
                    return layerMetadata.abstract;
                }
                else {
                    return this.layer.title;
                }
            case TooltipType.CUSTOM:
                if (layerTooltip && layerTooltip.text) {
                    return layerTooltip.text;
                }
                else {
                    return this.layer.title;
                }
            default:
                return this.layer.title;
        }
    }
    onResolutionChange() {
        const inResolutionRange = this.layer.isInResolutionsRange;
        if (inResolutionRange === false &&
            this.updateLegendOnResolutionChange === true) {
            this.toggleLegend(true);
        }
        this.inResolutionRange$.next(inResolutionRange);
    }
    updateQueryBadge() {
        const hidden = this.queryBadge === false ||
            this.layer.visible === false ||
            !layerIsQueryable(this.layer);
        this.queryBadgeHidden$.next(hidden);
    }
    toggleLayerTool() {
        this.layerTool$.next(!this.layerTool$.getValue());
        if (this.layerTool$.getValue() === true) {
            this.renderer.addClass(this.elRef.nativeElement, this.focusedCls);
        }
        else {
            this.renderer.removeClass(this.elRef.nativeElement, this.focusedCls);
        }
        this.action.emit(this.layer);
    }
    check() {
        this.layerCheck = !this.layerCheck;
        this.checkbox.emit({ layer: this.layer, check: this.layerCheck });
    }
}
LayerItemComponent.ɵfac = function LayerItemComponent_Factory(t) { return new (t || LayerItemComponent)(i0.ɵɵdirectiveInject(i2$1.NetworkService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
LayerItemComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: LayerItemComponent, selectors: [["igo-layer-item"]], inputs: { activeLayer: "activeLayer", selectAll: "selectAll", layerCheck: "layerCheck", layer: "layer", toggleLegendOnVisibilityChange: "toggleLegendOnVisibilityChange", expandLegendIfVisible: "expandLegendIfVisible", updateLegendOnResolutionChange: "updateLegendOnResolutionChange", orderable: "orderable", lowerDisabled: "lowerDisabled", raiseDisabled: "raiseDisabled", queryBadge: "queryBadge", selectionMode: "selectionMode", changeDetection: "changeDetection" }, outputs: { action: "action", checkbox: "checkbox" }, decls: 11, vars: 9, consts: [[1, "igo-layer-list-item"], ["class", "layerCheck", "mat-list-icon", "", 3, "checked", "change", 4, "ngIf"], ["matLine", "", "matTooltipShowDelay", "500", 1, "igo-layer-title", 3, "matTooltip", "click"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "color", "matTooltip", "click", 4, "ngIf"], ["class", "selection-eye", "mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "color", "matTooltip", "click", 4, "ngIf"], ["class", "actions-button", "tooltip-position", "below", "matTooltipShowDelay", "500", "mat-icon-button", "", "color", "primary", 3, "matTooltip", "click", 4, "ngIf"], [1, "igo-layer-legend-container"], ["legend", ""], [3, "layer", "updateLegendOnResolutionChange", 4, "ngIf"], ["mat-list-icon", "", 1, "layerCheck", 3, "checked", "change"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "color", "matTooltip", "click"], ["matBadge", "?", "matBadgeColor", "accent", "matBadgeSize", "small", "matBadgePosition", "after", 3, "matBadgeHidden", "ngClass", "svgIcon"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "selection-eye", 3, "color", "matTooltip", "click"], ["tooltip-position", "below", "matTooltipShowDelay", "500", "mat-icon-button", "", "color", "primary", 1, "actions-button", 3, "matTooltip", "click"], ["svgIcon", "dots-horizontal"], [3, "layer", "updateLegendOnResolutionChange"]], template: function LayerItemComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-list-item", 0);
        i0.ɵɵtemplate(1, LayerItemComponent_mat_checkbox_1_Template, 1, 1, "mat-checkbox", 1);
        i0.ɵɵelementStart(2, "h4", 2);
        i0.ɵɵlistener("click", function LayerItemComponent_Template_h4_click_2_listener() { return ctx.toggleLegendOnClick(); });
        i0.ɵɵtext(3);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(4, LayerItemComponent_button_4_Template, 7, 17, "button", 3);
        i0.ɵɵtemplate(5, LayerItemComponent_button_5_Template, 6, 15, "button", 4);
        i0.ɵɵtemplate(6, LayerItemComponent_button_6_Template, 3, 3, "button", 5);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(7, "div", 6, 7);
        i0.ɵɵtemplate(9, LayerItemComponent_igo_layer_legend_9_Template, 1, 2, "igo-layer-legend", 8);
        i0.ɵɵpipe(10, "async");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.selectionMode);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", ctx.tooltipText);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.layer.title);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx.selectionMode);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.selectionMode);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx.selectionMode);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(10, 7, ctx.showLegend$));
    } }, styles: ["[_nghost-%COMP%]{overflow:hidden}mat-list-item[_ngcontent-%COMP%]     .mat-list-item-content .layerCheck{align-self:baseline;width:16px;padding-right:0}.igo-layer-list-item[_ngcontent-%COMP%]{height:46px;clear:both}.igo-layer-title[_ngcontent-%COMP%]{cursor:pointer}.igo-layer-legend-container[_ngcontent-%COMP%]{padding-left:18px;width:calc(100% - 18px)}mat-icon.disabled[_ngcontent-%COMP%]{color:#00000061}mat-icon[matBadge][_ngcontent-%COMP%]     .mat-badge-content{font-size:12px}.selection-eye[_ngcontent-%COMP%]{padding-right:45px}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LayerItemComponent, [{
        type: Component,
        args: [{
                selector: 'igo-layer-item',
                templateUrl: './layer-item.component.html',
                styleUrls: ['./layer-item.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i2$1.NetworkService }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, { activeLayer: [{
            type: Input
        }], selectAll: [{
            type: Input
        }], layerCheck: [{
            type: Input
        }], layer: [{
            type: Input
        }], toggleLegendOnVisibilityChange: [{
            type: Input
        }], expandLegendIfVisible: [{
            type: Input
        }], updateLegendOnResolutionChange: [{
            type: Input
        }], orderable: [{
            type: Input
        }], lowerDisabled: [{
            type: Input
        }], raiseDisabled: [{
            type: Input
        }], queryBadge: [{
            type: Input
        }], selectionMode: [{
            type: Input
        }], changeDetection: [{
            type: Input
        }], action: [{
            type: Output
        }], checkbox: [{
            type: Output
        }] }); })();

var LayerListControlsEnum;
(function (LayerListControlsEnum) {
    LayerListControlsEnum["always"] = "always";
    LayerListControlsEnum["never"] = "never";
    LayerListControlsEnum["default"] = "default";
})(LayerListControlsEnum || (LayerListControlsEnum = {}));
var LayerListSelectVisibleEnum;
(function (LayerListSelectVisibleEnum) {
    LayerListSelectVisibleEnum["ALL_VISIBLE"] = "ALL_VISIBLE";
    LayerListSelectVisibleEnum["ALL_HIDDEN"] = "ALL_HIDDEN";
    LayerListSelectVisibleEnum["MIXED"] = "MIXED";
    LayerListSelectVisibleEnum["NULL"] = "NULL";
})(LayerListSelectVisibleEnum || (LayerListSelectVisibleEnum = {}));
var LayerListDisplacement;
(function (LayerListDisplacement) {
    LayerListDisplacement["Raise"] = "raise";
    LayerListDisplacement["Lower"] = "lower";
})(LayerListDisplacement || (LayerListDisplacement = {}));

const _c0$d = ["igoLayerItemToolbar"];
function LayerListComponent_igo_layer_list_tool_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-layer-list-tool", 6);
    i0.ɵɵlistener("appliedFilterAndSort", function LayerListComponent_igo_layer_list_tool_1_Template_igo_layer_list_tool_appliedFilterAndSort_0_listener($event) { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.onAppliedFilterAndSortChange($event); })("selection", function LayerListComponent_igo_layer_list_tool_1_Template_igo_layer_list_tool_selection_0_listener($event) { i0.ɵɵrestoreView(_r7); const ctx_r8 = i0.ɵɵnextContext(); return ctx_r8.toggleSelectionMode($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("layersAreAllVisible", ctx_r0.layersAreAllVisible)("term", ctx_r0.layerFilterAndSortOptions.keyword)("onlyVisible", ctx_r0.layerFilterAndSortOptions.onlyVisible)("sortAlpha", ctx_r0.layerFilterAndSortOptions.sortAlpha);
} }
function LayerListComponent_mat_list_item_3_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-list-item", 7);
    i0.ɵɵelementStart(1, "mat-checkbox", 8);
    i0.ɵɵlistener("change", function LayerListComponent_mat_list_item_3_Template_mat_checkbox_change_1_listener() { i0.ɵɵrestoreView(_r10); const ctx_r9 = i0.ɵɵnextContext(); return ctx_r9.selectAll(); });
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("color", !ctx_r1.selectAllCheck && ctx_r1.layersChecked.length > 0 ? "accent" : "primary")("checked", ctx_r1.selectAllCheck)("indeterminate", !ctx_r1.selectAllCheck && ctx_r1.layersChecked.length > 0);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", ctx_r1.selectAllCheck ? i0.ɵɵpipeBind1(3, 4, "igo.geo.layer.deselectAll") : i0.ɵɵpipeBind1(4, 6, "igo.geo.layer.selectAll"), " ");
} }
function LayerListComponent_ng_template_7_igo_layer_item_0_Template(rf, ctx) { if (rf & 1) {
    const _r15 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-layer-item", 10);
    i0.ɵɵlistener("action", function LayerListComponent_ng_template_7_igo_layer_item_0_Template_igo_layer_item_action_0_listener($event) { i0.ɵɵrestoreView(_r15); const ctx_r14 = i0.ɵɵnextContext(2); return ctx_r14.toggleLayerTool($event); })("checkbox", function LayerListComponent_ng_template_7_igo_layer_item_0_Template_igo_layer_item_checkbox_0_listener($event) { i0.ɵɵrestoreView(_r15); const ctx_r16 = i0.ɵɵnextContext(2); return ctx_r16.layersCheck($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const layer_r11 = i0.ɵɵnextContext().$implicit;
    const ctx_r13 = i0.ɵɵnextContext();
    i0.ɵɵproperty("layer", layer_r11)("activeLayer", ctx_r13.activeLayer)("orderable", ctx_r13.orderable && !layer_r11.baseLayer)("lowerDisabled", ctx_r13.getLowerLayer().id === layer_r11.id)("raiseDisabled", ctx_r13.getUpperLayer().id === layer_r11.id)("queryBadge", ctx_r13.queryBadge)("expandLegendIfVisible", ctx_r13.expandLegendOfVisibleLayers)("updateLegendOnResolutionChange", ctx_r13.updateLegendOnResolutionChange)("toggleLegendOnVisibilityChange", ctx_r13.toggleLegendOnVisibilityChange)("selectionMode", ctx_r13.selection)("selectAll", ctx_r13.selectAllCheck)("layerCheck", layer_r11.options.check)("changeDetection", ctx_r13.layerItemChangeDetection$);
} }
function LayerListComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, LayerListComponent_ng_template_7_igo_layer_item_0_Template, 1, 13, "igo-layer-item", 9);
} if (rf & 2) {
    const layer_r11 = ctx.$implicit;
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngIf", !(ctx_r3.excludeBaseLayers && layer_r11.baseLayer));
} }
function LayerListComponent_igo_panel_9_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r22 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 26);
    i0.ɵɵlistener("click", function LayerListComponent_igo_panel_9_button_2_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r22); const ctx_r21 = i0.ɵɵnextContext(2); return ctx_r21.removeLayers(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 27);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.layer.removeLayer"));
} }
function LayerListComponent_igo_panel_9_button_19_Template(rf, ctx) { if (rf & 1) {
    const _r24 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 28);
    i0.ɵɵlistener("click", function LayerListComponent_igo_panel_9_button_19_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r24); const ctx_r23 = i0.ɵɵnextContext(2); return ctx_r23.zoomLayerExtents(ctx_r23.activeLayer); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 29);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.layer.zoomLayer"));
} }
const _c1$b = function (a0) { return { layer: a0 }; };
function LayerListComponent_igo_panel_9_Template(rf, ctx) { if (rf & 1) {
    const _r26 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-panel", 11);
    i0.ɵɵelementStart(1, "div", 12);
    i0.ɵɵtemplate(2, LayerListComponent_igo_panel_9_button_2_Template, 3, 3, "button", 13);
    i0.ɵɵelementStart(3, "button", 14);
    i0.ɵɵlistener("click", function LayerListComponent_igo_panel_9_Template_button_click_3_listener() { i0.ɵɵrestoreView(_r26); const ctx_r25 = i0.ɵɵnextContext(); return ctx_r25.moveActiveLayer(ctx_r25.activeLayer, ctx_r25.layerListDisplacement.Lower); });
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵpipe(5, "translate");
    i0.ɵɵelement(6, "mat-icon", 15);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(7, "button", 16);
    i0.ɵɵlistener("click", function LayerListComponent_igo_panel_9_Template_button_click_7_listener() { i0.ɵɵrestoreView(_r26); const ctx_r27 = i0.ɵɵnextContext(); return ctx_r27.moveActiveLayer(ctx_r27.activeLayer, ctx_r27.layerListDisplacement.Raise); });
    i0.ɵɵpipe(8, "translate");
    i0.ɵɵpipe(9, "translate");
    i0.ɵɵelement(10, "mat-icon", 17);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(11, "button", 18);
    i0.ɵɵpipe(12, "translate");
    i0.ɵɵelement(13, "mat-icon", 19);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(14, "mat-menu", 20, 21);
    i0.ɵɵelementStart(16, "div", 22);
    i0.ɵɵelementStart(17, "mat-slider", 23);
    i0.ɵɵlistener("input", function LayerListComponent_igo_panel_9_Template_mat_slider_input_17_listener($event) { i0.ɵɵrestoreView(_r26); const ctx_r28 = i0.ɵɵnextContext(); return ctx_r28.changeOpacity($event); })("click", function LayerListComponent_igo_panel_9_Template_mat_slider_click_17_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵpipe(18, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(19, LayerListComponent_igo_panel_9_button_19_Template, 3, 3, "button", 24);
    i0.ɵɵelementContainer(20, 25);
    i0.ɵɵprojection(21);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r19 = i0.ɵɵreference(15);
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("title", ctx_r4.activeLayer.title);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.isLayerRemovable(ctx_r4.activeLayer));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", ctx_r4.sortAlpha || ctx_r4.onlyVisible || ctx_r4.keyword ? i0.ɵɵpipeBind1(4, 20, "igo.geo.layer.filterLowerLayer") : i0.ɵɵpipeBind1(5, 22, "igo.geo.layer.lowerLayer"))("disabled", ctx_r4.lowerDisabled);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("matBadge", ctx_r4.sortAlpha || ctx_r4.onlyVisible || ctx_r4.keyword ? "!" : "")("matBadgeHidden", ctx_r4.lowerDisabled);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", ctx_r4.sortAlpha || ctx_r4.onlyVisible || ctx_r4.keyword ? i0.ɵɵpipeBind1(8, 24, "igo.geo.layer.filterRaiseLayer") : i0.ɵɵpipeBind1(9, 26, "igo.geo.layer.raiseLayer"))("disabled", ctx_r4.raiseDisabled);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("matBadge", ctx_r4.sortAlpha || ctx_r4.onlyVisible || ctx_r4.keyword ? "!" : "")("matBadgeHidden", ctx_r4.raiseDisabled);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matMenuTriggerFor", _r19)("matTooltip", i0.ɵɵpipeBind1(12, 28, "igo.geo.layer.opacity"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matBadge", ctx_r4.badgeOpacity);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("min", 0)("max", 100)("value", ctx_r4.opacity)("matTooltip", i0.ɵɵpipeBind1(18, 30, "igo.geo.layer.opacity"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.activeLayerIsValid(ctx_r4.activeLayer));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r4.templateLayerToolbar)("ngTemplateOutletContext", i0.ɵɵpureFunction1(32, _c1$b, ctx_r4.activeLayer));
} }
function LayerListComponent_igo_panel_10_mat_slider_25_Template(rf, ctx) { if (rf & 1) {
    const _r34 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-slider", 38);
    i0.ɵɵlistener("ngModelChange", function LayerListComponent_igo_panel_10_mat_slider_25_Template_mat_slider_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r34); const ctx_r33 = i0.ɵɵnextContext(2); return ctx_r33.checkOpacity = $event; })("click", function LayerListComponent_igo_panel_10_mat_slider_25_Template_mat_slider_click_0_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r31 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("min", 0)("max", 100)("ngModel", ctx_r31.checkOpacity)("matTooltip", i0.ɵɵpipeBind1(1, 4, "igo.geo.layer.opacity"));
} }
function LayerListComponent_igo_panel_10_button_26_Template(rf, ctx) { if (rf & 1) {
    const _r37 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 28);
    i0.ɵɵlistener("click", function LayerListComponent_igo_panel_10_button_26_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r37); const ctx_r36 = i0.ɵɵnextContext(2); return ctx_r36.zoomLayersExtents(ctx_r36.layersChecked); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 39);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.layer.zoomLayers"));
} }
function LayerListComponent_igo_panel_10_Template(rf, ctx) { if (rf & 1) {
    const _r39 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-panel", 11);
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelementStart(2, "div", 30);
    i0.ɵɵelementStart(3, "button", 31);
    i0.ɵɵlistener("click", function LayerListComponent_igo_panel_10_Template_button_click_3_listener() { i0.ɵɵrestoreView(_r39); const ctx_r38 = i0.ɵɵnextContext(); return ctx_r38.removeLayers(ctx_r38.layersChecked); });
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵpipe(5, "translate");
    i0.ɵɵelement(6, "mat-icon", 32);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(7, "button", 33);
    i0.ɵɵlistener("click", function LayerListComponent_igo_panel_10_Template_button_click_7_listener() { i0.ɵɵrestoreView(_r39); const ctx_r40 = i0.ɵɵnextContext(); return ctx_r40.toggleVisibility(ctx_r40.layersChecked); });
    i0.ɵɵpipe(8, "translate");
    i0.ɵɵpipe(9, "translate");
    i0.ɵɵelement(10, "mat-icon", 34);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(11, "button", 14);
    i0.ɵɵlistener("click", function LayerListComponent_igo_panel_10_Template_button_click_11_listener() { i0.ɵɵrestoreView(_r39); const ctx_r41 = i0.ɵɵnextContext(); return ctx_r41.lowerLayers(ctx_r41.layersChecked); });
    i0.ɵɵpipe(12, "translate");
    i0.ɵɵpipe(13, "translate");
    i0.ɵɵelement(14, "mat-icon", 15);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(15, "button", 16);
    i0.ɵɵlistener("click", function LayerListComponent_igo_panel_10_Template_button_click_15_listener() { i0.ɵɵrestoreView(_r39); const ctx_r42 = i0.ɵɵnextContext(); return ctx_r42.raiseLayers(ctx_r42.layersChecked); });
    i0.ɵɵpipe(16, "translate");
    i0.ɵɵpipe(17, "translate");
    i0.ɵɵelement(18, "mat-icon", 17);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(19, "button", 35);
    i0.ɵɵpipe(20, "translate");
    i0.ɵɵelement(21, "mat-icon", 36);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(22, "mat-menu", 20, 21);
    i0.ɵɵelementStart(24, "div", 22);
    i0.ɵɵtemplate(25, LayerListComponent_igo_panel_10_mat_slider_25_Template, 2, 6, "mat-slider", 37);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(26, LayerListComponent_igo_panel_10_button_26_Template, 3, 3, "button", 24);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r30 = i0.ɵɵreference(23);
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("title", i0.ɵɵpipeBind1(1, 21, "igo.geo.layer.tools"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("disabled", ctx_r5.layersChecked.length === 0)("matTooltip", ctx_r5.isAllLayersRemovable(ctx_r5.layersChecked) ? i0.ɵɵpipeBind1(4, 23, "igo.geo.layer.removeSelectedLayers") : i0.ɵɵpipeBind1(5, 25, "igo.geo.layer.removeSelectedLayersRestriction"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("matBadge", "!")("matBadgeHidden", ctx_r5.isAllLayersRemovable(ctx_r5.layersChecked));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("disabled", ctx_r5.layersChecked.length === 0)("matTooltip", ctx_r5.statusSelectedLayersCheck === "ALL_HIDDEN" ? i0.ɵɵpipeBind1(8, 27, "igo.geo.layer.showSelectedLayers") : i0.ɵɵpipeBind1(9, 29, "igo.geo.layer.hideSelectedLayers"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("svgIcon", ctx_r5.statusSelectedLayersCheck === "ALL_HIDDEN" ? "eye-off" : "eye");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", ctx_r5.sortAlpha || ctx_r5.onlyVisible || ctx_r5.keyword ? i0.ɵɵpipeBind1(12, 31, "igo.geo.layer.filterLowerLayer") : i0.ɵɵpipeBind1(13, 33, "igo.geo.layer.lowerLayer"))("disabled", ctx_r5.lowerDisabledSelection);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("matBadge", ctx_r5.sortAlpha || ctx_r5.onlyVisible || ctx_r5.keyword ? "!" : "")("matBadgeHidden", ctx_r5.lowerDisabledSelection);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", ctx_r5.sortAlpha || ctx_r5.onlyVisible || ctx_r5.keyword ? i0.ɵɵpipeBind1(16, 35, "igo.geo.layer.filterRaiseLayer") : i0.ɵɵpipeBind1(17, 37, "igo.geo.layer.raiseLayer"))("disabled", ctx_r5.raiseDisabledSelection);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("matBadge", ctx_r5.sortAlpha || ctx_r5.onlyVisible || ctx_r5.keyword ? "!" : "")("matBadgeHidden", ctx_r5.raiseDisabledSelection);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("disabled", ctx_r5.layersChecked.length === 0)("matMenuTriggerFor", _r30)("matTooltip", i0.ɵɵpipeBind1(20, 39, "igo.geo.layer.opacity"));
    i0.ɵɵadvance(6);
    i0.ɵɵproperty("ngIf", ctx_r5.layersChecked.length);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r5.layersChecked.length !== 0 && ctx_r5.activeLayersAreValid(ctx_r5.layersChecked));
} }
const _c2$5 = [[["", "igoLayerItemToolbar", ""]]];
const _c3$2 = function (a0, a1, a2) { return { "igo-list-tools-multi": a0, "igo-list-tools-single": a1, "igo-list-no-tools": a2 }; };
const _c4$1 = ["[igoLayerItemToolbar]"];
// TODO: This class could use a clean up. Also, some methods could be moved ealsewhere
class LayerListComponent {
    constructor(elRef) {
        this.elRef = elRef;
        this.orderable = true;
        this.thresholdToFilterAndSort = 5;
        this.layers$ = new BehaviorSubject([]);
        this.change$ = new ReplaySubject(1);
        this.showToolbar$ = new BehaviorSubject(false);
        this.hideSelectedLayers = true;
        this.activeLayer$ = new BehaviorSubject(undefined);
        this.layersChecked = [];
        this.layerItemChangeDetection$ = new BehaviorSubject(undefined);
        this.layersAreAllVisible = true;
        this.ogcButton = true;
        this.timeButton = true;
        this.floatLabel = 'auto';
        this.layerFilterAndSortOptions = {};
        this.excludeBaseLayers = false;
        this.toggleLegendOnVisibilityChange = false;
        this.expandLegendOfVisibleLayers = false;
        this.updateLegendOnResolutionChange = false;
        this.queryBadge = false;
        this.appliedFilterAndSort = new EventEmitter();
        this._keyword = undefined;
        this._onlyVisible = false;
        this._sortedAlpha = false;
        this.toggleOpacity = false;
        this.selectAllCheck$ = new BehaviorSubject(undefined);
    }
    get map() {
        return this._map;
    }
    set map(value) {
        this._map = value;
    }
    set layers(value) {
        this._layers = this.removeProblemLayerInList(value);
        this.next();
    }
    get layers() {
        return this._layers;
    }
    set activeLayer(value) {
        this._activeLayer = value;
        this.activeLayer$.next(value);
    }
    get activeLayer() {
        return this._activeLayer;
    }
    get keyword() {
        return this._keyword;
    }
    set keyword(value) {
        this._keyword = value;
        this.next();
    }
    get onlyVisible() {
        return this._onlyVisible;
    }
    set onlyVisible(value) {
        this._onlyVisible = value;
        this.next();
    }
    get sortAlpha() {
        return this._sortedAlpha;
    }
    set sortAlpha(value) {
        this._sortedAlpha = value;
        this.next();
    }
    get opacity() {
        return Math.round(this.activeLayer$.getValue().opacity * 100);
    }
    set opacity(opacity) {
        this.activeLayer$.getValue().opacity = opacity / 100;
    }
    get badgeOpacity() {
        if (this.opacity === 100) {
            return;
        }
        return this.opacity;
    }
    get raiseDisabled() {
        if (!this.orderable ||
            this.activeLayer.baseLayer ||
            this.getUpperLayer().id === this.activeLayer.id ||
            this.isUpperBaselayer(this.activeLayer)) {
            return true;
        }
        return false;
    }
    get lowerDisabled() {
        if (!this.orderable ||
            this.activeLayer.baseLayer ||
            this.getLowerLayer().id === this.activeLayer.id ||
            this.isLowerBaselayer(this.activeLayer)) {
            return true;
        }
        return false;
    }
    get raiseDisabledSelection() {
        if (this.layersChecked.length === 0 ||
            !this.orderable ||
            !this.raisableLayers(this.layersChecked) ||
            this.selectAllCheck === true) {
            return true;
        }
        return false;
    }
    get lowerDisabledSelection() {
        if (this.layersChecked.length === 0 ||
            !this.orderable ||
            !this.lowerableLayers(this.layersChecked) ||
            this.selectAllCheck === true) {
            return true;
        }
        return false;
    }
    get checkOpacity() {
        return this.layersCheckedOpacity() * 100;
    }
    set checkOpacity(opacity) {
        for (const layer of this.layersChecked) {
            layer.opacity = opacity / 100;
        }
    }
    get layerListDisplacement() {
        return LayerListDisplacement;
    }
    /**
     * Subscribe to the search term stream and trigger researches
     * @internal
     */
    ngOnInit() {
        this.change$$ = this.change$
            .pipe(debounce(() => {
            return this.layers.length === 0 ? EMPTY : timer(50);
        }))
            .subscribe(() => {
            this.showToolbar$.next(this.computeShowToolbar());
            this.layers$.next(this.computeLayers(this.layers.slice(0)));
            this.appliedFilterAndSort.emit({
                keyword: this.keyword,
                sortAlpha: this.sortAlpha,
                onlyVisible: this.onlyVisible
            });
        });
        this.selectAllCheck$$ = this.selectAllCheck$.subscribe((value) => {
            this.selectAllCheck = value;
        });
        this.layers$$ = this.layers$.subscribe(() => {
            if (this.layers) {
                let checks = 0;
                for (const layer of this.layers) {
                    layer.status$.subscribe(valStatus => {
                        if (valStatus === 0) {
                            this.map.removeLayer(layer);
                        }
                    });
                    if (layer.options.active) {
                        this.activeLayer = layer;
                        this.layerTool = true;
                    }
                    if (layer.options.check) {
                        checks += 1;
                    }
                }
                if (this.excludeBaseLayers) {
                    this.selectAllCheck =
                        checks ===
                            this.layers.filter((lay) => lay.baseLayer !== true && lay.showInLayerList).length
                            ? true
                            : false;
                }
                else {
                    this.selectAllCheck =
                        checks === this.layers.filter((lay) => lay.showInLayerList).length
                            ? true
                            : false;
                }
            }
        });
    }
    ngOnDestroy() {
        this.change$$.unsubscribe();
        this.selectAllCheck$$.unsubscribe();
        this.layers$$.unsubscribe();
    }
    activeLayerIsValid(layer) {
        let valid = false;
        const layerExtent = layer.options.extent;
        const maxLayerZoomExtent = this.map.viewController.maxLayerZoomExtent;
        if (layerExtent) {
            if (maxLayerZoomExtent) {
                valid = olextent.containsExtent(maxLayerZoomExtent, layerExtent);
            }
            else {
                valid = true;
            }
        }
        return valid;
    }
    activeLayersAreValid(layers) {
        let valid = false;
        const layersExtent = olextent.createEmpty();
        const maxLayerZoomExtent = this.map.viewController.maxLayerZoomExtent;
        for (const layer of layers) {
            const layerExtent = layer.options.extent;
            if (layerExtent && !layerExtent.includes(Infinity)) {
                olextent.extend(layersExtent, layerExtent);
            }
        }
        if (!olextent.isEmpty(layersExtent)) {
            if (maxLayerZoomExtent) {
                valid = (olextent.containsExtent(maxLayerZoomExtent, layersExtent));
            }
            else {
                valid = true;
            }
        }
        return valid;
    }
    zoomLayerExtents(layer) {
        this.map.viewController.zoomToExtent(layer.options.extent);
    }
    zoomLayersExtents(layers) {
        const layersExtent = olextent.createEmpty();
        for (const layer of layers) {
            const layerExtent = layer.options.extent;
            if (layerExtent) {
                olextent.extend(layersExtent, layerExtent);
            }
        }
        this.map.viewController.zoomToExtent(layersExtent);
    }
    changeOpacity(event) {
        this.opacity = event.value;
    }
    clearKeyword() {
        this.keyword = undefined;
    }
    getLowerLayer() {
        return this.layers
            .filter((l) => !l.baseLayer)
            .reduce((prev, current) => {
            return prev.zIndex < current.zIndex ? prev : current;
        }, { zIndex: undefined, id: undefined });
    }
    isLowerBaselayer(layer) {
        const index = this.layers.findIndex((lay) => layer.id === lay.id);
        if (this.layers &&
            this.layers[index + 1] &&
            this.layers[index + 1].baseLayer === true) {
            return true;
        }
        return false;
    }
    getUpperLayer() {
        return this.layers
            .filter((l) => !l.baseLayer)
            .reduce((prev, current) => {
            return prev.zIndex > current.zIndex ? prev : current;
        }, { zIndex: undefined, id: undefined });
    }
    isUpperBaselayer(layer) {
        const index = this.layers.findIndex((lay) => layer.id === lay.id);
        if (this.layers &&
            this.layers[index - 1] &&
            this.layers[index - 1].baseLayer === true) {
            return true;
        }
        return false;
    }
    moveActiveLayer(activeLayer, actiontype) {
        const layersToMove = [activeLayer];
        const sortedLayersToMove = [];
        this.getLinkedLayers(activeLayer, layersToMove);
        this.layers.map(layer => {
            if (layersToMove.indexOf(layer) !== -1) {
                sortedLayersToMove.push(layer);
            }
        });
        if (actiontype === LayerListDisplacement.Raise) {
            this.raiseLayers(sortedLayersToMove, false);
        }
        else if (actiontype === LayerListDisplacement.Lower) {
            this.lowerLayers(sortedLayersToMove, false);
        }
    }
    getLinkedLayers(activeLayer, layersList) {
        const linkedLayers = activeLayer.options.linkedLayers;
        if (!linkedLayers) {
            return;
        }
        const currentLinkedId = linkedLayers.linkId;
        const currentLinks = linkedLayers.links;
        const isParentLayer = currentLinks ? true : false;
        if (isParentLayer) {
            // search for child layers
            currentLinks.map(link => {
                if (!link.properties || link.properties.indexOf(LinkedProperties.ZINDEX) === -1) {
                    return;
                }
                link.linkedIds.map(linkedId => {
                    const childLayer = this.layers.find(layer => { var _a; return ((_a = layer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.linkId) === linkedId; });
                    if (childLayer) {
                        if (!layersList.includes(childLayer)) {
                            layersList.push(childLayer);
                        }
                    }
                });
            });
        }
        else {
            // search for parent layer
            this.layers.map(parentLayer => {
                var _a;
                if ((_a = parentLayer.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.links) {
                    parentLayer.options.linkedLayers.links.map(l => {
                        var _a;
                        if (((_a = l.properties) === null || _a === void 0 ? void 0 : _a.indexOf(LinkedProperties.ZINDEX)) !== -1 &&
                            l.bidirectionnal !== false &&
                            l.linkedIds.indexOf(currentLinkedId) !== -1) {
                            layersList.push(parentLayer);
                            this.getLinkedLayers(parentLayer, layersList);
                        }
                    });
                }
            });
        }
    }
    /*
     * For selection mode disabled attribute
     */
    raisableLayers(layers) {
        let response = false;
        let base = 0;
        for (const layer of layers) {
            const mapIndex = this.layers.findIndex((lay) => layer.id === lay.id);
            const currentLayer = this.layers[mapIndex];
            if (currentLayer.baseLayer) {
                base += 1;
            }
            const previousLayer = this.layers[mapIndex - 1];
            if (previousLayer &&
                previousLayer.baseLayer !== true &&
                !layers.find((lay) => previousLayer.id === lay.id) &&
                currentLayer.baseLayer !== true) {
                response = true;
            }
        }
        if ((this.layersChecked.length === 1 && this.layersChecked[0].baseLayer) ||
            base === this.layersChecked.length) {
            response = false;
        }
        return response;
    }
    /*
     * When multiple layers is selected but some may be allow to move
     */
    raisableLayer(index) {
        if (index < 1) {
            return false;
        }
        if (this.layers[index - 1].options.check) {
            return this.raisableLayer(index - 1);
        }
        return true;
    }
    raiseLayers(layers, fromUi = true) {
        const layersToRaise = [];
        for (const layer of layers) {
            const index = this.layers.findIndex((lay) => lay.id === layer.id);
            if (this.raisableLayer(index)) {
                layersToRaise.push(layer);
            }
        }
        this.map.raiseLayers(layersToRaise);
        if (fromUi) {
            setTimeout(() => {
                const elements = this.computeElementRef();
                if (!this.isScrolledIntoView(elements[0], elements[1].offsetParent)) {
                    elements[0].scrollTop = elements[1].offsetParent.offsetTop;
                }
            }, 100);
        }
    }
    /*
     * For selection mode disabled attribute
     */
    lowerableLayers(layers) {
        let response = false;
        let base = 0;
        for (const layer of layers) {
            const mapIndex = this.layers.findIndex((lay) => layer.id === lay.id);
            const currentLayer = this.layers[mapIndex];
            if (currentLayer.baseLayer) {
                base += 1;
            }
            const nextLayer = this.layers[mapIndex + 1];
            if (nextLayer &&
                nextLayer.baseLayer !== true &&
                !layers.find((lay) => nextLayer.id === lay.id)) {
                response = true;
            }
        }
        if ((this.layersChecked.length === 1 && this.layersChecked[0].baseLayer) ||
            base === this.layersChecked.length) {
            response = false;
        }
        return response;
    }
    /*
     * When multiple layers is selected but some may be allow to move
     */
    lowerableLayer(index) {
        if (index >
            this.layers.filter((lay) => lay.baseLayer !== true).length - 2) {
            return false;
        }
        if (this.layers[index + 1].options.check) {
            return this.lowerableLayer(index + 1);
        }
        return true;
    }
    lowerLayers(layers, fromUi = true) {
        const layersToLower = [];
        for (const layer of layers) {
            const index = this.layers.findIndex((lay) => lay.id === layer.id);
            if (this.lowerableLayer(index)) {
                layersToLower.push(layer);
            }
        }
        this.map.lowerLayers(layersToLower);
        if (fromUi) {
            setTimeout(() => {
                const elements = this.computeElementRef('lower');
                if (!this.isScrolledIntoView(elements[0], elements[1].offsetParent)) {
                    elements[0].scrollTop =
                        elements[1].offsetParent.offsetTop +
                            elements[1].offsetParent.offsetHeight -
                            elements[0].clientHeight;
                }
            }, 100);
        }
    }
    next() {
        this.change$.next();
    }
    computeLayers(layers) {
        let layersOut = this.filterLayers(layers);
        if (this.sortAlpha) {
            layersOut = this.sortLayersByTitle(layersOut);
        }
        else {
            layersOut = this.sortLayersByZindex(layersOut);
        }
        return layersOut;
    }
    onKeywordChange(term) {
        this.keyword = term;
    }
    onAppliedFilterAndSortChange(appliedFilter) {
        this.keyword = appliedFilter.keyword;
        this.onlyVisible = appliedFilter.onlyVisible;
        this.sortAlpha = appliedFilter.sortAlpha;
    }
    filterLayers(layers) {
        if (this.layerFilterAndSortOptions.showToolbar === LayerListControlsEnum.never) {
            return layers;
        }
        if (!this.keyword && !this.onlyVisible) {
            return layers;
        }
        const keepLayerIds = layers.map((layer) => layer.id);
        layers.forEach((layer) => {
            const layerOptions = layer.options || {};
            const dataSourceOptions = layer.dataSource.options || {};
            const metadata = layerOptions.metadata || {};
            const keywords = metadata.keywordList || [];
            const layerKeywords = keywords.map((kw) => {
                return kw.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            });
            if (this.keyword && layer.title) {
                const localKeyword = this.keyword
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '');
                const layerTitle = layer.title
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '');
                const dataSourceType = dataSourceOptions.type || '';
                const keywordRegex = new RegExp(localKeyword, 'gi');
                const keywordInList = layerKeywords.find((kw) => keywordRegex.test(kw)) !==
                    undefined;
                if (!keywordRegex.test(layerTitle) &&
                    !(this.keyword.toLowerCase() === dataSourceType.toLowerCase()) &&
                    !keywordInList) {
                    const index = keepLayerIds.indexOf(layer.id);
                    if (index > -1) {
                        keepLayerIds.splice(index, 1);
                    }
                }
            }
            if (this.onlyVisible && layer.visible === false) {
                const index = keepLayerIds.indexOf(layer.id);
                if (index > -1) {
                    keepLayerIds.splice(index, 1);
                }
            }
        });
        return layers.filter((layer) => keepLayerIds.indexOf(layer.id) !== -1);
    }
    sortLayersByZindex(layers) {
        return layers.sort((layer1, layer2) => layer2.zIndex - layer1.zIndex);
    }
    sortLayersByTitle(layers) {
        return layers.sort((a, b) => {
            if (this.normalize(a.title) < this.normalize(b.title)) {
                return -1;
            }
            if (this.normalize(a.title) > this.normalize(b.title)) {
                return 1;
            }
            return 0;
        });
    }
    normalize(str) {
        return str
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .toLowerCase();
    }
    computeShowToolbar() {
        switch (this.layerFilterAndSortOptions.showToolbar) {
            case LayerListControlsEnum.always:
                return true;
            case LayerListControlsEnum.never:
                return false;
            default:
                if (this.layers.length >= this.thresholdToFilterAndSort ||
                    this.keyword ||
                    this.onlyVisible) {
                    return true;
                }
                return false;
        }
    }
    toggleLayerTool(layer) {
        this.toggleOpacity = false;
        if (this.layerTool && layer === this.activeLayer) {
            this.layerTool = false;
        }
        else {
            this.layerTool = true;
        }
        for (const lay of this.layers) {
            lay.options.active = false;
        }
        layer.options.active = true;
        this.activeLayer = layer;
    }
    removeLayers(layers) {
        if (layers && layers.length > 0) {
            this.layersChecked = [];
            for (const layer of layers) {
                if (layer.options.removable !== false) {
                    layer.map.removeLayer(layer);
                }
                else {
                    this.layersChecked.push(layer);
                }
            }
        }
        else if (!layers && this.activeLayer.options.removable !== false) {
            this.activeLayer.map.removeLayer(this.activeLayer);
            this.layerTool = false;
        }
    }
    toggleVisibility(layers) {
        if (layers && layers.length > 0) {
            for (const layer of layers) {
                layer.visible = this.hideSelectedLayers;
            }
        }
        this.layerItemChangeDetection$.next(true);
    }
    isLayerRemovable(layer) {
        return layer.options.removable !== false;
    }
    isAllLayersRemovable(layers) {
        return layers.every(l => this.isLayerRemovable(l));
    }
    get statusSelectedLayersCheck() {
        let statusSelectedLayers = LayerListSelectVisibleEnum.NULL;
        let findTrue = false;
        let findFalse = false;
        if (this.layersChecked.length === 0) {
            statusSelectedLayers = LayerListSelectVisibleEnum.NULL;
        }
        else {
            statusSelectedLayers = LayerListSelectVisibleEnum.MIXED;
            this.hideSelectedLayers = false;
            for (const layer2 of this.layersChecked) {
                if (layer2.visible === true) {
                    findTrue = true;
                }
                if (layer2.visible === false) {
                    findFalse = true;
                }
            }
            if (findTrue === true && findFalse === false) {
                statusSelectedLayers = LayerListSelectVisibleEnum.ALL_VISIBLE;
            }
            if (findTrue === false && findFalse === true) {
                statusSelectedLayers = LayerListSelectVisibleEnum.ALL_HIDDEN;
                this.hideSelectedLayers = true;
            }
        }
        return statusSelectedLayers;
    }
    layersCheck(event) {
        event.layer.options.check = event.check;
        if (event.check === true) {
            const eventMapIndex = this.layers.findIndex((layer) => event.layer.id === layer.id);
            for (const layer of this.layersChecked) {
                const mapIndex = this.layers.findIndex((lay) => layer.id === lay.id);
                if (eventMapIndex < mapIndex) {
                    this.layersChecked.splice(this.layersChecked.findIndex((lay) => layer.id === lay.id), 0, event.layer);
                    if (this.excludeBaseLayers) {
                        if (this.layersChecked.length ===
                            this.layers.filter((lay) => lay.baseLayer !== true && lay.showInLayerList).length) {
                            this.selectAllCheck = true;
                        }
                        else {
                            this.selectAllCheck = false;
                        }
                    }
                    else if (!this.excludeBaseLayers) {
                        if (this.layersChecked.length ===
                            this.layers.filter((lay) => lay.showInLayerList).length) {
                            this.selectAllCheck = true;
                        }
                        else {
                            this.selectAllCheck = false;
                        }
                    }
                    return;
                }
            }
            this.layersChecked.push(event.layer);
        }
        else {
            const index = this.layersChecked.findIndex((layer) => event.layer.id === layer.id);
            this.layersChecked.splice(index, 1);
        }
        if (this.excludeBaseLayers) {
            if (this.layersChecked.length ===
                this.layers.filter((lay) => lay.baseLayer !== true && lay.showInLayerList).length) {
                this.selectAllCheck = true;
            }
            else {
                this.selectAllCheck = false;
            }
        }
        else if (!this.excludeBaseLayers) {
            if (this.layersChecked.length ===
                this.layers.filter((lay) => lay.showInLayerList).length) {
                this.selectAllCheck = true;
            }
            else {
                this.selectAllCheck = false;
            }
        }
    }
    toggleSelectionMode(value) {
        this.selection = value;
        this.activeLayer = undefined;
        if (value === true) {
            this.layerTool = false;
            for (const layer of this.layers) {
                if (layer.options.check) {
                    this.layersChecked.push(layer);
                }
            }
        }
    }
    layersCheckedOpacity() {
        if (this.layersChecked.length > 1) {
            return 1;
        }
        else {
            const opacity = [];
            for (const layer of this.layersChecked) {
                opacity.push(layer.opacity);
            }
            return opacity;
        }
    }
    selectAll() {
        if (!this.selectAllCheck) {
            for (const layer of this.layers) {
                if (this.excludeBaseLayers &&
                    layer.baseLayer !== true &&
                    layer.showInLayerList) {
                    layer.options.check = true;
                    this.layersChecked.push(layer);
                }
                else if (!this.excludeBaseLayers && layer.showInLayerList) {
                    layer.options.check = true;
                    this.layersChecked.push(layer);
                }
            }
            this.selectAllCheck$.next(true);
        }
        else {
            for (const layer of this.layers) {
                layer.options.check = false;
            }
            this.layersChecked = [];
            this.selectAllCheck$.next(false);
        }
    }
    isScrolledIntoView(elemSource, elem) {
        const docViewTop = elemSource.scrollTop;
        const docViewBottom = docViewTop + elemSource.clientHeight;
        const elemTop = elem.offsetTop;
        const elemBottom = elemTop + elem.clientHeight;
        return elemBottom <= docViewBottom && elemTop >= docViewTop;
    }
    computeElementRef(type) {
        const checkItems = this.elRef.nativeElement.getElementsByClassName('mat-checkbox-checked');
        const checkItem = type === 'lower'
            ? this.elRef.nativeElement.getElementsByClassName('mat-checkbox-checked')[checkItems.length - 1]
            : this.elRef.nativeElement.getElementsByClassName('mat-checkbox-checked')[0];
        const igoList = this.elRef.nativeElement.getElementsByTagName('igo-list')[0];
        return [igoList, checkItem];
    }
    removeProblemLayerInList(layersList) {
        for (const layer of layersList) {
            if (layer.olLoadingProblem === true) {
                this.map.removeLayer(layer);
            }
        }
        return layersList;
    }
}
LayerListComponent.ɵfac = function LayerListComponent_Factory(t) { return new (t || LayerListComponent)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
LayerListComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: LayerListComponent, selectors: [["igo-layer-list"]], contentQueries: function LayerListComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, _c0$d, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateLayerToolbar = _t.first);
    } }, inputs: { layersAreAllVisible: "layersAreAllVisible", ogcButton: "ogcButton", timeButton: "timeButton", map: "map", layers: "layers", floatLabel: "floatLabel", layerFilterAndSortOptions: "layerFilterAndSortOptions", excludeBaseLayers: "excludeBaseLayers", toggleLegendOnVisibilityChange: "toggleLegendOnVisibilityChange", expandLegendOfVisibleLayers: "expandLegendOfVisibleLayers", updateLegendOnResolutionChange: "updateLegendOnResolutionChange", queryBadge: "queryBadge" }, outputs: { appliedFilterAndSort: "appliedFilterAndSort" }, ngContentSelectors: _c4$1, decls: 11, vars: 16, consts: [["floatLabel", "auto", 3, "layersAreAllVisible", "term", "onlyVisible", "sortAlpha", "appliedFilterAndSort", "selection", 4, "ngIf"], ["class", "select-all", 4, "ngIf"], [3, "ngClass", "navigation", "selection"], ["igoList", ""], ["ngFor", "", 3, "ngForOf"], ["class", "igo-layer-actions-container", 3, "title", 4, "ngIf"], ["floatLabel", "auto", 3, "layersAreAllVisible", "term", "onlyVisible", "sortAlpha", "appliedFilterAndSort", "selection"], [1, "select-all"], [1, "select-all-checkbox", "mat-subheading-2", 3, "color", "checked", "indeterminate", "change"], ["igoListItem", "", 3, "layer", "activeLayer", "orderable", "lowerDisabled", "raiseDisabled", "queryBadge", "expandLegendIfVisible", "updateLegendOnResolutionChange", "toggleLegendOnVisibilityChange", "selectionMode", "selectAll", "layerCheck", "changeDetection", "action", "checkbox", 4, "ngIf"], ["igoListItem", "", 3, "layer", "activeLayer", "orderable", "lowerDisabled", "raiseDisabled", "queryBadge", "expandLegendIfVisible", "updateLegendOnResolutionChange", "toggleLegendOnVisibilityChange", "selectionMode", "selectAll", "layerCheck", "changeDetection", "action", "checkbox"], [1, "igo-layer-actions-container", 3, "title"], [1, "igo-layer-button-group"], ["class", "delete-button", "mat-icon-button", "", "color", "warn", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "click", 4, "ngIf"], ["mat-icon-button", "", "color", "primary", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "down-button", 3, "matTooltip", "disabled", "click"], ["matBadgeColor", "warn", "matBadgeSize", "medium", "svgIcon", "arrow-down", 3, "matBadge", "matBadgeHidden"], ["color", "primary", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "up-button", 3, "matTooltip", "disabled", "click"], ["matBadgeColor", "warn", "matBadgeSize", "medium", "svgIcon", "arrow-up", 3, "matBadge", "matBadgeHidden"], ["color", "primary", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "opacity-button", 3, "matMenuTriggerFor", "matTooltip"], ["matBadgeColor", "primary", "matBadgeSize", "medium", "svgIcon", "opacity", 3, "matBadge"], [1, "mat-menu-opacity-slider"], ["opacityMenu", "matMenu"], ["id", "opacity-menu"], ["id", "opacity-slider", "color", "primary", "thumbLabel", "", "tickInterval", "5", "step", "5", "matTooltipShowDelay", "500", "tooltip-position", "below", 3, "min", "max", "value", "matTooltip", "input", "click"], ["class", "zoomLayer-button", "color", "primary", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "click", 4, "ngIf"], ["igoLayerItemToolbar", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["mat-icon-button", "", "color", "warn", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "delete-button", 3, "matTooltip", "click"], ["svgIcon", "delete"], ["color", "primary", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "zoomLayer-button", 3, "matTooltip", "click"], ["matBadgeColor", "primary", "matBadgeSize", "medium", "svgIcon", "magnify-scan"], [1, "actions-buttons-multi"], ["mat-icon-button", "", "color", "warn", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "delete-button", 3, "disabled", "matTooltip", "click"], ["matBadgeColor", "warn", "matBadgeSize", "medium", "svgIcon", "delete", 3, "matBadge", "matBadgeHidden"], ["mat-icon-button", "", "color", "primary", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "eye-button", 3, "disabled", "matTooltip", "click"], [3, "svgIcon"], ["color", "primary", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "opacity-button", 3, "disabled", "matMenuTriggerFor", "matTooltip"], ["svgIcon", "opacity"], ["id", "opacity-slider", "color", "primary", "thumbLabel", "", "tickInterval", "5", "step", "5", "matTooltipShowDelay", "500", "tooltip-position", "below", 3, "min", "max", "ngModel", "matTooltip", "ngModelChange", "click", 4, "ngIf"], ["id", "opacity-slider", "color", "primary", "thumbLabel", "", "tickInterval", "5", "step", "5", "matTooltipShowDelay", "500", "tooltip-position", "below", 3, "min", "max", "ngModel", "matTooltip", "ngModelChange", "click"], ["svgIcon", "magnify-scan"]], template: function LayerListComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c2$5);
        i0.ɵɵelementStart(0, "mat-list");
        i0.ɵɵtemplate(1, LayerListComponent_igo_layer_list_tool_1_Template, 1, 4, "igo-layer-list-tool", 0);
        i0.ɵɵpipe(2, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(3, LayerListComponent_mat_list_item_3_Template, 5, 8, "mat-list-item", 1);
        i0.ɵɵelement(4, "mat-divider");
        i0.ɵɵelementStart(5, "igo-list", 2, 3);
        i0.ɵɵtemplate(7, LayerListComponent_ng_template_7_Template, 1, 1, "ng-template", 4);
        i0.ɵɵpipe(8, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(9, LayerListComponent_igo_panel_9_Template, 22, 34, "igo-panel", 5);
        i0.ɵɵtemplate(10, LayerListComponent_igo_panel_10_Template, 27, 41, "igo-panel", 5);
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(2, 8, ctx.showToolbar$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.selection);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction3(12, _c3$2, ctx.selection, ctx.layerTool && !ctx.selection, !ctx.layerTool && !ctx.selection))("navigation", false)("selection", false);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(8, 10, ctx.layers$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.selection && ctx.layerTool && ctx.activeLayer);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.selection && ctx.layers.length > 0);
    } }, styles: ["[_nghost-%COMP%]   .igo-list-no-tools[_ngcontent-%COMP%]{height:calc(100% - 57px);padding-top:8px}[_nghost-%COMP%]   .igo-list-tools-single[_ngcontent-%COMP%]{height:calc(100% - 153px);padding-top:8px}[_nghost-%COMP%]   .igo-list-tools-multi[_ngcontent-%COMP%]{height:calc(100% - 191px);padding-top:8px}mat-form-field.inputFilter[_ngcontent-%COMP%]{width:calc(100% - 100px);max-width:200px}.igo-layer-actions-container[_ngcontent-%COMP%]{width:calc(100% - 5px);padding-left:4px}.igo-layer-actions-container[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{text-align:center}mat-list-item[_ngcontent-%COMP%]     .mat-list-item-content{margin-bottom:10px}mat-checkbox[_ngcontent-%COMP%]     .mat-checkbox-inner-container{margin-left:8px;margin-right:16px}#opacity-slider[_ngcontent-%COMP%]{float:left;min-width:unset;width:110px;left:10px;top:10px}.igo-layer-button-group[_ngcontent-%COMP%], .actions-buttons-multi[_ngcontent-%COMP%]{display:flex;align-items:center;flex-direction:row-reverse;overflow-x:auto;overflow-y:hidden}.igo-layer-button-group[_ngcontent-%COMP%]::-webkit-scrollbar, .actions-buttons-multi[_ngcontent-%COMP%]::-webkit-scrollbar{height:4px}.igo-layer-button-group[_ngcontent-%COMP%]::-webkit-scrollbar-track, .actions-buttons-multi[_ngcontent-%COMP%]::-webkit-scrollbar-track{background:#f1f1f1}.igo-layer-button-group[_ngcontent-%COMP%]::-webkit-scrollbar-thumb, .actions-buttons-multi[_ngcontent-%COMP%]::-webkit-scrollbar-thumb{background:#888}.igo-layer-button-group[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover, .actions-buttons-multi[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover{background:#555}.igo-layer-button-group[_ngcontent-%COMP%]{padding-top:5px}[_nghost-%COMP%]   igo-panel[_ngcontent-%COMP%]{height:unset}#opacity-menu[_ngcontent-%COMP%]{max-width:unset;width:132px;height:50px}#opacity-menu[_ngcontent-%COMP%]   .mat-menu-content[_ngcontent-%COMP%]:not(:empty){padding-top:20px}.select-all[_ngcontent-%COMP%]     .mat-list-item-content{margin:0}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LayerListComponent, [{
        type: Component,
        args: [{
                selector: 'igo-layer-list',
                templateUrl: './layer-list.component.html',
                styleUrls: ['./layer-list.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i0.ElementRef }]; }, { templateLayerToolbar: [{
            type: ContentChild,
            args: ['igoLayerItemToolbar', /* TODO: add static flag */ {}]
        }], layersAreAllVisible: [{
            type: Input
        }], ogcButton: [{
            type: Input
        }], timeButton: [{
            type: Input
        }], map: [{
            type: Input
        }], layers: [{
            type: Input
        }], floatLabel: [{
            type: Input
        }], layerFilterAndSortOptions: [{
            type: Input
        }], excludeBaseLayers: [{
            type: Input
        }], toggleLegendOnVisibilityChange: [{
            type: Input
        }], expandLegendOfVisibleLayers: [{
            type: Input
        }], updateLegendOnResolutionChange: [{
            type: Input
        }], queryBadge: [{
            type: Input
        }], appliedFilterAndSort: [{
            type: Output
        }] }); })();

function LayerListToolComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r2 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 9);
    i0.ɵɵlistener("click", function LayerListToolComponent_button_5_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r2); const ctx_r1 = i0.ɵɵnextContext(); return ctx_r1.clearTerm(); });
    i0.ɵɵelement(1, "mat-icon", 10);
    i0.ɵɵelementEnd();
} }
class LayerListToolComponent {
    constructor() {
        this.onlyVisible$ = new BehaviorSubject(false);
        this.sortAlpha$ = new BehaviorSubject(false);
        this.term$ = new BehaviorSubject(undefined);
        this.layersAreAllVisible = true;
        this.floatLabel = 'auto';
        this.selectionMode = false;
        this.appliedFilterAndSort = new EventEmitter();
        this.selection = new EventEmitter();
    }
    set onlyVisible(value) {
        this.onlyVisible$.next(value);
    }
    get onlyVisible() {
        return this.onlyVisible$.value;
    }
    set sortAlpha(value) {
        this.sortAlpha$.next(value);
    }
    get sortAlpha() {
        return this.sortAlpha$.value;
    }
    set term(value) {
        this.term$.next(value);
    }
    get term() {
        return this.term$.value;
    }
    ngOnInit() {
        this.term$$ = this.term$.subscribe(keyword => {
            this.appliedFilterAndSort.emit({
                keyword,
                onlyVisible: this.onlyVisible,
                sortAlpha: this.sortAlpha
            });
        });
        this.onlyVisible$$ = this.onlyVisible$.subscribe(onlyVisible => {
            this.appliedFilterAndSort.emit({
                keyword: this.term,
                onlyVisible,
                sortAlpha: this.sortAlpha
            });
        });
        this.sortAlpha$$ = this.sortAlpha$.subscribe(sortAlpha => {
            this.appliedFilterAndSort.emit({
                keyword: this.term,
                onlyVisible: this.onlyVisible,
                sortAlpha
            });
        });
    }
    ngOnDestroy() {
        this.onlyVisible$$.unsubscribe();
        this.sortAlpha$$.unsubscribe();
        this.term$$.unsubscribe();
    }
    clearTerm() {
        this.term = undefined;
    }
    toggleSortAlpha() {
        this.sortAlpha = !this.sortAlpha;
    }
    toggleOnlyVisible() {
        this.onlyVisible = !this.onlyVisible;
    }
    toggleSelectionMode() {
        this.selectionMode = !this.selectionMode;
        this.selection.emit(this.selectionMode);
    }
}
LayerListToolComponent.ɵfac = function LayerListToolComponent_Factory(t) { return new (t || LayerListToolComponent)(); };
LayerListToolComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: LayerListToolComponent, selectors: [["igo-layer-list-tool"]], inputs: { layersAreAllVisible: "layersAreAllVisible", floatLabel: "floatLabel", onlyVisible: "onlyVisible", sortAlpha: "sortAlpha", term: "term" }, outputs: { appliedFilterAndSort: "appliedFilterAndSort", selection: "selection" }, decls: 21, vars: 30, consts: [[1, "inputFilter", 3, "floatLabel"], ["matInput", "", "matTooltipShowDelay", "500", "type", "text", 3, "placeholder", "matTooltip", "ngModel", "ngModelChange"], ["mat-button", "", "matSuffix", "", "mat-icon-button", "", "aria-label", "Clear", "color", "warn", 3, "click", 4, "ngIf"], ["matTooltipShowDelay", "500", 3, "matTooltip"], ["mat-icon-button", "", 1, "sort-alpha", 3, "color", "click"], [3, "svgIcon"], ["mat-icon-button", "", 1, "only-visible", 3, "disabled", "color", "click"], ["matBadge", "icon", "igoMatBadgeIcon", "eye", "igoMatBadgeInverseColor", "true", "igoMatBadgeInheritColor", "true", 3, "svgIcon"], ["mat-icon-button", "", "color", "primary", 1, "selection-mode", 3, "click"], ["mat-button", "", "matSuffix", "", "mat-icon-button", "", "aria-label", "Clear", "color", "warn", 3, "click"], ["svgIcon", "close"]], template: function LayerListToolComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-list-item");
        i0.ɵɵelementStart(1, "mat-form-field", 0);
        i0.ɵɵelementStart(2, "input", 1);
        i0.ɵɵlistener("ngModelChange", function LayerListToolComponent_Template_input_ngModelChange_2_listener($event) { return ctx.term = $event; });
        i0.ɵɵpipe(3, "translate");
        i0.ɵɵpipe(4, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(5, LayerListToolComponent_button_5_Template, 2, 0, "button", 2);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(6, "div", 3);
        i0.ɵɵpipe(7, "translate");
        i0.ɵɵpipe(8, "translate");
        i0.ɵɵelementStart(9, "button", 4);
        i0.ɵɵlistener("click", function LayerListToolComponent_Template_button_click_9_listener() { return ctx.toggleSortAlpha(); });
        i0.ɵɵelement(10, "mat-icon", 5);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(11, "div", 3);
        i0.ɵɵpipe(12, "translate");
        i0.ɵɵpipe(13, "translate");
        i0.ɵɵelementStart(14, "button", 6);
        i0.ɵɵlistener("click", function LayerListToolComponent_Template_button_click_14_listener() { return ctx.toggleOnlyVisible(); });
        i0.ɵɵelement(15, "mat-icon", 7);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(16, "div", 3);
        i0.ɵɵpipe(17, "translate");
        i0.ɵɵpipe(18, "translate");
        i0.ɵɵelementStart(19, "button", 8);
        i0.ɵɵlistener("click", function LayerListToolComponent_Template_button_click_19_listener() { return ctx.toggleSelectionMode(); });
        i0.ɵɵelement(20, "mat-icon", 5);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("floatLabel", ctx.floatLabel);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("placeholder", i0.ɵɵpipeBind1(3, 14, "igo.geo.layer.filterPlaceholder"))("matTooltip", i0.ɵɵpipeBind1(4, 16, "igo.geo.layer.subsetLayersListKeyword"))("ngModel", ctx.term);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.term);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", ctx.sortAlpha ? i0.ɵɵpipeBind1(7, 18, "igo.geo.layer.sortMapOrder") : i0.ɵɵpipeBind1(8, 20, "igo.geo.layer.sortAlphabetically"));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("color", ctx.sortAlpha ? "warn" : "primary");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("svgIcon", ctx.sortAlpha ? "sort-ascending" : "sort-alphabetical-ascending");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", ctx.onlyVisible ? i0.ɵɵpipeBind1(12, 22, "igo.geo.layer.resetLayersList") : i0.ɵɵpipeBind1(13, 24, "igo.geo.layer.subsetLayersListOnlyVisible"));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("disabled", ctx.layersAreAllVisible && !ctx.onlyVisible)("color", ctx.onlyVisible ? "warn" : "primary");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("svgIcon", ctx.onlyVisible ? "filter-remove" : "filter");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", ctx.selectionMode ? i0.ɵɵpipeBind1(17, 26, "igo.geo.layer.deactivateSelectionMode") : i0.ɵɵpipeBind1(18, 28, "igo.geo.layer.activateSelectionMode"));
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("svgIcon", ctx.selectionMode ? "checkbox-multiple-marked-outline" : "checkbox-multiple-blank-outline");
    } }, directives: [i1$3.MatListItem, i12.MatFormField, i5$1.MatInput, i16.DefaultValueAccessor, i3.MatTooltip, i16.NgControlStatus, i16.NgModel, i1$1.NgIf, i2.MatButton, i4.MatIcon, i9$1.MatBadge, i6.IgoBadgeIconDirective, i12.MatSuffix], pipes: [i7.TranslatePipe], styles: ["mat-form-field.inputFilter[_ngcontent-%COMP%]{width:calc(100% - 100px);max-width:200px}.selection-mode[_ngcontent-%COMP%]{margin-left:5px}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LayerListToolComponent, [{
        type: Component,
        args: [{
                selector: 'igo-layer-list-tool',
                templateUrl: './layer-list-tool.component.html',
                styleUrls: ['./layer-list-tool.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { layersAreAllVisible: [{
            type: Input
        }], floatLabel: [{
            type: Input
        }], onlyVisible: [{
            type: Input
        }], sortAlpha: [{
            type: Input
        }], term: [{
            type: Input
        }], appliedFilterAndSort: [{
            type: Output
        }], selection: [{
            type: Output
        }] }); })();

class LayerListBindingDirective {
    constructor(component, mapService, route) {
        this.mapService = mapService;
        this.route = route;
        this.component = component;
    }
    ngOnInit() {
        // Override input layers
        // this.component.layers = [];
        this.layersOrResolutionChange$$ = combineLatest([
            this.mapService.getMap().layers$,
            this.mapService.getMap().viewController.resolution$
        ]).pipe(debounceTime(10)).subscribe((bunch) => {
            const shownLayers = bunch[0].filter((layer) => {
                return layer.showInLayerList === true;
            });
            this.component.layers = shownLayers;
            this.setLayersVisibilityStatus(shownLayers, this.component.excludeBaseLayers);
        });
    }
    setLayersVisibilityStatus(layers, excludeBaseLayers) {
        if (this.layersVisibility$$ !== undefined) {
            this.layersVisibility$$.unsubscribe();
            this.layersVisibility$$ = undefined;
        }
        this.layersVisibility$$ = combineLatest(layers
            .filter(layer => layer.baseLayer !== excludeBaseLayers)
            .map((layer) => layer.visible$))
            .pipe(map((visibles) => visibles.every(Boolean)))
            .subscribe((allLayersAreVisible) => this.component.layersAreAllVisible = allLayersAreVisible);
    }
    ngOnDestroy() {
        this.layersOrResolutionChange$$.unsubscribe();
        if (this.layersVisibility$$ !== undefined) {
            this.layersVisibility$$.unsubscribe();
            this.layersVisibility$$ = undefined;
        }
    }
}
LayerListBindingDirective.ɵfac = function LayerListBindingDirective_Factory(t) { return new (t || LayerListBindingDirective)(i0.ɵɵdirectiveInject(LayerListComponent, 2), i0.ɵɵdirectiveInject(MapService), i0.ɵɵdirectiveInject(i2$1.RouteService, 8)); };
LayerListBindingDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: LayerListBindingDirective, selectors: [["", "igoLayerListBinding", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LayerListBindingDirective, [{
        type: Directive,
        args: [{
                selector: '[igoLayerListBinding]'
            }]
    }], function () { return [{ type: LayerListComponent, decorators: [{
                type: Self
            }] }, { type: MapService }, { type: i2$1.RouteService, decorators: [{
                type: Optional
            }] }]; }, null); })();

function LayerLegendListComponent_mat_slide_toggle_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-slide-toggle", 6);
    i0.ɵɵlistener("change", function LayerLegendListComponent_mat_slide_toggle_1_Template_mat_slide_toggle_change_0_listener($event) { i0.ɵɵrestoreView(_r8); const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.toggleShowAllLegends($event.checked); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 4, "igo.geo.layer.legend.showAll"))("checked", ctx_r0.showAllLegendsValue)("labelPosition", "before");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(3, 6, "igo.geo.layer.legend.showAll"), " ");
} }
function LayerLegendListComponent_mat_divider_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-divider");
} }
function LayerLegendListComponent_ng_template_6_igo_layer_legend_item_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-layer-legend-item", 8);
} if (rf & 2) {
    const layer_r9 = i0.ɵɵnextContext().$implicit;
    const ctx_r11 = i0.ɵɵnextContext();
    i0.ɵɵproperty("layer", layer_r9)("updateLegendOnResolutionChange", ctx_r11.updateLegendOnResolutionChange);
} }
function LayerLegendListComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, LayerLegendListComponent_ng_template_6_igo_layer_legend_item_0_Template, 1, 2, "igo-layer-legend-item", 7);
} if (rf & 2) {
    const layer_r9 = ctx.$implicit;
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngIf", !(ctx_r2.excludeBaseLayers && layer_r9.baseLayer));
} }
function LayerLegendListComponent_p_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 9);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 1, "igo.geo.layer.legend.noLayersVisibleWithShowAllButton"), " ");
} }
function LayerLegendListComponent_p_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 9);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 1, "igo.geo.layer.legend.noLayersVisibleWithShowAllButtonButZoom"), " ");
} }
function LayerLegendListComponent_p_16_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 9);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 1, "igo.geo.layer.legend.noLayersVisible"), " ");
} }
function LayerLegendListComponent_p_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 9);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 1, "igo.geo.layer.legend.noLayersVisibleButZoom"), " ");
} }
class LayerLegendListComponent {
    constructor() {
        this.orderable = true;
        this.hasVisibleOrInRangeLayers$ = new BehaviorSubject(true);
        this.hasVisibleAndNotInRangeLayers$ = new BehaviorSubject(true);
        this.layersInUi$ = new BehaviorSubject([]);
        this.layers$ = new BehaviorSubject([]);
        this.showAllLegend = false;
        this.change$ = new ReplaySubject(1);
        this.excludeBaseLayers = false;
        this.updateLegendOnResolutionChange = false;
        this.allowShowAllLegends = false;
        this.showAllLegendsValue = false;
        this.allLegendsShown = new EventEmitter(false);
    }
    set layers(value) {
        this._layers = value;
        this.next();
    }
    get layers() {
        return this._layers;
    }
    ngOnInit() {
        this.change$$ = this.change$
            .pipe(debounce(() => {
            return this.layers.length === 0 ? EMPTY : timer(50);
        }))
            .subscribe(() => {
            const layers = this.computeShownLayers(this.layers.slice(0));
            this.layers$.next(layers);
            this.hasVisibleOrInRangeLayers$.next(this.layers.slice(0)
                .filter(layer => layer.baseLayer !== true)
                .filter(layer => layer.visible$.value && layer.isInResolutionsRange$.value).length > 0);
            this.hasVisibleAndNotInRangeLayers$.next(this.layers.slice(0)
                .filter(layer => layer.baseLayer !== true)
                .filter(layer => layer.visible$.value && !layer.isInResolutionsRange$.value).length > 0);
            this.layersInUi$.next(this.layers.slice(0).filter(layer => layer.showInLayerList !== false && (!this.excludeBaseLayers || !layer.baseLayer)));
        });
    }
    ngOnDestroy() {
        this.change$$.unsubscribe();
    }
    next() {
        this.change$.next();
    }
    computeShownLayers(layers) {
        let shownLayers = layers.filter((layer) => layer.visible && layer.isInResolutionsRange);
        if (this.showAllLegendsValue) {
            shownLayers = layers;
        }
        return this.sortLayersByZindex(shownLayers);
    }
    sortLayersByZindex(layers) {
        return layers.sort((layer1, layer2) => layer2.zIndex - layer1.zIndex);
    }
    toggleShowAllLegends(toggle) {
        this.showAllLegendsValue = toggle;
        this.next();
        this.allLegendsShown.emit(toggle);
    }
}
LayerLegendListComponent.ɵfac = function LayerLegendListComponent_Factory(t) { return new (t || LayerLegendListComponent)(); };
LayerLegendListComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: LayerLegendListComponent, selectors: [["igo-layer-legend-list"]], inputs: { layers: "layers", excludeBaseLayers: "excludeBaseLayers", updateLegendOnResolutionChange: "updateLegendOnResolutionChange", allowShowAllLegends: "allowShowAllLegends", showAllLegendsValue: "showAllLegendsValue" }, outputs: { allLegendsShown: "allLegendsShown" }, decls: 24, vars: 39, consts: [[1, "layer-legend-list-container"], ["tooltip-position", "above", "matTooltipShowDelay", "500", "class", "mat-typography", 3, "matTooltip", "checked", "labelPosition", "change", 4, "ngIf"], [4, "ngIf"], [3, "navigation", "selection"], ["ngFor", "", 3, "ngForOf"], ["class", "layers-empty mat-typography", 4, "ngIf"], ["tooltip-position", "above", "matTooltipShowDelay", "500", 1, "mat-typography", 3, "matTooltip", "checked", "labelPosition", "change"], ["igoListItem", "", 3, "layer", "updateLegendOnResolutionChange", 4, "ngIf"], ["igoListItem", "", 3, "layer", "updateLegendOnResolutionChange"], [1, "layers-empty", "mat-typography"]], template: function LayerLegendListComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtemplate(1, LayerLegendListComponent_mat_slide_toggle_1_Template, 4, 8, "mat-slide-toggle", 1);
        i0.ɵɵpipe(2, "async");
        i0.ɵɵtemplate(3, LayerLegendListComponent_mat_divider_3_Template, 1, 0, "mat-divider", 2);
        i0.ɵɵpipe(4, "async");
        i0.ɵɵelementStart(5, "igo-list", 3);
        i0.ɵɵtemplate(6, LayerLegendListComponent_ng_template_6_Template, 1, 1, "ng-template", 4);
        i0.ɵɵpipe(7, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(8, LayerLegendListComponent_p_8_Template, 3, 3, "p", 5);
        i0.ɵɵpipe(9, "async");
        i0.ɵɵpipe(10, "async");
        i0.ɵɵpipe(11, "async");
        i0.ɵɵtemplate(12, LayerLegendListComponent_p_12_Template, 3, 3, "p", 5);
        i0.ɵɵpipe(13, "async");
        i0.ɵɵpipe(14, "async");
        i0.ɵɵpipe(15, "async");
        i0.ɵɵtemplate(16, LayerLegendListComponent_p_16_Template, 3, 3, "p", 5);
        i0.ɵɵpipe(17, "async");
        i0.ɵɵpipe(18, "async");
        i0.ɵɵpipe(19, "async");
        i0.ɵɵtemplate(20, LayerLegendListComponent_p_20_Template, 3, 3, "p", 5);
        i0.ɵɵpipe(21, "async");
        i0.ɵɵpipe(22, "async");
        i0.ɵɵpipe(23, "async");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(2, 9, ctx.layersInUi$).length && ctx.allowShowAllLegends);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(4, 11, ctx.layersInUi$).length && ctx.allowShowAllLegends);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("navigation", false)("selection", false);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(7, 13, ctx.layers$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.showAllLegendsValue && i0.ɵɵpipeBind1(9, 15, ctx.layersInUi$).length && i0.ɵɵpipeBind1(10, 17, ctx.hasVisibleOrInRangeLayers$) === false && i0.ɵɵpipeBind1(11, 19, ctx.hasVisibleAndNotInRangeLayers$) === false && ctx.allowShowAllLegends);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", !ctx.showAllLegendsValue && i0.ɵɵpipeBind1(13, 21, ctx.layersInUi$).length && i0.ɵɵpipeBind1(14, 23, ctx.hasVisibleOrInRangeLayers$) === false && i0.ɵɵpipeBind1(15, 25, ctx.hasVisibleAndNotInRangeLayers$) && ctx.allowShowAllLegends);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(17, 27, ctx.layersInUi$).length && i0.ɵɵpipeBind1(18, 29, ctx.hasVisibleOrInRangeLayers$) === false && i0.ɵɵpipeBind1(19, 31, ctx.hasVisibleAndNotInRangeLayers$) === false && !ctx.allowShowAllLegends);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(21, 33, ctx.layersInUi$).length && i0.ɵɵpipeBind1(22, 35, ctx.hasVisibleOrInRangeLayers$) === false && i0.ɵɵpipeBind1(23, 37, ctx.hasVisibleAndNotInRangeLayers$) && !ctx.allowShowAllLegends);
    } }, styles: ["mat-slide-toggle[_ngcontent-%COMP%]{width:100%;margin:10px}mat-slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-content{width:calc(100% - 60px)}igo-list[_ngcontent-%COMP%]{display:contents}.layers-empty[_ngcontent-%COMP%]{text-align:justify;margin:10px}.layer-legend-list-container[_ngcontent-%COMP%]{max-height:100%;overflow:auto}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LayerLegendListComponent, [{
        type: Component,
        args: [{
                selector: 'igo-layer-legend-list',
                templateUrl: './layer-legend-list.component.html',
                styleUrls: ['./layer-legend-list.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { layers: [{
            type: Input
        }], excludeBaseLayers: [{
            type: Input
        }], updateLegendOnResolutionChange: [{
            type: Input
        }], allowShowAllLegends: [{
            type: Input
        }], showAllLegendsValue: [{
            type: Input
        }], allLegendsShown: [{
            type: Output
        }] }); })();

class LayerLegendListBindingDirective {
    constructor(component, mapService) {
        this.mapService = mapService;
        this.component = component;
    }
    ngOnInit() {
        // Override input layers
        this.component.layers = [];
        this.layersOrResolutionChange$$ = combineLatest([
            this.mapService.getMap().layers$,
            this.mapService.getMap().viewController.resolution$
        ]).pipe(debounceTime(10)).subscribe((bunch) => {
            const shownLayers = bunch[0].filter((layer) => {
                return layer.showInLayerList === true;
            });
            this.component.layers = shownLayers;
            this.layersVisibility$$ = combineLatest(shownLayers
                .map((layer) => layer.visible$))
                .subscribe((r) => {
                this.component.change$.next();
            });
        });
    }
    ngOnDestroy() {
        this.layersOrResolutionChange$$.unsubscribe();
        if (this.layersVisibility$$ !== undefined) {
            this.layersVisibility$$.unsubscribe();
            this.layersVisibility$$ = undefined;
        }
    }
}
LayerLegendListBindingDirective.ɵfac = function LayerLegendListBindingDirective_Factory(t) { return new (t || LayerLegendListBindingDirective)(i0.ɵɵdirectiveInject(LayerLegendListComponent, 2), i0.ɵɵdirectiveInject(MapService)); };
LayerLegendListBindingDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: LayerLegendListBindingDirective, selectors: [["", "igoLayerLegendListBinding", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LayerLegendListBindingDirective, [{
        type: Directive,
        args: [{
                selector: '[igoLayerLegendListBinding]'
            }]
    }], function () { return [{ type: LayerLegendListComponent, decorators: [{
                type: Self
            }] }, { type: MapService }]; }, null); })();

function TrackFeatureButtonComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 1);
    i0.ɵɵlistener("click", function TrackFeatureButtonComponent_button_0_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r2); const ctx_r1 = i0.ɵɵnextContext(); return ctx_r1.toggleTrackFeature(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 2, "igo.geo.layer.trackFeature"))("color", ctx_r0.color);
} }
class TrackFeatureButtonComponent {
    constructor() {
        this.trackFeature = false;
        this.color = 'primary';
    }
    get options() {
        if (!this.layer) {
            return;
        }
        return this.layer.options;
    }
    ngOnInit() {
        this.color = this.trackFeature ? 'primary' : 'basic';
    }
    toggleTrackFeature() {
        if (this.trackFeature) {
            this.layer.disableTrackFeature(this.layer.options.trackFeature);
            this.color = 'basic';
        }
        else {
            this.layer.enableTrackFeature(this.layer.options.trackFeature);
            this.color = 'primary';
        }
        this.trackFeature = !this.trackFeature;
    }
}
TrackFeatureButtonComponent.ɵfac = function TrackFeatureButtonComponent_Factory(t) { return new (t || TrackFeatureButtonComponent)(); };
TrackFeatureButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TrackFeatureButtonComponent, selectors: [["igo-track-feature-button"]], inputs: { layer: "layer", trackFeature: "trackFeature" }, decls: 1, vars: 1, consts: [["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", "click", 4, "ngIf"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", "click"], ["svgIcon", "crosshairs-gps"]], template: function TrackFeatureButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TrackFeatureButtonComponent_button_0_Template, 3, 4, "button", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.options.trackFeature);
    } }, directives: [i1$1.NgIf, i2.MatButton, i3.MatTooltip, i4.MatIcon], pipes: [i7.TranslatePipe], styles: [""], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TrackFeatureButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-track-feature-button',
                templateUrl: './track-feature-button.component.html',
                styleUrls: ['./track-feature-button.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { layer: [{
            type: Input
        }], trackFeature: [{
            type: Input
        }] }); })();

class LayerLegendItemComponent {
    constructor(networkService) {
        this.networkService = networkService;
        this.inResolutionRange$ = new BehaviorSubject(true);
        this.updateLegendOnResolutionChange = false;
    }
    ngOnInit() {
        const resolution$ = this.layer.map.viewController.resolution$;
        this.resolution$$ = resolution$.subscribe(() => {
            this.onResolutionChange();
        });
        this.tooltipText = this.computeTooltip();
        this.network$$ = this.networkService.currentState().subscribe((state) => {
            this.state = state;
            this.onResolutionChange();
        });
    }
    ngOnDestroy() {
        this.resolution$$.unsubscribe();
        this.network$$.unsubscribe();
    }
    computeTooltip() {
        const layerOptions = this.layer.options;
        if (!layerOptions.tooltip) {
            return this.layer.title;
        }
        const layerTooltip = layerOptions.tooltip;
        const layerMetadata = layerOptions.metadata;
        switch (layerOptions.tooltip.type) {
            case TooltipType.TITLE:
                return this.layer.title;
            case TooltipType.ABSTRACT:
                if (layerMetadata && layerMetadata.abstract) {
                    return layerMetadata.abstract;
                }
                else {
                    return this.layer.title;
                }
            case TooltipType.CUSTOM:
                if (layerTooltip && layerTooltip.text) {
                    return layerTooltip.text;
                }
                else {
                    return this.layer.title;
                }
            default:
                return this.layer.title;
        }
    }
    onResolutionChange() {
        const inResolutionRange = this.layer.isInResolutionsRange;
        this.inResolutionRange$.next(inResolutionRange);
    }
}
LayerLegendItemComponent.ɵfac = function LayerLegendItemComponent_Factory(t) { return new (t || LayerLegendItemComponent)(i0.ɵɵdirectiveInject(i2$1.NetworkService)); };
LayerLegendItemComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: LayerLegendItemComponent, selectors: [["igo-layer-legend-item"]], inputs: { layer: "layer", updateLegendOnResolutionChange: "updateLegendOnResolutionChange" }, decls: 6, vars: 4, consts: [[1, "igo-layer-list-item"], ["matLine", "", "matTooltipShowDelay", "500", 1, "igo-layer-title", 3, "matTooltip"], [1, "igo-layer-legend-container"], ["legend", ""], [3, "layer", "updateLegendOnResolutionChange"]], template: function LayerLegendItemComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-list-item", 0);
        i0.ɵɵelementStart(1, "h4", 1);
        i0.ɵɵtext(2);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(3, "div", 2, 3);
        i0.ɵɵelement(5, "igo-layer-legend", 4);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", ctx.tooltipText);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.layer.title);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("layer", ctx.layer)("updateLegendOnResolutionChange", ctx.updateLegendOnResolutionChange);
    } }, styles: ["[_nghost-%COMP%]{overflow:hidden}.igo-layer-list-item[_ngcontent-%COMP%]{height:46px;clear:both}.igo-layer-legend-container[_ngcontent-%COMP%]{padding-left:18px;width:calc(100% - 18px)}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LayerLegendItemComponent, [{
        type: Component,
        args: [{
                selector: 'igo-layer-legend-item',
                templateUrl: './layer-legend-item.component.html',
                styleUrls: ['./layer-legend-item.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i2$1.NetworkService }]; }, { layer: [{
            type: Input
        }], updateLegendOnResolutionChange: [{
            type: Input
        }] }); })();

class IgoLayerModule {
    static forRoot() {
        return {
            ngModule: IgoLayerModule,
            providers: [LayerService, StyleService, LayerListToolService]
        };
    }
}
IgoLayerModule.ɵfac = function IgoLayerModule_Factory(t) { return new (t || IgoLayerModule)(); };
IgoLayerModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoLayerModule });
IgoLayerModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            MatInputModule,
            MatFormFieldModule,
            CommonModule,
            FormsModule,
            MatDividerModule,
            MatMenuModule,
            MatIconModule,
            MatButtonModule,
            MatSlideToggleModule,
            MatSelectModule,
            MatTooltipModule,
            MatListModule,
            MatSliderModule,
            MatBadgeModule,
            MatCheckboxModule,
            IgoLanguageModule,
            IgoListModule,
            IgoCollapsibleModule,
            IgoImageModule,
            IgoPanelModule,
            IgoMatBadgeIconModule,
            IgoCustomHtmlModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoLayerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    MatInputModule,
                    MatFormFieldModule,
                    CommonModule,
                    FormsModule,
                    MatDividerModule,
                    MatMenuModule,
                    MatIconModule,
                    MatButtonModule,
                    MatSlideToggleModule,
                    MatSelectModule,
                    MatTooltipModule,
                    MatListModule,
                    MatSliderModule,
                    MatBadgeModule,
                    MatCheckboxModule,
                    IgoLanguageModule,
                    IgoListModule,
                    IgoCollapsibleModule,
                    IgoImageModule,
                    IgoPanelModule,
                    IgoMatBadgeIconModule,
                    IgoCustomHtmlModule
                ],
                exports: [
                    LayerItemComponent,
                    LayerLegendItemComponent,
                    LayerLegendComponent,
                    LayerListComponent,
                    LayerListToolComponent,
                    LayerLegendListComponent,
                    LayerListBindingDirective,
                    LayerLegendListBindingDirective,
                    TrackFeatureButtonComponent
                ],
                declarations: [
                    LayerItemComponent,
                    LayerLegendItemComponent,
                    LayerLegendComponent,
                    LayerListComponent,
                    LayerListToolComponent,
                    LayerLegendListComponent,
                    LayerListBindingDirective,
                    LayerLegendListBindingDirective,
                    TrackFeatureButtonComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoLayerModule, { declarations: [LayerItemComponent,
        LayerLegendItemComponent,
        LayerLegendComponent,
        LayerListComponent,
        LayerListToolComponent,
        LayerLegendListComponent,
        LayerListBindingDirective,
        LayerLegendListBindingDirective,
        TrackFeatureButtonComponent], imports: [MatInputModule,
        MatFormFieldModule,
        CommonModule,
        FormsModule,
        MatDividerModule,
        MatMenuModule,
        MatIconModule,
        MatButtonModule,
        MatSlideToggleModule,
        MatSelectModule,
        MatTooltipModule,
        MatListModule,
        MatSliderModule,
        MatBadgeModule,
        MatCheckboxModule,
        IgoLanguageModule,
        IgoListModule,
        IgoCollapsibleModule,
        IgoImageModule,
        IgoPanelModule,
        IgoMatBadgeIconModule,
        IgoCustomHtmlModule], exports: [LayerItemComponent,
        LayerLegendItemComponent,
        LayerLegendComponent,
        LayerListComponent,
        LayerListToolComponent,
        LayerLegendListComponent,
        LayerListBindingDirective,
        LayerLegendListBindingDirective,
        TrackFeatureButtonComponent] }); })();
i0.ɵɵsetComponentScope(LayerItemComponent, [i1$3.MatListItem, i1$1.NgIf, i11.MatCheckbox, i1$3.MatListIconCssMatStyler, i9.MatLine, i3.MatTooltip, i2.MatButton, i4.MatIcon, i9$1.MatBadge, i1$1.NgClass, LayerLegendComponent], [i7.TranslatePipe, i1$1.AsyncPipe]);
i0.ɵɵsetComponentScope(LayerLegendItemComponent, [i1$3.MatListItem, i9.MatLine, i3.MatTooltip, LayerLegendComponent], []);
i0.ɵɵsetComponentScope(LayerListComponent, [i1$3.MatList, i1$1.NgIf, LayerListToolComponent, i1$3.MatListItem, i11.MatCheckbox, i10.MatDivider, i6.ListComponent, i1$1.NgClass, i1$1.NgForOf, LayerItemComponent, i6.ListItemDirective, i6.PanelComponent, i2.MatButton, i3.MatTooltip, i4.MatIcon, i9$1.MatBadge, i5$2.MatMenuTrigger, i5$2.MatMenu, i13$1.MatSlider, i1$1.NgTemplateOutlet, i16.NgControlStatus, i16.NgModel], [i1$1.AsyncPipe, i7.TranslatePipe]);
i0.ɵɵsetComponentScope(LayerLegendListComponent, [i1$1.NgIf, i22.MatSlideToggle, i3.MatTooltip, i10.MatDivider, i6.ListComponent, i1$1.NgForOf, LayerLegendItemComponent, i6.ListItemDirective], [i7.TranslatePipe, i1$1.AsyncPipe]);

/**
 * @ignore
 */
class IgoCatalogBrowserModule {
}
IgoCatalogBrowserModule.ɵfac = function IgoCatalogBrowserModule_Factory(t) { return new (t || IgoCatalogBrowserModule)(); };
IgoCatalogBrowserModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoCatalogBrowserModule });
IgoCatalogBrowserModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatBadgeModule,
            MatButtonModule,
            MatIconModule,
            MatListModule,
            MatTooltipModule,
            IgoMatBadgeIconModule,
            IgoLanguageModule,
            IgoListModule,
            IgoCollapsibleModule,
            IgoMetadataModule,
            IgoLayerModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoCatalogBrowserModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatBadgeModule,
                    MatButtonModule,
                    MatIconModule,
                    MatListModule,
                    MatTooltipModule,
                    IgoMatBadgeIconModule,
                    IgoLanguageModule,
                    IgoListModule,
                    IgoCollapsibleModule,
                    IgoMetadataModule,
                    IgoLayerModule
                ],
                exports: [
                    CatalogBrowserComponent
                ],
                declarations: [
                    CatalogBrowserComponent,
                    CatalogBrowserGroupComponent,
                    CatalogBrowserLayerComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoCatalogBrowserModule, { declarations: [CatalogBrowserComponent,
        CatalogBrowserGroupComponent,
        CatalogBrowserLayerComponent], imports: [CommonModule,
        MatBadgeModule,
        MatButtonModule,
        MatIconModule,
        MatListModule,
        MatTooltipModule,
        IgoMatBadgeIconModule,
        IgoLanguageModule,
        IgoListModule,
        IgoCollapsibleModule,
        IgoMetadataModule,
        IgoLayerModule], exports: [CatalogBrowserComponent] }); })();
i0.ɵɵsetComponentScope(CatalogBrowserComponent, [i6.ListComponent, i1$1.NgForOf, i1$1.NgIf, CatalogBrowserGroupComponent,
    CatalogBrowserLayerComponent, i6.ListItemDirective], [i1$1.AsyncPipe]);

function AddCatalogDialogComponent_mat_option_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 17);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const predefinedCatalog_r7 = ctx.$implicit;
    i0.ɵɵproperty("matTooltip", predefinedCatalog_r7.title)("value", predefinedCatalog_r7);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", predefinedCatalog_r7.title, " ");
} }
function AddCatalogDialogComponent_mat_option_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 17);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const predefinedCatalog_r8 = ctx.$implicit;
    i0.ɵɵproperty("matTooltip", predefinedCatalog_r8.url)("value", predefinedCatalog_r8);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", predefinedCatalog_r8.url, " ");
} }
function AddCatalogDialogComponent_mat_option_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 18);
    i0.ɵɵlistener("click", function AddCatalogDialogComponent_mat_option_23_Template_mat_option_click_0_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵelementStart(1, "p", 19);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const type_r9 = ctx.$implicit;
    i0.ɵɵproperty("value", type_r9);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(type_r9);
} }
const _c0$c = function (a0, a1) { return { value: a0, email: a1 }; };
function AddCatalogDialogComponent_span_24_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵelementStart(1, "p", 20);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r5.languageService.translate.instant("igo.geo.catalog.externalProvider.unavailableWithEmail", i0.ɵɵpureFunction2(1, _c0$c, ctx_r5.addedCatalog.url, ctx_r5.emailAddress)));
} }
const _c1$a = function (a0) { return { value: a0 }; };
function AddCatalogDialogComponent_span_25_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵelementStart(1, "p", 20);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r6.languageService.translate.instant("igo.geo.catalog.unavailable", i0.ɵɵpureFunction1(1, _c1$a, ctx_r6.addedCatalog.url)));
} }
class AddCatalogDialogComponent {
    constructor(formBuilder, languageService, configService, dialogRef, data) {
        this.formBuilder = formBuilder;
        this.languageService = languageService;
        this.configService = configService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.defaultAddedCatalogType = 'wms';
        this.predefinedCatalogsList$ = new BehaviorSubject([]);
        this.predefinedCatalogs = [];
        this.error = false;
        this.store = data.store;
        this.predefinedCatalogs = data.predefinedCatalogs;
        this.error = data.error;
        this.addedCatalog = data.addedCatalog;
        this.form = this.formBuilder.group({
            id: ['', []],
            title: ['', []],
            url: ['', [Validators.required]],
            type: [this.defaultAddedCatalogType, [Validators.required]]
        });
    }
    ngOnInit() {
        this.store.state.clear();
        this.typeCapabilities = Object.keys(TypeCapabilities);
        this.addedCatalogType$$ = this.form
            .get('type')
            .valueChanges.subscribe((value) => {
            if (value === 'wmts') {
                this.form.get('title').setValidators(Validators.required);
            }
            else {
                this.form.get('title').setValidators([]);
            }
            this.form.get('title').updateValueAndValidity();
        });
        this.computePredefinedCatalogList();
        this.storeViewAll$$ = this.store.view
            .all$()
            .subscribe(() => this.computePredefinedCatalogList());
        this.emailAddress = this.configService.getConfig('emailAddress');
    }
    ngOnDestroy() {
        this.addedCatalogType$$.unsubscribe();
        this.storeViewAll$$.unsubscribe();
    }
    changeUrlOrTitle(catalog) {
        this.form.patchValue(catalog);
        this.error = false;
        this.computePredefinedCatalogList();
    }
    computePredefinedCatalogList() {
        this.predefinedCatalogsList$.next(this.predefinedCatalogs.filter((c) => !this.store.get(c.id)));
    }
    addCatalog(addedCatalog) {
        this.error = false;
        this.dialogRef.close(addedCatalog);
    }
    cancel() {
        this.error = false;
        this.dialogRef.close();
    }
}
AddCatalogDialogComponent.ɵfac = function AddCatalogDialogComponent_Factory(t) { return new (t || AddCatalogDialogComponent)(i0.ɵɵdirectiveInject(i16.FormBuilder), i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(i2$1.ConfigService), i0.ɵɵdirectiveInject(i1.MatDialogRef), i0.ɵɵdirectiveInject(MAT_DIALOG_DATA, 8)); };
AddCatalogDialogComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AddCatalogDialogComponent, selectors: [["igo-add-catalog-dialog"]], decls: 34, vars: 25, consts: [["mat-dialog-title", "", 1, "mat-typography"], ["mat-dialog-content", "", 1, "mat-typography"], [1, "igo-form", 3, "formGroup"], [1, "igo-input-container"], ["type", "text", "formControlName", "title", "matInput", "", 3, "placeholder", "matAutocomplete"], [3, "optionSelected"], ["auto2", "matAutocomplete"], ["matTooltipShowDelay", "500", 3, "matTooltip", "value", 4, "ngFor", "ngForOf"], ["type", "text", "formControlName", "url", "placeholder", "URL", "matInput", "", 3, "matAutocomplete"], ["auto", "matAutocomplete"], ["formControlName", "type", "placeholder", "Type"], [3, "value", "click", 4, "ngFor", "ngForOf"], [4, "ngIf"], ["mat-dialog-actions", "", 2, "justify-content", "center"], [1, "igo-form-button-group", "add-catalog-button-top-padding"], ["mat-raised-button", "", "type", "button", 3, "click"], ["id", "addCatalogBtnDialog", "mat-raised-button", "", "type", "button", "color", "primary", 3, "disabled", "click"], ["matTooltipShowDelay", "500", 3, "matTooltip", "value"], [3, "value", "click"], ["mat-line", ""], [1, "error"]], template: function AddCatalogDialogComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "h1", 0);
        i0.ɵɵtext(1);
        i0.ɵɵpipe(2, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(3, "div", 1);
        i0.ɵɵelementStart(4, "form", 2);
        i0.ɵɵelementStart(5, "div", 3);
        i0.ɵɵelementStart(6, "mat-form-field");
        i0.ɵɵelement(7, "input", 4);
        i0.ɵɵpipe(8, "translate");
        i0.ɵɵelementStart(9, "mat-autocomplete", 5, 6);
        i0.ɵɵlistener("optionSelected", function AddCatalogDialogComponent_Template_mat_autocomplete_optionSelected_9_listener($event) { return ctx.changeUrlOrTitle($event.option.value); });
        i0.ɵɵtemplate(11, AddCatalogDialogComponent_mat_option_11_Template, 2, 3, "mat-option", 7);
        i0.ɵɵpipe(12, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(13, "div", 3);
        i0.ɵɵelementStart(14, "mat-form-field");
        i0.ɵɵelement(15, "input", 8);
        i0.ɵɵelementStart(16, "mat-autocomplete", 5, 9);
        i0.ɵɵlistener("optionSelected", function AddCatalogDialogComponent_Template_mat_autocomplete_optionSelected_16_listener($event) { return ctx.changeUrlOrTitle($event.option.value); });
        i0.ɵɵtemplate(18, AddCatalogDialogComponent_mat_option_18_Template, 2, 3, "mat-option", 7);
        i0.ɵɵpipe(19, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(20, "div", 3);
        i0.ɵɵelementStart(21, "mat-form-field");
        i0.ɵɵelementStart(22, "mat-select", 10);
        i0.ɵɵtemplate(23, AddCatalogDialogComponent_mat_option_23_Template, 3, 2, "mat-option", 11);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(24, AddCatalogDialogComponent_span_24_Template, 3, 4, "span", 12);
        i0.ɵɵtemplate(25, AddCatalogDialogComponent_span_25_Template, 3, 3, "span", 12);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(26, "div", 13);
        i0.ɵɵelementStart(27, "div", 14);
        i0.ɵɵelementStart(28, "button", 15);
        i0.ɵɵlistener("click", function AddCatalogDialogComponent_Template_button_click_28_listener() { return ctx.cancel(); });
        i0.ɵɵtext(29);
        i0.ɵɵpipe(30, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(31, "button", 16);
        i0.ɵɵlistener("click", function AddCatalogDialogComponent_Template_button_click_31_listener() { return ctx.addCatalog(ctx.form.value); });
        i0.ɵɵtext(32);
        i0.ɵɵpipe(33, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = i0.ɵɵreference(10);
        const _r2 = i0.ɵɵreference(17);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(2, 13, "igo.geo.catalog.library.addTitle"));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("formGroup", ctx.form);
        i0.ɵɵadvance(3);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(8, 15, "igo.geo.printForm.title"));
        i0.ɵɵproperty("matAutocomplete", _r0);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(12, 17, ctx.predefinedCatalogsList$));
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("matAutocomplete", _r2);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(19, 19, ctx.predefinedCatalogsList$));
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngForOf", ctx.typeCapabilities);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.error && ctx.addedCatalog && ctx.emailAddress);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.error && ctx.addedCatalog && !ctx.emailAddress);
        i0.ɵɵadvance(4);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(30, 21, "igo.geo.catalog.library.cancel"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("disabled", !ctx.form.valid);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(33, 23, "igo.geo.catalog.library.add"), " ");
    } }, directives: [i1.MatDialogTitle, i1.MatDialogContent, i16.ɵNgNoValidate, i16.NgControlStatusGroup, i16.FormGroupDirective, i12.MatFormField, i16.DefaultValueAccessor, i5$1.MatInput, i6$1.MatAutocompleteTrigger, i16.NgControlStatus, i16.FormControlName, i6$1.MatAutocomplete, i1$1.NgForOf, i13.MatSelect, i1$1.NgIf, i1.MatDialogActions, i2.MatButton, i9.MatOption, i3.MatTooltip, i9.MatLine], pipes: [i7.TranslatePipe, i1$1.AsyncPipe], styles: ["mat-form-field[_ngcontent-%COMP%]{width:100%}.add-catalog-button-top-padding[_ngcontent-%COMP%]{padding-top:25px}.igo-form[_ngcontent-%COMP%]{padding:10px 5px 5px}.igo-form-button-group[_ngcontent-%COMP%]{text-align:center}button[_ngcontent-%COMP%]{cursor:pointer}button#addCatalogBtnDialog[disabled=true][_ngcontent-%COMP%]{cursor:default;background-color:#0000001f;color:#00000042}.error[_ngcontent-%COMP%]{color:red}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AddCatalogDialogComponent, [{
        type: Component,
        args: [{
                selector: 'igo-add-catalog-dialog',
                templateUrl: './add-catalog-dialog.component.html',
                styleUrls: ['./add-catalog-dialog.component.scss']
            }]
    }], function () { return [{ type: i16.FormBuilder }, { type: i2$1.LanguageService }, { type: i2$1.ConfigService }, { type: i1.MatDialogRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MAT_DIALOG_DATA]
            }] }]; }, null); })();

function CatalogLibaryComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-catalog-library-item", 3);
    i0.ɵɵlistener("catalogRemove", function CatalogLibaryComponent_ng_template_1_Template_igo_catalog_library_item_catalogRemove_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r4); const catalog_r2 = restoredCtx.$implicit; const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.onCatalogRemove(catalog_r2); })("select", function CatalogLibaryComponent_ng_template_1_Template_igo_catalog_library_item_select_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r4); const catalog_r2 = restoredCtx.$implicit; const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.onCatalogSelect(catalog_r2); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const catalog_r2 = ctx.$implicit;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("map", ctx_r0.map)("catalog", catalog_r2);
} }
function CatalogLibaryComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 4);
    i0.ɵɵelementStart(1, "button", 5);
    i0.ɵɵlistener("click", function CatalogLibaryComponent_div_3_Template_button_click_1_listener() { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.addCatalogDialog(); });
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵtext(3);
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵelement(5, "mat-icon", 6);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(2, 2, "igo.geo.catalog.library.addBtn"));
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(4, 4, "igo.geo.catalog.library.addBtn"), " ");
} }
/**
 * Component to browse a list of available catalogs
 */
class CatalogLibaryComponent {
    constructor(capabilitiesService, messageService, languageService, storageService, dialog) {
        this.capabilitiesService = capabilitiesService;
        this.messageService = messageService;
        this.languageService = languageService;
        this.storageService = storageService;
        this.dialog = dialog;
        /**
         * Determine if the form to add a catalog is allowed
         */
        this.addCatalogAllowed = false;
        /**
         * Determine if the form to add a catalog is allowed
         */
        this.predefinedCatalogs = [];
        /**
         * Event emitted a catalog is selected or unselected
         */
        this.catalogSelectChange = new EventEmitter();
        this.submitDisabled = true;
    }
    get addedCatalogs() {
        return (this.storageService.get('addedCatalogs') || []);
    }
    set addedCatalogs(catalogs) {
        this.storageService.set('addedCatalogs', catalogs);
    }
    /**
     * @internal
     */
    ngOnInit() {
        this.store.state.clear();
        this.predefinedCatalogs = this.predefinedCatalogs.map(c => {
            c.id = Md5.hashStr((c.type || 'wms') + standardizeUrl(c.url));
            c.title = c.title === '' || !c.title ? c.url : c.title;
            return c;
        });
    }
    getCatalogs() {
        return this.store.view.all$();
    }
    /**
     * When a catalog is selected, update it's state in the store
     * and emit the catalog select change event
     * @internal
     */
    onCatalogSelect(catalog) {
        this.store.state.update(catalog, {
            selected: true,
            focused: true
        }, true);
        this.catalogSelectChange.emit({ selected: true, catalog });
    }
    unsubscribeAddingCatalog() {
        if (this.addingCatalog$$) {
            this.addingCatalog$$.unsubscribe();
        }
    }
    addCatalog(addedCatalog) {
        if (!addedCatalog) {
            return;
        }
        let id = Md5.hashStr(addedCatalog.type + standardizeUrl(addedCatalog.url));
        const predefinedCatalog = this.predefinedCatalogs.find((c) => c.id === addedCatalog.id);
        if (predefinedCatalog) {
            addedCatalog.version = predefinedCatalog.version;
            addedCatalog.externalProvider = predefinedCatalog.externalProvider;
            id = predefinedCatalog.id;
        }
        if (this.store.get(id)) {
            const title = this.languageService.translate.instant('igo.geo.catalog.library.inlist.title');
            const message = this.languageService.translate.instant('igo.geo.catalog.library.inlist.message');
            this.messageService.alert(message, title);
            return;
        }
        this.unsubscribeAddingCatalog();
        this.addingCatalog$$ = this.capabilitiesService
            .getCapabilities(addedCatalog.type, addedCatalog.url, addedCatalog.version)
            .pipe(catchError((e) => {
            const title = this.languageService.translate.instant('igo.geo.catalog.unavailableTitle');
            if (e.error) {
                this.addCatalogDialog(true, addedCatalog);
                e.error.caught = true;
                return e;
            }
            const message = this.languageService.translate.instant('igo.geo.catalog.unavailable', { value: addedCatalog.url });
            this.messageService.error(message, title);
            throw e;
        }))
            .subscribe((capabilities) => {
            let title;
            let version;
            switch (addedCatalog.type) {
                case 'wms':
                    title = addedCatalog.title || capabilities.Service.Title;
                    version = addedCatalog.version || capabilities.version;
                    break;
                case 'arcgisrest':
                case 'imagearcgisrest':
                case 'tilearcgisrest':
                    title = addedCatalog.title || capabilities.mapName;
                    break;
                case 'wmts':
                    title =
                        addedCatalog.title ||
                            capabilities.ServiceIdentification.ServiceType;
                    break;
                default:
                    title = addedCatalog.title;
            }
            const catalogToAdd = ObjectUtils.removeUndefined(Object.assign({}, predefinedCatalog, ObjectUtils.removeUndefined({
                id,
                title,
                url: addedCatalog.url,
                type: addedCatalog.type || 'wms',
                externalProvider: addedCatalog.externalProvider || false,
                removable: true,
                version
            })));
            this.store.insert(catalogToAdd);
            const newCatalogs = this.addedCatalogs.slice(0);
            newCatalogs.push(catalogToAdd);
            this.addedCatalogs = newCatalogs;
            this.unsubscribeAddingCatalog();
        });
    }
    ngOnDestroy() {
        this.unsubscribeAddingCatalog();
    }
    onCatalogRemove(catalog) {
        this.store.delete(catalog);
        this.addedCatalogs = this.addedCatalogs
            .slice(0)
            .filter((c) => c.id !== catalog.id);
    }
    addCatalogDialog(error, addedCatalog) {
        const dialogRef = this.dialog.open(AddCatalogDialogComponent, {
            width: '700px',
            data: {
                predefinedCatalogs: this.predefinedCatalogs,
                store: this.store,
                error,
                addedCatalog
            }
        });
        dialogRef.afterClosed().subscribe((catalog) => {
            this.addCatalog(catalog);
        });
    }
}
CatalogLibaryComponent.ɵfac = function CatalogLibaryComponent_Factory(t) { return new (t || CatalogLibaryComponent)(i0.ɵɵdirectiveInject(CapabilitiesService), i0.ɵɵdirectiveInject(i2$1.MessageService), i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(i2$1.StorageService), i0.ɵɵdirectiveInject(i1.MatDialog)); };
CatalogLibaryComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: CatalogLibaryComponent, selectors: [["igo-catalog-library"]], inputs: { store: "store", map: "map", addCatalogAllowed: "addCatalogAllowed", predefinedCatalogs: "predefinedCatalogs" }, outputs: { catalogSelectChange: "catalogSelectChange" }, decls: 4, vars: 5, consts: [[3, "navigation"], ["ngFor", "", 3, "ngForOf"], ["class", "btnAddCatalog", 4, "ngIf"], ["igoListItem", "", "color", "accent", 3, "map", "catalog", "catalogRemove", "select"], [1, "btnAddCatalog"], ["mat-raised-button", "", "matTooltipPosition", "above", "color", "primary", 3, "matTooltip", "click"], ["svgIcon", "earth-plus"]], template: function CatalogLibaryComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "igo-list", 0);
        i0.ɵɵtemplate(1, CatalogLibaryComponent_ng_template_1_Template, 1, 2, "ng-template", 1);
        i0.ɵɵpipe(2, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(3, CatalogLibaryComponent_div_3_Template, 6, 6, "div", 2);
    } if (rf & 2) {
        i0.ɵɵproperty("navigation", false);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(2, 3, ctx.getCatalogs()));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.addCatalogAllowed);
    } }, styles: ["igo-list[_ngcontent-%COMP%]{height:auto}.btnAddCatalog[_ngcontent-%COMP%]{justify-content:center;display:flex;margin:30px 0}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CatalogLibaryComponent, [{
        type: Component,
        args: [{
                selector: 'igo-catalog-library',
                templateUrl: './catalog-library.component.html',
                styleUrls: ['./catalog-library.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: CapabilitiesService }, { type: i2$1.MessageService }, { type: i2$1.LanguageService }, { type: i2$1.StorageService }, { type: i1.MatDialog }]; }, { store: [{
            type: Input
        }], map: [{
            type: Input
        }], addCatalogAllowed: [{
            type: Input
        }], predefinedCatalogs: [{
            type: Input
        }], catalogSelectChange: [{
            type: Output
        }] }); })();

function CatalogLibaryItemComponent_mat_icon_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-icon", 4);
    i0.ɵɵlistener("click", function CatalogLibaryItemComponent_mat_icon_3_Template_mat_icon_click_0_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.catalog.externalProvider.catalog"));
} }
function CatalogLibaryItemComponent_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 5);
    i0.ɵɵlistener("click", function CatalogLibaryItemComponent_button_4_Template_button_click_0_listener($event) { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.removeCatalogFromLibrary($event); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 6);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.catalog.library.remove"));
} }
function CatalogLibaryItemComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 7);
    i0.ɵɵelement(1, "mat-icon", 8);
    i0.ɵɵelementEnd();
} }
/**
 * Catalog library item
 */
class CatalogLibaryItemComponent {
    constructor() {
        this.catalogRemove = new EventEmitter();
    }
    /**
     * @internal
     */
    get title() { return getEntityTitle(this.catalog); }
    removeCatalogFromLibrary(event) {
        event.stopPropagation();
        this.catalogRemove.emit();
    }
}
CatalogLibaryItemComponent.ɵfac = function CatalogLibaryItemComponent_Factory(t) { return new (t || CatalogLibaryItemComponent)(); };
CatalogLibaryItemComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: CatalogLibaryItemComponent, selectors: [["igo-catalog-library-item"]], inputs: { catalog: "catalog", map: "map" }, outputs: { catalogRemove: "catalogRemove" }, decls: 6, vars: 4, consts: [["mat-line", ""], ["class", "igo-external-provider", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "primary", "svgIcon", "earth-arrow-right", 3, "matTooltip", "click", 4, "ngIf"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "warn", 3, "matTooltip", "click", 4, "ngIf"], ["class", "igo-blank", "disabled", "true", "mat-icon-button", "", 4, "ngIf"], ["tooltip-position", "below", "matTooltipShowDelay", "500", "color", "primary", "svgIcon", "earth-arrow-right", 1, "igo-external-provider", 3, "matTooltip", "click"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "warn", 3, "matTooltip", "click"], ["svgIcon", "delete"], ["disabled", "true", "mat-icon-button", "", 1, "igo-blank"], ["svgIcon", "blank"]], template: function CatalogLibaryItemComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-list-item");
        i0.ɵɵelementStart(1, "h4", 0);
        i0.ɵɵtext(2);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(3, CatalogLibaryItemComponent_mat_icon_3_Template, 2, 3, "mat-icon", 1);
        i0.ɵɵtemplate(4, CatalogLibaryItemComponent_button_4_Template, 3, 3, "button", 2);
        i0.ɵɵtemplate(5, CatalogLibaryItemComponent_button_5_Template, 2, 0, "button", 3);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵtextInterpolate1(" ", ctx.title, " ");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.catalog.externalProvider);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.catalog.removable);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx.catalog.removable);
    } }, directives: [i1$3.MatListItem, i9.MatLine, i1$1.NgIf, i4.MatIcon, i3.MatTooltip, i2.MatButton], pipes: [i7.TranslatePipe], styles: [".igo-blank[_ngcontent-%COMP%]{cursor:pointer}.igo-external-provider[_ngcontent-%COMP%]{cursor:help}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CatalogLibaryItemComponent, [{
        type: Component,
        args: [{
                selector: 'igo-catalog-library-item',
                templateUrl: './catalog-library-item.component.html',
                styleUrls: ['./catalog-library-item.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { catalog: [{
            type: Input
        }], map: [{
            type: Input
        }], catalogRemove: [{
            type: Output
        }] }); })();

/**
 * @ignore
 */
class IgoCatalogLibraryModule {
}
IgoCatalogLibraryModule.ɵfac = function IgoCatalogLibraryModule_Factory(t) { return new (t || IgoCatalogLibraryModule)(); };
IgoCatalogLibraryModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoCatalogLibraryModule });
IgoCatalogLibraryModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatIconModule,
            MatBadgeModule,
            MatListModule,
            MatTooltipModule,
            IgoListModule,
            IgoLanguageModule,
            MatButtonModule,
            MatFormFieldModule,
            ReactiveFormsModule,
            MatInputModule,
            MatSelectModule,
            MatAutocompleteModule,
            MatDialogModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoCatalogLibraryModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatIconModule,
                    MatBadgeModule,
                    MatListModule,
                    MatTooltipModule,
                    IgoListModule,
                    IgoLanguageModule,
                    MatButtonModule,
                    MatFormFieldModule,
                    ReactiveFormsModule,
                    MatInputModule,
                    MatSelectModule,
                    MatAutocompleteModule,
                    MatDialogModule
                ],
                exports: [
                    CatalogLibaryComponent,
                    AddCatalogDialogComponent
                ],
                declarations: [
                    CatalogLibaryComponent,
                    CatalogLibaryItemComponent,
                    AddCatalogDialogComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoCatalogLibraryModule, { declarations: [CatalogLibaryComponent,
        CatalogLibaryItemComponent,
        AddCatalogDialogComponent], imports: [CommonModule,
        MatIconModule,
        MatBadgeModule,
        MatListModule,
        MatTooltipModule,
        IgoListModule,
        IgoLanguageModule,
        MatButtonModule,
        MatFormFieldModule,
        ReactiveFormsModule,
        MatInputModule,
        MatSelectModule,
        MatAutocompleteModule,
        MatDialogModule], exports: [CatalogLibaryComponent,
        AddCatalogDialogComponent] }); })();
i0.ɵɵsetComponentScope(CatalogLibaryComponent, [i6.ListComponent, i1$1.NgForOf, CatalogLibaryItemComponent, i6.ListItemDirective, i1$1.NgIf, i2.MatButton, i3.MatTooltip, i4.MatIcon], [i1$1.AsyncPipe, i7.TranslatePipe]);

class IgoCatalogModule {
}
IgoCatalogModule.ɵfac = function IgoCatalogModule_Factory(t) { return new (t || IgoCatalogModule)(); };
IgoCatalogModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoCatalogModule });
IgoCatalogModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatBadgeModule,
            MatIconModule,
            MatListModule,
            MatTooltipModule,
            IgoMatBadgeIconModule,
            IgoListModule,
            IgoCollapsibleModule
        ], IgoCatalogBrowserModule,
        IgoCatalogLibraryModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoCatalogModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatBadgeModule,
                    MatIconModule,
                    MatListModule,
                    MatTooltipModule,
                    IgoMatBadgeIconModule,
                    IgoListModule,
                    IgoCollapsibleModule
                ],
                exports: [
                    IgoCatalogBrowserModule,
                    IgoCatalogLibraryModule
                ],
                declarations: []
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoCatalogModule, { imports: [CommonModule,
        MatBadgeModule,
        MatIconModule,
        MatListModule,
        MatTooltipModule,
        IgoMatBadgeIconModule,
        IgoListModule,
        IgoCollapsibleModule], exports: [IgoCatalogBrowserModule,
        IgoCatalogLibraryModule] }); })();

class IgoDataSourceModule {
    static forRoot() {
        return {
            ngModule: IgoDataSourceModule,
            providers: []
        };
    }
}
IgoDataSourceModule.ɵfac = function IgoDataSourceModule_Factory(t) { return new (t || IgoDataSourceModule)(); };
IgoDataSourceModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoDataSourceModule });
IgoDataSourceModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoDataSourceModule, [{
        type: NgModule,
        args: [{
                imports: [],
                exports: [],
                declarations: []
            }]
    }], null, null); })();

class FilterableDataSourcePipe {
    transform(value, arg) {
        let layers;
        if (arg === 'time') {
            layers = value.filter((layer) => {
                const datasource = layer.dataSource;
                return (this.isTimeFilterable(datasource) &&
                    datasource.options.timeFilter !== undefined &&
                    Object.keys(datasource.options.timeFilter).length);
            });
        }
        if (arg === 'ogc') {
            layers = value.filter((layer) => {
                const datasource = layer.dataSource;
                return this.isOgcFilterable(datasource);
            });
        }
        return layers;
    }
    isTimeFilterable(dataSource) {
        if (dataSource.options.type !== 'wms') {
            return false;
        }
        return dataSource.options.timeFilterable;
    }
    isOgcFilterable(dataSource) {
        let isOgcFilterable = false;
        if (dataSource.options.ogcFilters &&
            dataSource.options.ogcFilters.enabled &&
            dataSource.options.ogcFilters.editable) {
            isOgcFilterable = true;
        }
        if (dataSource.options.ogcFilters &&
            dataSource.options.ogcFilters.enabled &&
            (dataSource.options.ogcFilters.pushButtons ||
                dataSource.options.ogcFilters.checkboxes ||
                dataSource.options.ogcFilters.radioButtons ||
                dataSource.options.ogcFilters.select)) {
            isOgcFilterable = true;
        }
        return isOgcFilterable;
    }
}
FilterableDataSourcePipe.ɵfac = function FilterableDataSourcePipe_Factory(t) { return new (t || FilterableDataSourcePipe)(); };
FilterableDataSourcePipe.ɵpipe = /*@__PURE__*/ i0.ɵɵdefinePipe({ name: "filterableDataSource", type: FilterableDataSourcePipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(FilterableDataSourcePipe, [{
        type: Pipe,
        args: [{
                name: 'filterableDataSource'
            }]
    }], null, null); })();

class TimeFilterService {
    constructor() { }
    filterByDate(datasource, date) {
        let time;
        let newdateform;
        let newdateformStart;
        let newdateformEnd;
        if (Array.isArray(date)) {
            const dates = [];
            if (date[0]) {
                newdateformStart = this.reformatDateTime(date[0]);
                dates.push(date[0]);
            }
            if (date[1]) {
                newdateformEnd = this.reformatDateTime(date[1]);
                dates.push(date[1]);
            }
            if (dates.length === 2 && newdateformStart !== newdateformEnd) {
                if (datasource instanceof TileArcGISRestDataSource) {
                    time = newdateformStart + ',' + newdateformEnd;
                }
                else {
                    time = newdateformStart + '/' + newdateformEnd;
                }
            }
            if (newdateformStart === newdateformEnd) {
                time = newdateformStart;
            }
        }
        else if (date) {
            newdateform = this.reformatDateTime(date);
            time = newdateform;
        }
        const params = { TIME: time };
        datasource.ol.updateParams(params);
        if (datasource instanceof WMSDataSource) {
            const wmsDataSource = datasource;
            wmsDataSource.setTimeFilter(wmsDataSource.timeFilter, true);
        }
    }
    filterByYear(datasource, year) {
        let time;
        let newdateformStart;
        let newdateformEnd;
        if (Array.isArray(year)) {
            const years = [];
            if (year[0]) {
                newdateformStart = year[0];
                years.push(year[0]);
            }
            if (year[1]) {
                newdateformEnd = year[1];
                years.push(year[1]);
            }
            if (years.length === 2 && newdateformStart !== newdateformEnd) {
                if (datasource instanceof TileArcGISRestDataSource) {
                    time = newdateformStart + ',' + newdateformEnd;
                }
                else {
                    time = newdateformStart + '/' + newdateformEnd;
                }
            }
            if (newdateformStart === newdateformEnd) {
                time = newdateformStart;
            }
        }
        else { // to reset filter.
            time = year;
        }
        const params = { TIME: time };
        datasource.ol.updateParams(params);
        if (datasource instanceof WMSDataSource) {
            const wmsDataSource = datasource;
            wmsDataSource.setTimeFilter(wmsDataSource.timeFilter, true);
        }
    }
    reformatDateTime(value) {
        const year = value.getFullYear();
        let month = value.getMonth() + 1;
        let day = value.getUTCDate();
        let hour = value.getUTCHours();
        let minute = value.getUTCMinutes();
        if (Number(month) < 10) {
            month = '0' + month;
        }
        if (Number(day) < 10) {
            day = '0' + day;
        }
        if (Number(hour) < 10) {
            hour = '0' + hour;
        }
        if (Number(minute) < 10) {
            minute = '0' + minute;
        }
        return year + '-' + month + '-' + day + 'T' + hour + ':' + minute + ':00Z';
    }
}
TimeFilterService.ɵfac = function TimeFilterService_Factory(t) { return new (t || TimeFilterService)(); };
TimeFilterService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TimeFilterService, factory: TimeFilterService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TimeFilterService, [{
        type: Injectable
    }], function () { return []; }, null); })();

class OGCFilterService {
    constructor() { }
    filterByOgc(wmsDatasource, filterString) {
        const appliedFilter = new OgcFilterWriter().formatProcessedOgcFilter(filterString, wmsDatasource.options.params.LAYERS);
        wmsDatasource.ol.updateParams({ FILTER: appliedFilter });
    }
    setOgcWFSFiltersOptions(wfsDatasource) {
        const options = wfsDatasource.options;
        const ogcFilterWriter = new OgcFilterWriter();
        if (options.ogcFilters.enabled && options.ogcFilters.filters) {
            options.ogcFilters.filters = ogcFilterWriter.checkIgoFiltersProperties(options.ogcFilters.filters, options.paramsWFS.fieldNameGeometry, new olProjection({ code: options.paramsWFS.srsName }), true);
            if (!options.ogcFilters.interfaceOgcFilters) {
                options.ogcFilters.interfaceOgcFilters = ogcFilterWriter.defineInterfaceFilterSequence(options.ogcFilters.filters, options.paramsWFS.fieldNameGeometry);
            }
        }
    }
    setOgcWMSFiltersOptions(wmsDatasource) {
        const options = wmsDatasource.options;
        const ogcFilterWriter = new OgcFilterWriter();
        if (options.ogcFilters.enabled && options.ogcFilters.filters) {
            options.ogcFilters.filters = ogcFilterWriter.checkIgoFiltersProperties(options.ogcFilters.filters, options.fieldNameGeometry, undefined, true);
            if (!options.ogcFilters.interfaceOgcFilters) {
                options.ogcFilters.interfaceOgcFilters = ogcFilterWriter.defineInterfaceFilterSequence(
                // With some wms server, this param must be set to make spatials call.
                options.ogcFilters.filters, options.fieldNameGeometry);
            }
            this.filterByOgc(wmsDatasource, ogcFilterWriter.buildFilter(options.ogcFilters.filters, undefined, undefined, undefined, wmsDatasource.options));
            options.filtered = true;
        }
        else {
            options.ogcFilters.filters = undefined;
            options.ogcFilters.interfaceOgcFilters = [];
            options.filtered = false;
        }
    }
}
OGCFilterService.ɵfac = function OGCFilterService_Factory(t) { return new (t || OGCFilterService)(); };
OGCFilterService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: OGCFilterService, factory: OGCFilterService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OGCFilterService, [{
        type: Injectable
    }], function () { return []; }, null); })();

var SpatialFilterQueryType;
(function (SpatialFilterQueryType) {
    SpatialFilterQueryType["AdmRegion"] = "AdmRegion";
    SpatialFilterQueryType["Mun"] = "Mun";
    SpatialFilterQueryType["Arrond"] = "Arrond";
    SpatialFilterQueryType["CircFed"] = "CircFed";
    SpatialFilterQueryType["CircProv"] = "CircProv";
    SpatialFilterQueryType["DirReg"] = "DirReg";
    SpatialFilterQueryType["MRC"] = "MRC";
    SpatialFilterQueryType["RegTour"] = "RegTour";
})(SpatialFilterQueryType || (SpatialFilterQueryType = {}));
var SpatialFilterType;
(function (SpatialFilterType) {
    SpatialFilterType["Predefined"] = "Predefined";
    SpatialFilterType["Polygon"] = "Polygon";
    SpatialFilterType["Point"] = "Point";
})(SpatialFilterType || (SpatialFilterType = {}));
var SpatialFilterItemType;
(function (SpatialFilterItemType) {
    SpatialFilterItemType["Address"] = "Address";
    SpatialFilterItemType["Thematics"] = "Thematics";
})(SpatialFilterItemType || (SpatialFilterItemType = {}));

class SpatialFilterService {
    constructor(http, languageService, configService) {
        this.http = http;
        this.languageService = languageService;
        this.configService = configService;
        this.baseUrl = 'https://geoegl.msp.gouv.qc.ca/apis/terrapi/';
        /*
         * Type association with URL
         */
        this.urlFilterList = {
            AdmRegion: 'regadmin',
            Arrond: 'arrondissements',
            CircFed: 'circ-fed',
            CircProv: 'circ-prov',
            DirReg: 'dir-reg',
            MRC: 'mrc',
            Mun: 'municipalites',
            RegTour: 'tourisme',
            bornes: 'bornes-sumi',
            hydro: 'hydro',
            routes: 'routes'
        };
        this.baseUrl =
            this.configService.getConfig('spatialFilter.url') || this.baseUrl;
    }
    getKeyByValue(object, value) {
        return Object.keys(object).find(key => object[key] === value);
    }
    /*
     * Loading data for spatial filter list component (NO GEOMETRY)
     */
    loadFilterList(type) {
        const urlPath = type;
        if (urlPath) {
            return this.http
                .get(this.baseUrl + this.urlFilterList[urlPath])
                .pipe(map(featureCollection => featureCollection.features.map(f => {
                f.meta = {
                    id: f.properties.code
                };
                return f;
            })));
        }
    }
    /*
     * Loading item list (STRING)
     */
    loadThematicsList() {
        const url = 'types';
        const items = [];
        return this.http.get(this.baseUrl + url).pipe(map((types) => {
            types.forEach(type => {
                if (type.startsWith('lieux')) {
                    const item = {
                        name: undefined,
                        source: type
                    };
                    let substr = type.substring(6, type.length);
                    let name = substr;
                    if (substr.includes('.')) {
                        const index = substr.indexOf('.');
                        name = substr.substring(index + 1, substr.length);
                        substr = substr.substring(0, index);
                    }
                    try {
                        item.name = this.languageService.translate.instant('igo.geo.terrapi.' + name);
                    }
                    catch (e) {
                        item.name = name.substring(0, 1).toUpperCase() + name.substring(1, name.length - 1);
                    }
                    try {
                        item.group = this.languageService.translate.instant('igo.geo.spatialFilter.group.' + substr);
                    }
                    catch (e) {
                        item.group = substr.substring(0, 1).toUpperCase() + substr.substring(1, name.length - 1);
                    }
                    items.push(item);
                }
                else {
                    if (this.getKeyByValue(this.urlFilterList, type)) {
                        const item = {
                            name: undefined,
                            source: type
                        };
                        const name = this.getKeyByValue(this.urlFilterList, type);
                        try {
                            item.name = this.languageService.translate.instant('igo.geo.terrapi.' + name);
                        }
                        catch (e) {
                            item.name = name.substring(0, 1).toUpperCase() + name.substring(1, name.length - 1);
                        }
                        item.source = type;
                        items.push(item);
                    }
                }
            });
            return items;
        }));
    }
    /*
     * Loading data for spatial filter item component (Address or Thematics) depends on predefined zone or draw zone (feature)
     */
    loadFilterItem(feature, itemType, type, thematic, buffer) {
        if (type) {
            // Predefined type
            const urlType = type;
            const url = this.baseUrl + this.urlFilterList[urlType];
            let urlItem = '';
            if (itemType === SpatialFilterItemType.Address) {
                urlItem = 'adresses';
                return this.http
                    .get(url + '/' + feature.properties.code + '/' + urlItem, {
                    params: {
                        geometry: 'true',
                        icon: 'true',
                        bufferInput: buffer.toString(),
                        simplified: '100'
                    }
                })
                    .pipe(map(featureCollection => featureCollection.features.map(f => {
                    f.meta = {
                        id: f.properties.code,
                        title: this.languageService.translate.instant('igo.geo.spatialFilter.Address'),
                        icon: f.icon
                    };
                    return f;
                })));
            }
            else {
                // If thematics search
                urlItem = thematic.source;
                return this.http
                    .get(url + '/' + feature.properties.code + '/' + urlItem, {
                    params: {
                        geometry: 'true',
                        icon: 'true',
                        bufferInput: buffer.toString(),
                        simplified: '100'
                    }
                })
                    .pipe(map(featureCollection => featureCollection.features.map(f => {
                    f.meta = {
                        id: f.properties.code,
                        title: thematic.name,
                        icon: f.icon
                    };
                    return f;
                })));
            }
        }
        else {
            // Draw type
            const url = this.baseUrl + 'locate';
            if (itemType === SpatialFilterItemType.Address) {
                const urlItem = '?type=adresses';
                return this.http
                    .post(url + urlItem, {
                    geometry: 'true',
                    icon: 'true',
                    loc: JSON.stringify(feature),
                    bufferInput: buffer.toString(),
                    simplified: '100'
                })
                    .pipe(map(featureCollection => featureCollection.features.map(f => {
                    f.meta = {
                        id: f.properties.code,
                        title: this.languageService.translate.instant('igo.geo.spatialFilter.Address'),
                        icon: f.icon
                    };
                    return f;
                })));
            }
            else {
                // If thematics search
                const urlItem = '?type=' + thematic.source;
                return this.http
                    .post(url + urlItem, {
                    geometry: 'true',
                    icon: 'true',
                    loc: JSON.stringify(feature),
                    bufferInput: buffer.toString(),
                    simplified: '100'
                })
                    .pipe(map(featureCollection => featureCollection.features.map(f => {
                    f.meta = {
                        id: f.properties.code,
                        title: thematic.name,
                        icon: f.icon
                    };
                    return f;
                })));
            }
        }
    }
    /*
     * Get one territory by id (WITH GEOMETRY)
     */
    loadItemById(feature, type) {
        const featureType = this.urlFilterList[type];
        const featureCode = '/' + feature.properties.code;
        if (featureType && featureCode) {
            return this.http
                .get(this.baseUrl + featureType + featureCode, {
                params: {
                    geometry: 'true'
                }
            })
                .pipe(map(f => {
                f.meta = {
                    id: f.properties.code,
                    alias: f.properties.nom,
                    title: f.properties.nom
                };
                return f;
            }));
        }
    }
    /*
     * Get buffer geometry
     */
    loadBufferGeometry(feature, filterType, buffer, type) {
        if (filterType === SpatialFilterType.Predefined) {
            const featureType = this.urlFilterList[type];
            const featureCode = '/' + feature.properties.code;
            if (featureType && featureCode) {
                return this.http
                    .get(this.baseUrl + featureType + featureCode, {
                    params: {
                        geometry: '100',
                        bufferOutput: buffer.toString()
                    }
                })
                    .pipe(map(f => {
                    f.meta = {
                        id: f.properties.code,
                        alias: f.properties.nom,
                        title: f.properties.nom
                    };
                    return f;
                }));
            }
        }
        else {
            return this.http
                .post(this.baseUrl + 'geospatial/buffer?', {
                buffer,
                loc: JSON.stringify(feature)
            })
                .pipe(map(f => {
                return f;
            }));
        }
    }
}
SpatialFilterService.ɵfac = function SpatialFilterService_Factory(t) { return new (t || SpatialFilterService)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i2$1.ConfigService)); };
SpatialFilterService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: SpatialFilterService, factory: SpatialFilterService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SpatialFilterService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.LanguageService }, { type: i2$1.ConfigService }]; }, null); })();

class DownloadService {
    constructor(messageService, languageService) {
        this.messageService = messageService;
        this.languageService = languageService;
    }
    open(layer) {
        const translate = this.languageService.translate;
        const title = translate.instant('igo.geo.download.title');
        this.messageService.success(translate.instant('igo.geo.download.start'), title);
        const DSOptions = layer.dataSource.options;
        if (Object.keys(DSOptions.download).length > 0) {
            if (DSOptions.download.dynamicUrl &&
                DSOptions.download.url === undefined) {
                let wfsOptions;
                let currentProj = new olProjection({ code: layer.map.projection });
                const paramsWFS = layer.dataSource.options.paramsWFS;
                if (paramsWFS && Object.keys(paramsWFS).length > 0) {
                    currentProj = paramsWFS.srsName ? new olProjection({ code: paramsWFS.srsName }) : currentProj;
                    wfsOptions = layer.dataSource.options.paramsWFS;
                }
                else {
                    wfsOptions = layer.dataSource.options.params;
                }
                const currentExtent = olproj.transformExtent(layer.map.viewController.getExtent(), new olProjection({ code: layer.map.projection }), currentProj);
                const outputFormatDownload = wfsOptions.outputFormatDownload === undefined
                    ? wfsOptions.outputFormat === undefined ? '' : 'outputformat=' + wfsOptions.outputFormat
                    : 'outputformat=' + wfsOptions.outputFormatDownload;
                const baseurl = DSOptions.download.dynamicUrl
                    .replace(/&?outputformat=[^&]*/gi, '')
                    .replace(/&?filter=[^&]*/gi, '')
                    .replace(/&?bbox=[^&]*/gi, '');
                const ogcFilters = layer.dataSource.options.ogcFilters;
                let filterQueryString;
                filterQueryString = new OgcFilterWriter()
                    .handleOgcFiltersAppliedValue(layer.dataSource.options, ogcFilters.geometryName, currentExtent, currentProj);
                if (!filterQueryString) {
                    // Prevent getting all the features for empty filter
                    filterQueryString = new OgcFilterWriter().buildFilter(undefined, currentExtent, currentProj, ogcFilters.geometryName);
                }
                else {
                    filterQueryString = 'filter=' + encodeURIComponent(filterQueryString);
                }
                window.open(`${baseurl}&${filterQueryString}&${outputFormatDownload}`, '_blank');
            }
            else if (DSOptions.download) {
                window.open(DSOptions.download.url, '_blank');
            }
        }
    }
}
DownloadService.ɵfac = function DownloadService_Factory(t) { return new (t || DownloadService)(i0.ɵɵinject(i2$1.MessageService), i0.ɵɵinject(i2$1.LanguageService)); };
DownloadService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DownloadService, factory: DownloadService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DownloadService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i2$1.MessageService }, { type: i2$1.LanguageService }]; }, null); })();

function DownloadButtonComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 1);
    i0.ɵɵlistener("click", function DownloadButtonComponent_button_0_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r2); const ctx_r1 = i0.ɵɵnextContext(); return ctx_r1.openDownload(ctx_r1.layer); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 2, "igo.geo.download.action"))("color", ctx_r0.color);
} }
class DownloadButtonComponent {
    constructor(downloadService) {
        this.downloadService = downloadService;
        this._color = 'primary';
    }
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    openDownload(layer) {
        this.downloadService.open(layer);
    }
    get options() {
        if (!this.layer) {
            return;
        }
        return this.layer.dataSource.options;
    }
}
DownloadButtonComponent.ɵfac = function DownloadButtonComponent_Factory(t) { return new (t || DownloadButtonComponent)(i0.ɵɵdirectiveInject(DownloadService)); };
DownloadButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: DownloadButtonComponent, selectors: [["igo-download-button"]], inputs: { layer: "layer", color: "color" }, decls: 1, vars: 1, consts: [["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", "click", 4, "ngIf"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", "click"], ["svgIcon", "download"]], template: function DownloadButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, DownloadButtonComponent_button_0_Template, 3, 4, "button", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.options && ctx.options.download && (ctx.options.download["dynamicUrl"] || ctx.options.download["url"]));
    } }, directives: [i1$1.NgIf, i2.MatButton, i3.MatTooltip, i4.MatIcon], pipes: [i7.TranslatePipe], styles: [""], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DownloadButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-download-button',
                templateUrl: './download-button.component.html',
                styleUrls: ['./download-button.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: DownloadService }]; }, { layer: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

class IgoDownloadModule {
    static forRoot() {
        return {
            ngModule: IgoDownloadModule
        };
    }
}
IgoDownloadModule.ɵfac = function IgoDownloadModule_Factory(t) { return new (t || IgoDownloadModule)(); };
IgoDownloadModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoDownloadModule });
IgoDownloadModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatIconModule,
            MatButtonModule,
            MatTooltipModule,
            IgoLanguageModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoDownloadModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatIconModule,
                    MatButtonModule,
                    MatTooltipModule,
                    IgoLanguageModule
                ],
                exports: [DownloadButtonComponent],
                declarations: [DownloadButtonComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoDownloadModule, { declarations: [DownloadButtonComponent], imports: [CommonModule,
        MatIconModule,
        MatButtonModule,
        MatTooltipModule,
        IgoLanguageModule], exports: [DownloadButtonComponent] }); })();

function FeatureDetailsComponent_table_0_tr_2_td_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "td");
    i0.ɵɵelement(1, "mat-icon", 7);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("svgIcon", ctx_r4.icon);
} }
function FeatureDetailsComponent_table_0_tr_2_td_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "td");
    i0.ɵɵelementStart(1, "a", 8);
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const property_r3 = i0.ɵɵnextContext().$implicit;
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("href", property_r3.value, i0.ɵɵsanitizeUrl);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate2(" ", i0.ɵɵpipeBind1(3, 3, "igo.geo.targetHtmlUrl"), " ", ctx_r5.title, "");
} }
function FeatureDetailsComponent_table_0_tr_2_td_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "td", 9);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const property_r3 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", property_r3.key, " ");
} }
function FeatureDetailsComponent_table_0_tr_2_td_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "td", 10);
} if (rf & 2) {
    const property_r3 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵproperty("innerHTML", property_r3.value, i0.ɵɵsanitizeHtml);
} }
function FeatureDetailsComponent_table_0_tr_2_td_5_img_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "img", 13);
    i0.ɵɵpipe(1, "async");
    i0.ɵɵpipe(2, "secureImage");
} if (rf & 2) {
    const property_r3 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵpropertyInterpolate("src", i0.ɵɵpipeBind1(1, 1, i0.ɵɵpipeBind1(2, 3, property_r3.value)), i0.ɵɵsanitizeUrl);
} }
function FeatureDetailsComponent_table_0_tr_2_td_5_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", i0.ɵɵpipeBind1(2, 1, "igo.geo.targetHtmlUrl"), " ");
} }
function FeatureDetailsComponent_table_0_tr_2_td_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "td");
    i0.ɵɵelementStart(1, "a", 8);
    i0.ɵɵtemplate(2, FeatureDetailsComponent_table_0_tr_2_td_5_img_2_Template, 3, 5, "img", 11);
    i0.ɵɵtemplate(3, FeatureDetailsComponent_table_0_tr_2_td_5_ng_template_3_Template, 3, 3, "ng-template", null, 12, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r14 = i0.ɵɵreference(4);
    const property_r3 = i0.ɵɵnextContext().$implicit;
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("href", property_r3.value, i0.ɵɵsanitizeUrl);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r8.isImg(property_r3.value))("ngIfElse", _r14);
} }
function FeatureDetailsComponent_table_0_tr_2_td_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "td", 10);
    i0.ɵɵpipe(1, "json");
} if (rf & 2) {
    const property_r3 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵproperty("innerHTML", i0.ɵɵpipeBind1(1, 1, property_r3.value), i0.ɵɵsanitizeHtml);
} }
function FeatureDetailsComponent_table_0_tr_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "tr");
    i0.ɵɵtemplate(1, FeatureDetailsComponent_table_0_tr_2_td_1_Template, 2, 1, "td", 4);
    i0.ɵɵtemplate(2, FeatureDetailsComponent_table_0_tr_2_td_2_Template, 4, 5, "td", 4);
    i0.ɵɵtemplate(3, FeatureDetailsComponent_table_0_tr_2_td_3_Template, 2, 1, "td", 5);
    i0.ɵɵtemplate(4, FeatureDetailsComponent_table_0_tr_2_td_4_Template, 1, 1, "td", 6);
    i0.ɵɵtemplate(5, FeatureDetailsComponent_table_0_tr_2_td_5_Template, 5, 3, "td", 4);
    i0.ɵɵtemplate(6, FeatureDetailsComponent_table_0_tr_2_td_6_Template, 2, 3, "td", 6);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const property_r3 = ctx.$implicit;
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.feature.properties.target === "_blank" && property_r3.key === "url");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.feature.properties.target === "_blank" && property_r3.key === "url");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.feature.properties.target === undefined);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.feature.properties.target === undefined && !ctx_r2.isObject(property_r3.value) && !ctx_r2.isUrl(property_r3.value));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.feature.properties.target === undefined && !ctx_r2.isObject(property_r3.value) && ctx_r2.isUrl(property_r3.value));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.feature.properties.target === undefined && ctx_r2.isObject(property_r3.value));
} }
function FeatureDetailsComponent_table_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "table", 2);
    i0.ɵɵelementStart(1, "tbody");
    i0.ɵɵtemplate(2, FeatureDetailsComponent_table_0_tr_2_Template, 7, 6, "tr", 3);
    i0.ɵɵpipe(3, "keyvalue");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(3, 1, ctx_r0.filterFeatureProperties(ctx_r0.feature)));
} }
function FeatureDetailsComponent_iframe_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "iframe", 14);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("srcdoc", ctx_r1.htmlSanitizer(ctx_r1.feature.properties), i0.ɵɵsanitizeHtml)("src", ctx_r1.urlSanitizer(ctx_r1.feature.properties.url), i0.ɵɵsanitizeResourceUrl);
} }
class FeatureDetailsComponent {
    constructor(cdRef, sanitizer, networkService) {
        this.cdRef = cdRef;
        this.sanitizer = sanitizer;
        this.networkService = networkService;
        this.unsubscribe$ = new Subject();
        this.ready = false;
        this.routeEvent = new EventEmitter();
        this.selectFeature = new EventEmitter();
        this.htmlDisplayEvent = new EventEmitter();
        this.networkService.currentState().pipe(takeUntil(this.unsubscribe$)).subscribe((state) => {
            this.state = state;
        });
    }
    get source() {
        return this._source;
    }
    set source(value) {
        this._source = value;
        this.cdRef.detectChanges();
    }
    get feature() {
        return this._feature;
    }
    set feature(value) {
        this._feature = value;
        this.cdRef.detectChanges();
        this.selectFeature.emit();
    }
    /**
     * @internal
     */
    get title() {
        return getEntityTitle(this.feature);
    }
    /**
     * @internal
     */
    get icon() {
        return getEntityIcon(this.feature) || 'link';
    }
    ngOnInit() {
        this.ready = true;
    }
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    urlSanitizer(value) {
        return this.sanitizer.bypassSecurityTrustResourceUrl(value);
    }
    isHtmlDisplay() {
        if (this.feature && this.isObject(this.feature.properties) && this.feature.properties.target === 'iframe') {
            this.htmlDisplayEvent.emit(true);
            return true;
        }
        else {
            this.htmlDisplayEvent.emit(false);
            return false;
        }
    }
    htmlSanitizer(value) {
        if (!value.body || userAgent.getBrowserName() === 'Internet Explorer') {
            return;
        }
        const regexBase = /<base href="[\w:\/\.]+">/;
        if (!regexBase.test(value.body)) {
            const url = new URL(value.url, window.location.origin);
            value.body = value.body.replace('<head>', `<head><base href="${url.origin}">`);
        }
        return this.sanitizer.bypassSecurityTrustHtml(value.body);
    }
    isObject(value) {
        return typeof value === 'object';
    }
    isUrl(value) {
        if (typeof value === 'string') {
            return (value.slice(0, 8) === 'https://' || value.slice(0, 7) === 'http://');
        }
        else {
            return false;
        }
    }
    isImg(value) {
        if (this.isUrl(value)) {
            return (['jpg', 'png', 'gif'].includes(value.split('.').pop().toLowerCase()));
        }
        else {
            return false;
        }
    }
    filterFeatureProperties(feature) {
        const allowedFieldsAndAlias = feature.meta ? feature.meta.alias : undefined;
        const properties = {};
        let offlineButtonState;
        if (this.map) {
            this.map.offlineButtonToggle$.pipe(takeUntil(this.unsubscribe$)).subscribe(state => {
                offlineButtonState = state;
            });
        }
        if (feature.properties && feature.properties.Route && this.toolbox && !this.toolbox.getTool('directions')) {
            delete feature.properties.Route;
        }
        if (allowedFieldsAndAlias) {
            Object.keys(allowedFieldsAndAlias).forEach(field => {
                properties[allowedFieldsAndAlias[field]] = feature.properties[field];
            });
            return properties;
        }
        else if (offlineButtonState !== undefined) {
            if (!offlineButtonState) {
                if (this.state.connection && feature.meta && feature.meta.excludeAttribute) {
                    const excludeAttribute = feature.meta.excludeAttribute;
                    excludeAttribute.forEach(attribute => {
                        delete feature.properties[attribute];
                    });
                }
                else if (!this.state.connection && feature.meta && feature.meta.excludeAttributeOffline) {
                    const excludeAttributeOffline = feature.meta.excludeAttributeOffline;
                    excludeAttributeOffline.forEach(attribute => {
                        delete feature.properties[attribute];
                    });
                }
            }
            else {
                if (feature.meta && feature.meta.excludeAttributeOffline) {
                    const excludeAttributeOffline = feature.meta.excludeAttributeOffline;
                    excludeAttributeOffline.forEach(attribute => {
                        delete feature.properties[attribute];
                    });
                }
            }
        }
        else {
            if (this.state.connection && feature.meta && feature.meta.excludeAttribute) {
                const excludeAttribute = feature.meta.excludeAttribute;
                excludeAttribute.forEach(attribute => {
                    delete feature.properties[attribute];
                });
            }
            else if (!this.state.connection && feature.meta && feature.meta.excludeAttributeOffline) {
                const excludeAttributeOffline = feature.meta.excludeAttributeOffline;
                excludeAttributeOffline.forEach(attribute => {
                    delete feature.properties[attribute];
                });
            }
        }
        return feature.properties;
    }
}
FeatureDetailsComponent.ɵfac = function FeatureDetailsComponent_Factory(t) { return new (t || FeatureDetailsComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1$4.DomSanitizer), i0.ɵɵdirectiveInject(i2$1.NetworkService)); };
FeatureDetailsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: FeatureDetailsComponent, selectors: [["igo-feature-details"]], inputs: { source: "source", map: "map", toolbox: "toolbox", feature: "feature" }, outputs: { routeEvent: "routeEvent", selectFeature: "selectFeature", htmlDisplayEvent: "htmlDisplayEvent" }, decls: 2, vars: 2, consts: [["class", "igo-striped mat-typography", 4, "ngIf"], [3, "srcdoc", "src", 4, "ngIf"], [1, "igo-striped", "mat-typography"], [4, "ngFor", "ngForOf"], [4, "ngIf"], ["id", "keyValue", 4, "ngIf"], [3, "innerHTML", 4, "ngIf"], ["mat-list-avatar", "", 3, "svgIcon"], ["target", "_blank", "rel", "noopener noreferrer", 3, "href"], ["id", "keyValue"], [3, "innerHTML"], ["width", "225", "heigth", "auto", 3, "src", 4, "ngIf", "ngIfElse"], ["notImg", ""], ["width", "225", "heigth", "auto", 3, "src"], [3, "srcdoc", "src"]], template: function FeatureDetailsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, FeatureDetailsComponent_table_0_Template, 4, 3, "table", 0);
        i0.ɵɵtemplate(1, FeatureDetailsComponent_iframe_1_Template, 1, 2, "iframe", 1);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.ready && ctx.feature && ctx.isObject(ctx.feature.properties) && ctx.feature.properties.target !== "iframe");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.isHtmlDisplay());
    } }, directives: [i1$1.NgIf, i1$1.NgForOf, i4.MatIcon], pipes: [i6.KeyValuePipe, i7.TranslatePipe, i1$1.AsyncPipe, i6.SecureImagePipe, i1$1.JsonPipe], styles: ["table[_ngcontent-%COMP%]{width:100%}table[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{padding:5px}#keyValue[_ngcontent-%COMP%]{width:30%}table[_ngcontent-%COMP%]     .routing{cursor:pointer}iframe[_ngcontent-%COMP%]{height:calc(100% - 4px);width:100%;border:0}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(FeatureDetailsComponent, [{
        type: Component,
        args: [{
                selector: 'igo-feature-details',
                templateUrl: './feature-details.component.html',
                styleUrls: ['./feature-details.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i1$4.DomSanitizer }, { type: i2$1.NetworkService }]; }, { source: [{
            type: Input
        }], map: [{
            type: Input
        }], toolbox: [{
            type: Input
        }], feature: [{
            type: Input
        }], routeEvent: [{
            type: Output
        }], selectFeature: [{
            type: Output
        }], htmlDisplayEvent: [{
            type: Output
        }] }); })();

const _c0$b = ["igoForm"];
const _c1$9 = ["*", [["", "formButtons", ""]]];
const _c2$4 = ["*", "[formButtons]"];
/**
 * A configurable form, optionnally bound to a feature.
 * This component creates an entity form and, on submit,
 * returns a feature made out of the submitted data. It also
 * does things like managing the feature visibility while it's being updated
 * as well as disabling the selection of another feature.
 */
class FeatureFormComponent {
    constructor() {
        this.feature$ = new BehaviorSubject(undefined);
        /**
         * Event emitted when the form is submitted
         */
        this.submitForm = new EventEmitter();
    }
    /**
     * Feature to update
     */
    set feature(value) { this.feature$.next(value); }
    get feature() { return this.feature$.value; }
    /**
     * Transform the form data to a feature and emit an event
     * @param event Form submit event
     * @internal
     */
    onSubmit(data) {
        const feature = this.formDataToFeature(data);
        this.submitForm.emit(feature);
    }
    getData() {
        return this.formDataToFeature(this.igoForm.getData());
    }
    /**
     * Transform the form data to a feature
     * @param data Form data
     * @returns A feature
     */
    formDataToFeature(data) {
        const properties = {};
        const meta = {};
        if (this.feature === undefined) {
            meta.id = uuid();
        }
        else {
            Object.assign(properties, this.feature.properties);
            Object.assign(meta, this.feature.meta, {
                revision: getEntityRevision(this.feature) + 1
            });
        }
        const propertyPrefix = 'properties.';
        Object.entries(data).forEach((entry) => {
            const [key, value] = entry;
            if (key.startsWith(propertyPrefix)) {
                const property = key.substr(propertyPrefix.length);
                properties[property] = value;
            }
        });
        let geometry = data.geometry;
        if (geometry === undefined && this.feature !== undefined) {
            geometry = this.feature.geometry;
        }
        return {
            meta: meta,
            type: FEATURE,
            geometry,
            projection: 'EPSG:4326',
            properties
        };
    }
}
FeatureFormComponent.ɵfac = function FeatureFormComponent_Factory(t) { return new (t || FeatureFormComponent)(); };
FeatureFormComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: FeatureFormComponent, selectors: [["igo-feature-form"]], viewQuery: function FeatureFormComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$b, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.igoForm = _t.first);
    } }, inputs: { form: "form", feature: "feature" }, outputs: { submitForm: "submitForm" }, ngContentSelectors: _c2$4, decls: 5, vars: 4, consts: [[3, "form", "formData", "submitForm"], ["igoForm", ""]], template: function FeatureFormComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c1$9);
        i0.ɵɵelementStart(0, "igo-form", 0, 1);
        i0.ɵɵlistener("submitForm", function FeatureFormComponent_Template_igo_form_submitForm_0_listener($event) { return ctx.onSubmit($event); });
        i0.ɵɵpipe(2, "async");
        i0.ɵɵprojection(3);
        i0.ɵɵprojection(4, 1, ["formButtons", ""]);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("form", ctx.form)("formData", i0.ɵɵpipeBind1(2, 2, ctx.feature$));
    } }, directives: [i6.FormComponent], pipes: [i1$1.AsyncPipe], styles: ["[_nghost-%COMP%]{display:block}igo-form[_ngcontent-%COMP%]{height:100%}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(FeatureFormComponent, [{
        type: Component,
        args: [{
                selector: 'igo-feature-form',
                templateUrl: './feature-form.component.html',
                styleUrls: ['./feature-form.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { form: [{
            type: Input
        }], feature: [{
            type: Input
        }], submitForm: [{
            type: Output
        }], igoForm: [{
            type: ViewChild,
            args: ['igoForm', { static: true }]
        }] }); })();

var GeometryType;
(function (GeometryType) {
    GeometryType["Point"] = "Point";
    GeometryType["LineString"] = "LineString";
    GeometryType["Polygon"] = "Polygon";
    GeometryType["Circle"] = "Circle";
})(GeometryType || (GeometryType = {}));

/* eslint-disable */
// See this issue: https://github.com/Microsoft/TypeScript/issues/13965
// And the solution: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
// for an explanation as to why the prototype is set manually
/* eslint-enable */
class GeometrySliceError extends Error {
}
class GeometrySliceMultiPolygonError extends GeometrySliceError {
    constructor() {
        super('Can\'t slice a MultiPolygon.');
        Object.setPrototypeOf(this, GeometrySliceMultiPolygonError.prototype);
    }
}
class GeometrySliceLineStringError extends GeometrySliceError {
    constructor() {
        super('Can\'t slice with a line that has more than 2 points.');
        Object.setPrototypeOf(this, GeometrySliceLineStringError.prototype);
    }
}
class GeometrySliceTooManyIntersectionError extends GeometrySliceError {
    constructor() {
        super('More than 2 intersections found between the target polygon and the slicing line.');
        Object.setPrototypeOf(this, GeometrySliceTooManyIntersectionError.prototype);
    }
}

/**
 * Create a default style for draw and modify interactions
 * @param color Style color (R, G, B)
 * @returns OL style
 */
function createDrawInteractionStyle(color) {
    color = color || [0, 153, 255];
    return new olstyle.Circle({
        stroke: new olstyle.Stroke({
            color: color.concat([1]),
            width: 2
        }),
        fill: new olstyle.Fill({
            color: color.concat([0.2])
        }),
        radius: 8
    });
}
/**
 * Create a default style for drawing a hole
 * @returns OL style
 */
function createDrawHoleInteractionStyle() {
    return new olstyle.Style({
        stroke: new olstyle.Stroke({
            color: [0, 153, 255, 1],
            width: 2
        })
    });
}
/**
 * Slice geometry into two parts
 * @param olGeometry OL geometry
 * @param olSlicer Slicing line
 * @returns New OL geometries
 */
function sliceOlGeometry(olGeometry, olSlicer) {
    if (olGeometry instanceof OlPolygon) {
        return sliceOlPolygon(olGeometry, olSlicer);
    }
    else if (olGeometry instanceof OlLineString) {
        return sliceOlLineString(olGeometry, olSlicer);
    }
    return [];
}
/**
 * Slice OL LineString into one or more lines
 * @param olLineString OL line string
 * @param olSlicer Slicing line
 * @returns New OL line strings
 */
function sliceOlLineString(olLineString, olSlicer) {
    return [];
}
/**
 * Slice OL Polygon into one or more polygons
 * @param olPolygon OL polygon
 * @param olSlicer Slicing line
 * @returns New OL polygons
 */
function sliceOlPolygon(olPolygon, olSlicer) {
    if (olPolygon.getLinearRingCount() > 1) {
        throw new GeometrySliceMultiPolygonError();
    }
    if (olSlicer.getCoordinates().length > 2) {
        throw new GeometrySliceLineStringError();
    }
    const olGeoJSON = new OlGeoJSON();
    const slicer = olGeoJSON.writeGeometryObject(olSlicer);
    const outerCoordinates = olPolygon.getLinearRing(0).getCoordinates();
    const parts = [[], []];
    let totalIntersectionCount = 0;
    for (let i = 0, ii = outerCoordinates.length - 1; i < ii; i++) {
        const segmentCoordinates = [outerCoordinates[i], outerCoordinates[i + 1]];
        const segment = lineString(segmentCoordinates);
        const intersections = lineIntersect(segment, slicer).features;
        const intersectionCount = intersections.length;
        totalIntersectionCount += intersectionCount;
        if (intersectionCount > 1 || totalIntersectionCount > 2) {
            throw new GeometrySliceTooManyIntersectionError();
        }
        parts[0].push(segmentCoordinates[0]);
        if (intersectionCount === 1) {
            const intersection = intersections[0].geometry.coordinates;
            parts[0].push(intersection);
            parts[1].push(intersection);
            parts.reverse();
        }
    }
    if (totalIntersectionCount <= 1) {
        return [];
    }
    parts[0].push(parts[0][0]);
    parts[1].push(parts[1][0]);
    return [new OlPolygon([parts[0]]), new OlPolygon([parts[1]])];
}
/**
 * Splice geometry into two parts
 * @param olGeometry OL geometry
 * @param olSlicer Slicing line
 * @returns New OL geometries
 */
function addLinearRingToOlPolygon(olPolygon, olLinearRing) {
    // TODO: make some validation and support updating an existing linear ring
    olPolygon.appendLinearRing(olLinearRing);
}
function getMousePositionFromOlGeometryEvent(olEvent) {
    const olGeometry = olEvent.target;
    if (olGeometry instanceof OlPolygon) {
        return olGeometry.getFlatCoordinates().slice(-4, -2);
    }
    const olGeometryCast = olGeometry;
    return olGeometryCast.getFlatCoordinates().slice(-2);
}

/**
 * Control to draw entities
 */
class DrawControl {
    constructor(options) {
        this.options = options;
        /**
         * Draw start observable
         */
        this.start$ = new Subject();
        /**
         * Draw end observable
         */
        this.end$ = new Subject();
        /**
         * Draw changes observable (while drawing)
         */
        this.changes$ = new Subject();
        /**
         * Draw modify observable (modify drawn features)
         */
        this.modify$ = new Subject();
        /**
         * Draw select observable (modify drawn features)
         */
        this.select$ = new Subject();
        /**
         * Draw abort observable (abort drawn features)
         */
        this.abort$ = new Subject();
        /**
         * Freehand mode observable (defaults to false)
         */
        this.freehand$ = new BehaviorSubject(false);
        this.olDrawingLayer = options.drawingLayer ? options.drawingLayer : this.createOlInnerOverlayLayer();
        this.olGeometryType = this.options.geometryType;
    }
    /**
     * Wheter the control is active
     */
    get active() {
        return this.olMap !== undefined;
    }
    /**
     * OL overlay source
     * @internal
     */
    get olDrawingLayerSource() {
        return this.olDrawingLayer.getSource();
    }
    /**
     * Add or remove this control to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap, activateModifyAndSelect) {
        if (!olMap) {
            this.clearOlInnerOverlaySource();
            this.removeOlInnerOverlayLayer();
            this.removeOlInteractions();
            this.olMap = olMap;
            return;
        }
        this.olMap = olMap;
        this.addOlInnerOverlayLayer();
        this.addOlInteractions(activateModifyAndSelect);
    }
    /**
     * Return the drawing layer source
     */
    getSource() {
        return this.olDrawingLayerSource;
    }
    /**
     * Set the current geometry type
     * @param geometryType the geometry type
     */
    setGeometryType(geometryType) {
        this.olGeometryType = geometryType;
    }
    /**
     * Create a drawing source if none is defined in the options
     */
    createOlInnerOverlayLayer() {
        return new OlVectorLayer({
            source: this.options.drawingLayerSource ? this.options.drawingLayerSource : new OlVectorSource(),
            style: this.options.drawingLayerStyle,
            zIndex: 500
        });
    }
    /**
     * Clear the drawing layer if it wasn't defined in the options
     */
    removeOlInnerOverlayLayer() {
        if (!this.options.drawingLayer && this.olMap) {
            this.olMap.removeLayer(this.olDrawingLayer);
        }
    }
    /**
     * Add the drawing layer if it wasn't defined in the options
     */
    addOlInnerOverlayLayer() {
        if (!this.options.drawingLayer) {
            this.olMap.addLayer(this.olDrawingLayer);
        }
    }
    /**
     * Clear the drawing layer source if it wasn't defined in the options
     */
    clearOlInnerOverlaySource() {
        if (!this.options.drawingLayer && !this.options.drawingLayerSource) {
            this.olDrawingLayerSource.clear(true);
        }
    }
    /**
     * Add interactions to the map an set up some listeners
     */
    addOlInteractions(activateModifyAndSelect) {
        // Create Draw interaction
        let olDrawInteraction;
        if (!this.freehand$.getValue()) {
            olDrawInteraction = new OlDraw({
                type: this.olGeometryType,
                source: this.getSource(),
                stopClick: true,
                style: this.options.interactionStyle,
                maxPoints: this.options.maxPoints,
                freehand: false,
                freehandCondition: () => false
            });
        }
        else {
            if (this.olGeometryType === 'Point') {
                olDrawInteraction = new OlDraw({
                    type: 'Circle',
                    source: this.getSource(),
                    maxPoints: this.options.maxPoints,
                    freehand: true
                });
            }
            else {
                olDrawInteraction = new OlDraw({
                    type: this.olGeometryType,
                    source: this.getSource(),
                    maxPoints: this.options.maxPoints,
                    freehand: true
                });
            }
        }
        // Add Draw interaction to map and create listeners
        this.olMap.addInteraction(olDrawInteraction);
        this.olDrawInteraction = olDrawInteraction;
        this.onDrawStartKey = olDrawInteraction.on('drawstart', (event) => this.onDrawStart(event));
        this.onDrawEndKey = olDrawInteraction.on('drawend', (event) => this.onDrawEnd(event));
        this.onDrawAbortKey = olDrawInteraction.on('drawabort', (event) => this.abort$.next(event.feature.getGeometry()));
        if (activateModifyAndSelect) {
            // Create a Modify interaction, add it to map and create a listener
            const olModifyInteraction = new OlModify({
                source: this.getSource()
            });
            this.olMap.addInteraction(olModifyInteraction);
            this.olModifyInteraction = olModifyInteraction;
            // Create a select interaction and add it to map
            if (!this.olSelectInteraction) {
                const olSelectInteraction = new OlSelect({
                    condition: doubleClick,
                    style: undefined
                });
                this.olMap.addInteraction(olSelectInteraction);
                this.olSelectInteraction = olSelectInteraction;
                this.olSelectInteraction.on('select', (event) => this.onSelect(event));
            }
        }
    }
    /**
     * Remove interactions
     */
    removeOlInteractions() {
        this.unsubscribeKeyDown();
        unByKey([this.onDrawStartKey, this.onDrawEndKey, this.onDrawKey, this.onDrawAbortKey]);
        if (this.olMap) {
            this.olMap.removeInteraction(this.olDrawInteraction);
            this.olMap.removeInteraction(this.olModifyInteraction);
        }
        this.olDrawInteraction = undefined;
        this.olModifyInteraction = undefined;
    }
    /**
     * When drawing starts, clear the overlay and start watching for changes
     * @param event Draw start event
     */
    onDrawStart(event) {
        const olGeometry = event.feature.getGeometry();
        this.start$.next(olGeometry);
        this.clearOlInnerOverlaySource();
        this.onDrawKey = olGeometry.on('change', (olGeometryEvent) => {
            this.mousePosition = getMousePositionFromOlGeometryEvent(olGeometryEvent);
            this.changes$.next(olGeometryEvent.target);
        });
        this.subscribeKeyDown();
    }
    /**
     * When drawing ends, update the drawing (feature) geometry observable and add
     * @param event Draw event (drawend)
     */
    onDrawEnd(event) {
        this.unsubscribeKeyDown();
        unByKey(this.onDrawKey);
        const olGeometry = event.feature.getGeometry();
        olGeometry.on('change', () => {
            this.modify$.next(olGeometry);
        });
        this.end$.next(olGeometry);
    }
    /**
     * When a feature is selected, update the selected feature observable
     * @param event Modify event (modifyend)
     */
    onSelect(event) {
        if (event.selected.length === 1) {
            this.select$.next(event.selected[0]);
        }
    }
    /**
     * Subscribe to key downs used as drawing interaction shorcuts
     */
    subscribeKeyDown() {
        this.unsubscribeKeyDown();
        this.keyDown$$ = fromEvent(document, 'keydown').subscribe((event) => {
            // On Escape or 'c' keydowns, abort the current drawing
            if (event.key === 'Escape') {
                this.olDrawInteraction.abortDrawing();
                return;
            }
            // On Backspace or 'u' keydowns, remove last vertex of current drawing
            if (event.key === 'Backspace') {
                this.olDrawInteraction.removeLastPoint();
            }
            // On Enter or 'f' keydowns, finish current drawing
            if (event.key === 'Enter') {
                this.olDrawInteraction.finishDrawing();
            }
            // On space bar key down, pan to the current mouse position
            if (event.key === ' ') {
                this.olMap.getView().animate({
                    center: this.mousePosition,
                    duration: 100
                });
                return;
            }
        });
    }
    /**
     * Unsubscribe to key down
     */
    unsubscribeKeyDown() {
        if (this.keyDown$$) {
            this.keyDown$$.unsubscribe();
            this.keyDown$$ = undefined;
        }
    }
}

class DrawPopupComponent {
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
    }
    noLabel() {
        this.dialogRef.close();
    }
}
DrawPopupComponent.ɵfac = function DrawPopupComponent_Factory(t) { return new (t || DrawPopupComponent)(i0.ɵɵdirectiveInject(i1.MatDialogRef), i0.ɵɵdirectiveInject(MAT_DIALOG_DATA)); };
DrawPopupComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: DrawPopupComponent, selectors: [["igo-draw-popup-component"]], decls: 14, vars: 11, consts: [["mat-dialog-content", ""], [1, "mat-typography"], [1, "example-full-width"], ["matInput", "", 3, "placeholder", "value"], ["input", ""], ["mat-dialog-actions", ""], ["mat-raised-button", "", 3, "click"], ["mat-raised-button", "", "color", "primary", 3, "mat-dialog-close"]], template: function DrawPopupComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelementStart(1, "p", 1);
        i0.ɵɵtext(2);
        i0.ɵɵpipe(3, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(4, "mat-form-field", 2);
        i0.ɵɵelement(5, "input", 3, 4);
        i0.ɵɵpipe(7, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(8, "div", 5);
        i0.ɵɵelementStart(9, "button", 6);
        i0.ɵɵlistener("click", function DrawPopupComponent_Template_button_click_9_listener() { return ctx.noLabel(); });
        i0.ɵɵtext(10);
        i0.ɵɵpipe(11, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(12, "button", 7);
        i0.ɵɵtext(13, "OK ");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = i0.ɵɵreference(6);
        i0.ɵɵadvance(2);
        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 5, "igo.geo.draw.dialogInstruction"));
        i0.ɵɵadvance(3);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(7, 7, "igo.geo.draw.dialogTitle"));
        i0.ɵɵpropertyInterpolate("value", ctx.data.currentLabel);
        i0.ɵɵadvance(5);
        i0.ɵɵtextInterpolate1("", i0.ɵɵpipeBind1(11, 9, "igo.geo.draw.noLabel"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("mat-dialog-close", _r0.value);
    } }, directives: [i1.MatDialogContent, i12.MatFormField, i5$1.MatInput, i1.MatDialogActions, i2.MatButton, i1.MatDialogClose], pipes: [i7.TranslatePipe], styles: [""] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DrawPopupComponent, [{
        type: Component,
        args: [{
                selector: 'igo-draw-popup-component',
                templateUrl: './draw-popup.component.html',
                styleUrls: ['./draw-popup.component.scss'],
            }]
    }], function () { return [{ type: i1.MatDialogRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_DIALOG_DATA]
            }] }]; }, null); })();

class DrawShorcutsComponent {
}
DrawShorcutsComponent.ɵfac = function DrawShorcutsComponent_Factory(t) { return new (t || DrawShorcutsComponent)(); };
DrawShorcutsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: DrawShorcutsComponent, selectors: [["igo-draw-shorcuts"]], decls: 24, vars: 12, consts: [[1, "shortcut", "mat-typography"], ["svgIcon", "keyboard-return", 1, "shortcut-icon"], ["svgIcon", "backspace-outline", 1, "shortcut-icon"], ["svgIcon", "keyboard-esc", 1, "shortcut-icon"], ["svgIcon", "keyboard-space", 1, "shortcut-icon"], [1, "shortcuts-close"], ["mat-raised-button", "", "mat-dialog-close", "", "color", "primary"]], template: function DrawShorcutsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-dialog-content");
        i0.ɵɵelementStart(1, "div");
        i0.ɵɵelementStart(2, "span", 0);
        i0.ɵɵelement(3, "mat-icon", 1);
        i0.ɵɵtext(4);
        i0.ɵɵpipe(5, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(6, "div");
        i0.ɵɵelementStart(7, "span", 0);
        i0.ɵɵelement(8, "mat-icon", 2);
        i0.ɵɵtext(9);
        i0.ɵɵpipe(10, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(11, "div");
        i0.ɵɵelementStart(12, "span", 0);
        i0.ɵɵelement(13, "mat-icon", 3);
        i0.ɵɵtext(14);
        i0.ɵɵpipe(15, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(16, "div");
        i0.ɵɵelementStart(17, "span", 0);
        i0.ɵɵelement(18, "mat-icon", 4);
        i0.ɵɵtext(19);
        i0.ɵɵpipe(20, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(21, "mat-dialog-actions", 5);
        i0.ɵɵelementStart(22, "button", 6);
        i0.ɵɵtext(23, "OK");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(4);
        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(5, 4, "igo.geo.draw.finish"));
        i0.ɵɵadvance(5);
        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(10, 6, "igo.geo.draw.undo"));
        i0.ɵɵadvance(5);
        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(15, 8, "igo.geo.draw.abort"));
        i0.ɵɵadvance(5);
        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(20, 10, "igo.geo.draw.move"));
    } }, directives: [i1.MatDialogContent, i4.MatIcon, i1.MatDialogActions, i2.MatButton, i1.MatDialogClose], pipes: [i7.TranslatePipe], styles: [".shortcut[_ngcontent-%COMP%]{display:flex;align-items:center}.shortcut-icon[_ngcontent-%COMP%]{margin-right:10px}.shortcuts-close[_ngcontent-%COMP%]{display:flex;justify-content:center}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DrawShorcutsComponent, [{
        type: Component,
        args: [{
                selector: 'igo-draw-shorcuts',
                templateUrl: './draw-shorcuts.component.html',
                styleUrls: ['./draw-shorcuts.component.scss']
            }]
    }], null, null); })();

const MEASURE_UNIT_AUTO = 'auto';
var MeasureType;
(function (MeasureType) {
    MeasureType["Length"] = "length";
    MeasureType["Area"] = "area";
})(MeasureType || (MeasureType = {}));
var MeasureLengthUnit;
(function (MeasureLengthUnit) {
    MeasureLengthUnit["Meters"] = "meters";
    MeasureLengthUnit["Kilometers"] = "kilometers";
    MeasureLengthUnit["Miles"] = "miles";
    MeasureLengthUnit["Feet"] = "feet";
})(MeasureLengthUnit || (MeasureLengthUnit = {}));
const MeasureLengthUnitAbbreviation = {
    [MeasureLengthUnit.Meters]: 'm',
    [MeasureLengthUnit.Kilometers]: 'km',
    [MeasureLengthUnit.Miles]: 'mi',
    [MeasureLengthUnit.Feet]: 'ft'
};
var MeasureAreaUnit;
(function (MeasureAreaUnit) {
    MeasureAreaUnit["SquareMeters"] = "squareMeters";
    MeasureAreaUnit["SquareKilometers"] = "squareKilometers";
    MeasureAreaUnit["SquareMiles"] = "squareMiles";
    MeasureAreaUnit["SquareFeet"] = "squareFeet";
    MeasureAreaUnit["Hectares"] = "hectares";
    MeasureAreaUnit["Acres"] = "acres";
})(MeasureAreaUnit || (MeasureAreaUnit = {}));
const MeasureAreaUnitAbbreviation = {
    [MeasureAreaUnit.SquareMeters]: 'm²',
    [MeasureAreaUnit.SquareKilometers]: 'km²',
    [MeasureAreaUnit.SquareMiles]: 'mi²',
    [MeasureAreaUnit.SquareFeet]: 'ft²',
    [MeasureAreaUnit.Hectares]: 'ha',
    [MeasureAreaUnit.Acres]: 'ac'
};

/**
 * Convert value from meters to kilometers
 * @param value Value in meters
 * @returns Value in kilometers
 */
function metersToKilometers(value) {
    return value * 0.001;
}
/**
 * Convert value from meters to feet
 * @param value Value in meters
 * @returns Value in feet
 */
function metersToFeet(value) {
    return value * 3.2808;
}
/**
 * Convert value from meters to miles
 * @param value Value in meters
 * @returns Value in miles
 */
function metersToMiles(value) {
    return value * 0.000621;
}
/**
 * Convert value from square meters to square kilometers
 * @param value Value in square meters
 * @returns Value in square kilometers
 */
function squareMetersToSquareKilometers(value) {
    return value * 0.000001;
}
/**
 * Convert value from square meters to square miles
 * @param value Value in square meters
 * @returns Value in square miles
 */
function squareMetersToSquareMiles(value) {
    return value * 0.0000003861;
}
/**
 * Convert value from square meters to square feet
 * @param value Value in square meters
 * @returns Value in square feet
 */
function squareMetersToSquareFeet(value) {
    return value * 10.764;
}
/**
 * Convert value from square meters to hectares
 * @param value Value in square meters
 * @returns Value in hectares
 */
function squareMetersToHectares(value) {
    return value * 0.0001;
}
/**
 * Convert value from square meters to acres
 * @param value Value in square meters
 * @returns Value in acres
 */
function squareMetersToAcres(value) {
    return value * 0.00024711;
}
/**
 * Convert value from meters to the specified length unit
 * @param value Value in meters
 * @param unit Length unit
 * @returns Value in unit
 */
function metersToUnit(value, unit) {
    const conversionMapper = new Map([
        [MeasureLengthUnit.Meters, (val) => val],
        [MeasureLengthUnit.Kilometers, metersToKilometers],
        [MeasureLengthUnit.Miles, metersToMiles],
        [MeasureLengthUnit.Feet, metersToFeet],
    ]);
    const conversion = conversionMapper.get(unit);
    return conversion ? conversion(value) : undefined;
}
/**
 * Convert value from square meters to the specified area unit
 * @param value Value in meters
 * @param unit Area unit
 * @returns Value in unit
 */
function squareMetersToUnit(value, unit) {
    const conversionMapper = new Map([
        [MeasureAreaUnit.SquareMeters, (val) => val],
        [MeasureAreaUnit.SquareKilometers, squareMetersToSquareKilometers],
        [MeasureAreaUnit.SquareMiles, squareMetersToSquareMiles],
        [MeasureAreaUnit.SquareFeet, squareMetersToSquareFeet],
        [MeasureAreaUnit.Hectares, squareMetersToHectares],
        [MeasureAreaUnit.Acres, squareMetersToAcres],
    ]);
    const conversion = conversionMapper.get(unit);
    return conversion ? conversion(value) : undefined;
}
/**
 * This method format a measure to a readable format
 * @param measure Measure
 * @param options Formatting options
 * @returns Formatted measure
 */
function formatMeasure(measure, options, languageService) {
    let decimal = options.decimal;
    if (decimal === undefined || decimal < 0) {
        decimal = 1;
    }
    const parts = [];
    if (options.locale !== undefined) {
        parts.push(measure.toLocaleString(options.locale, {
            minimumFractionDigits: decimal,
            maximumFractionDigits: decimal
        }));
    }
    else {
        parts.push(measure.toFixed(decimal).toString());
    }
    if (options.unit !== undefined && options.unitAbbr === true) {
        if (languageService) {
            parts.push(MeasureLengthUnitAbbreviation[options.unit] ?
                languageService.translate.instant('igo.geo.measure.' + MeasureLengthUnitAbbreviation[options.unit]) :
                languageService.translate.instant('igo.geo.measure.' + MeasureAreaUnitAbbreviation[options.unit]));
        }
        else {
            parts.push(MeasureLengthUnitAbbreviation[options.unit] || MeasureAreaUnitAbbreviation[options.unit]);
        }
    }
    return parts.filter(p => p !== undefined).join(' ');
}
/**
 * Compute best length measure unit for a given measure in meters
 * @param value Value in meters
 * @returns Measure unit
 */
function computeBestLengthUnit(value) {
    let unit = MeasureLengthUnit.Meters;
    let converted = value;
    const possibleUnits = [MeasureLengthUnit.Kilometers];
    while (converted > 1000 && possibleUnits.length > 0) {
        unit = possibleUnits.pop();
        converted = metersToUnit(value, unit);
    }
    return unit;
}
/**
 * Compute best length measure unit for a given measure in square meters
 * @param value Value in meters
 * @returns Measure unit
 */
function computeBestAreaUnit(value) {
    let unit = MeasureAreaUnit.SquareMeters;
    let converted = value;
    const possibleUnits = [MeasureAreaUnit.SquareKilometers];
    while (converted > 1000000 && possibleUnits.length > 0) {
        unit = possibleUnits.pop();
        converted = squareMetersToUnit(value, unit);
    }
    return unit;
}
/**
 * Create a default style for a measure interaction
 * @returns OL style
 */
function createMeasureInteractionStyle() {
    return new olstyle.Style({
        stroke: new olstyle.Stroke({
            color: '#ffcc33',
            lineDash: [10, 10],
            width: 2
        }),
        fill: new olstyle.Fill({
            color: 'rgba(255, 255, 255, 0.2)'
        }),
        image: new olstyle.Circle({
            radius: 5,
            stroke: new olstyle.Stroke({
                color: '#ffcc33',
            }),
            fill: new olstyle.Fill({
                color: 'rgba(255, 255, 255, 0.2)'
            })
        })
    });
}
/**
 * Create a default style for a measure layer
 * @returns OL style
 */
function createMeasureLayerStyle() {
    return new olstyle.Style({
        stroke: new olstyle.Stroke({
            color: '#ffcc33',
            width: 2
        }),
        fill: new olstyle.Fill({
            color: 'rgba(255, 255, 255, 0.2)'
        })
    });
}
/**
 * Compute the length in meters of an OL geometry with a given projection
 * @param olGeometry Ol geometry
 * @param projection olGeometry's projection
 * @returns Length in meters
 */
function measureOlGeometryLength(olGeometry, projection) {
    if (olGeometry instanceof OlPoint) {
        return undefined;
    }
    if (olGeometry.getFlatCoordinates().length === 0) {
        return undefined;
    }
    return getLength(olGeometry, { projection });
}
/**
 * Compute the area in square meters of an OL geometry with a given projection
 * @param olGeometry Ol geometry
 * @param projection olGeometry's projection
 * @returns Area in square meters
 */
function measureOlGeometryArea(olGeometry, projection) {
    if (olGeometry instanceof OlPoint || olGeometry instanceof OlLineString) {
        return undefined;
    }
    if (olGeometry.getFlatCoordinates().length === 0) {
        return undefined;
    }
    return getArea(olGeometry, { projection });
}
/**
 * Compute the area (square meters), length (meters) and last length (meters)
 * of an OL geometry with a given projection.
 * @param olGeometry Ol geometry
 * @param projection olGeometry's projection
 * @returns Computed measure
 */
function measureOlGeometry(olGeometry, projection) {
    const length = measureOlGeometryLength(olGeometry, projection);
    const area = measureOlGeometryArea(olGeometry, projection);
    const lengths = [];
    const coordinates = olGeometry.getFlatCoordinates();
    const coordinatesLength = coordinates.length;
    for (let i = 0; i <= coordinatesLength - 4; i += 2) {
        const olSegment = new OlLineString([
            [coordinates[i], coordinates[i + 1]],
            [coordinates[i + 2], coordinates[i + 3]]
        ]);
        lengths.push(measureOlGeometryLength(olSegment, projection));
    }
    return {
        area,
        length,
        lengths
    };
}
/**
 * Update an OL geometry midpoints and return an array of those points
 * @param olGeometry OL Geometry
 * @returns OL points
 */
function updateOlGeometryMidpoints(olGeometry) {
    let olMidpoints;
    if (olGeometry instanceof OlPoint) {
        const olMidpointPoint = new OlPoint(olGeometry.getFlatCoordinates());
        olMidpoints = new Array(1);
        olMidpoints[0] = olMidpointPoint;
    }
    else {
        olMidpoints = getOlGeometryMidpoints(olGeometry);
        // TODO: handle multi geometries
        const coordinates = olGeometry.getFlatCoordinates();
        const midpointsLength = olMidpoints.length;
        for (let i = 0; i < midpointsLength; i++) {
            const j = i * 2;
            const olSegment = new OlLineString([
                [coordinates[j], coordinates[j + 1]],
                [coordinates[j + 2], coordinates[j + 3]]
            ]);
            const midpointCoordinate = olSegment.getCoordinateAt(0.5);
            const olMidpoint = olMidpoints[i];
            if (olMidpoint !== undefined) {
                olMidpoint.setCoordinates(midpointCoordinate);
            }
            else {
                olMidpoints[i] = new OlPoint(midpointCoordinate);
            }
        }
    }
    return olMidpoints;
}
/**
 * Clear an OL geometry midpoints and return an array of those points
 * @param olGeometry OL Geometry
 */
function clearOlGeometryMidpoints(olGeometry) {
    const olMidpoints = olGeometry.get('_midpoints') || [];
    const midpointsLength = olMidpoints.length;
    for (let i = 0; i < midpointsLength; i++) {
        const olMidpoint = olMidpoints[i];
        if (olMidpoint !== undefined) {
            if (olMidpoint !== undefined) {
                clearOlMidpointTooltip(olMidpoint);
            }
        }
    }
    olGeometry.set('_midpoints', undefined, true);
    return olMidpoints;
}
/**
 * Return an array of  OL geometry midpoints, if any
 * @param olGeometry OL Geometry
 * @returns OL points
 */
function getOlGeometryMidpoints(olGeometry) {
    let expectedNumber;
    if (olGeometry instanceof OlCircle) {
        expectedNumber = 0;
    }
    else {
        expectedNumber = Math.max((olGeometry.getFlatCoordinates().length / 2) - 1, 0);
    }
    // TODO: This works but it's quite messy. If time permits,
    // clean this. Maybe a Tooltip class could handle that
    let olMidpoints = olGeometry.get('_midpoints');
    if (olMidpoints === undefined) {
        if (olGeometry instanceof OlPoint) {
            olMidpoints = new Array(1);
        }
        else {
            olMidpoints = new Array(expectedNumber);
        }
        olGeometry.set('_midpoints', olMidpoints, true);
        return olMidpoints;
    }
    if (expectedNumber === 0) {
        return olMidpoints;
    }
    if (expectedNumber === olMidpoints.length) {
        return olMidpoints;
    }
    if (expectedNumber > olMidpoints.length) {
        olMidpoints.push(...new Array(expectedNumber - olMidpoints.length));
        return olMidpoints;
    }
    for (let i = expectedNumber; i < olMidpoints.length; i++) {
        const olMidpoint = olMidpoints[expectedNumber];
        if (olMidpoint !== undefined) {
            clearOlMidpointTooltip(olMidpoint);
        }
    }
    olMidpoints.splice(expectedNumber);
    return olMidpoints;
}
/**
 * Remove an OL midpoint's tooltip from the map
 * @param olMidpoint OL Point
 */
function clearOlMidpointTooltip(olMidpoint) {
    const olTooltip = olMidpoint.get('_tooltip');
    if (olTooltip !== undefined) {
        const olMap = olTooltip.getMap();
        if (olMap !== undefined) {
            olMap.removeOverlay(olTooltip);
        }
    }
}
/**
 * Add an OL overlay at each midpoint and return an array of those overlays
 * @param olGeometry OL Geometry
 * @returns OL overlays
 */
function updateOlTooltipsAtMidpoints(olGeometry) {
    const olMidpoints = updateOlGeometryMidpoints(olGeometry);
    let typeGeom = '';
    if (olGeometry instanceof OlLineString) {
        typeGeom = 'line-';
    }
    else if (olGeometry instanceof OlPolygon) {
        typeGeom = 'polygone-';
    }
    const olTooltips = olMidpoints.map((olMidpoint) => {
        let olTooltip = olMidpoint.get('_tooltip');
        if (olTooltip === undefined) {
            olTooltip = createOlTooltipAtPoint(olMidpoint, false, typeGeom);
        }
        else {
            olTooltip.setPosition(olMidpoint.getFlatCoordinates());
        }
        return olTooltip;
    });
    return olTooltips;
}
/**
 * Return an array of OL overlay at midspoints, if any
 * @param olGeometry OL Geometry
 * @returns OL overlays
 */
function getOlTooltipsAtMidpoints(olGeometry) {
    const olMidpoints = getOlGeometryMidpoints(olGeometry);
    return olMidpoints.map((olMidpoint) => {
        return olMidpoint ? olMidpoint.get('_tooltip') : undefined;
    });
}
/**
 * Update an OL geometry center and return it
 * @param olGeometry OL Geometry
 * @returns OL point
 */
function updateOlGeometryCenter(olGeometry) {
    let olCenter = olGeometry.get('_center');
    const centerCoordinate = getCenter(olGeometry.getExtent());
    if (olCenter !== undefined) {
        olCenter.setCoordinates(centerCoordinate);
    }
    else {
        olCenter = new OlPoint(centerCoordinate);
        olGeometry.set('_center', olCenter);
    }
    return olCenter;
}
/**
 * Add an OL overlay at the center of a geometry and return that overlay
 * @param olGeometry OL Geometry
 * @returns OL overlay
 */
function updateOlTooltipAtCenter(olGeometry) {
    const olCenter = updateOlGeometryCenter(olGeometry);
    let olTooltip = olCenter.get('_tooltip');
    if (olTooltip === undefined) {
        olTooltip = createOlTooltipAtPoint(olCenter, true);
    }
    else {
        olTooltip.setPosition(olCenter.getFlatCoordinates());
    }
    return olTooltip;
}
/**
 * Return an array of OL overlay at midspoints, if any
 * @param olGeometry OL Geometry
 * @returns OL overlays
 */
function getOlTooltipAtCenter(olGeometry) {
    const olCenter = olGeometry.get('_center');
    return olCenter ? olCenter.get('_tooltip') : undefined;
}
/**
 * Get all the tooltips of an OL geometry
 * @param olGeometry OL Geometry
 * @returns OL overlays
 */
function getTooltipsOfOlGeometry(olGeometry) {
    const olTooltips = [].concat(getOlTooltipsAtMidpoints(olGeometry) || []);
    const olCenterTooltip = getOlTooltipAtCenter(olGeometry);
    if (olCenterTooltip !== undefined) {
        olTooltips.push(olCenterTooltip);
    }
    return olTooltips;
}
/**
 * Create an OL overlay at a point and bind the overlay to the point
 * @param olPoint OL Point
 * @returns OL overlay
 */
function createOlTooltipAtPoint(olPoint, center = false, srcGeomType = '') {
    const olTooltip = new OlOverlay({
        element: document.createElement('div'),
        offset: [-30, -10],
        className: (center ?
            ['igo-map-tooltip',
                'igo-map-tooltip-measure', 'igo-map-tooltip-measure-area'] : ['igo-map-tooltip', 'igo-map-tooltip-measure',
            `igo-map-tooltip-measure-${srcGeomType}segments`]).join(' '),
        stopEvent: false
    });
    olTooltip.setPosition(olPoint.getFlatCoordinates());
    olPoint.set('_tooltip', olTooltip);
    return olTooltip;
}

/**
 * Create a default style
 * @param fillColor the fill color
 * @param strokeColor the stroke color
 * @param strokeWidth the stroke width
 * @param label a label
 * @returns OL style
 */
function createInteractionStyle(fillColor, strokeColor, strokeWidth, label) {
    return new olstyle.Style({
        stroke: new olstyle.Stroke({
            color: strokeColor ? strokeColor : 'rgba(143,7,7,1)',
            width: strokeWidth ? strokeWidth : 1
        }),
        fill: new olstyle.Fill({
            color: fillColor ? fillColor : 'rgba(255,255,255,0.4)'
        }),
        image: new olstyle.Circle({
            radius: 5,
            stroke: new olstyle.Stroke({
                color: strokeColor ? strokeColor : 'rgba(143,7,7,1)',
                width: strokeWidth ? strokeWidth : 1
            }),
            fill: new olstyle.Fill({
                color: fillColor ? fillColor : 'rgba(255,255,255,0.4)'
            })
        })
    });
}
/**
 * Add an OL overlay at each midpoint and return an array of those overlays
 * @param olGeometry OL Geometry
 * @returns OL overlays
 */
function updateOlTooltipsDrawAtMidpoints(olGeometry) {
    let olMidpoints;
    if (olGeometry instanceof OlPoint) {
        const olMidpointPoint = new OlPoint(olGeometry.getFlatCoordinates());
        olMidpoints = new Array(1);
        olMidpoints[0] = olMidpointPoint;
        olGeometry.setProperties({ _midpoints: olMidpoints }, true);
    }
    else if (olGeometry instanceof OlCircle) {
        const olMidpointPoint = new OlPoint(olGeometry.getCenter());
        olMidpoints = new Array(1);
        olMidpoints[0] = olMidpointPoint;
        olGeometry.setProperties({ _midpoints: olMidpoints }, true);
    }
    else {
        olMidpoints = updateOlGeometryMidpoints(olGeometry);
    }
    const olTooltips = olMidpoints.map((olMidpoint) => {
        let olTooltip = olMidpoint.get('_tooltip');
        if (olTooltip === undefined) {
            olTooltip = createOlTooltipDrawAtPoint(olMidpoint);
        }
        else {
            olTooltip.setPosition(olMidpoint.getFlatCoordinates());
        }
        return olTooltip;
    });
    return olTooltips;
}
/**
 * Add an OL overlay at the center of a geometry and return that overlay
 * @param olGeometry OL Geometry
 * @returns OL overlay
 */
function updateOlTooltipDrawAtCenter(olGeometry) {
    const olCenter = updateOlGeometryCenter(olGeometry);
    let olTooltip = olCenter.get('_tooltip');
    if (olTooltip === undefined) {
        olTooltip = createOlTooltipDrawAtPoint(olCenter);
    }
    else {
        olTooltip.setPosition(olCenter.getFlatCoordinates());
    }
    return olTooltip;
}
/**
 * Create an OL overlay at a point and bind the overlay to the point
 * @param olPoint OL Point
 * @returns OL overlay
 */
function createOlTooltipDrawAtPoint(olPoint) {
    const olTooltip = new OlOverlay({
        element: document.createElement('div'),
        offset: [-30, -10],
        className: [
            'igo-map-tooltip',
            'igo-map-tooltip-draw'
        ].join(' '),
        stopEvent: false
    });
    olTooltip.setPosition(olPoint.getFlatCoordinates());
    olPoint.set('_tooltip', olTooltip);
    return olTooltip;
}

class DrawStyleService {
    constructor(mapService) {
        this.mapService = mapService;
        this.fillColor = 'rgba(255,255,255,0.4)';
        this.strokeColor = 'rgba(143,7,7,1)';
        this.strokeWidth = 1;
        this.labelsAreShown = true;
    }
    getFillColor() {
        return this.fillColor;
    }
    setFillColor(fillColor) {
        this.fillColor = fillColor;
    }
    getStrokeColor() {
        return this.strokeColor;
    }
    setStrokeColor(strokeColor) {
        this.strokeColor = strokeColor;
    }
    getStrokeWidth() {
        return this.strokeWidth;
    }
    getLabelsAreShown() {
        return this.labelsAreShown;
    }
    toggleLabelsAreShown() {
        this.labelsAreShown = !this.labelsAreShown;
    }
    setIcon(icon) {
        this.icon = icon;
    }
    getIcon() {
        return this.icon;
    }
    createDrawingLayerStyle(feature, resolution, labelsAreShown, icon) {
        let style;
        let labelsAreOffset = false;
        const proj = this.mapService.getMap().projection;
        const geom = feature.getGeometry();
        if (geom instanceof OlPoint) {
            labelsAreOffset = !labelsAreOffset;
        }
        // if feature is a circle
        if (feature.get('rad')) {
            const coordinates = transform(feature.getGeometry().flatCoordinates, proj, 'EPSG:4326');
            style = new olstyle.Style({
                text: new olstyle.Text({
                    text: labelsAreShown ? feature.get('draw') : '',
                    stroke: new olstyle.Stroke({
                        color: 'white',
                        width: 0.75
                    }),
                    fill: new olstyle.Fill({
                        color: 'black'
                    }),
                    font: '20px sans-serif',
                    overflow: true
                }),
                image: new olstyle.Circle({
                    radius: feature.get('rad') / Math.cos((Math.PI / 180) * coordinates[1]) / resolution,
                    stroke: new olstyle.Stroke({
                        color: this.strokeColor,
                        width: this.strokeWidth
                    }),
                    fill: new olstyle.Fill({
                        color: this.fillColor
                    })
                })
            });
            return style;
            // if feature is an icon
        }
        else if (icon) {
            style = new olstyle.Style({
                text: new olstyle.Text({
                    text: labelsAreShown ? feature.get('draw') : '',
                    offsetY: -26,
                    stroke: new olstyle.Stroke({
                        color: 'white',
                        width: 0.75
                    }),
                    fill: new olstyle.Fill({
                        color: 'black'
                    }),
                    font: '20px sans-serif',
                    overflow: true
                }),
                stroke: new olstyle.Stroke({
                    color: this.strokeColor,
                    width: this.strokeWidth
                }),
                fill: new olstyle.Fill({
                    color: this.fillColor
                }),
                image: new olstyle.Icon({
                    src: icon
                })
            });
            return style;
            // if feature is a point, a linestring or a polygon
        }
        else {
            style = new olstyle.Style({
                text: new olstyle.Text({
                    text: labelsAreShown ? feature.get('draw') : '',
                    stroke: new olstyle.Stroke({
                        color: 'white',
                        width: 0.75
                    }),
                    fill: new olstyle.Fill({
                        color: 'black'
                    }),
                    font: '20px sans-serif',
                    overflow: true,
                    offsetY: labelsAreOffset ? -15 : 0
                }),
                stroke: new olstyle.Stroke({
                    color: this.strokeColor,
                    width: this.strokeWidth
                }),
                fill: new olstyle.Fill({
                    color: this.fillColor
                }),
                image: new olstyle.Circle({
                    radius: 5,
                    stroke: new olstyle.Stroke({
                        color: this.strokeColor,
                        width: this.strokeWidth
                    }),
                    fill: new olstyle.Fill({
                        color: this.fillColor
                    })
                })
            });
            return style;
        }
    }
}
DrawStyleService.ɵfac = function DrawStyleService_Factory(t) { return new (t || DrawStyleService)(i0.ɵɵinject(MapService)); };
DrawStyleService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DrawStyleService, factory: DrawStyleService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DrawStyleService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: MapService }]; }, null); })();

class DrawIconService {
    constructor(config) {
        this.config = config;
        this.getIconsList();
    }
    getIcons() {
        return this.icons;
    }
    getPath() {
        return this.config.getConfig('drawingTool.icons') || [];
    }
    getIconsList() {
        this.icons = this.getPath();
    }
}
DrawIconService.ɵfac = function DrawIconService_Factory(t) { return new (t || DrawIconService)(i0.ɵɵinject(i2$1.ConfigService)); };
DrawIconService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DrawIconService, factory: DrawIconService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DrawIconService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i2$1.ConfigService }]; }, null); })();

function DrawComponent_mat_form_field_46_div_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 24);
    i0.ɵɵelement(1, "img", 25);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("src", ctx_r3.icon, i0.ɵɵsanitizeUrl);
} }
function DrawComponent_mat_form_field_46_mat_option_10_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-option", 26);
    i0.ɵɵlistener("click", function DrawComponent_mat_form_field_46_mat_option_10_Template_mat_option_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r7); const icon_html_r5 = restoredCtx.$implicit; const ctx_r6 = i0.ɵɵnextContext(2); return ctx_r6.onIconChange(icon_html_r5); });
    i0.ɵɵelementStart(1, "div", 24);
    i0.ɵɵelement(2, "img", 25);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const icon_html_r5 = ctx.$implicit;
    i0.ɵɵproperty("value", icon_html_r5);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("src", icon_html_r5, i0.ɵɵsanitizeUrl);
} }
function DrawComponent_mat_form_field_46_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field");
    i0.ɵɵelementStart(1, "mat-label");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "mat-select");
    i0.ɵɵelementStart(5, "mat-select-trigger");
    i0.ɵɵtemplate(6, DrawComponent_mat_form_field_46_div_6_Template, 2, 1, "div", 21);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(7, "mat-option", 22);
    i0.ɵɵlistener("click", function DrawComponent_mat_form_field_46_Template_mat_option_click_7_listener() { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(); return ctx_r8.onIconChange(); });
    i0.ɵɵtext(8);
    i0.ɵɵpipe(9, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(10, DrawComponent_mat_form_field_46_mat_option_10_Template, 3, 2, "mat-option", 23);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 4, "igo.geo.draw.icon"));
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r0.icon);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(9, 6, "igo.geo.draw.noIcon"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r0.icons);
} }
function DrawComponent_button_49_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 27);
    i0.ɵɵlistener("click", function DrawComponent_button_49_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.deleteDrawings(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelement(3, "mat-icon", 28);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 2, "igo.geo.draw.delete"))("disabled", i0.ɵɵpipeBind1(2, 4, ctx_r1.selectedFeatures$).length === 0);
} }
class DrawComponent {
    constructor(languageService, formBuilder, drawStyleService, dialog, drawIconService) {
        this.languageService = languageService;
        this.formBuilder = formBuilder;
        this.drawStyleService = drawStyleService;
        this.dialog = dialog;
        this.drawIconService = drawIconService;
        /**
         * Table template
         * @internal
         */
        this.tableTemplate = {
            selection: true,
            selectMany: true,
            selectionCheckbox: true,
            sort: true,
            columns: [{
                    name: 'Drawing',
                    title: this.languageService.translate.instant('igo.geo.draw.labels'),
                    valueAccessor: (feature) => {
                        return feature.properties.draw;
                    }
                }]
        };
        this.geometryType = GeometryType; // Reference to the GeometryType enum
        this.draw$ = new BehaviorSubject({}); // Observable of draw
        this.olDrawingLayerSource = new OlVectorSource();
        this.selectedFeatures$ = new BehaviorSubject([]);
        this.drawControlIsDisabled = true;
        this.drawControlIsActive = false;
        this.subscriptions$$ = [];
        this.position = 'bottom';
        this.buildForm();
        this.fillColor = this.drawStyleService.getFillColor();
        this.strokeColor = this.drawStyleService.getStrokeColor();
        this.strokeWidth = this.drawStyleService.getStrokeWidth();
        this.labelsAreShown = this.drawStyleService.getLabelsAreShown();
        this.icons = this.drawIconService.getIcons();
        this.icon = this.drawStyleService.getIcon();
    }
    // Initialize the store that will contain the entities and create the Draw control
    ngOnInit() {
        this.initStore();
        this.drawControl = this.createDrawControl(this.fillColor, this.strokeColor, this.strokeWidth);
        this.drawControl.setGeometryType(this.geometryType.Point);
        this.toggleDrawControl();
    }
    /**
     * Remove the drawing layer and the interactions
     * @internal
     */
    ngOnDestroy() {
        this.drawControl.setOlMap(undefined);
        this.subscriptions$$.map(s => s.unsubscribe());
    }
    /**
     * Create a Draw Control
     * @param fillColor the fill color
     * @param strokeColor the stroke color
     * @param strokeWidth the stroke width
     * @returns a Draw Control
     */
    createDrawControl(fillColor, strokeColor, strokeWidth) {
        const drawControl = new DrawControl({
            geometryType: undefined,
            drawingLayerSource: this.olDrawingLayerSource,
            drawingLayerStyle: new olstyle.Style({}),
            interactionStyle: createInteractionStyle(fillColor, strokeColor, strokeWidth),
        });
        return drawControl;
    }
    /**
     * Called when the user selects a new geometry type
     * @param geometryType the geometry type selected by the user
     */
    onGeometryTypeChange(geometryType) {
        this.drawControl.setGeometryType(geometryType);
        this.toggleDrawControl();
    }
    /**
     * Store initialization, including drawing layer creation
     */
    initStore() {
        this.map.removeLayer(this.olDrawingLayer);
        this.olDrawingLayer = new VectorLayer({
            isIgoInternalLayer: true,
            id: 'igo-draw-layer',
            title: this.languageService.translate.instant('igo.geo.draw.drawing'),
            zIndex: 200,
            source: new FeatureDataSource(),
            style: (feature, resolution) => {
                return this.drawStyleService.createDrawingLayerStyle(feature, resolution, this.labelsAreShown, this.icon);
            },
            showInLayerList: true,
            exportable: true,
            browsable: false,
            workspace: {
                enabled: false
            },
        });
        tryBindStoreLayer(this.store, this.olDrawingLayer);
        tryAddLoadingStrategy(this.store, new FeatureStoreLoadingStrategy({
            motion: FeatureMotion.None
        }));
        tryAddSelectionStrategy(this.store, new FeatureStoreSelectionStrategy({
            map: this.map,
            motion: FeatureMotion.None,
            many: true
        }));
        this.store.layer.visible = true;
        this.store.source.ol.on('removefeature', (event) => {
            const olGeometry = event.feature.getGeometry();
            this.clearLabelsOfOlGeometry(olGeometry);
        });
        this.subscriptions$$.push(this.store.stateView.manyBy$((record) => {
            return record.state.selected === true;
        }).pipe(skip(1) // Skip initial emission
        ).subscribe((records) => {
            this.selectedFeatures$.next(records.map(record => record.entity));
        }));
        this.subscriptions$$.push(this.store.count$.subscribe(cnt => {
            cnt >= 1 ? this.store.layer.options.showInLayerList = true : this.store.layer.options.showInLayerList = false;
        }));
    }
    /**
     * Called when the user changes the color in a color picker
     * @param labelsAreShown wheter the labels are shown or not
     * @param isAnIcon wheter the feature is an icon or not
     */
    onColorChange(labelsAreShown, isAnIcon) {
        this.fillForm = this.fillColor;
        this.strokeForm = this.strokeColor;
        this.drawStyleService.setFillColor(this.fillColor);
        this.drawStyleService.setStrokeColor(this.strokeColor);
        if (isAnIcon) {
            this.store.layer.ol.setStyle((feature, resolution) => {
                return this.drawStyleService.createDrawingLayerStyle(feature, resolution, labelsAreShown, this.icon);
            });
            this.icon = undefined;
        }
        else {
            this.store.layer.ol.setStyle((feature, resolution) => {
                return this.drawStyleService.createDrawingLayerStyle(feature, resolution, labelsAreShown);
            });
        }
        this.createDrawControl();
    }
    /**
     * Called when the user toggles the Draw control is toggled
     * @internal
     */
    onToggleDrawControl(toggleIsChecked) {
        toggleIsChecked ? this.toggleDrawControl() : this.deactivateDrawControl();
    }
    /**
     * Activate the correct control
     */
    toggleDrawControl() {
        this.deactivateDrawControl();
        this.activateDrawControl();
    }
    /**
     * Open a dialog box to enter label and do something
     * @param olGeometry geometry at draw end or selected geometry
     * @param drawEnd event fired at drawEnd?
     */
    openDialog(olGeometryFeature, isDrawEnd) {
        setTimeout(() => {
            // open the dialog box used to enter label
            const dialogRef = this.dialog.open(DrawPopupComponent, {
                disableClose: false,
                data: { currentLabel: olGeometryFeature.get('draw') }
            });
            // when dialog box is closed, get label and set it to geometry
            dialogRef.afterClosed().subscribe((label) => {
                this.updateLabelOfOlGeometry(olGeometryFeature, label);
                // if event was fired at draw end
                if (isDrawEnd) {
                    this.onDrawEnd(olGeometryFeature);
                    // if event was fired at select
                }
                else {
                    this.onSelectDraw(olGeometryFeature, label);
                }
            });
        }, 250);
    }
    /**
     * Activate a given control
     */
    activateDrawControl() {
        this.drawControlIsDisabled = false;
        this.drawControlIsActive = true;
        this.drawEnd$$ = this.drawControl.end$.subscribe((olGeometry) => {
            this.openDialog(olGeometry, true);
        });
        this.drawControl.modify$.subscribe((olGeometry) => {
            this.onModifyDraw(olGeometry);
        });
        if (!this.drawSelect$$) {
            this.drawSelect$$ = this.drawControl.select$.subscribe((olFeature) => {
                this.openDialog(olFeature, false);
            });
        }
        this.drawControl.setOlMap(this.map.ol, true);
    }
    /**
     * Deactivate the active draw control
     */
    deactivateDrawControl() {
        if (!this.drawControl) {
            return;
        }
        if (this.drawEnd$$) {
            this.drawEnd$$.unsubscribe();
        }
        this.drawControl.setOlMap(undefined);
        this.drawControlIsActive = false;
    }
    /**
     * Clear the draw source and track the geometry being draw
     * @param olGeometry Ol linestring or polygon
     */
    onDrawEnd(olGeometry, radius) {
        this.addFeatureToStore(olGeometry, radius);
        this.clearLabelsOfOlGeometry(olGeometry);
        this.store.layer.ol.getSource().refresh();
    }
    onModifyDraw(olGeometry) {
        const entities = this.store.all();
        entities.forEach(entity => {
            const entityId = entity.properties.id;
            const olGeometryId = olGeometry.ol_uid;
            if (entityId === olGeometryId) {
                this.updateLabelOfOlGeometry(olGeometry, entity.properties.draw);
                this.replaceFeatureInStore(entity, olGeometry);
            }
        });
    }
    onSelectDraw(olFeature, label) {
        const entities = this.store.all();
        const olGeometry = olFeature.getGeometry();
        olGeometry.ol_uid = olFeature.get('id');
        const olGeometryCoordinates = JSON.stringify(olGeometry.getCoordinates()[0]);
        entities.forEach(entity => {
            const entityCoordinates = JSON.stringify(entity.geometry.coordinates[0]);
            if (olGeometryCoordinates === entityCoordinates) {
                const rad = entity.properties.rad ? entity.properties.rad : undefined;
                this.updateLabelOfOlGeometry(olGeometry, label);
                this.replaceFeatureInStore(entity, olGeometry, rad);
            }
        });
    }
    /**
     * Add a feature with draw label to the store. The loading stragegy of the store
     * will trigger and add the feature to the map.
     * @internal
     */
    addFeatureToStore(olGeometry, radius, feature) {
        let rad;
        let center4326;
        let point4326;
        let lon4326;
        let lat4326;
        const featureId = feature ? feature.properties.id : olGeometry.ol_uid;
        const projection = this.map.ol.getView().getProjection();
        const geometry = new OlGeoJSON().writeGeometryObject(olGeometry, {
            featureProjection: projection,
            dataProjection: projection
        });
        if (olGeometry instanceof OlCircle || radius) {
            if (radius) {
                rad = radius;
            }
            else {
                geometry.type = 'Point';
                geometry.coordinates = olGeometry.getCenter();
                const extent4326 = transform([olGeometry.getFlatCoordinates()[2], olGeometry.getFlatCoordinates()[3]], projection, 'EPSG:4326');
                center4326 = transform([olGeometry.getFlatCoordinates()[0], olGeometry.getFlatCoordinates()[1]], projection, 'EPSG:4326');
                lon4326 = center4326[0];
                lat4326 = center4326[1];
                rad = getDistance(center4326, extent4326);
            }
        }
        if (olGeometry instanceof OlPoint) {
            point4326 = transform(olGeometry.getFlatCoordinates(), projection, 'EPSG:4326');
            lon4326 = point4326[0];
            lat4326 = point4326[1];
        }
        this.store.update({
            type: FEATURE,
            geometry,
            projection: projection.getCode(),
            properties: {
                id: featureId,
                draw: olGeometry.get('_label'),
                longitude: lon4326 ? lon4326 : null,
                latitude: lat4326 ? lat4326 : null,
                rad: rad ? rad : null
            },
            meta: {
                id: featureId
            }
        });
    }
    /**
     * Replace the feature in the store
     * @param entity the entity to replace
     * @param olGeometry the new geometry to insert in the store
     */
    replaceFeatureInStore(entity, olGeometry, radius) {
        this.store.delete(entity);
        this.onDrawEnd(olGeometry, radius);
    }
    buildForm() {
        this.form = this.formBuilder.group({
            fill: [''],
            stroke: ['']
        });
    }
    deleteDrawings() {
        this.store.deleteMany(this.selectedFeatures$.value);
        this.selectedFeatures$.value.forEach(selectedFeature => {
            this.olDrawingLayerSource.getFeatures().forEach(drawingLayerFeature => {
                const geometry = drawingLayerFeature.getGeometry();
                if (selectedFeature.properties.id === geometry.ol_uid) {
                    this.olDrawingLayerSource.removeFeature(drawingLayerFeature);
                }
            });
        });
    }
    /**
     * Clear the tooltips of an OL geometry
     * @param olGeometry OL geometry with tooltips
     */
    clearLabelsOfOlGeometry(olGeometry) {
        getTooltipsOfOlGeometry(olGeometry).forEach((olTooltip) => {
            if (olTooltip && olTooltip.getMap()) {
                this.map.ol.removeOverlay(olTooltip);
            }
        });
    }
    /**
     * Called when the user toggles the labels toggle
     */
    onToggleLabels() {
        this.drawStyleService.toggleLabelsAreShown();
        this.labelsAreShown = !this.labelsAreShown;
        this.icon ? this.onColorChange(this.labelsAreShown, true) : this.onColorChange(this.labelsAreShown, false);
    }
    /**
     * Update the label of a geometry when a label is entered in a dialog box
     * @param olGeometry the geometry
     * @param label the label
     */
    updateLabelOfOlGeometry(olGeometry, label) {
        olGeometry.setProperties({
            _label: label
        }, true);
    }
    onIconChange(event) {
        this.icon = event;
        this.drawStyleService.setIcon(this.icon);
        this.store.layer.ol.setStyle((feature, resolution) => {
            return this.drawStyleService.createDrawingLayerStyle(feature, resolution, true, this.icon);
        });
    }
    openShorcutsDialog() {
        this.dialog.open(DrawShorcutsComponent);
    }
}
DrawComponent.ɵfac = function DrawComponent_Factory(t) { return new (t || DrawComponent)(i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(i16.FormBuilder), i0.ɵɵdirectiveInject(DrawStyleService), i0.ɵɵdirectiveInject(i1.MatDialog), i0.ɵɵdirectiveInject(DrawIconService)); };
DrawComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: DrawComponent, selectors: [["igo-draw"]], inputs: { map: "map", store: "store" }, outputs: { fillColor: "fillColor", strokeColor: "strokeColor", strokeWidth: "strokeWidth" }, decls: 55, vars: 78, consts: [[1, "geometry-type-toggle", "mat-typography"], [3, "value", "change"], [3, "value"], [1, "draw-options", "mat-typography"], [3, "disabled", "checked", "labelPosition", "change"], [3, "checked", "labelPosition", "change"], [1, "igo-form", 3, "formGroup"], [1, "fill-color-picker", "mat-typography"], ["svgIcon", "square", 1, "stroke-palette-icon"], ["appearance", "outline", "floatLabel", "always", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "fill-field", 3, "matTooltip"], ["formControlName", "fill", "matInput", "", "type", "text", 3, "colorPicker", "readonly", "cpWidth", "cpOutputFormat", "cpPosition", "cpPositionOffset", "cpCancelButton", "cpCancelButtonText", "cpOKButton", "colorPickerChange"], [1, "stroke-color-picker", "mat-typography"], ["svgIcon", "square-outline", 1, "stroke-palette-icon"], ["appearance", "outline", "floatLabel", "always", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "stroke-field", 3, "matTooltip"], ["formControlName", "stroke", "matInput", "", "type", "text", 3, "colorPicker", "readonly", "cpWidth", "cpPosition", "cpPositionOffset", "cpOutputFormat", "cpCancelButton", "cpCancelButtonText", "cpOKButton", "colorPickerChange"], [4, "ngIf"], ["class", "deleteBtn", "mat-icon-button", "", "color", "warn", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "disabled", "click", 4, "ngIf"], [1, "table-compact", 3, "store", "template"], ["table", ""], ["mat-icon-button", "", "color", "accent", "disableRipple", "true", 3, "click"], ["svgIcon", "keyboard-outline", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "shortcuts-icon", 3, "matTooltip"], ["class", "box", 4, "ngIf"], ["value", "", 3, "click"], [3, "value", "click", 4, "ngFor", "ngForOf"], [1, "box"], [3, "src"], [3, "value", "click"], ["mat-icon-button", "", "color", "warn", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "deleteBtn", 3, "matTooltip", "disabled", "click"], ["svgIcon", "delete"]], template: function DrawComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵelementStart(2, "mat-button-toggle-group", 1);
        i0.ɵɵlistener("change", function DrawComponent_Template_mat_button_toggle_group_change_2_listener($event) { return ctx.onGeometryTypeChange($event.value); });
        i0.ɵɵelementStart(3, "mat-button-toggle", 2);
        i0.ɵɵtext(4);
        i0.ɵɵpipe(5, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(6, "mat-button-toggle", 2);
        i0.ɵɵtext(7);
        i0.ɵɵpipe(8, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(9, "mat-button-toggle", 2);
        i0.ɵɵtext(10);
        i0.ɵɵpipe(11, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(12, "mat-button-toggle", 2);
        i0.ɵɵtext(13);
        i0.ɵɵpipe(14, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(15, "div", 3);
        i0.ɵɵelementStart(16, "mat-slide-toggle", 4);
        i0.ɵɵlistener("change", function DrawComponent_Template_mat_slide_toggle_change_16_listener($event) { return ctx.onToggleDrawControl($event.checked); });
        i0.ɵɵtext(17);
        i0.ɵɵpipe(18, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(19, "mat-slide-toggle", 5);
        i0.ɵɵlistener("change", function DrawComponent_Template_mat_slide_toggle_change_19_listener() { return ctx.onToggleLabels(); });
        i0.ɵɵtext(20);
        i0.ɵɵpipe(21, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(22, "form", 6);
        i0.ɵɵelementStart(23, "div", 7);
        i0.ɵɵelementStart(24, "span");
        i0.ɵɵelement(25, "mat-icon", 8);
        i0.ɵɵtext(26);
        i0.ɵɵpipe(27, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(28, "mat-form-field", 9);
        i0.ɵɵpipe(29, "translate");
        i0.ɵɵelementStart(30, "mat-label");
        i0.ɵɵtext(31);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(32, "input", 10);
        i0.ɵɵlistener("colorPickerChange", function DrawComponent_Template_input_colorPickerChange_32_listener($event) { return ctx.fillColor = $event; })("colorPickerChange", function DrawComponent_Template_input_colorPickerChange_32_listener() { return ctx.onColorChange(ctx.labelsAreShown, false); });
        i0.ɵɵpipe(33, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(34, "div", 11);
        i0.ɵɵelementStart(35, "span");
        i0.ɵɵelement(36, "mat-icon", 12);
        i0.ɵɵtext(37);
        i0.ɵɵpipe(38, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(39, "mat-form-field", 13);
        i0.ɵɵpipe(40, "translate");
        i0.ɵɵelementStart(41, "mat-label");
        i0.ɵɵtext(42);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(43, "input", 14);
        i0.ɵɵlistener("colorPickerChange", function DrawComponent_Template_input_colorPickerChange_43_listener($event) { return ctx.strokeColor = $event; })("colorPickerChange", function DrawComponent_Template_input_colorPickerChange_43_listener() { return ctx.onColorChange(ctx.labelsAreShown, false); });
        i0.ɵɵpipe(44, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(45, "div");
        i0.ɵɵtemplate(46, DrawComponent_mat_form_field_46_Template, 11, 8, "mat-form-field", 15);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelement(47, "mat-divider");
        i0.ɵɵelementStart(48, "div");
        i0.ɵɵtemplate(49, DrawComponent_button_49_Template, 4, 6, "button", 16);
        i0.ɵɵelement(50, "igo-entity-table", 17, 18);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(52, "button", 19);
        i0.ɵɵlistener("click", function DrawComponent_Template_button_click_52_listener() { return ctx.openShorcutsDialog(); });
        i0.ɵɵelement(53, "mat-icon", 20);
        i0.ɵɵpipe(54, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", ctx.geometryType.Point);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("value", ctx.geometryType.Point);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(5, 52, "igo.geo.draw." + ctx.geometryType.Point), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", ctx.geometryType.LineString);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(8, 54, "igo.geo.draw." + ctx.geometryType.LineString), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", ctx.geometryType.Polygon);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(11, 56, "igo.geo.draw." + ctx.geometryType.Polygon), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", ctx.geometryType.Circle);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(14, 58, "igo.geo.draw." + ctx.geometryType.Circle), " ");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("disabled", ctx.drawControlIsDisabled)("checked", ctx.drawControlIsActive)("labelPosition", "before");
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(18, 60, "igo.geo.spatialFilter.drawControl"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("checked", ctx.labelsAreShown)("labelPosition", "before");
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(21, 62, "igo.geo.draw.toggleMapTooltips"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("formGroup", ctx.form);
        i0.ɵɵadvance(4);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(27, 64, "igo.geo.draw.fill"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(29, 66, "igo.geo.draw.colorPicker"));
        i0.ɵɵadvance(3);
        i0.ɵɵtextInterpolate(ctx.fillColor);
        i0.ɵɵadvance(1);
        i0.ɵɵstyleProp("background", ctx.fillColor);
        i0.ɵɵproperty("colorPicker", ctx.fillColor)("readonly", true)("colorPicker", ctx.fillColor)("cpWidth", "200px")("cpOutputFormat", "rgba")("cpPosition", "bottom")("cpPositionOffset", "-75%")("cpCancelButton", true)("cpCancelButtonText", i0.ɵɵpipeBind1(33, 68, "igo.geo.draw.cancelColorPicker"))("cpOKButton", true);
        i0.ɵɵadvance(5);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(38, 70, "igo.geo.draw.stroke"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(40, 72, "igo.geo.draw.colorPicker"));
        i0.ɵɵadvance(3);
        i0.ɵɵtextInterpolate(ctx.strokeColor);
        i0.ɵɵadvance(1);
        i0.ɵɵstyleProp("background", ctx.strokeColor);
        i0.ɵɵproperty("colorPicker", ctx.strokeColor)("readonly", true)("colorPicker", ctx.strokeColor)("cpWidth", "200px")("cpPosition", "bottom")("cpPositionOffset", "-75%")("cpOutputFormat", "rgba")("cpCancelButton", true)("cpCancelButtonText", i0.ɵɵpipeBind1(44, 74, "igo.geo.draw.cancelColorPicker"))("cpOKButton", true);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.icons.length >= 1);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.store.count$.getValue() > 0);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("store", ctx.store)("template", ctx.tableTemplate);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(54, 76, "igo.geo.draw.shortcuts"));
    } }, directives: [i18.MatButtonToggleGroup, i18.MatButtonToggle, i22.MatSlideToggle, i16.ɵNgNoValidate, i16.NgControlStatusGroup, i16.FormGroupDirective, i4.MatIcon, i12.MatFormField, i3.MatTooltip, i12.MatLabel, i16.DefaultValueAccessor, i5$1.MatInput, i16.NgControlStatus, i16.FormControlName, i12$1.ColorPickerDirective, i1$1.NgIf, i10.MatDivider, i6.EntityTableComponent, i2.MatButton, i13.MatSelect, i13.MatSelectTrigger, i9.MatOption, i1$1.NgForOf], pipes: [i7.TranslatePipe, i1$1.AsyncPipe], styles: [".geometry-type-toggle[_ngcontent-%COMP%]{padding:10px;text-align:center}.geometry-type-toggle[_ngcontent-%COMP%]   mat-button-toggle-group[_ngcontent-%COMP%]{width:100%}.geometry-type-toggle[_ngcontent-%COMP%]   mat-button-toggle-group[_ngcontent-%COMP%]   mat-button-toggle[_ngcontent-%COMP%]{width:25%}.draw-options[_ngcontent-%COMP%]{overflow-x:hidden}.draw-options[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]{width:100%;margin:10px}.draw-options[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-content{width:calc(100% - 60px)}.igo-form[_ngcontent-%COMP%]{padding:10px}.fill-field[_ngcontent-%COMP%], .stroke-field[_ngcontent-%COMP%]{width:130px}.fill-color-picker[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{position:relative;top:7px}.fill-color-picker[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%]{left:8px}.stroke-color-picker[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{position:relative;top:7px}.stroke-color-picker[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%]{left:35px}.box[_ngcontent-%COMP%]{width:25px;height:25px}img[_ngcontent-%COMP%]{width:100%;height:100%}.deleteBtn[_ngcontent-%COMP%]{margin-left:12px}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DrawComponent, [{
        type: Component,
        args: [{
                selector: 'igo-draw',
                templateUrl: './draw.component.html',
                styleUrls: ['./draw.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i2$1.LanguageService }, { type: i16.FormBuilder }, { type: DrawStyleService }, { type: i1.MatDialog }, { type: DrawIconService }]; }, { fillColor: [{
            type: Output
        }], strokeColor: [{
            type: Output
        }], strokeWidth: [{
            type: Output
        }], map: [{
            type: Input
        }], store: [{
            type: Input
        }] }); })();

/**
 * @ignore
 */
class IgoDrawModule {
}
IgoDrawModule.ɵfac = function IgoDrawModule_Factory(t) { return new (t || IgoDrawModule)(); };
IgoDrawModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoDrawModule });
IgoDrawModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            FormsModule,
            ReactiveFormsModule,
            CommonModule,
            MatButtonModule,
            MatButtonToggleModule,
            MatDividerModule,
            MatFormFieldModule,
            MatIconModule,
            MatTooltipModule,
            MatFormFieldModule,
            MatInputModule,
            MatListModule,
            MatSelectModule,
            MatSlideToggleModule,
            MatDialogModule,
            IgoLanguageModule,
            IgoEntityTableModule,
            ColorPickerModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoDrawModule, [{
        type: NgModule,
        args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    CommonModule,
                    MatButtonModule,
                    MatButtonToggleModule,
                    MatDividerModule,
                    MatFormFieldModule,
                    MatIconModule,
                    MatTooltipModule,
                    MatFormFieldModule,
                    MatInputModule,
                    MatListModule,
                    MatSelectModule,
                    MatSlideToggleModule,
                    MatDialogModule,
                    IgoLanguageModule,
                    IgoEntityTableModule,
                    ColorPickerModule
                ],
                declarations: [
                    DrawComponent,
                    DrawPopupComponent,
                    DrawShorcutsComponent
                ],
                exports: [
                    DrawComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoDrawModule, { declarations: [DrawComponent,
        DrawPopupComponent,
        DrawShorcutsComponent], imports: [FormsModule,
        ReactiveFormsModule,
        CommonModule,
        MatButtonModule,
        MatButtonToggleModule,
        MatDividerModule,
        MatFormFieldModule,
        MatIconModule,
        MatTooltipModule,
        MatFormFieldModule,
        MatInputModule,
        MatListModule,
        MatSelectModule,
        MatSlideToggleModule,
        MatDialogModule,
        IgoLanguageModule,
        IgoEntityTableModule,
        ColorPickerModule], exports: [DrawComponent] }); })();

class IgoDrawingToolModule {
}
IgoDrawingToolModule.ɵfac = function IgoDrawingToolModule_Factory(t) { return new (t || IgoDrawingToolModule)(); };
IgoDrawingToolModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoDrawingToolModule });
IgoDrawingToolModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[], IgoDrawModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoDrawingToolModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [],
                exports: [
                    IgoDrawModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoDrawingToolModule, { exports: [IgoDrawModule] }); })();

class FeatureDetailsDirective {
    constructor(component, el) {
        this.el = el;
        this.geolocation$ = new BehaviorSubject(undefined);
        this.start = {
            meta: { id: 1 },
            type: FEATURE,
            geometry: {
                type: 'Point',
                coordinates: undefined
            },
            projection: 'EPSG:4326',
            properties: {
                id: 1,
                name: 'User coordinates',
            }
        };
        this.feature$ = new BehaviorSubject(undefined);
        this.routingEvent = new EventEmitter();
        this.component = component;
    }
    get map() {
        return this.component.map;
    }
    get feature() {
        return this.component.feature;
    }
    get geolocation() {
        return this.component.map.geolocation$.getValue();
    }
    set geolocation(value) {
        if (value) {
            this.geolocation = value;
            this.geolocation.on('change', evt => {
                this.geolocation$.next(this.geolocation);
            });
        }
    }
    setFeature() {
        this.feature$.next(this.feature);
    }
    ngOnInit() {
        this.map.geolocation$.subscribe(geolocation => {
            if (!geolocation) {
                return;
            }
            geolocation.setProjection(this.map.projection);
            if (geolocation && geolocation.getTracking() === false) {
                geolocation.setTracking(false);
            }
            if (geolocation.getTracking() === true) {
                let userCoord = geolocation.getPosition();
                userCoord = olproj.transform(userCoord, this.map.projection, 'EPSG:4326');
                this.start.geometry.coordinates = userCoord;
            }
        });
        this.feature$.subscribe(() => {
            if (this.feature.geometry) {
                if (this.feature.geometry.type === 'Point') {
                    this.end = this.feature;
                }
                else {
                    this.end = pointOnFeature(this.feature.geometry);
                }
                this.geolocation$.next(this.geolocation);
                this.bindClicking();
            }
        });
    }
    bindClicking() {
        setTimeout(() => {
            const routeElement = this.el.nativeElement.querySelector('span.routing');
            if (routeElement) {
                routeElement.addEventListener('click', () => {
                    this.activateRouting();
                });
            }
        }, 1);
    }
    activateRouting() {
        this.start.geometry.coordinates ? this.routingEvent.emit([this.start, this.end]) : this.routingEvent.emit([this.end]);
    }
}
FeatureDetailsDirective.ɵfac = function FeatureDetailsDirective_Factory(t) { return new (t || FeatureDetailsDirective)(i0.ɵɵdirectiveInject(FeatureDetailsComponent, 2), i0.ɵɵdirectiveInject(i0.ElementRef)); };
FeatureDetailsDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: FeatureDetailsDirective, selectors: [["", "igoFeatureDetailsDirective", ""]], hostBindings: function FeatureDetailsDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("selectFeature", function FeatureDetailsDirective_selectFeature_HostBindingHandler() { return ctx.setFeature(); });
    } }, outputs: { routingEvent: "routingEvent" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(FeatureDetailsDirective, [{
        type: Directive,
        args: [{
                // This directive allow to view the route between the user coordinates and the feature
                selector: '[igoFeatureDetailsDirective]'
            }]
    }], function () { return [{ type: FeatureDetailsComponent, decorators: [{
                type: Self
            }] }, { type: i0.ElementRef }]; }, { routingEvent: [{
            type: Output
        }], setFeature: [{
            type: HostListener,
            args: ['selectFeature']
        }] }); })();

/**
 * @ignore
 */
class IgoFeatureDetailsModule {
}
IgoFeatureDetailsModule.ɵfac = function IgoFeatureDetailsModule_Factory(t) { return new (t || IgoFeatureDetailsModule)(); };
IgoFeatureDetailsModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoFeatureDetailsModule });
IgoFeatureDetailsModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatIconModule,
            IgoLanguageModule,
            IgoKeyValueModule,
            IgoImageModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoFeatureDetailsModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatIconModule,
                    IgoLanguageModule,
                    IgoKeyValueModule,
                    IgoImageModule
                ],
                exports: [
                    FeatureDetailsComponent,
                    FeatureDetailsDirective
                ],
                declarations: [
                    FeatureDetailsComponent,
                    FeatureDetailsDirective
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoFeatureDetailsModule, { declarations: [FeatureDetailsComponent,
        FeatureDetailsDirective], imports: [CommonModule,
        MatIconModule,
        IgoLanguageModule,
        IgoKeyValueModule,
        IgoImageModule], exports: [FeatureDetailsComponent,
        FeatureDetailsDirective] }); })();

/**
 * @ignore
 */
class IgoFeatureFormModule {
}
IgoFeatureFormModule.ɵfac = function IgoFeatureFormModule_Factory(t) { return new (t || IgoFeatureFormModule)(); };
IgoFeatureFormModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoFeatureFormModule });
IgoFeatureFormModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            IgoFormModule
        ], IgoFormModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoFeatureFormModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    IgoFormModule
                ],
                exports: [
                    IgoFormModule,
                    FeatureFormComponent
                ],
                declarations: [
                    FeatureFormComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoFeatureFormModule, { declarations: [FeatureFormComponent], imports: [CommonModule,
        IgoFormModule], exports: [IgoFormModule,
        FeatureFormComponent] }); })();

class IgoFeatureModule {
}
IgoFeatureModule.ɵfac = function IgoFeatureModule_Factory(t) { return new (t || IgoFeatureModule)(); };
IgoFeatureModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoFeatureModule });
IgoFeatureModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [], imports: [[
            CommonModule
        ], IgoFeatureDetailsModule,
        IgoFeatureFormModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoFeatureModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    IgoFeatureDetailsModule,
                    IgoFeatureFormModule
                ],
                declarations: [],
                providers: []
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoFeatureModule, { imports: [CommonModule], exports: [IgoFeatureDetailsModule,
        IgoFeatureFormModule] }); })();

/**
 * Control to modify geometries
 */
class ModifyControl {
    constructor(options) {
        this.options = options;
        /**
         * Modify start observable
         */
        this.start$ = new Subject();
        /**
         * Modify end observable
         */
        this.end$ = new Subject();
        /**
         * Geometry changes observable
         */
        this.changes$ = new Subject();
        this.olModifyInteractionIsActive = false;
        this.olTranslateInteractionIsActive = false;
        this.olDrawInteractionIsActive = false;
        this.removedOlInteractions = [];
        /**
         * Whether a modify control should be available
         */
        this.modify = true;
        /**
         * Whether a translate control should be available
         */
        this.translate = true;
        if (options.modify !== undefined) {
            this.modify = options.modify;
        }
        if (options.translate !== undefined) {
            this.translate = options.translate;
        }
        if (options.layer !== undefined) {
            this.olOverlayLayer = options.layer;
        }
        else {
            this.olOverlayLayer = this.createOlInnerOverlayLayer();
        }
        this.olLinearRingsLayer = this.createOlLinearRingsLayer();
    }
    /**
     * Wheter the control is active
     */
    get active() {
        return this.olMap !== undefined;
    }
    /**
     * OL overlay source
     * @internal
     */
    get olOverlaySource() {
        return this.olOverlayLayer.getSource();
    }
    /**
     * OL linear rings source
     * @internal
     */
    get olLinearRingsSource() {
        return this.olLinearRingsLayer.getSource();
    }
    /**
     * Add or remove this control to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap) {
        if (olMap === undefined) {
            this.clearOlInnerOverlaySource();
            this.removeOlInnerOverlayLayer();
            this.removeOlModifyInteraction();
            this.removeOlTranslateInteraction();
            this.removeOlDrawInteraction();
            this.olMap = olMap;
            return;
        }
        this.olMap = olMap;
        this.addOlInnerOverlayLayer();
        // The order in which these interactions
        // are added is important
        if (this.modify === true) {
            this.addOlDrawInteraction();
        }
        if (this.translate === true) {
            this.addOlTranslateInteraction();
            this.activateTranslateInteraction();
        }
        if (this.modify === true) {
            this.addOlModifyInteraction();
            this.activateModifyInteraction();
        }
    }
    /**
     * Return the overlay source
     */
    getSource() {
        return this.olOverlaySource;
    }
    /**
     * Add an OL geometry to the overlay and start modifying it
     * @param olGeometry Ol Geometry
     */
    setOlGeometry(olGeometry) {
        const olFeature = new OlFeature({ geometry: olGeometry });
        this.olOverlaySource.clear();
        this.olOverlaySource.addFeature(olFeature);
    }
    /**
     * Create an overlay source if none is defined in the options
     */
    createOlInnerOverlayLayer() {
        return new OlVectorLayer({
            source: this.options.source ? this.options.source : new OlVectorSource(),
            style: this.options.layerStyle,
            zIndex: 500
        });
    }
    /**
     * Add the overlay layer if it wasn't defined in the options
     */
    addOlInnerOverlayLayer() {
        if (this.options.layer === undefined) {
            this.olMap.addLayer(this.olOverlayLayer);
        }
    }
    /**
     * Clear the overlay layer if it wasn't defined in the options
     */
    removeOlInnerOverlayLayer() {
        if (this.options.layer === undefined && this.olMap !== undefined) {
            this.olMap.removeLayer(this.olOverlayLayer);
        }
    }
    /**
     * Clear the overlay source if it wasn't defined in the options
     */
    clearOlInnerOverlaySource() {
        if (this.options.layer === undefined && this.options.source === undefined) {
            this.olOverlaySource.clear(true);
        }
    }
    createOlLinearRingsLayer() {
        return new OlVectorLayer({
            source: new OlVectorSource(),
            style: createDrawHoleInteractionStyle(),
            zIndex: 500
        });
    }
    /**
     * Add the linear rings layer
     */
    addOlLinearRingsLayer() {
        this.olMap.addLayer(this.olLinearRingsLayer);
    }
    /**
     * Clear the linear rings layer
     */
    removeOlLinearRingsLayer() {
        this.olMap.removeLayer(this.olLinearRingsLayer);
    }
    /**
     * Clear the linear rings source
     */
    clearOlLinearRingsSource() {
        this.olLinearRingsSource.clear(true);
    }
    /**
     * Add a modify interaction to the map an set up some listeners
     */
    addOlModifyInteraction() {
        const olModifyInteraction = new OlModify({
            source: this.olOverlaySource,
            style: this.options.drawStyle
        });
        this.olModifyInteraction = olModifyInteraction;
    }
    /**
     * Remove the modify interaction
     */
    removeOlModifyInteraction() {
        if (this.olModifyInteraction === undefined) {
            return;
        }
        this.deactivateModifyInteraction();
        this.olModifyInteraction = undefined;
    }
    activateModifyInteraction() {
        if (this.olModifyInteractionIsActive === true) {
            return;
        }
        this.olModifyInteractionIsActive = true;
        this.onModifyStartKey = this.olModifyInteraction.on('modifystart', (event) => this.onModifyStart(event));
        this.onModifyEndKey = this.olModifyInteraction.on('modifyend', (event) => this.onModifyEnd(event));
        this.olMap.addInteraction(this.olModifyInteraction);
    }
    deactivateModifyInteraction() {
        if (this.olModifyInteractionIsActive === false) {
            return;
        }
        this.olModifyInteractionIsActive = false;
        unByKey([this.onModifyStartKey, this.onModifyEndKey, this.onModifyKey]);
        if (this.olMap !== undefined) {
            this.olMap.removeInteraction(this.olModifyInteraction);
        }
    }
    /**
     * When modifying starts, clear the overlay and start watching for changes
     * @param event Modify start event
     */
    onModifyStart(event) {
        const olGeometry = event.features.item(0).getGeometry();
        this.start$.next(olGeometry);
        this.onModifyKey = olGeometry.on('change', (olGeometryEvent) => {
            this.mousePosition = getMousePositionFromOlGeometryEvent(olGeometryEvent);
            this.changes$.next(olGeometryEvent.target);
        });
        this.subscribeToKeyDown();
    }
    /**
     * When modifying ends, update the geometry observable and stop watching for changes
     * @param event Modify end event
     */
    onModifyEnd(event) {
        unByKey(this.onModifyKey);
        this.end$.next(event.features.item(0).getGeometry());
        this.unsubscribeToKeyDown();
    }
    /**
     * Subscribe to space key down to pan the map
     */
    subscribeToKeyDown() {
        this.keyDown$$ = fromEvent(document, 'keydown').subscribe((event) => {
            if (event.key === ' ') {
                // On space bar, pan to the current mouse position
                this.olMap.getView().animate({
                    center: this.mousePosition,
                    duration: 0
                });
                return;
            }
        });
    }
    /**
     * Unsubscribe to key down
     */
    unsubscribeToKeyDown() {
        if (this.keyDown$$ !== undefined) {
            this.keyDown$$.unsubscribe();
        }
    }
    /**
     * Add a translate interaction to the map an set up some listeners
     */
    addOlTranslateInteraction() {
        const olTranslateInteraction = new OlTranslate({
            layers: [this.olOverlayLayer]
        });
        this.olTranslateInteraction = olTranslateInteraction;
    }
    /**
     * Remove the translate interaction
     */
    removeOlTranslateInteraction() {
        if (this.olTranslateInteraction === undefined) {
            return;
        }
        this.deactivateTranslateInteraction();
        this.olTranslateInteraction = undefined;
    }
    activateTranslateInteraction() {
        if (this.olTranslateInteractionIsActive === true) {
            return;
        }
        this.olTranslateInteractionIsActive = true;
        this.onTranslateStartKey = this.olTranslateInteraction.on('translatestart', (event) => this.onTranslateStart(event));
        this.onTranslateEndKey = this.olTranslateInteraction.on('translateend', (event) => this.onTranslateEnd(event));
        this.olMap.addInteraction(this.olTranslateInteraction);
    }
    deactivateTranslateInteraction() {
        if (this.olTranslateInteractionIsActive === false) {
            return;
        }
        this.olTranslateInteractionIsActive = false;
        unByKey([
            this.onTranslateStartKey,
            this.onTranslateEndKey,
            this.onTranslateKey
        ]);
        if (this.olMap !== undefined) {
            this.olMap.removeInteraction(this.olTranslateInteraction);
        }
    }
    /**
     * When translation starts, clear the overlay and start watching for changes
     * @param event Translate start event
     */
    onTranslateStart(event) {
        const olGeometry = event.features.item(0).getGeometry();
        this.start$.next(olGeometry);
        this.onTranslateKey = olGeometry.on('change', (olGeometryEvent) => {
            // this.changes$.next(olGeometryEvent.target);
        });
    }
    /**
     * When translation ends, update the geometry observable and stop watchign for changes
     * @param event Translate end event
     */
    onTranslateEnd(event) {
        unByKey(this.onTranslateKey);
        this.end$.next(event.features.item(0).getGeometry());
    }
    /**
     * Add a draw interaction to the map an set up some listeners
     */
    addOlDrawInteraction() {
        const olDrawInteraction = new OlDraw({
            type: 'Polygon',
            source: this.olLinearRingsSource,
            stopClick: true,
            style: createDrawHoleInteractionStyle(),
            condition: (event) => {
                const olOuterGeometry = this.olOuterGeometry || this.getOlGeometry();
                const intersects = olOuterGeometry.intersectsCoordinate(event.coordinate);
                return intersects;
            }
        });
        this.olDrawInteraction = olDrawInteraction;
        this.subscribeToDrawKeyDown();
    }
    /**
     * Subscribe to CTRL key down to activate the draw control
     */
    subscribeToDrawKeyDown() {
        this.drawKeyDown$$ = fromEvent(document, 'keydown').subscribe((event) => {
            if (event.key !== 'Control') {
                return;
            }
            this.unsubscribeToDrawKeyDown();
            const olGeometry = this.getOlGeometry();
            if (!olGeometry || !(olGeometry instanceof OlPolygon)) {
                return;
            }
            this.subscribeToDrawKeyUp();
            this.deactivateModifyInteraction();
            this.deactivateTranslateInteraction();
            this.activateDrawInteraction();
        });
    }
    /**
     * Subscribe to CTRL key up to deactivate the draw control
     */
    subscribeToDrawKeyUp() {
        this.drawKeyUp$$ = fromEvent(document, 'keyup').subscribe((event) => {
            if (event.key !== 'Control') {
                return;
            }
            this.unsubscribeToDrawKeyUp();
            this.unsubscribeToKeyDown();
            this.deactivateDrawInteraction();
            this.activateModifyInteraction();
            if (this.translate === true) {
                this.activateTranslateInteraction();
            }
            this.subscribeToDrawKeyDown();
            this.olOuterGeometry = undefined;
            this.clearOlLinearRingsSource();
            this.end$.next(this.getOlGeometry());
        });
    }
    /**
     * Unsubscribe to draw key down
     */
    unsubscribeToDrawKeyDown() {
        if (this.drawKeyDown$$ !== undefined) {
            this.drawKeyDown$$.unsubscribe();
        }
    }
    /**
     * Unsubscribe to key up
     */
    unsubscribeToDrawKeyUp() {
        if (this.drawKeyUp$$ !== undefined) {
            this.drawKeyUp$$.unsubscribe();
        }
    }
    /**
     * Remove the draw interaction
     */
    removeOlDrawInteraction() {
        if (this.olDrawInteraction === undefined) {
            return;
        }
        this.unsubscribeToKeyDown();
        this.unsubscribeToDrawKeyUp();
        this.unsubscribeToDrawKeyDown();
        this.deactivateDrawInteraction();
        this.clearOlLinearRingsSource();
        this.olDrawInteraction = undefined;
    }
    /**
     * Activate the draw interaction
     */
    activateDrawInteraction() {
        if (this.olDrawInteractionIsActive === true) {
            return;
        }
        this.clearOlLinearRingsSource();
        this.addOlLinearRingsLayer();
        this.olMap.getInteractions().forEach((olInteraction) => {
            if (olInteraction instanceof OlDragBoxInteraction) {
                this.olMap.removeInteraction(olInteraction);
                this.removedOlInteractions.push(olInteraction);
            }
        });
        this.olDrawInteractionIsActive = true;
        this.onDrawStartKey = this.olDrawInteraction.on('drawstart', (event) => this.onDrawStart(event));
        this.onDrawEndKey = this.olDrawInteraction.on('drawend', (event) => this.onDrawEnd(event));
        this.olMap.addInteraction(this.olDrawInteraction);
    }
    /**
     * Deactivate the draw interaction
     */
    deactivateDrawInteraction() {
        if (this.olDrawInteractionIsActive === false) {
            return;
        }
        this.removeOlLinearRingsLayer();
        this.removedOlInteractions.forEach((olInteraction) => {
            this.olMap.addInteraction(olInteraction);
        });
        this.removedOlInteractions = [];
        this.olDrawInteractionIsActive = false;
        unByKey([this.onDrawStartKey, this.onDrawEndKey, this.onDrawKey]);
        if (this.olMap !== undefined) {
            this.olMap.removeInteraction(this.olDrawInteraction);
        }
    }
    /**
     * When draw start, add a new linerar ring to the geometry and start watching for changes
     * @param event Draw start event
     */
    onDrawStart(event) {
        const olGeometry = event.feature.getGeometry();
        this.olOuterGeometry = this.getOlGeometry().clone();
        const linearRingCoordinates = olGeometry.getLinearRing().getCoordinates();
        this.addLinearRingToOlGeometry(linearRingCoordinates);
        this.start$.next(this.getOlGeometry());
        this.onDrawKey = olGeometry.on('change', (olGeometryEvent) => {
            this.mousePosition = getMousePositionFromOlGeometryEvent(olGeometryEvent);
            const olGeometryTarget = olGeometryEvent.target;
            const _linearRingCoordinates = olGeometryTarget
                .getLinearRing(0)
                .getCoordinates();
            this.updateLinearRingOfOlGeometry(_linearRingCoordinates);
            this.changes$.next(this.getOlGeometry());
        });
        this.subscribeToKeyDown();
    }
    /**
     * When translation ends, update the geometry observable and stop watchign for changes
     * @param event Draw end event
     */
    onDrawEnd(event) {
        unByKey(this.onDrawKey);
        this.olOuterGeometry = undefined;
        const linearRingCoordinates = event.feature
            .getGeometry()
            .getLinearRing()
            .getCoordinates();
        this.updateLinearRingOfOlGeometry(linearRingCoordinates);
        this.clearOlLinearRingsSource();
        this.end$.next(this.getOlGeometry());
        this.unsubscribeToKeyDown();
    }
    /**
     * Add a linear ring to the geometry being modified
     * @param coordinates Linear ring coordinates
     */
    addLinearRingToOlGeometry(coordinates) {
        const olGeometry = this.getOlGeometry();
        const olLinearRing = new OlLinearRing(coordinates);
        addLinearRingToOlPolygon(olGeometry, olLinearRing);
    }
    /**
     * Update the last linear ring of the geometry being modified
     * @param coordinates Linear ring coordinates
     */
    updateLinearRingOfOlGeometry(coordinates) {
        const olGeometry = this.getOlGeometry();
        // Remove the last linear ring (the one we are updating)
        const olLinearRings = olGeometry.getLinearRings().slice(0, -1);
        const newCoordinates = olLinearRings.map((olLinearRing) => {
            return olLinearRing.getCoordinates();
        });
        newCoordinates.push(coordinates);
        olGeometry.setCoordinates(newCoordinates);
    }
    /**
     * Get the geometry being modified
     * @returns OL Geometry
     */
    getOlGeometry() {
        const olFeatures = this.olOverlaySource.getFeatures();
        return olFeatures.length > 0 ? olFeatures[0].getGeometry() : undefined;
    }
}

/**
 * Control to modify geometries
 */
class SliceControl {
    constructor(options) {
        this.options = options;
        /**
         * Slice end observable
         */
        this.end$ = new Subject();
        /**
         * Slice error, if any
         */
        this.error$ = new Subject();
        if (options.layer !== undefined) {
            this.olOverlayLayer = options.layer;
        }
        else {
            this.olOverlayLayer = this.createOlInnerOverlayLayer();
        }
    }
    /**
     * Wheter the control is active
     */
    get active() {
        return this.olMap !== undefined;
    }
    /**
     * OL overlay source
     * @internal
     */
    get olOverlaySource() {
        return this.olOverlayLayer.getSource();
    }
    /**
     * Add or remove this control to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap) {
        if (olMap === undefined) {
            this.clearOlInnerOverlaySource();
            this.removeOlInnerOverlayLayer();
            this.removeDrawLineControl();
            this.olMap = olMap;
            return;
        }
        this.olMap = olMap;
        this.addOlInnerOverlayLayer();
        this.addDrawLineControl();
    }
    /**
     * Return the overlay source
     */
    getSource() {
        return this.olOverlaySource;
    }
    /**
     * Add an OL geometry to the overlay for slicing
     * @param olGeometry Ol Geometry
     */
    setOlGeometry(olGeometry) {
        const olFeature = new OlFeature({ geometry: olGeometry });
        this.olOverlaySource.clear(true);
        this.olOverlaySource.addFeature(olFeature);
    }
    /**
     * Create an overlay source if none is defined in the options
     */
    createOlInnerOverlayLayer() {
        return new OlVectorLayer({
            source: this.options.source ? this.options.source : new OlVectorSource(),
            style: this.options.layerStyle,
            zIndex: 500
        });
    }
    /**
     * Clear the overlay layer if it wasn't defined in the options
     */
    removeOlInnerOverlayLayer() {
        if (this.options.layer === undefined && this.olMap !== undefined) {
            this.olMap.removeLayer(this.olOverlayLayer);
        }
    }
    /**
     * Add the overlay layer if it wasn't defined in the options
     */
    addOlInnerOverlayLayer() {
        if (this.options.layer === undefined) {
            this.olMap.addLayer(this.olOverlayLayer);
        }
    }
    /**
     * Clear the overlay source if it wasn't defined in the options
     */
    clearOlInnerOverlaySource() {
        if (this.options.layer === undefined && this.options.source === undefined) {
            this.olOverlaySource.clear(true);
        }
    }
    /**
     * Create a draw line control and add it to the map
     */
    addDrawLineControl() {
        this.drawLineControl = new DrawControl({
            geometryType: 'LineString',
            interactionStyle: this.options.drawStyle,
            maxPoints: 2
        });
        this.drawLineStart$$ = this.drawLineControl.start$
            .subscribe((olLine) => this.onDrawLineStart(olLine));
        this.drawLineEnd$$ = this.drawLineControl.end$
            .subscribe((olLine) => this.onDrawLineEnd(olLine));
        this.drawLineControl.setOlMap(this.olMap);
    }
    /**
     * Remove draw line control
     */
    removeDrawLineControl() {
        if (this.drawLineControl === undefined) {
            return;
        }
        this.drawLineStart$$.unsubscribe();
        this.drawLineEnd$$.unsubscribe();
        this.drawLineControl.getSource().clear(true);
        this.drawLineControl.setOlMap(undefined);
    }
    /**
     * Clear the draw source and track the geometry being draw
     * @param olLine Ol linestring or polygon
     */
    onDrawLineStart(olLine) {
        this.drawLineControl.getSource().clear(true);
    }
    /**
     * Slice the first geometry encountered with the drawn line
     * @param olLine Ol linestring
     */
    onDrawLineEnd(olLine) {
        const olSlicedGeometries = [];
        const lineExtent = olLine.getExtent();
        const olFeaturesToRemove = [];
        try {
            this.olOverlaySource.forEachFeatureInExtent(lineExtent, (olFeature) => {
                const olGeometry = olFeature.getGeometry();
                const olParts = sliceOlGeometry(olGeometry, olLine);
                if (olParts.length > 0) {
                    olSlicedGeometries.push(...olParts);
                    olFeaturesToRemove.push(olFeature);
                }
            });
        }
        catch (e) {
            if (e instanceof GeometrySliceError) {
                this.error$.next(e);
                return;
            }
            else {
                throw e;
            }
        }
        this.drawLineControl.getSource().clear(true);
        this.olOverlaySource.addFeatures(olSlicedGeometries.map((olGeometry) => new OlFeature(olGeometry)));
        olFeaturesToRemove.forEach((olFeature) => {
            this.olOverlaySource.removeFeature(olFeature);
        });
        this.error$.next(undefined);
        this.end$.next(olSlicedGeometries);
    }
}

const LAYER = 'Layer';

var LayerListToolControlsEnum;
(function (LayerListToolControlsEnum) {
    LayerListToolControlsEnum["always"] = "always";
    LayerListToolControlsEnum["never"] = "never";
    LayerListToolControlsEnum["default"] = "default";
})(LayerListToolControlsEnum || (LayerListToolControlsEnum = {}));

function MeasurerDialogComponent_table_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "table", 2);
    i0.ɵɵelementStart(1, "thead");
    i0.ɵɵelementStart(2, "tr");
    i0.ɵɵelementStart(3, "th", 3);
    i0.ɵɵtext(4);
    i0.ɵɵpipe(5, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(6, "tbody");
    i0.ɵɵelementStart(7, "tr");
    i0.ɵɵelementStart(8, "td");
    i0.ɵɵtext(9);
    i0.ɵɵpipe(10, "measureFormat");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(11, "td");
    i0.ɵɵtext(12);
    i0.ɵɵpipe(13, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(14, "tr");
    i0.ɵɵelementStart(15, "td");
    i0.ɵɵtext(16);
    i0.ɵɵpipe(17, "measureFormat");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(18, "td");
    i0.ɵɵtext(19);
    i0.ɵɵpipe(20, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(21, "tr");
    i0.ɵɵelementStart(22, "td");
    i0.ɵɵtext(23);
    i0.ɵɵpipe(24, "measureFormat");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(25, "td");
    i0.ɵɵtext(26);
    i0.ɵɵpipe(27, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(28, "tr");
    i0.ɵɵelementStart(29, "td");
    i0.ɵɵtext(30);
    i0.ɵɵpipe(31, "measureFormat");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(32, "td");
    i0.ɵɵtext(33);
    i0.ɵɵpipe(34, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(5, 9, "igo.geo.measure.dialog.length.title"));
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(10, 11, ctx_r0.data.length, ctx_r0.measureLengthUnit.Meters));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(13, 14, "igo.geo.measure.dialog.lengthInMeters"));
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(17, 16, ctx_r0.data.length, ctx_r0.measureLengthUnit.Kilometers));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(20, 19, "igo.geo.measure.dialog.lengthInKilometers"));
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(24, 21, ctx_r0.data.length, ctx_r0.measureLengthUnit.Miles));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(27, 24, "igo.geo.measure.dialog.lengthInMiles"));
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(31, 26, ctx_r0.data.length, ctx_r0.measureLengthUnit.Feet));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(34, 29, "igo.geo.measure.dialog.lengthInFeet"));
} }
function MeasurerDialogComponent_table_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "table", 2);
    i0.ɵɵelementStart(1, "thead");
    i0.ɵɵelementStart(2, "tr");
    i0.ɵɵelementStart(3, "th", 3);
    i0.ɵɵtext(4);
    i0.ɵɵpipe(5, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(6, "tbody");
    i0.ɵɵelementStart(7, "tr");
    i0.ɵɵelementStart(8, "td");
    i0.ɵɵtext(9);
    i0.ɵɵpipe(10, "measureFormat");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(11, "td");
    i0.ɵɵtext(12);
    i0.ɵɵpipe(13, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(14, "tr");
    i0.ɵɵelementStart(15, "td");
    i0.ɵɵtext(16);
    i0.ɵɵpipe(17, "measureFormat");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(18, "td");
    i0.ɵɵtext(19);
    i0.ɵɵpipe(20, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(21, "tr");
    i0.ɵɵelementStart(22, "td");
    i0.ɵɵtext(23);
    i0.ɵɵpipe(24, "measureFormat");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(25, "td");
    i0.ɵɵtext(26);
    i0.ɵɵpipe(27, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(28, "tr");
    i0.ɵɵelementStart(29, "td");
    i0.ɵɵtext(30);
    i0.ɵɵpipe(31, "measureFormat");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(32, "td");
    i0.ɵɵtext(33);
    i0.ɵɵpipe(34, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(35, "tr");
    i0.ɵɵelementStart(36, "td");
    i0.ɵɵtext(37);
    i0.ɵɵpipe(38, "measureFormat");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(39, "td");
    i0.ɵɵtext(40);
    i0.ɵɵpipe(41, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(42, "tr");
    i0.ɵɵelementStart(43, "td");
    i0.ɵɵtext(44);
    i0.ɵɵpipe(45, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(46, "td");
    i0.ɵɵtext(47);
    i0.ɵɵpipe(48, "measureFormat");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(5, 13, "igo.geo.measure.dialog.area.title"));
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(10, 15, ctx_r1.data.area, ctx_r1.measureAreaUnit.SquareMeters));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(13, 18, "igo.geo.measure.dialog.areaInSquareMeters"));
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(17, 20, ctx_r1.data.area, ctx_r1.measureAreaUnit.SquareKilometers));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(20, 23, "igo.geo.measure.dialog.areaInSquareKilometers"));
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(24, 25, ctx_r1.data.area, ctx_r1.measureAreaUnit.SquareMiles));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(27, 28, "igo.geo.measure.dialog.areaInSquareMiles"));
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(31, 30, ctx_r1.data.area, ctx_r1.measureAreaUnit.Acres));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(34, 33, "igo.geo.measure.dialog.areaInAcres"));
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(38, 35, ctx_r1.data.area, ctx_r1.measureAreaUnit.Hectares));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(41, 38, "igo.geo.measure.dialog.areaInHectares"));
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(45, 40, "igo.geo.measure.dialog.perimeterInMeters"));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(48, 42, ctx_r1.data.perimeter, ctx_r1.measureLengthUnit.Meters));
} }
class MeasurerDialogComponent {
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
        this.measureAreaUnit = MeasureAreaUnit;
        this.measureLengthUnit = MeasureLengthUnit;
    }
    onNoClick() {
        this.dialogRef.close();
    }
}
MeasurerDialogComponent.ɵfac = function MeasurerDialogComponent_Factory(t) { return new (t || MeasurerDialogComponent)(i0.ɵɵdirectiveInject(i1.MatDialogRef), i0.ɵɵdirectiveInject(MAT_DIALOG_DATA)); };
MeasurerDialogComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MeasurerDialogComponent, selectors: [["igo-measurer-dialog"]], decls: 5, vars: 5, consts: [["mat-dialog-title", ""], ["class", "mat-typography", 4, "ngIf"], [1, "mat-typography"], ["colspan", "2"]], template: function MeasurerDialogComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "h3", 0);
        i0.ɵɵtext(1);
        i0.ɵɵpipe(2, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(3, MeasurerDialogComponent_table_3_Template, 35, 31, "table", 1);
        i0.ɵɵtemplate(4, MeasurerDialogComponent_table_4_Template, 49, 45, "table", 1);
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(2, 3, "igo.geo.measure.dialog.title"));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.data.length > 0);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.data.area > 0);
    } }, styles: ["[_nghost-%COMP%]{font-family:Roboto,\"Helvetica Neue\",sans-serif}h3[_ngcontent-%COMP%]{text-align:center;margin:0}table[_ngcontent-%COMP%]{width:100%;padding:10px}table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]:last-child{padding-left:10px}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MeasurerDialogComponent, [{
        type: Component,
        args: [{
                selector: 'igo-measurer-dialog',
                templateUrl: 'measurer-dialog.component.html',
                styleUrls: ['./measurer-dialog.component.scss']
            }]
    }], function () { return [{ type: i1.MatDialogRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_DIALOG_DATA]
            }] }]; }, null); })();

const _c0$a = ["table"];
function MeasurerComponent_mat_divider_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-divider");
} }
function MeasurerComponent_mat_slide_toggle_15_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-slide-toggle", 7);
    i0.ɵɵlistener("change", function MeasurerComponent_mat_slide_toggle_15_Template_mat_slide_toggle_change_0_listener($event) { i0.ɵɵrestoreView(_r12); const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.onToggleDisplayLines($event.checked); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("checked", ctx_r1.displayLines)("labelPosition", "before");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 3, "igo.geo.measure.toggleDisplayLines"), " ");
} }
function MeasurerComponent_mat_divider_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-divider");
} }
function MeasurerComponent_mat_slide_toggle_20_Template(rf, ctx) { if (rf & 1) {
    const _r14 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-slide-toggle", 7);
    i0.ɵɵlistener("change", function MeasurerComponent_mat_slide_toggle_20_Template_mat_slide_toggle_change_0_listener($event) { i0.ɵɵrestoreView(_r14); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.onToggleDisplayDistance($event.checked); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("checked", ctx_r3.displayDistance)("labelPosition", "before");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 3, "igo.geo.measure.toggleDisplayDistance"), " ");
} }
function MeasurerComponent_mat_slide_toggle_22_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-slide-toggle", 7);
    i0.ɵɵlistener("change", function MeasurerComponent_mat_slide_toggle_22_Template_mat_slide_toggle_change_0_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.onToggleDisplayAreas($event.checked); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("checked", ctx_r4.displayAreas)("labelPosition", "before");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 3, "igo.geo.measure.toggleDisplayAreas"), " ");
} }
function MeasurerComponent_mat_divider_24_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-divider");
} }
function MeasurerComponent_ng_container_29_igo_measurer_item_1_Template(rf, ctx) { if (rf & 1) {
    const _r21 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-measurer-item", 14);
    i0.ɵɵlistener("measureUnitChange", function MeasurerComponent_ng_container_29_igo_measurer_item_1_Template_igo_measurer_item_measureUnitChange_0_listener($event) { i0.ɵɵrestoreView(_r21); const ctx_r20 = i0.ɵɵnextContext(2); return ctx_r20.onLengthUnitChange($event); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const measure_r17 = i0.ɵɵnextContext().ngIf;
    const ctx_r18 = i0.ɵɵnextContext();
    i0.ɵɵproperty("measureType", ctx_r18.measureType.Length)("measureUnit", ctx_r18.measureLengthUnit.Meters)("measure", measure_r17.length)("auto", ctx_r18.measureUnitsAuto)("placeholder", i0.ɵɵpipeBind1(1, 5, ctx_r18.activeMeasureType === ctx_r18.measureType.Area ? "igo.geo.measure.perimeter" : "igo.geo.measure.length"));
} }
function MeasurerComponent_ng_container_29_igo_measurer_item_2_Template(rf, ctx) { if (rf & 1) {
    const _r24 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-measurer-item", 14);
    i0.ɵɵlistener("measureUnitChange", function MeasurerComponent_ng_container_29_igo_measurer_item_2_Template_igo_measurer_item_measureUnitChange_0_listener($event) { i0.ɵɵrestoreView(_r24); const ctx_r23 = i0.ɵɵnextContext(2); return ctx_r23.onAreaUnitChange($event); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const measure_r17 = i0.ɵɵnextContext().ngIf;
    const ctx_r19 = i0.ɵɵnextContext();
    i0.ɵɵproperty("measureType", ctx_r19.measureType.Area)("measureUnit", ctx_r19.measureAreaUnit.SquareMeters)("measure", measure_r17.area)("auto", ctx_r19.measureUnitsAuto)("placeholder", i0.ɵɵpipeBind1(1, 5, "igo.geo.measure.area"));
} }
function MeasurerComponent_ng_container_29_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, MeasurerComponent_ng_container_29_igo_measurer_item_1_Template, 2, 7, "igo-measurer-item", 13);
    i0.ɵɵtemplate(2, MeasurerComponent_ng_container_29_igo_measurer_item_2_Template, 2, 7, "igo-measurer-item", 13);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r6.activeMeasureType === ctx_r6.measureType.Length || ctx_r6.activeMeasureType === ctx_r6.measureType.Area);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r6.activeMeasureType === ctx_r6.measureType.Area);
} }
function MeasurerComponent_mat_divider_31_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-divider");
} }
function MeasurerComponent_button_35_Template(rf, ctx) { if (rf & 1) {
    const _r27 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 15);
    i0.ɵɵlistener("click", function MeasurerComponent_button_35_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r27); const ctx_r26 = i0.ɵɵnextContext(); return ctx_r26.onCalculateClick(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelement(3, "mat-icon", 16);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 2, "igo.geo.measure.actionbar.calculate.tooltip"))("disabled", i0.ɵɵpipeBind1(2, 4, ctx_r8.selectedFeatures$).length === 0);
} }
function MeasurerComponent_button_38_Template(rf, ctx) { if (rf & 1) {
    const _r29 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 17);
    i0.ɵɵlistener("click", function MeasurerComponent_button_38_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r29); const ctx_r28 = i0.ɵɵnextContext(); return ctx_r28.onDeleteClick(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelement(3, "mat-icon", 18);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 2, "igo.geo.measure.actionbar.delete.tooltip"))("disabled", i0.ɵɵpipeBind1(2, 4, ctx_r9.selectedFeatures$).length === 0);
} }
/**
 * Tool to measure lengths and areas
 */
class MeasurerComponent {
    constructor(languageService, dialog, storageService) {
        this.languageService = languageService;
        this.dialog = dialog;
        this.storageService = storageService;
        /**
         * Table template
         * @internal
         */
        this.tableTemplate = {
            selection: true,
            selectMany: true,
            selectionCheckbox: true,
            sort: true,
            columns: [
                {
                    name: 'length',
                    title: this.languageService.translate.instant('igo.geo.measure.lengthHeader'),
                    valueAccessor: (localFeature) => {
                        const unit = this.activeLengthUnit;
                        const measure = metersToUnit(localFeature.properties.measure.length, unit);
                        return formatMeasure(measure, {
                            decimal: 1,
                            unit,
                            unitAbbr: false,
                            locale: 'fr'
                        });
                    }
                },
                {
                    name: 'area',
                    title: this.languageService.translate.instant('igo.geo.measure.areaHeader'),
                    valueAccessor: (localFeature) => {
                        const unit = this.activeAreaUnit;
                        const measure = squareMetersToUnit(localFeature.properties.measure.area, unit);
                        return measure ? formatMeasure(measure, {
                            decimal: 1,
                            unit,
                            unitAbbr: false,
                            locale: 'fr'
                        }) : '';
                    }
                }
            ]
        };
        this.subscriptions$$ = [];
        /**
         * Reference to the MeasureType enum
         * @internal
         */
        this.measureType = MeasureType;
        /**
         * Reference to the AreaMeasureUnit enum
         * @internal
         */
        this.measureAreaUnit = MeasureAreaUnit;
        /**
         * Reference to the LengthMeasureUnit enum
         * @internal
         */
        this.measureLengthUnit = MeasureLengthUnit;
        /**
         * Whether measure units should be automatically determined
         * @internal
         */
        this.measureUnitsAuto = false;
        /**
         * Whether display of distances of areas
         * @internal
         */
        this.displayDistance = true;
        /**
         * Whether display of distances of lines
         * @internal
         */
        this.displayLines = true;
        /**
         * Whether display of areas
         * @internal
         */
        this.displayAreas = true;
        /**
         * Observable of line boolean
         * @internal
         */
        this.hasLine$ = new BehaviorSubject(false);
        /**
         * Observable of area boolean
         * @internal
         */
        this.hasArea$ = new BehaviorSubject(false);
        /**
         * Observable of area
         * @internal
         */
        this.measure$ = new BehaviorSubject({});
        /**
         * Observable of selected features
         * @internal
         */
        this.selectedFeatures$ = new BehaviorSubject([]);
        /**
         * OL draw source
         * @internal
         */
        this.showTooltips = true;
        /**
         * Whether draw control toggle is disabled or not
         * @internal
         */
        this.drawControlIsDisabled = true;
        /**
         * Active mlength unit
         */
        this.activeLengthUnit = MeasureLengthUnit.Meters;
        /**
         * Active area unit
         */
        this.activeAreaUnit = MeasureAreaUnit.SquareMeters;
        /**
         * OL draw source
         */
        this.olDrawSource = new OlVectorSource();
        /**
         * The minimum length a segment must have to display a tooltip.
         * It also applies to area tooltips.
         */
        this.minSegmentLength = 10;
    }
    /**
     * Measure type
     * @internal
     */
    set activeMeasureType(value) { this.setActiveMeasureType(value); }
    get activeMeasureType() { return this._activeMeasureType; }
    /**
     * Wheter one of the draw control is active
     * @internal
     */
    get drawControlIsActive() {
        return this.activeDrawControl !== undefined;
    }
    get projection() {
        return this.map.ol.getView().getProjection().getCode();
    }
    /**
     * Add draw controls and activate one
     * @internal
     */
    ngOnInit() {
        this.initStore();
        this.createDrawLineControl();
        this.createDrawPolygonControl();
        this.createModifyControl();
        this.toggleDrawControl();
        this.updateTooltipsOfOlSource(this.store.source.ol);
        this.checkDistanceAreaToggle();
        this.setActiveMeasureType(MeasureType.Length);
    }
    /**
     * Clear the overlay layer and any interaction added by this component.
     * @internal
     */
    ngOnDestroy() {
        this.setActiveMeasureType(undefined);
        this.deactivateModifyControl();
        this.freezeStore();
        this.subscriptions$$.map(s => s.unsubscribe());
    }
    /**
     * Set the measure type
     * @internal
     */
    onMeasureTypeChange(measureType) {
        this.activeMeasureType = measureType;
    }
    /**
     * Activate or deactivate the current draw control
     * @internal
     */
    onToggleDrawControl(toggle) {
        if (toggle === true) {
            this.toggleDrawControl();
        }
        else {
            this.deactivateDrawControl();
        }
    }
    /**
     * Activate or deactivate the current draw control
     * @internal
     */
    onToggleMeasureUnitsAuto(toggle) {
        this.measureUnitsAuto = toggle;
    }
    /**
     * Activate or deactivate the current display of distances of the areas
     * @internal
     */
    onToggleDisplayDistance(toggle) {
        this.displayDistance = toggle;
        this.onDisplayDistance();
        toggle ? (this.storageService.set('distanceToggle', true, StorageScope.SESSION)) :
            (this.storageService.set('distanceToggle', false, StorageScope.SESSION));
    }
    /**
     * Activate or deactivate the current display of distances of the lines
     * @internal
     */
    onToggleDisplayLines(toggle) {
        this.displayLines = toggle;
        this.onDisplayLines();
        toggle ? (this.storageService.set('linesToggle', true, StorageScope.SESSION)) :
            (this.storageService.set('linesToggle', false, StorageScope.SESSION));
    }
    /**
     * Activate or deactivate the current display of areas
     * @internal
     */
    onToggleDisplayAreas(toggle) {
        this.displayAreas = toggle;
        this.onDisplayAreas();
        toggle ? (this.storageService.set('areasToggle', true, StorageScope.SESSION)) :
            (this.storageService.set('areasToggle', false, StorageScope.SESSION));
    }
    /**
     * Set display parametres in current values
     * @internal
     */
    checkDistanceAreaToggle() {
        if (this.storageService.get('distanceToggle') === false) {
            this.displayDistance = false;
        }
        if (this.storageService.get('linesToggle') === false) {
            this.displayLines = false;
        }
        if (this.storageService.get('areasToggle') === false) {
            this.displayAreas = false;
        }
    }
    /**
     * Activate or deactivate the current display of distances of areas
     * @internal
     */
    onDisplayDistance() {
        if (this.displayDistance) {
            Array.from(document.getElementsByClassName('igo-map-tooltip-measure-polygone-segments')).map((value) => value.classList.remove('igo-map-tooltip-hidden'));
        }
        else {
            Array.from(document.getElementsByClassName('igo-map-tooltip-measure-polygone-segments')).map((value) => value.classList.add('igo-map-tooltip-hidden'));
        }
    }
    /**
     * Activate or deactivate the current display of distances of lines
     * @internal
     */
    onDisplayLines() {
        if (this.displayLines) {
            Array.from(document.getElementsByClassName('igo-map-tooltip-measure-line-segments')).map((value) => value.classList.remove('igo-map-tooltip-hidden'));
        }
        else {
            Array.from(document.getElementsByClassName('igo-map-tooltip-measure-line-segments')).map((value) => value.classList.add('igo-map-tooltip-hidden'));
        }
    }
    /**
     * Activate or deactivate the current display of areas
     * @internal
     */
    onDisplayAreas() {
        if (this.displayAreas) {
            Array.from(document.getElementsByClassName('igo-map-tooltip-measure-area')).map((value) => value.classList.remove('igo-map-tooltip-hidden'));
        }
        else {
            Array.from(document.getElementsByClassName('igo-map-tooltip-measure-area')).map((value) => value.classList.add('igo-map-tooltip-hidden'));
        }
    }
    /**
     * Set the measure type
     * @internal
     */
    onLengthUnitChange(unit) {
        this.activeLengthUnit = unit;
        this.table.refresh();
        this.updateTooltipsOfOlSource(this.store.source.ol);
        if (this.activeOlGeometry !== undefined) {
            this.updateTooltipsOfOlGeometry(this.activeOlGeometry);
        }
    }
    /**
     * Set the measure type
     * @internal
     */
    onAreaUnitChange(unit) {
        this.activeAreaUnit = unit;
        this.table.refresh();
        this.updateTooltipsOfOlSource(this.store.source.ol);
        if (this.activeOlGeometry !== undefined) {
            this.updateTooltipsOfOlGeometry(this.activeOlGeometry);
        }
    }
    onCalculateClick() {
        const features = this.selectedFeatures$.value;
        const area = features.reduce((sum, localFeature) => {
            return sum + localFeature.properties.measure.area || 0;
        }, 0);
        const length = features.reduce((sum, localFeature) => {
            if (localFeature.geometry.type === 'Polygon') {
                return sum;
            }
            return sum + localFeature.properties.measure.length || 0;
        }, 0);
        const perimeter = features.reduce((sum, localFeature) => {
            if (localFeature.geometry.type === 'LineString') {
                return sum;
            }
            return sum + localFeature.properties.measure.length || 0;
        }, 0);
        this.openDialog({
            area,
            length,
            perimeter
        });
    }
    onDeleteClick() {
        this.store.deleteMany(this.selectedFeatures$.value);
        this.selectedFeatures$.value.forEach(selectedFeature => {
            this.olDrawSource.getFeatures().forEach(drawingLayerFeature => {
                const geometry = drawingLayerFeature.getGeometry();
                if (selectedFeature.properties.id === geometry.ol_uid) {
                    this.olDrawSource.removeFeature(drawingLayerFeature);
                }
            });
        });
    }
    onModifyClick() {
        if (this.selectedFeatures$.value.length !== 1) {
            return;
        }
        if (this.modifyControl.active === true) {
            this.deactivateModifyControl();
            this.toggleDrawControl();
        }
        else {
            const localFeature = this.selectedFeatures$.value[0];
            const olFeatures = this.store.layer.ol.getSource().getFeatures();
            const olFeature = olFeatures.find((_olFeature) => {
                return _olFeature.get('id') === localFeature.properties.id;
            });
            if (olFeature !== undefined) {
                this.deactivateDrawControl();
                this.activateModifyControl();
                const olGeometry = olFeature.getGeometry();
                this.clearTooltipsOfOlGeometry(olGeometry);
                this.modifyControl.setOlGeometry(olGeometry);
            }
        }
    }
    openDialog(data) {
        this.dialog.open(MeasurerDialogComponent, { data });
    }
    /**
     * Initialize the measure store and set up some listeners
     * @internal
     */
    initStore() {
        const store = this.store;
        const layer = new VectorLayer({
            title: this.languageService.translate.instant('igo.geo.measure.layerTitle'),
            isIgoInternalLayer: true,
            id: `igo-measures-${uuid()}`,
            zIndex: 200,
            source: new FeatureDataSource(),
            style: createMeasureLayerStyle(),
            showInLayerList: true,
            exportable: true,
            browsable: false,
            workspace: { enabled: false }
        });
        tryBindStoreLayer(store, layer);
        store.layer.visible = true;
        layer.visible$.subscribe(visible => {
            if (visible) {
                Array.from(document.getElementsByClassName('igo-map-tooltip-measure')).map((value) => value.classList.remove('igo-map-tooltip-measure-by-display'));
            }
            else {
                Array.from(document.getElementsByClassName('igo-map-tooltip-measure')).map((value) => value.classList.add('igo-map-tooltip-measure-by-display'));
            }
        });
        tryAddLoadingStrategy(store);
        tryAddSelectionStrategy(store, new FeatureStoreSelectionStrategy({
            map: this.map,
            many: true
        }));
        this.onFeatureAddedKey = store.source.ol.on('addfeature', (event) => {
            const localFeature = event.feature;
            const olGeometry = localFeature.getGeometry();
            this.updateMeasureOfOlGeometry(olGeometry, localFeature.get('measure'));
            this.onDisplayDistance();
        });
        this.onFeatureRemovedKey = store.source.ol.on('removefeature', (event) => {
            const olGeometry = event.feature.getGeometry();
            this.clearTooltipsOfOlGeometry(olGeometry);
        });
        this.selectedFeatures$$ = store.stateView.manyBy$((record) => {
            return record.state.selected === true;
        }).pipe(skip(1) // Skip initial emission
        )
            .subscribe((records) => {
            if (this.modifyControl.active === true) {
                this.deactivateModifyControl();
            }
            this.selectedFeatures$.next(records.map(record => record.entity));
        });
        this.subscriptions$$.push(this.store.entities$.subscribe(objectsExists => {
            if (objectsExists.find(objectExist => objectExist.geometry.type === 'Polygon')) {
                this.hasArea$.next(true);
            }
            else {
                this.hasArea$.next(false);
            }
            if (objectsExists.find(objectExist => objectExist.geometry.type === 'LineString')) {
                this.hasLine$.next(true);
            }
            else {
                this.hasLine$.next(false);
            }
        }));
        this.subscriptions$$.push(this.store.count$.subscribe(cnt => {
            cnt >= 1 ?
                this.store.layer.options.showInLayerList = true :
                this.store.layer.options.showInLayerList = false;
        }));
    }
    /**
     * Freeze any store, meaning the layer is removed, strategies are deactivated
     * and some listener removed
     * @internal
     */
    freezeStore() {
        const store = this.store;
        this.selectedFeatures$$.unsubscribe();
        unByKey(this.onFeatureAddedKey);
        unByKey(this.onFeatureRemovedKey);
        store.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
        store.deactivateStrategyOfType(FeatureStoreSelectionStrategy);
    }
    /**
     * Create a draw line control
     */
    createDrawLineControl() {
        this.drawLineControl = new DrawControl({
            geometryType: 'LineString',
            drawingLayerSource: this.olDrawSource,
            interactionStyle: createMeasureInteractionStyle(),
            drawingLayerStyle: new OlStyle({})
        });
    }
    /**
     * Create a draw polygon control
     */
    createDrawPolygonControl() {
        this.drawPolygonControl = new DrawControl({
            geometryType: 'Polygon',
            drawingLayerSource: this.olDrawSource,
            interactionStyle: createMeasureInteractionStyle(),
            drawingLayerStyle: new OlStyle({})
        });
    }
    /**
     * Create a draw polygon control
     */
    createModifyControl() {
        this.modifyControl = new ModifyControl({
            source: this.olDrawSource,
            drawStyle: createMeasureInteractionStyle(),
            layerStyle: new OlStyle({})
        });
    }
    /**
     * Activate the right control
     */
    toggleDrawControl() {
        this.deactivateDrawControl();
        // this.deactivateModifyControl();
        if (this.activeMeasureType === MeasureType.Length) {
            this.activateDrawControl(this.drawLineControl);
        }
        else if (this.activeMeasureType === MeasureType.Area) {
            this.activateDrawControl(this.drawPolygonControl);
        }
    }
    /**
     * Activate a given control
     * @param drawControl Draw control
     */
    activateDrawControl(drawControl) {
        this.drawControlIsDisabled = false;
        this.activeDrawControl = drawControl;
        this.drawStart$$ = drawControl.start$
            .subscribe((olGeometry) => this.onDrawStart(olGeometry));
        this.drawEnd$$ = drawControl.end$
            .subscribe((olGeometry) => this.onDrawEnd(olGeometry));
        this.drawChanges$$ = drawControl.changes$
            .subscribe((olGeometry) => this.onDrawChanges(olGeometry));
        this.drawChanges$$ = drawControl.abort$
            .subscribe((olGeometry) => {
            this.clearTooltipsOfOlGeometry(olGeometry);
            this.clearMeasures();
        });
        drawControl.setOlMap(this.map.ol, false);
    }
    /**
     * Deactivate the active draw control
     */
    deactivateDrawControl() {
        if (this.activeDrawControl === undefined) {
            return;
        }
        this.olDrawSource.clear();
        if (this.drawStart$$ !== undefined) {
            this.drawStart$$.unsubscribe();
        }
        if (this.drawEnd$$ !== undefined) {
            this.drawEnd$$.unsubscribe();
        }
        if (this.drawChanges$$ !== undefined) {
            this.drawChanges$$.unsubscribe();
        }
        this.clearTooltipsOfOlSource(this.olDrawSource);
        if (this.activeOlGeometry !== undefined) {
            this.clearTooltipsOfOlGeometry(this.activeOlGeometry);
        }
        this.activeDrawControl.setOlMap(undefined);
        this.activeDrawControl = undefined;
        this.activeOlGeometry = undefined;
    }
    setActiveMeasureType(measureType) {
        this._activeMeasureType = measureType;
        this.clearMeasures();
        this.toggleDrawControl();
    }
    /**
     * Clear the draw source and track the geometry being drawn
     * @param olGeometry Ol linestring or polygon
     */
    onDrawStart(olGeometry) {
        this.activeOlGeometry = olGeometry;
    }
    /**
     * Clear the draw source and track the geometry being draw
     * @param olGeometry Ol linestring or polygon
     */
    onDrawEnd(olGeometry) {
        this.activeOlGeometry = undefined;
        this.finalizeMeasureOfOlGeometry(olGeometry);
        this.addFeatureToStore(olGeometry);
        this.clearTooltipsOfOlGeometry(olGeometry);
        this.olDrawSource.clear(true);
    }
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    onDrawChanges(olGeometry) {
        const measure = measureOlGeometry(olGeometry, this.projection);
        this.updateMeasureOfOlGeometry(olGeometry, Object.assign({}, measure, {
            area: undefined // We don't want to display an area tooltip while drawing.
        }));
        this.measure$.next(measure);
    }
    /**
     * Activate a given control
     * @param modifyControl Modify control
     */
    activateModifyControl() {
        const selection = this.store.getStrategyOfType(FeatureStoreSelectionStrategy);
        selection.deactivate();
        selection.clear();
        this.modifyStart$$ = this.modifyControl.start$
            .subscribe((olGeometry) => this.onModifyStart(olGeometry));
        this.modifyEnd$$ = this.modifyControl.end$
            .subscribe((olGeometry) => this.onModifyEnd(olGeometry));
        this.modifyChanges$$ = this.modifyControl.changes$
            .subscribe((olGeometry) => this.onModifyChanges(olGeometry));
        this.modifyControl.setOlMap(this.map.ol);
    }
    /**
     * Deactivate the active modify control
     */
    deactivateModifyControl() {
        if (this.modifyStart$$ !== undefined) {
            this.modifyStart$$.unsubscribe();
        }
        if (this.modifyEnd$$ !== undefined) {
            this.modifyEnd$$.unsubscribe();
        }
        if (this.modifyChanges$$ !== undefined) {
            this.modifyChanges$$.unsubscribe();
        }
        if (this.activeOlGeometry !== undefined) {
            if (this.selectedFeatures$.value.length === 1) {
                const localFeature = this.selectedFeatures$.value[0];
                this.addFeatureToStore(this.activeOlGeometry, localFeature);
            }
            this.finalizeMeasureOfOlGeometry(this.activeOlGeometry);
        }
        this.olDrawSource.clear();
        this.store.activateStrategyOfType(FeatureStoreSelectionStrategy);
        this.activeOlGeometry = undefined;
        this.modifyControl.setOlMap(undefined);
    }
    /**
     * Clear the draw source and track the geometry being drawn
     * @param olGeometry Ol linestring or polygon
     */
    onModifyStart(olGeometry) {
        this.onDrawStart(olGeometry);
    }
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    onModifyChanges(olGeometry) {
        this.onDrawChanges(olGeometry);
    }
    /**
     * Clear the draw source and track the geometry being draw
     * @param olGeometry Ol linestring or polygon
     */
    onModifyEnd(olGeometry) {
        this.finalizeMeasureOfOlGeometry(olGeometry);
    }
    finalizeMeasureOfOlGeometry(olGeometry) {
        const measure = measureOlGeometry(olGeometry, this.projection);
        this.updateMeasureOfOlGeometry(olGeometry, measure);
    }
    /**
     * Update measures observables
     * @param olGeometry Ol linestring or polygon
     * @param measure Measure
     */
    updateMeasureOfOlGeometry(olGeometry, measure) {
        olGeometry.setProperties({ _measure: measure }, true);
        this.updateTooltipsOfOlGeometry(olGeometry);
    }
    /**
     * Clear the measures observables
     */
    clearMeasures() {
        this.measure$.next({});
    }
    /**
     * Add a feature with measures to the store. The loading stragegy of the store
     * will trigger and add the feature to the map.
     * @internal
     */
    addFeatureToStore(olGeometry, localFeature) {
        const featureId = localFeature ? localFeature.properties.id : olGeometry.ol_uid;
        const projection = this.map.ol.getView().getProjection();
        const geometry = new OlGeoJSON().writeGeometryObject(olGeometry, {
            featureProjection: projection,
            dataProjection: projection
        });
        this.store.update({
            type: FEATURE,
            geometry,
            projection: projection.getCode(),
            properties: {
                id: featureId,
                measure: olGeometry.get('_measure')
            },
            meta: {
                id: featureId
            }
        });
    }
    /**
     * Update all the tooltips of an OL geometry
     * @param olGeometry OL Geometry
     * @param lengths Lengths of the OL geometry's segments
     * @param measureUnit Display tooltip measure in those units
     */
    updateTooltipsOfOlGeometry(olGeometry) {
        const measure = olGeometry.get('_measure');
        const lengths = measure.lengths;
        const area = measure.area;
        const olMidpointsTooltips = updateOlTooltipsAtMidpoints(olGeometry);
        if (lengths.length === olMidpointsTooltips.length) {
            for (let i = 0; i < olMidpointsTooltips.length; i++) {
                const length = lengths[i];
                if (length !== undefined) {
                    this.updateOlTooltip(olMidpointsTooltips[i], metersToUnit(length, this.activeLengthUnit), this.activeLengthUnit, MeasureType.Length);
                }
            }
        }
        if (area !== undefined) {
            this.updateOlTooltip(updateOlTooltipAtCenter(olGeometry), squareMetersToUnit(area, this.activeAreaUnit), this.activeAreaUnit, MeasureType.Area);
        }
    }
    /**
     * Show the map tooltips of a geoemtry
     */
    showTooltipsOfOlGeometry(olGeometry) {
        getTooltipsOfOlGeometry(olGeometry).forEach((olTooltip) => {
            if (this.shouldShowTooltip(olTooltip)) {
                this.map.ol.addOverlay(olTooltip);
            }
        });
    }
    /**
     * Clear the tooltips of an OL geometrys
     * @param olGeometry OL geometry with tooltips
     */
    clearTooltipsOfOlGeometry(olGeometry) {
        getTooltipsOfOlGeometry(olGeometry).forEach((olTooltip) => {
            if (olTooltip !== undefined && olTooltip.getMap() !== undefined) {
                this.map.ol.removeOverlay(olTooltip);
            }
        });
    }
    /**
     * Show the map tooltips of all the geometries of a source
     */
    updateTooltipsOfOlSource(olSource) {
        olSource.forEachFeature((olFeature) => {
            this.updateTooltipsOfOlGeometry(olFeature.getGeometry());
        });
    }
    /**
     * Show the map tooltips of all the geometries of a source
     */
    showTooltipsOfOlSource(olSource) {
        olSource.forEachFeature((olFeature) => {
            this.showTooltipsOfOlGeometry(olFeature.getGeometry());
        });
    }
    /**
     * Clear the map tooltips
     * @param olDrawSource OL vector source
     */
    clearTooltipsOfOlSource(olSource) {
        olSource.forEachFeature((olFeature) => {
            const olGeometry = olFeature.getGeometry();
            if (olGeometry !== undefined) {
                this.clearTooltipsOfOlGeometry(olFeature.getGeometry());
            }
        });
    }
    /**
     * Update an OL tooltip properties and inner HTML and add it to the map if possible
     * @param olTooltip OL tooltip
     * @param measure The measure valeu ti display
     * @param measureUnit Display tooltip measure in those units
     */
    updateOlTooltip(olTooltip, measure, unit, type) {
        olTooltip.setProperties({ _measure: measure, _unit: unit, _type: type }, true);
        olTooltip.getElement().innerHTML = this.computeTooltipInnerHTML(olTooltip);
        if (this.shouldShowTooltip(olTooltip)) {
            this.map.ol.addOverlay(olTooltip);
        }
    }
    /**
     * Compute a tooltip's content
     * @param olTooltip OL overlay
     * @returns Inner HTML
     */
    computeTooltipInnerHTML(olTooltip) {
        const properties = olTooltip.getProperties();
        return formatMeasure(properties._measure, {
            decimal: 1,
            unit: properties._unit,
            unitAbbr: true,
            locale: 'fr'
        }, this.languageService);
    }
    /**
     * Whether a tooltip should be showned based on the length
     * of the segment it is bound to.
     * @param olTooltip OL overlay
     * @returns True if the tooltip should be shown
     */
    shouldShowTooltip(olTooltip) {
        if (this.showTooltips === false) {
            return false;
        }
        const properties = olTooltip.getProperties();
        const measure = properties._measure;
        if (measure === undefined) {
            return false;
        }
        if (properties._unit === MeasureType.Length) {
            const minSegmentLength = metersToUnit(this.minSegmentLength, properties._unit) || 0;
            return measure > Math.max(minSegmentLength, 0);
        }
        return true;
    }
}
MeasurerComponent.ɵfac = function MeasurerComponent_Factory(t) { return new (t || MeasurerComponent)(i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(i1.MatDialog), i0.ɵɵdirectiveInject(i2$1.StorageService)); };
MeasurerComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MeasurerComponent, selectors: [["igo-measurer"]], viewQuery: function MeasurerComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$a, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.table = _t.first);
    } }, inputs: { map: "map", store: "store", activeMeasureType: "activeMeasureType", minSegmentLength: "minSegmentLength" }, decls: 43, vars: 60, consts: [[1, "measure-type-toggle", "mat-typography"], [3, "value", "change"], [3, "value"], [1, "measure-options", "mat-typography"], [3, "disabled", "checked", "labelPosition", "change"], [4, "ngIf"], [3, "checked", "labelPosition", "change", 4, "ngIf"], [3, "checked", "labelPosition", "change"], [1, "measure-store-buttons"], ["mat-icon-button", "", "color", "accent", 3, "matTooltip", "disabled", "click", 4, "ngIf"], ["mat-icon-button", "", "color", "warn", 3, "matTooltip", "disabled", "click", 4, "ngIf"], [1, "table-compact", 3, "store", "template"], ["table", ""], [3, "measureType", "measureUnit", "measure", "auto", "placeholder", "measureUnitChange", 4, "ngIf"], [3, "measureType", "measureUnit", "measure", "auto", "placeholder", "measureUnitChange"], ["mat-icon-button", "", "color", "accent", 3, "matTooltip", "disabled", "click"], ["svgIcon", "calculator"], ["mat-icon-button", "", "color", "warn", 3, "matTooltip", "disabled", "click"], ["svgIcon", "delete"]], template: function MeasurerComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵelementStart(2, "mat-button-toggle-group", 1);
        i0.ɵɵlistener("change", function MeasurerComponent_Template_mat_button_toggle_group_change_2_listener($event) { return ctx.onMeasureTypeChange($event.value); });
        i0.ɵɵelementStart(3, "mat-button-toggle", 2);
        i0.ɵɵtext(4);
        i0.ɵɵpipe(5, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(6, "mat-button-toggle", 2);
        i0.ɵɵtext(7);
        i0.ɵɵpipe(8, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(9, "div", 3);
        i0.ɵɵelementStart(10, "mat-slide-toggle", 4);
        i0.ɵɵlistener("change", function MeasurerComponent_Template_mat_slide_toggle_change_10_listener($event) { return ctx.onToggleDrawControl($event.checked); });
        i0.ɵɵtext(11);
        i0.ɵɵpipe(12, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(13, MeasurerComponent_mat_divider_13_Template, 1, 0, "mat-divider", 5);
        i0.ɵɵpipe(14, "async");
        i0.ɵɵtemplate(15, MeasurerComponent_mat_slide_toggle_15_Template, 3, 5, "mat-slide-toggle", 6);
        i0.ɵɵpipe(16, "async");
        i0.ɵɵtemplate(17, MeasurerComponent_mat_divider_17_Template, 1, 0, "mat-divider", 5);
        i0.ɵɵpipe(18, "async");
        i0.ɵɵpipe(19, "async");
        i0.ɵɵtemplate(20, MeasurerComponent_mat_slide_toggle_20_Template, 3, 5, "mat-slide-toggle", 6);
        i0.ɵɵpipe(21, "async");
        i0.ɵɵtemplate(22, MeasurerComponent_mat_slide_toggle_22_Template, 3, 5, "mat-slide-toggle", 6);
        i0.ɵɵpipe(23, "async");
        i0.ɵɵtemplate(24, MeasurerComponent_mat_divider_24_Template, 1, 0, "mat-divider", 5);
        i0.ɵɵpipe(25, "async");
        i0.ɵɵelementStart(26, "mat-slide-toggle", 7);
        i0.ɵɵlistener("change", function MeasurerComponent_Template_mat_slide_toggle_change_26_listener($event) { return ctx.onToggleMeasureUnitsAuto($event.checked); });
        i0.ɵɵtext(27);
        i0.ɵɵpipe(28, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(29, MeasurerComponent_ng_container_29_Template, 3, 2, "ng-container", 5);
        i0.ɵɵpipe(30, "async");
        i0.ɵɵtemplate(31, MeasurerComponent_mat_divider_31_Template, 1, 0, "mat-divider", 5);
        i0.ɵɵpipe(32, "async");
        i0.ɵɵpipe(33, "async");
        i0.ɵɵelementStart(34, "div", 8);
        i0.ɵɵtemplate(35, MeasurerComponent_button_35_Template, 4, 6, "button", 9);
        i0.ɵɵpipe(36, "async");
        i0.ɵɵpipe(37, "async");
        i0.ɵɵtemplate(38, MeasurerComponent_button_38_Template, 4, 6, "button", 10);
        i0.ɵɵpipe(39, "async");
        i0.ɵɵpipe(40, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵelement(41, "igo-entity-table", 11, 12);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", ctx.activeMeasureType);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("value", ctx.measureType.Length);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(5, 24, "igo.geo.measure." + ctx.measureType.Length), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", ctx.measureType.Area);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(8, 26, "igo.geo.measure." + ctx.measureType.Area), " ");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("disabled", ctx.drawControlIsDisabled)("checked", ctx.drawControlIsActive)("labelPosition", "before");
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(12, 28, "igo.geo.measure.toggleActive"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(14, 30, ctx.hasLine$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(16, 32, ctx.hasLine$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(18, 34, ctx.hasLine$) || i0.ɵɵpipeBind1(19, 36, ctx.hasArea$));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(21, 38, ctx.hasArea$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(23, 40, ctx.hasArea$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(25, 42, ctx.hasArea$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("checked", ctx.measureUnitsAuto)("labelPosition", "before");
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(28, 44, "igo.geo.measure.toggleAutoUnits"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(30, 46, ctx.measure$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(32, 48, ctx.hasLine$) || i0.ɵɵpipeBind1(33, 50, ctx.hasArea$));
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(36, 52, ctx.hasLine$) || i0.ɵɵpipeBind1(37, 54, ctx.hasArea$));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(39, 56, ctx.hasLine$) || i0.ɵɵpipeBind1(40, 58, ctx.hasArea$));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("store", ctx.store)("template", ctx.tableTemplate);
    } }, styles: [".measure-type-toggle[_ngcontent-%COMP%]{padding:10px;text-align:center}.measure-type-toggle[_ngcontent-%COMP%]   mat-button-toggle-group[_ngcontent-%COMP%]{width:100%}.measure-type-toggle[_ngcontent-%COMP%]   mat-button-toggle-group[_ngcontent-%COMP%]   mat-button-toggle[_ngcontent-%COMP%]{width:50%}.measure-options[_ngcontent-%COMP%]{overflow-x:hidden}.measure-options[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]{width:100%;margin:10px}.measure-options[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-content{width:calc(100% - 60px)}.measure-store-buttons[_ngcontent-%COMP%]{margin-left:-2px}.measure-store-buttons[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:first-of-type{margin-left:14px}.table-compact[_ngcontent-%COMP%]     .mat-header-cell.mat-column-selectionCheckbox{width:52px}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MeasurerComponent, [{
        type: Component,
        args: [{
                selector: 'igo-measurer',
                templateUrl: './measurer.component.html',
                styleUrls: ['./measurer.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i2$1.LanguageService }, { type: i1.MatDialog }, { type: i2$1.StorageService }]; }, { map: [{
            type: Input
        }], store: [{
            type: Input
        }], activeMeasureType: [{
            type: Input
        }], minSegmentLength: [{
            type: Input
        }], table: [{
            type: ViewChild,
            args: ['table', { static: true }]
        }] }); })();

/**
 * This pipe returns a measure converted from meters (or square meters)
 * to the specified unit. It also keeps a certain number of decimals.
 */
class MeasureFormatPipe {
    /**
     * @ignore
     */
    transform(value, unit, unitAbbr = false, decimal = 1) {
        let out;
        if (Object.values(MeasureAreaUnit).indexOf(unit) >= 0) {
            out = squareMetersToUnit(value, unit);
        }
        else if (Object.values(MeasureLengthUnit).indexOf(unit) >= 0) {
            out = metersToUnit(value, unit);
        }
        return out ? formatMeasure(out, {
            decimal: 1,
            unit,
            unitAbbr,
            locale: 'fr'
        }) : out;
    }
}
MeasureFormatPipe.ɵfac = function MeasureFormatPipe_Factory(t) { return new (t || MeasureFormatPipe)(); };
MeasureFormatPipe.ɵpipe = /*@__PURE__*/ i0.ɵɵdefinePipe({ name: "measureFormat", type: MeasureFormatPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MeasureFormatPipe, [{
        type: Pipe,
        args: [{
                name: 'measureFormat'
            }]
    }], null, null); })();

function GeometryFormFieldInputComponent_ng_template_0_Template(rf, ctx) { }
/**
 * This input allows a user to draw a new geometry or to edit
 * an existing one on a map. A text input is also displayed in the
 * form with some instructions.
 * This is still WIP.
 */
class GeometryFormFieldInputComponent {
    constructor(cdRef, ngControl) {
        this.cdRef = cdRef;
        this.ngControl = ngControl;
        this.olGeoJSON = new OlGeoJSON();
        this.ready = false;
        this.olTooltip = this.createMeasureTooltip();
        /**
         * The drawGuide around the mouse pointer to help drawing
         */
        this.drawGuide = null;
        /**
         * Whether a measure tooltip should be displayed
         */
        this.measure = false;
        this._drawControlIsActive = true;
        /**
         * Control options
         */
        this.controlOptions = {};
        this.onChange = () => { };
        this.onTouched = () => { };
        if (this.ngControl !== undefined) {
            // Setting the value accessor directly (instead of using
            // the providers) to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * The geometry type
     */
    set geometryType(value) {
        this._geometryType = value;
        if (this.ready === false) {
            return;
        }
        this.deactivateControl();
        this.createDrawControl();
        this.drawControl.freehand$.next(this.freehandDrawIsActive);
        this.toggleControl();
    }
    get geometryType() { return this._geometryType; }
    /**
     * Whether draw control should be active or not
     */
    get drawControlIsActive() { return this._drawControlIsActive; }
    set drawControlIsActive(value) {
        this._drawControlIsActive = value;
        if (this.ready === false) {
            return;
        }
        this.deactivateControl();
        if (!this._drawControlIsActive) {
            return;
        }
        else {
            this.toggleControl();
        }
    }
    /**
     * Whether freehand draw control should be active or not
     */
    get freehandDrawIsActive() { return this._freehandDrawIsActive; }
    set freehandDrawIsActive(value) {
        this._freehandDrawIsActive = value;
        this.deactivateControl();
        this.createDrawControl();
        this.createModifyControl();
        this.drawControl.freehand$.next(this.freehandDrawIsActive);
        if (this.ready === false) {
            return;
        }
        if (!this.drawControlIsActive) {
            return;
        }
        this.toggleControl();
    }
    /**
     * Style for the draw control (applies while the geometry is being drawn)
     */
    set drawStyle(value) {
        if (value === undefined) {
            value = createDrawInteractionStyle();
        }
        this._drawStyle = value;
        const olGuideStyle = this.getGuideStyleFromDrawStyle(value);
        if (olGuideStyle !== undefined) {
            this.defaultDrawStyleRadius = olGuideStyle.getRadius();
        }
        else {
            this.defaultDrawStyleRadius = null;
        }
        if (this.ready === false) {
            return;
        }
        this.deactivateControl();
        this.createDrawControl();
        this.createModifyControl();
        this.drawControl.freehand$.next(this.freehandDrawIsActive);
        this.toggleControl();
    }
    get drawStyle() { return this._drawStyle; }
    /**
     * Style for the overlay layer (applies once the geometry is added to the map)
     * If not specified, drawStyle applies
     */
    set overlayStyle(value) { this._overlayStyle = value; }
    get overlayStyle() { return this._overlayStyle; }
    /**
     * The geometry value (GeoJSON)
     * Implemented as part of ControlValueAccessor.
     */
    set value(value) {
        this._value = value;
        if (this.ready === false) {
            return;
        }
        if (value) {
            this.addGeoJSONToOverlay(value);
        }
        else {
            this.olOverlaySource.clear(true);
        }
        this.onChange(value);
        this.toggleControl();
        this.cdRef.detectChanges();
    }
    get value() { return this._value; }
    /**
     * The vector source to add the geometry to
     * @internal
     */
    get olOverlaySource() {
        return this.olOverlayLayer.getSource();
    }
    set radius(value) {
        if (this.ready === false) {
            return;
        }
        if (this.modifyControl.getSource()) {
            this.modifyControl.getSource().refresh();
        }
        if (this.freehandDrawIsActive) {
            let olModify;
            setTimeout(() => {
                olModify = this.modifyControl.olModifyInteraction;
                if (olModify) {
                    if (olModify.features_) {
                        olModify.features_.clear();
                        this.addGeoJSONToOverlay(this.value);
                    }
                }
            }, 0);
        }
    }
    /**
     * Create an overlay layer, add the initial geometry to it (if any)
     * and toggle the right interaction.
     * @internal
     */
    ngOnInit() {
        if (this.drawStyle === undefined) {
            this.drawStyle = createDrawInteractionStyle();
        }
        if (this.overlayStyle === undefined) {
            this.overlayStyle = this.drawStyle;
        }
        this.addOlOverlayLayer();
        this.createDrawControl();
        this.createModifyControl();
        if (this.value) {
            this.addGeoJSONToOverlay(this.value);
        }
        this.toggleControl();
        this.ready = true;
    }
    /**
     * Clear the overlay layer and any interaction added by this component.
     * @internal
     */
    ngOnDestroy() {
        // This is mandatory when the form control is reused after
        // this component has been destroyed. It seems like the control
        // keeps a reference to this component even after it's destroyed
        // and it attempts to set it's value
        this.ready = false;
        this.deactivateControl();
        this.olOverlaySource.clear();
        this.map.ol.removeLayer(this.olOverlayLayer);
    }
    /**
     * Implemented as part of ControlValueAccessor.
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * Implemented as part of ControlValueAccessor.
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Implemented as part of ControlValueAccessor.
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * Add an overlay layer to the map
     */
    addOlOverlayLayer() {
        this.olOverlayLayer = new OlVectorLayer({
            source: new OlVectorSource(),
            zIndex: 500,
            style: null
        });
        this.map.ol.addLayer(this.olOverlayLayer);
    }
    /**
     * Create a draw control and subscribe to it's geometry
     */
    createDrawControl() {
        const controlOptions = Object.assign({}, this.controlOptions, {
            geometryType: this.geometryType || 'Point',
            drawingLayer: this.olOverlayLayer,
            interactionStyle: typeof this.drawStyle === 'function' ? this.drawStyle : (olFeature, resolution) => {
                const style = this.drawStyle;
                this.updateDrawStyleWithDrawGuide(style, resolution);
                return style;
            }
        });
        this.drawControl = new DrawControl(controlOptions);
    }
    /**
     * Create a modify control and subscribe to it's geometry
     */
    createModifyControl() {
        const controlOptions = Object.assign({}, this.controlOptions, {
            layer: this.olOverlayLayer,
            drawStyle: typeof this.drawStyle === 'function' ? this.drawStyle : (olFeature, resolution) => {
                const style = this.drawStyle;
                this.updateDrawStyleWithDrawGuide(style, resolution);
                return style;
            }
        });
        this.modifyControl = new ModifyControl(controlOptions);
    }
    /**
     * Toggle the proper control (draw or modify)
     */
    toggleControl() {
        let activate;
        if (!this.value && this.geometryType) {
            activate = this.drawControl;
        }
        else {
            activate = this.modifyControl;
        }
        // If the control that should be activated
        // is not the same as the current active control,
        // deactivate the current control and activate the new one
        // Otherwise, do nothing and keep the current control active
        if (activate !== this.activeControl) {
            this.deactivateControl();
            this.activateControl(activate);
        }
    }
    /**
     * Activate a given control
     * @param control Control
     */
    activateControl(control) {
        this.activeControl = control;
        this.olGeometryEnds$$ = control.end$
            .subscribe((olGeometry) => this.onOlGeometryEnds(olGeometry));
        if (this.measure === true && control === this.drawControl) {
            this.olGeometryChanges$$ = control.changes$
                .subscribe((olGeometry) => this.onOlGeometryChanges(olGeometry));
        }
        control.setOlMap(this.map.ol, false);
    }
    /**
     * Deactivate the active control
     */
    deactivateControl() {
        this.removeMeasureTooltip();
        if (this.activeControl !== undefined) {
            this.activeControl.setOlMap(undefined);
        }
        if (this.olGeometryEnds$$ !== undefined) {
            this.olGeometryEnds$$.unsubscribe();
        }
        if (this.olGeometryChanges$$ !== undefined) {
            this.olGeometryChanges$$.unsubscribe();
        }
        this.activeControl = undefined;
    }
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    onOlGeometryEnds(olGeometry) {
        this.removeMeasureTooltip();
        this.setOlGeometry(olGeometry);
    }
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    onOlGeometryChanges(olGeometry) {
        if (olGeometry.getType() !== 'Point') {
            this.updateMeasureTooltip(olGeometry);
        }
    }
    /**
     * When drawing ends, convert the output value to GeoJSON and keep it.
     * Restore the double click interaction.
     * @param olGeometry OL geometry
     */
    setOlGeometry(olGeometry) {
        let value;
        if (olGeometry === undefined) {
            return;
        }
        if (olGeometry.getType() === 'Circle') { // Because Circle doesn't exist as a GeoJSON object
            olGeometry = this.circleToPoint(olGeometry);
        }
        value = this.olGeoJSON.writeGeometryObject(olGeometry, {
            featureProjection: this.map.projection,
            dataProjection: 'EPSG:4326'
        });
        if (olGeometry.get('radius')) {
            value.radius = olGeometry.get('radius');
            olGeometry.set('radius', value.radius);
        }
        this.writeValue(value);
    }
    circleToPoint(olGeometry) {
        const center = olGeometry.getCenter();
        const coordinates = olproj.transform(center, this.map.projection, 'EPSG:4326');
        const radius = Math.round(olGeometry.getRadius() * (Math.cos((Math.PI / 180) * coordinates[1])));
        // Convert it to a point object
        olGeometry = new OlPoint(center);
        olGeometry.set('radius', radius, true);
        return olGeometry;
    }
    /**
     * Add a GeoJSON geometry to the overlay
     * @param geometry GeoJSON geometry
     */
    addGeoJSONToOverlay(geometry) {
        const olGeometry = this.olGeoJSON.readGeometry(geometry, {
            dataProjection: 'EPSG:4326',
            featureProjection: this.map.projection
        });
        const olFeature = new OlFeature({
            geometry: olGeometry
        });
        olFeature.setStyle(this.overlayStyle);
        this.olOverlaySource.clear();
        this.olOverlaySource.addFeature(olFeature);
    }
    /**
     * Create the measure tooltip
     */
    createMeasureTooltip() {
        return new OlOverlay({
            element: document.createElement('div'),
            offset: [-30, -10],
            className: [
                'igo-map-tooltip',
                'igo-map-tooltip-measure'
            ].join(' '),
            stopEvent: false
        });
    }
    /**
     * Update the measure tooltip of an OL geometry
     * @param olGeometry OL Geometry
     */
    updateMeasureTooltip(olGeometry) {
        const measure = measureOlGeometry(olGeometry, this.map.projection);
        const lengths = measure.lengths;
        const lastIndex = olGeometry.getType() === 'Polygon' ? lengths.length - 2 : lengths.length - 1;
        const lastLength = lengths[lastIndex];
        const olMidpoints = updateOlGeometryMidpoints(olGeometry);
        const olLastMidpoint = olMidpoints[lastIndex];
        if (olMidpoints.length === 0 || olLastMidpoint === undefined) {
            this.removeMeasureTooltip();
            return;
        }
        this.olTooltip.setPosition(olLastMidpoint.getFlatCoordinates());
        const innerHtml = formatMeasure(lastLength, {
            decimal: 1,
            unit: MeasureLengthUnit.Meters,
            unitAbbr: true,
            locale: 'fr'
        });
        this.olTooltip.getElement().innerHTML = innerHtml;
        if (this.olTooltip.getMap() === undefined) {
            this.map.ol.addOverlay(this.olTooltip);
        }
    }
    /**
     * Remove the measure tooltip from the map
     */
    removeMeasureTooltip() {
        if (this.olTooltip.getMap && this.olTooltip.getMap() !== undefined) {
            this.map.ol.removeOverlay(this.olTooltip);
            this.olTooltip.setMap(undefined);
        }
    }
    /**
     * Adjust the draw style with the specified draw guide distance, if possible
     * @param olStyle Draw style to update
     * @param resolution Resolution (to make the screen size of symbol fit the drawGuide value)
     */
    updateDrawStyleWithDrawGuide(olStyle, resolution) {
        const olGuideStyle = this.getGuideStyleFromDrawStyle(olStyle);
        if (olGuideStyle === undefined) {
            return;
        }
        const drawGuide = this.drawGuide;
        let radius;
        if (!drawGuide || drawGuide < 0) {
            radius = this.defaultDrawStyleRadius;
        }
        else {
            radius = drawGuide > 0 ? drawGuide / resolution : drawGuide;
        }
        olGuideStyle.setRadius(radius);
    }
    /**
     * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
     * @param olStyle The style on which to perform the check
     */
    isStyleWithRadius(olStyle) {
        return typeof olStyle !== 'function' && olStyle.setRadius;
    }
    /**
     * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
     * @param olStyle The style on which to perform the check
     */
    getGuideStyleFromDrawStyle(olStyle) {
        if (Array.isArray(olStyle)) {
            olStyle = olStyle[0];
        }
        if (this.isStyleWithRadius(olStyle)) {
            return olStyle;
        }
        return undefined;
    }
}
GeometryFormFieldInputComponent.ɵfac = function GeometryFormFieldInputComponent_Factory(t) { return new (t || GeometryFormFieldInputComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i16.NgControl, 10)); };
GeometryFormFieldInputComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: GeometryFormFieldInputComponent, selectors: [["igo-geometry-form-field-input"]], inputs: { map: "map", geometryType: "geometryType", drawGuide: "drawGuide", measure: "measure", drawControlIsActive: "drawControlIsActive", freehandDrawIsActive: "freehandDrawIsActive", controlOptions: "controlOptions", drawStyle: "drawStyle", overlayStyle: "overlayStyle", value: "value", radius: "radius" }, decls: 1, vars: 0, template: function GeometryFormFieldInputComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, GeometryFormFieldInputComponent_ng_template_0_Template, 0, 0, "ng-template");
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(GeometryFormFieldInputComponent, [{
        type: Component,
        args: [{
                selector: 'igo-geometry-form-field-input',
                templateUrl: './geometry-form-field-input.component.html',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i16.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }]; }, { map: [{
            type: Input
        }], geometryType: [{
            type: Input
        }], drawGuide: [{
            type: Input
        }], measure: [{
            type: Input
        }], drawControlIsActive: [{
            type: Input
        }], freehandDrawIsActive: [{
            type: Input
        }], controlOptions: [{
            type: Input
        }], drawStyle: [{
            type: Input
        }], overlayStyle: [{
            type: Input
        }], value: [{
            type: Input
        }], radius: [{
            type: Input
        }] }); })();

function GeometryFormFieldComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r3 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 3);
    i0.ɵɵelementStart(1, "mat-button-toggle-group", 4);
    i0.ɵɵlistener("ngModelChange", function GeometryFormFieldComponent_div_3_Template_mat_button_toggle_group_ngModelChange_1_listener($event) { i0.ɵɵrestoreView(_r3); const ctx_r2 = i0.ɵɵnextContext(); return ctx_r2.geometryType = $event; });
    i0.ɵɵpipe(2, "async");
    i0.ɵɵelementStart(3, "mat-button-toggle", 5);
    i0.ɵɵtext(4);
    i0.ɵɵpipe(5, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(6, "mat-button-toggle", 6);
    i0.ɵɵtext(7);
    i0.ɵɵpipe(8, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(9, "mat-button-toggle", 7);
    i0.ɵɵtext(10);
    i0.ɵɵpipe(11, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("disabled", i0.ɵɵpipeBind1(2, 8, ctx_r0.value$) !== undefined)("ngModel", ctx_r0.geometryType);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("disabled", ctx_r0.geometryTypes.indexOf("Point") < 0);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(5, 10, "igo.geo.geometry.point"), " ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("disabled", ctx_r0.geometryTypes.indexOf("LineString") < 0);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(8, 12, "igo.geo.geometry.line"), " ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("disabled", ctx_r0.geometryTypes.indexOf("Polygon") < 0);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(11, 14, "igo.geo.geometry.polygon"), " ");
} }
function GeometryFormFieldComponent_mat_form_field_4_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 8);
    i0.ɵɵelementStart(1, "input", 9);
    i0.ɵɵlistener("ngModelChange", function GeometryFormFieldComponent_mat_form_field_4_Template_input_ngModelChange_1_listener($event) { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.drawGuide = $event; });
    i0.ɵɵelementEnd();
    i0.ɵɵelement(2, "mat-icon", 10);
    i0.ɵɵelementStart(3, "span", 11);
    i0.ɵɵtext(4);
    i0.ɵɵpipe(5, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("placeholder", ctx_r1.drawGuidePlaceholder)("ngModel", ctx_r1.drawGuide);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("color", "primary");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(5, 4, "igo.geo.measure.meters"));
} }
/**
 * This input allows a user to draw a new geometry or to edit
 * an existing one on a map.
 */
let GeometryFormFieldComponent = class GeometryFormFieldComponent {
    constructor(cdRef) {
        this.cdRef = cdRef;
        this.value$ = new BehaviorSubject(undefined);
        this._drawControlIsActive = true;
        this._freehandDrawIsActive = false;
        this.geometryType$ = new BehaviorSubject(undefined);
        /**
         * Whether a geometry type toggle should be displayed
         */
        this.geometryTypeField = false;
        /**
         * Available geometry types
         */
        this.geometryTypes = ['Point', 'LineString', 'Polygon'];
        /**
         * Whether a draw guide field should be displayed
         */
        this.drawGuideField = false;
        this.drawGuide$ = new BehaviorSubject(0);
        /**
         * Draw guide placeholder
         */
        this.drawGuidePlaceholder = '';
        /**
         * Whether a measure tooltip should be displayed
         */
        this.measure = false;
        /**
         * Control options
         */
        this.controlOptions = {};
    }
    set drawControlIsActive(value) {
        this._drawControlIsActive = value;
        this.cdRef.detectChanges();
    }
    get drawControlIsActive() {
        return this._drawControlIsActive;
    }
    set freehandDrawIsActive(value) {
        this._freehandDrawIsActive = value;
        this.cdRef.detectChanges();
    }
    get freehandDrawIsActive() {
        return this._freehandDrawIsActive;
    }
    set geometryType(value) { this.geometryType$.next(value); }
    get geometryType() { return this.geometryType$.value; }
    /**
     * The drawGuide around the mouse pointer to help drawing
     */
    set drawGuide(value) { this.drawGuide$.next(value); }
    get drawGuide() { return this.drawGuide$.value; }
    /**
     * Set up a value stream
     * @internal
     */
    ngOnInit() {
        this.value$.next(this.formControl.value ? this.formControl.value : undefined);
        this.value$$ = this.formControl.valueChanges.subscribe((value) => {
            this.value$.next(value ? value : undefined);
        });
    }
    /**
     * Unsubscribe to the value stream
     * @internal
     */
    ngOnDestroy() {
        this.value$$.unsubscribe();
    }
};
GeometryFormFieldComponent.ɵfac = function GeometryFormFieldComponent_Factory(t) { return new (t || GeometryFormFieldComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
GeometryFormFieldComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: GeometryFormFieldComponent, selectors: [["igo-geometry-form-field"]], inputs: { formControl: "formControl", map: "map", geometryType: "geometryType", geometryTypeField: "geometryTypeField", geometryTypes: "geometryTypes", drawGuideField: "drawGuideField", drawGuide: "drawGuide", drawGuidePlaceholder: "drawGuidePlaceholder", measure: "measure", controlOptions: "controlOptions", drawStyle: "drawStyle", overlayStyle: "overlayStyle" }, decls: 5, vars: 16, consts: [[3, "formControl", "map", "geometryType", "drawGuide", "measure", "drawControlIsActive", "freehandDrawIsActive", "controlOptions", "drawStyle", "overlayStyle"], ["class", "geometry-type-toggle", 4, "ngIf"], ["class", "draw-guide-field", 4, "ngIf"], [1, "geometry-type-toggle"], [3, "disabled", "ngModel", "ngModelChange"], ["value", "Point", 3, "disabled"], ["value", "LineString", 3, "disabled"], ["value", "Polygon", 3, "disabled"], [1, "draw-guide-field"], ["matInput", "", "type", "number", 3, "placeholder", "ngModel", "ngModelChange"], ["matPrefix", "", "svgIcon", "adjust", 3, "color"], ["matSuffix", "", 1, "draw-guide-units"]], template: function GeometryFormFieldComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelement(0, "igo-geometry-form-field-input", 0);
        i0.ɵɵpipe(1, "async");
        i0.ɵɵpipe(2, "async");
        i0.ɵɵtemplate(3, GeometryFormFieldComponent_div_3_Template, 12, 16, "div", 1);
        i0.ɵɵtemplate(4, GeometryFormFieldComponent_mat_form_field_4_Template, 6, 6, "mat-form-field", 2);
    } if (rf & 2) {
        i0.ɵɵproperty("formControl", ctx.formControl)("map", ctx.map)("geometryType", i0.ɵɵpipeBind1(1, 12, ctx.geometryType$))("drawGuide", i0.ɵɵpipeBind1(2, 14, ctx.drawGuide$))("measure", ctx.measure)("drawControlIsActive", ctx.drawControlIsActive)("freehandDrawIsActive", ctx.freehandDrawIsActive)("controlOptions", ctx.controlOptions)("drawStyle", ctx.drawStyle)("overlayStyle", ctx.overlayStyle);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.geometryTypeField);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.drawGuideField);
    } }, directives: [GeometryFormFieldInputComponent, i16.NgControlStatus, i16.FormControlDirective, i1$1.NgIf, i18.MatButtonToggleGroup, i16.NgModel, i18.MatButtonToggle, i12.MatFormField, i5$1.MatInput, i16.NumberValueAccessor, i16.DefaultValueAccessor, i4.MatIcon, i12.MatPrefix, i12.MatSuffix], pipes: [i1$1.AsyncPipe, i7.TranslatePipe], styles: ["[_nghost-%COMP%]{display:block;width:100%}.geometry-type-toggle[_ngcontent-%COMP%], .draw-guide-field[_ngcontent-%COMP%]{width:100%}.geometry-type-toggle[_ngcontent-%COMP%]{padding:10px;text-align:center}.draw-guide-field[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{margin:0 10px}.draw-guide-units[_ngcontent-%COMP%]{padding:10px}"], changeDetection: 0 });
GeometryFormFieldComponent = __decorate([
    IgoFormFieldComponent('geometry')
], GeometryFormFieldComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(GeometryFormFieldComponent, [{
        type: Component,
        args: [{
                selector: 'igo-geometry-form-field',
                templateUrl: './geometry-form-field.component.html',
                styleUrls: ['./geometry-form-field.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }]; }, { formControl: [{
            type: Input
        }], map: [{
            type: Input
        }], geometryType: [{
            type: Input
        }], geometryTypeField: [{
            type: Input
        }], geometryTypes: [{
            type: Input
        }], drawGuideField: [{
            type: Input
        }], drawGuide: [{
            type: Input
        }], drawGuidePlaceholder: [{
            type: Input
        }], measure: [{
            type: Input
        }], controlOptions: [{
            type: Input
        }], drawStyle: [{
            type: Input
        }], overlayStyle: [{
            type: Input
        }] }); })();

/**
 * @ignore
 */
class IgoGeometryFormFieldModule {
}
IgoGeometryFormFieldModule.ɵfac = function IgoGeometryFormFieldModule_Factory(t) { return new (t || IgoGeometryFormFieldModule)(); };
IgoGeometryFormFieldModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoGeometryFormFieldModule });
IgoGeometryFormFieldModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            ReactiveFormsModule,
            MatIconModule,
            MatFormFieldModule,
            MatInputModule,
            MatButtonModule,
            MatButtonToggleModule,
            IgoLanguageModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoGeometryFormFieldModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MatIconModule,
                    MatFormFieldModule,
                    MatInputModule,
                    MatButtonModule,
                    MatButtonToggleModule,
                    IgoLanguageModule
                ],
                exports: [
                    GeometryFormFieldComponent,
                    GeometryFormFieldInputComponent
                ],
                declarations: [
                    GeometryFormFieldComponent,
                    GeometryFormFieldInputComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoGeometryFormFieldModule, { declarations: [GeometryFormFieldComponent,
        GeometryFormFieldInputComponent], imports: [CommonModule,
        FormsModule,
        ReactiveFormsModule,
        MatIconModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        MatButtonToggleModule,
        IgoLanguageModule], exports: [GeometryFormFieldComponent,
        GeometryFormFieldInputComponent] }); })();

class IgoGeometryModule {
}
IgoGeometryModule.ɵfac = function IgoGeometryModule_Factory(t) { return new (t || IgoGeometryModule)(); };
IgoGeometryModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoGeometryModule });
IgoGeometryModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [], imports: [[
            CommonModule,
            IgoGeometryFormFieldModule
        ], IgoGeometryFormFieldModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoGeometryModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    IgoGeometryFormFieldModule
                ],
                exports: [
                    IgoGeometryFormFieldModule
                ],
                declarations: [],
                providers: []
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoGeometryModule, { imports: [CommonModule,
        IgoGeometryFormFieldModule], exports: [IgoGeometryFormFieldModule] }); })();

function TimeFilterButtonComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 2);
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 3);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 3, "igo.geo.filter.filterBy"))("color", ctx_r0.color);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matBadge", ctx_r0.badge);
} }
function TimeFilterButtonComponent_div_1_igo_time_filter_item_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-time-filter-item", 7);
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("header", false)("layer", ctx_r3.layer);
} }
function TimeFilterButtonComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 4, 5);
    i0.ɵɵtemplate(2, TimeFilterButtonComponent_div_1_igo_time_filter_item_2_Template, 1, 2, "igo-time-filter-item", 6);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r1.timeFilterCollapse && ctx_r1.options.timeFilter);
} }
class TimeFilterButtonComponent {
    constructor() {
        this.color = 'primary';
        this.header = true;
        this.timeFilterCollapse = false;
    }
    get badge() {
        const filter = this.options.timeFilter;
        if (filter && filter.enabled) {
            return 1;
        }
        else {
            return;
        }
    }
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
        if (value) {
            this.options = this.layer.dataSource.options;
        }
    }
    ngOnInit() {
        this.options = this.layer.dataSource.options;
    }
}
TimeFilterButtonComponent.ɵfac = function TimeFilterButtonComponent_Factory(t) { return new (t || TimeFilterButtonComponent)(); };
TimeFilterButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TimeFilterButtonComponent, selectors: [["igo-time-filter-button"]], inputs: { layer: "layer", map: "map", color: "color", header: "header" }, decls: 2, vars: 2, consts: [["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", 4, "ngIf"], ["class", "igo-layer-actions-container", 4, "ngIf"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color"], ["matBadgeColor", "warn", "matBadgeSize", "medium", "svgIcon", "history", 3, "matBadge"], [1, "igo-layer-actions-container"], ["ogcFilter", ""], ["igoListItem", "", 3, "header", "layer", 4, "ngIf"], ["igoListItem", "", 3, "header", "layer"]], template: function TimeFilterButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TimeFilterButtonComponent_button_0_Template, 3, 5, "button", 0);
        i0.ɵɵtemplate(1, TimeFilterButtonComponent_div_1_Template, 3, 1, "div", 1);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.header && ctx.options.timeFilterable && ctx.options.timeFilter);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.header && ctx.options.timeFilterable && ctx.options.timeFilter);
    } }, styles: [""], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TimeFilterButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-time-filter-button',
                templateUrl: './time-filter-button.component.html',
                styleUrls: ['./time-filter-button.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { layer: [{
            type: Input
        }], map: [{
            type: Input
        }], color: [{
            type: Input
        }], header: [{
            type: Input
        }] }); })();

function TimeFilterFormComponent_div_0_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 3);
    i0.ɵɵelementStart(1, "mat-form-field");
    i0.ɵɵelement(2, "mat-datetimepicker-toggle", 4);
    i0.ɵɵelement(3, "mat-datetimepicker", 5, 6);
    i0.ɵɵelementStart(5, "input", 7);
    i0.ɵɵlistener("ngModelChange", function TimeFilterFormComponent_div_0_div_1_Template_input_ngModelChange_5_listener($event) { i0.ɵɵrestoreView(_r8); const ctx_r7 = i0.ɵɵnextContext(2); return ctx_r7.date = $event; })("dateChange", function TimeFilterFormComponent_div_0_div_1_Template_input_dateChange_5_listener($event) { i0.ɵɵrestoreView(_r8); const ctx_r9 = i0.ɵɵnextContext(2); return ctx_r9.handleDateChange($event); });
    i0.ɵɵpipe(6, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r6 = i0.ɵɵreference(4);
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("for", _r6);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("type", ctx_r4.type);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(6, 7, "igo.geo.timeFilter.date"));
    i0.ɵɵproperty("matDatetimepicker", _r6)("ngModel", ctx_r4.date)("min", ctx_r4.min)("max", ctx_r4.max);
} }
function TimeFilterFormComponent_div_0_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r13 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelementStart(1, "div", 8);
    i0.ɵɵelementStart(2, "mat-form-field");
    i0.ɵɵelement(3, "mat-datetimepicker-toggle", 4);
    i0.ɵɵelement(4, "mat-datetimepicker", 5, 9);
    i0.ɵɵelementStart(6, "input", 10);
    i0.ɵɵlistener("ngModelChange", function TimeFilterFormComponent_div_0_div_2_Template_input_ngModelChange_6_listener($event) { i0.ɵɵrestoreView(_r13); const ctx_r12 = i0.ɵɵnextContext(2); return ctx_r12.startDate = $event; })("input", function TimeFilterFormComponent_div_0_div_2_Template_input_input_6_listener() { i0.ɵɵrestoreView(_r13); const ctx_r14 = i0.ɵɵnextContext(2); return ctx_r14.startDate; })("dateChange", function TimeFilterFormComponent_div_0_div_2_Template_input_dateChange_6_listener($event) { i0.ɵɵrestoreView(_r13); const ctx_r15 = i0.ɵɵnextContext(2); return ctx_r15.handleDateChange($event); });
    i0.ɵɵpipe(7, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(8, "div", 8);
    i0.ɵɵelementStart(9, "mat-form-field");
    i0.ɵɵelement(10, "mat-datetimepicker-toggle", 4);
    i0.ɵɵelement(11, "mat-datetimepicker", 5, 11);
    i0.ɵɵelementStart(13, "input", 7);
    i0.ɵɵlistener("ngModelChange", function TimeFilterFormComponent_div_0_div_2_Template_input_ngModelChange_13_listener($event) { i0.ɵɵrestoreView(_r13); const ctx_r16 = i0.ɵɵnextContext(2); return ctx_r16.endDate = $event; })("dateChange", function TimeFilterFormComponent_div_0_div_2_Template_input_dateChange_13_listener($event) { i0.ɵɵrestoreView(_r13); const ctx_r17 = i0.ɵɵnextContext(2); return ctx_r17.handleDateChange($event); });
    i0.ɵɵpipe(14, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r10 = i0.ɵɵreference(5);
    const _r11 = i0.ɵɵreference(12);
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("for", _r10);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("type", ctx_r5.type);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(7, 14, "igo.geo.timeFilter.startDate"));
    i0.ɵɵproperty("matDatetimepicker", _r10)("ngModel", ctx_r5.startDate)("min", ctx_r5.min)("max", ctx_r5.getRangeMaxDate());
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("for", _r11);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("type", ctx_r5.type);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(14, 16, "igo.geo.timeFilter.endDate"));
    i0.ɵɵproperty("matDatetimepicker", _r11)("ngModel", ctx_r5.endDate)("min", ctx_r5.getRangeMinDate())("max", ctx_r5.max);
} }
function TimeFilterFormComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtemplate(1, TimeFilterFormComponent_div_0_div_1_Template, 7, 9, "div", 2);
    i0.ɵɵtemplate(2, TimeFilterFormComponent_div_0_div_2_Template, 15, 18, "div", 0);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !ctx_r0.isRange);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.isRange);
} }
function TimeFilterFormComponent_div_1_div_1_mat_option_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 14);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const year_r21 = ctx.$implicit;
    i0.ɵɵproperty("value", year_r21);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(year_r21);
} }
function TimeFilterFormComponent_div_1_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r23 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 3);
    i0.ɵɵelementStart(1, "mat-form-field");
    i0.ɵɵelementStart(2, "mat-select", 12);
    i0.ɵɵlistener("ngModelChange", function TimeFilterFormComponent_div_1_div_1_Template_mat_select_ngModelChange_2_listener($event) { i0.ɵɵrestoreView(_r23); const ctx_r22 = i0.ɵɵnextContext(2); return ctx_r22.year = $event; })("selectionChange", function TimeFilterFormComponent_div_1_div_1_Template_mat_select_selectionChange_2_listener($event) { i0.ɵɵrestoreView(_r23); const ctx_r24 = i0.ɵɵnextContext(2); return ctx_r24.handleYearChange($event); });
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵtemplate(4, TimeFilterFormComponent_div_1_div_1_mat_option_4_Template, 2, 2, "mat-option", 13);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r18 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(3, 3, "igo.geo.timeFilter.date"));
    i0.ɵɵproperty("ngModel", ctx_r18.year);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r18.listYears);
} }
function TimeFilterFormComponent_div_1_div_2_mat_option_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 14);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const startYear_r27 = ctx.$implicit;
    i0.ɵɵproperty("value", startYear_r27);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(startYear_r27);
} }
function TimeFilterFormComponent_div_1_div_2_mat_option_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 14);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const endYear_r28 = ctx.$implicit;
    i0.ɵɵproperty("value", endYear_r28);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(endYear_r28);
} }
function TimeFilterFormComponent_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r30 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelementStart(1, "div", 8);
    i0.ɵɵelementStart(2, "mat-form-field");
    i0.ɵɵelementStart(3, "mat-select", 12);
    i0.ɵɵlistener("ngModelChange", function TimeFilterFormComponent_div_1_div_2_Template_mat_select_ngModelChange_3_listener($event) { i0.ɵɵrestoreView(_r30); const ctx_r29 = i0.ɵɵnextContext(2); return ctx_r29.startYear = $event; })("selectionChange", function TimeFilterFormComponent_div_1_div_2_Template_mat_select_selectionChange_3_listener($event) { i0.ɵɵrestoreView(_r30); const ctx_r31 = i0.ɵɵnextContext(2); return ctx_r31.handleYearChange($event); });
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵtemplate(5, TimeFilterFormComponent_div_1_div_2_mat_option_5_Template, 2, 2, "mat-option", 13);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(6, "div", 8);
    i0.ɵɵelementStart(7, "mat-form-field");
    i0.ɵɵelementStart(8, "mat-select", 12);
    i0.ɵɵlistener("ngModelChange", function TimeFilterFormComponent_div_1_div_2_Template_mat_select_ngModelChange_8_listener($event) { i0.ɵɵrestoreView(_r30); const ctx_r32 = i0.ɵɵnextContext(2); return ctx_r32.endYear = $event; })("selectionChange", function TimeFilterFormComponent_div_1_div_2_Template_mat_select_selectionChange_8_listener($event) { i0.ɵɵrestoreView(_r30); const ctx_r33 = i0.ɵɵnextContext(2); return ctx_r33.handleYearChange($event); });
    i0.ɵɵpipe(9, "translate");
    i0.ɵɵtemplate(10, TimeFilterFormComponent_div_1_div_2_mat_option_10_Template, 2, 2, "mat-option", 13);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r19 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(4, 6, "igo.geo.timeFilter.startDate"));
    i0.ɵɵproperty("ngModel", ctx_r19.startYear);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r19.startListYears);
    i0.ɵɵadvance(3);
    i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(9, 8, "igo.geo.timeFilter.endDate"));
    i0.ɵɵproperty("ngModel", ctx_r19.endYear);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r19.endListYears);
} }
function TimeFilterFormComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtemplate(1, TimeFilterFormComponent_div_1_div_1_Template, 5, 5, "div", 2);
    i0.ɵɵtemplate(2, TimeFilterFormComponent_div_1_div_2_Template, 11, 10, "div", 0);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !ctx_r1.isRange);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r1.isRange);
} }
function TimeFilterFormComponent_div_3_p_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 23);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r34 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r34.year);
} }
function TimeFilterFormComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r37 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵelementStart(1, "span");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "mat-slider", 16);
    i0.ɵɵlistener("input", function TimeFilterFormComponent_div_3_Template_mat_slider_input_3_listener($event) { i0.ɵɵrestoreView(_r37); const ctx_r36 = i0.ɵɵnextContext(); return ctx_r36.handleSliderYearChange($event); })("change", function TimeFilterFormComponent_div_3_Template_mat_slider_change_3_listener($event) { i0.ɵɵrestoreView(_r37); const ctx_r38 = i0.ɵɵnextContext(); return ctx_r38.handleSliderYearChange($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "span");
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(6, TimeFilterFormComponent_div_3_p_6_Template, 2, 1, "p", 17);
    i0.ɵɵelementStart(7, "div", 18, 19);
    i0.ɵɵelementStart(9, "mat-slide-toggle", 20);
    i0.ɵɵlistener("change", function TimeFilterFormComponent_div_3_Template_mat_slide_toggle_change_9_listener() { i0.ɵɵrestoreView(_r37); const ctx_r39 = i0.ɵɵnextContext(); return ctx_r39.toggleFilterState(); });
    i0.ɵɵpipe(10, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(11, "button", 21);
    i0.ɵɵlistener("click", function TimeFilterFormComponent_div_3_Template_button_click_11_listener($event) { i0.ɵɵrestoreView(_r37); const ctx_r40 = i0.ɵɵnextContext(); return ctx_r40.playYear($event); });
    i0.ɵɵelement(12, "mat-icon", 22);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(13, "button", 21);
    i0.ɵɵlistener("click", function TimeFilterFormComponent_div_3_Template_button_click_13_listener($event) { i0.ɵɵrestoreView(_r37); const ctx_r41 = i0.ɵɵnextContext(); return ctx_r41.resetFilter($event); });
    i0.ɵɵelement(14, "mat-icon", 22);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r2.startYear);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("step", ctx_r2.step);
    i0.ɵɵproperty("min", ctx_r2.startYear)("max", ctx_r2.endYear)("value", ctx_r2.handleSliderValue())("color", ctx_r2.color)("disabled", !ctx_r2.options.enabled || !ctx_r2.layer.visible);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r2.endYear);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.options.enabled);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(10, 17, "igo.geo.filter.toggleFilterState"))("color", ctx_r2.color)("checked", ctx_r2.options.enabled)("disabled", !ctx_r2.layer.visible);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("disabled", !ctx_r2.options.enabled || !ctx_r2.layer.visible);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("svgIcon", ctx_r2.playIcon);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("disabled", !ctx_r2.options.enabled || !ctx_r2.layer.visible);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("svgIcon", ctx_r2.resetIcon);
} }
function TimeFilterFormComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r43 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 3);
    i0.ɵɵelementStart(1, "mat-slider", 24);
    i0.ɵɵlistener("input", function TimeFilterFormComponent_div_4_Template_mat_slider_input_1_listener($event) { i0.ɵɵrestoreView(_r43); const ctx_r42 = i0.ɵɵnextContext(); return ctx_r42.handleSliderDateChange($event); })("selectionChange", function TimeFilterFormComponent_div_4_Template_mat_slider_selectionChange_1_listener($event) { i0.ɵɵrestoreView(_r43); const ctx_r44 = i0.ɵɵnextContext(); return ctx_r44.handleSliderDateChange($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(2, "p", 23);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "button", 25);
    i0.ɵɵlistener("click", function TimeFilterFormComponent_div_4_Template_button_click_4_listener($event) { i0.ɵɵrestoreView(_r43); const ctx_r45 = i0.ɵɵnextContext(); return ctx_r45.playFilter($event); });
    i0.ɵɵelement(5, "mat-icon", 22);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("step", ctx_r3.step);
    i0.ɵɵproperty("min", ctx_r3.dateToNumber(ctx_r3.min))("max", ctx_r3.dateToNumber(ctx_r3.max))("value", ctx_r3.handleSliderValue());
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r3.handleSliderTooltip());
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("svgIcon", ctx_r3.playIcon);
} }
class TimeFilterFormComponent {
    constructor(dateAdapter) {
        this.dateAdapter = dateAdapter;
        this.color = 'primary';
        this.listYears = [];
        this.startListYears = [];
        this.endListYears = [];
        this.playIcon = 'play-circle';
        this.resetIcon = 'replay';
        this.change = new EventEmitter();
        this.yearChange = new EventEmitter();
        this.dateAdapter.setLocale('fr');
    }
    set currentValue(value) {
        if (value) {
            if (this.type !== TimeFilterType.YEAR) {
                const valueArray = value.split('/');
                if (valueArray.length > 0) {
                    const startDate = new Date(valueArray[0]);
                    const endDate = new Date(valueArray[1]);
                    if (!isNaN(startDate.valueOf())) {
                        this.startDate = startDate;
                    }
                    if (!isNaN(endDate.valueOf())) {
                        this.endDate = endDate;
                    }
                }
            }
        }
    }
    get type() {
        return this.options.type === undefined
            ? TimeFilterType.DATE
            : this.options.type;
    }
    get isRange() {
        return this.options.range === undefined ||
            this.options.style === TimeFilterStyle.SLIDER
            ? false
            : this.options.range;
    }
    get style() {
        return this.options.style === undefined
            ? TimeFilterStyle.SLIDER
            : this.options.style;
    }
    get step() {
        let step = 10800000;
        if (this.options.step === undefined) {
            switch (this.type) {
                case TimeFilterType.DATE:
                case TimeFilterType.DATETIME:
                    step = 10800000;
                    break;
                case TimeFilterType.TIME:
                    step = 3600000;
                    break;
                case TimeFilterType.YEAR:
                    step = 31536000000;
                    break;
                default:
                    step = 10800000;
            }
        }
        else {
            step = this.getStepDefinition(this.options.step);
        }
        return step;
    }
    get timeInterval() {
        return this.options.timeInterval === undefined
            ? 2000
            : this.options.timeInterval;
    }
    get min() {
        if (this.options.min) {
            const min = new Date(this.options.min);
            return new Date(min.getTime() + min.getTimezoneOffset() * 60000);
        }
        else {
            return undefined;
        }
    }
    get max() {
        if (this.options.max) {
            const max = new Date(this.options.max);
            return new Date(max.getTime() + max.getTimezoneOffset() * 60000);
        }
        else {
            return undefined;
        }
    }
    get is() {
        return this.options.range === undefined ? false : this.options.range;
    }
    ngOnInit() {
        if (this.startDate === undefined) {
            this.startDate = new Date(this.min);
        }
        if (this.endDate === undefined) {
            this.endDate = new Date(this.max);
        }
        if (this.startYear === undefined) {
            this.startYear = new Date(this.startDate).getFullYear();
            this.initStartYear = this.startYear;
        }
        if (this.endYear === undefined) {
            this.endYear = new Date(this.endDate).getFullYear();
            this.initEndYear = this.endYear;
        }
        if (!this.isRange) {
            for (let i = this.startYear; i <= this.endYear + 1; i++) {
                this.listYears.push(i);
            }
        }
        else {
            for (let i = this.startYear; i < this.endYear; i++) {
                this.startListYears.push(i);
            }
            for (let i = this.startYear + 1; i <= this.endYear; i++) {
                this.endListYears.push(i);
            }
        }
        this.options.enabled =
            this.options.enabled === undefined ? true : this.options.enabled;
        this.checkFilterValue();
        if (this.options.enabled) {
            if (!this.isRange && this.style === 'slider' && this.type === 'year') {
                this.yearChange.emit(this.year);
            }
        }
        else {
            this.storeCurrentFilterValue();
            this.yearChange.emit(undefined); // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        }
    }
    storeCurrentFilterValue() {
        // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        if (!this.isRange &&
            this.style === TimeFilterStyle.SLIDER &&
            this.type === TimeFilterType.YEAR) {
            this.options.value = this.year.toString();
        }
    }
    checkFilterValue() {
        const olSource = this.layer.dataSource.ol;
        const timeFromWms = olSource.getParams().TIME;
        if (!this.isRange &&
            this.style === TimeFilterStyle.SLIDER &&
            this.type === TimeFilterType.YEAR) {
            if (timeFromWms) {
                this.year = new Date(timeFromWms.toString()).getFullYear() + 1;
            }
            else if (this.options.value) {
                this.year = new Date(this.options.value.toString()).getFullYear() + 1;
            }
            else {
                this.year = new Date(this.min).getFullYear() + 1;
            }
        }
        else if (this.isRange &&
            this.style === TimeFilterStyle.CALENDAR &&
            this.type === TimeFilterType.YEAR) {
            if (timeFromWms) {
                this.startYear = parseInt(timeFromWms.substr(0, 4), 10);
                this.endYear = parseInt(timeFromWms.substr(5, 4), 10);
                const newStartListYears = [];
                const newEndListYears = [];
                for (let i = this.initStartYear; i < this.endYear; i++) {
                    newStartListYears.push(i);
                }
                for (let i = this.startYear + 1; i <= this.initEndYear; i++) {
                    newEndListYears.push(i);
                }
                this.startListYears = newStartListYears;
                this.endListYears = newEndListYears;
            }
        }
        // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
    }
    handleDateChange(event) {
        this.setupDateOutput();
        this.applyTypeChange();
        // Only if is range, use 2 dates to make the range
        if (this.isRange) {
            this.change.emit([this.startDate, this.endDate]);
        }
        else {
            this.change.emit(this.startDate);
        }
    }
    handleYearChange(event) {
        if (this.isRange) {
            this.endListYears = [];
            for (let i = this.startYear + 1; i <= this.initEndYear; i++) {
                this.endListYears.push(i);
            }
            this.startListYears = [];
            for (let i = this.initStartYear + 1; i < this.endYear; i++) {
                this.startListYears.push(i);
            }
            this.yearChange.emit([this.startYear, this.endYear]);
        }
        else {
            this.yearChange.emit(this.year);
        }
    }
    handleListYearChange(event) {
        this.handleYearChange([this.startYear, this.endYear]);
    }
    handleListYearStartChange(event) {
        this.change.emit([this.startDate, this.endDate]);
    }
    dateToNumber(date) {
        let newDate;
        if (date) {
            newDate = new Date(date);
        }
        else {
            newDate = new Date(this.min);
        }
        return newDate.getTime();
    }
    setSliderThumbLabel(label) {
        const thumbLabel = this.findThumbLabel(this.mySlider._elementRef.nativeElement.childNodes);
        if (thumbLabel) {
            thumbLabel.textContent = label;
        }
    }
    findThumbLabel(test) {
        let thumbLabel;
        test.forEach(value => {
            if (value.className === 'mat-slider-thumb-label-text') {
                thumbLabel = value;
            }
            if (value.children.length > 0 && !thumbLabel) {
                thumbLabel = this.findThumbLabel(value.childNodes);
            }
        }, this);
        return thumbLabel;
    }
    toggleFilterState() {
        this.options.enabled = !this.options.enabled;
        if (this.options.enabled) {
            if (!this.isRange &&
                TimeFilterStyle.SLIDER &&
                this.type === TimeFilterType.YEAR) {
                this.yearChange.emit(this.year);
            }
        }
        else {
            this.stopFilter();
            this.storeCurrentFilterValue();
            this.change.emit(undefined); // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        }
    }
    resetFilter(event) {
        this.date = new Date(this.min);
        this.year = this.date.getFullYear();
        if (!this.isRange &&
            TimeFilterStyle.SLIDER &&
            this.type === TimeFilterType.YEAR) {
            this.yearChange.emit(this.year);
        }
        else {
            this.setupDateOutput();
            this.change.emit(undefined); // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        }
    }
    playFilter(event) {
        if (this.interval) {
            this.stopFilter();
        }
        else {
            this.playIcon = 'pause-circle';
            this.interval = setInterval(that => {
                let newMinDateNumber;
                const maxDateNumber = new Date(that.max);
                newMinDateNumber =
                    that.date === undefined ? that.min.getTime() : that.date.getTime();
                newMinDateNumber += that.mySlider.step;
                that.date = new Date(newMinDateNumber);
                if (newMinDateNumber > maxDateNumber.getTime()) {
                    that.stopFilter();
                }
                that.handleDateChange({ value: that.date, date: that.date });
            }, this.timeInterval, this);
        }
    }
    playYear(event) {
        if (this.year + this.mySlider.step >
            this.max.getFullYear() + this.mySlider.step) {
            this.stopFilter();
            this.resetFilter(event);
        }
        if (this.interval) {
            this.stopFilter();
        }
        else {
            this.playIcon = 'pause-circle';
            this.interval = setInterval(() => {
                if ((this.year + this.mySlider.step) > this.max.getFullYear()) {
                    this.stopFilter();
                }
                else {
                    this.year = this.year + this.mySlider.step;
                }
                this.yearChange.emit(this.year);
            }, this.timeInterval, this);
        }
    }
    stopFilter() {
        if (this.interval) {
            clearInterval(this.interval);
        }
        this.interval = undefined;
        this.playIcon = 'play-circle';
    }
    handleSliderDateChange(event) {
        this.date = new Date(event.value);
        this.setSliderThumbLabel(this.handleSliderTooltip());
        this.handleDateChange(event);
    }
    handleSliderYearChange(event) {
        this.year = event.value;
        this.yearChange.emit(this.year);
    }
    handleSliderValue() {
        if (this.options.current === true || !this.min) {
            const currentDate = new Date();
            this.date = this.getRoundedDate(currentDate);
        }
        if (this.type === TimeFilterType.YEAR) {
            return this.year;
        }
        else {
            return this.date === undefined ? this.min.getTime() : this.date.getTime();
        }
    }
    handleSliderTooltip() {
        let label;
        switch (this.type) {
            case TimeFilterType.DATE:
                label =
                    this.date === undefined
                        ? this.min.toDateString()
                        : this.date.toDateString();
                break;
            case TimeFilterType.TIME:
                label =
                    this.date === undefined
                        ? this.min.toTimeString()
                        : this.date.toTimeString();
                break;
            // datetime
            default:
                label =
                    this.date === undefined
                        ? this.min.toUTCString()
                        : this.date.toUTCString();
                break;
        }
        return label;
    }
    setupDateOutput() {
        if (this.style === TimeFilterStyle.SLIDER) {
            this.startDate = new Date(this.date);
            this.startDate.setSeconds(-(this.step / 1000));
            this.endDate = new Date(this.startDate);
            this.endDate.setSeconds(this.step / 1000);
        }
        else if (!this.isRange && !!this.date) {
            this.endDate = new Date(this.date);
            this.startDate = new Date(this.date);
        }
        else if (this.isRange && (!!this.date || !this.date)) {
            this.startDate =
                this.startDate === undefined ? new Date(this.min) : this.startDate;
            this.endDate =
                this.endDate === undefined ? new Date(this.max) : this.endDate;
        }
        else if (!this.date) {
            this.startDate =
                this.startDate === undefined ? new Date(this.min) : this.startDate;
            this.endDate =
                this.endDate === undefined ? new Date(this.max) : this.endDate;
        }
    }
    applyTypeChange() {
        switch (this.type) {
            case TimeFilterType.DATE:
                if (this.startDate !== undefined || this.endDate !== undefined) {
                    this.startDate.setHours(0);
                    this.startDate.setMinutes(0);
                    this.startDate.setSeconds(0);
                    this.endDate.setHours(23);
                    this.endDate.setMinutes(59);
                    this.endDate.setSeconds(59);
                }
                break;
            case TimeFilterType.TIME:
                if (this.style === TimeFilterStyle.CALENDAR) {
                    if (this.startDate.getDay() !== this.min.getDay()) {
                        const selectedHour = this.startDate.getHours();
                        const selectedMinute = this.startDate.getMinutes();
                        this.startDate = this.min;
                        this.startDate.setHours(selectedHour);
                        this.startDate.setMinutes(selectedMinute);
                    }
                    if (this.endDate.getDay() !== this.min.getDay()) {
                        const selectedHour = this.endDate.getHours();
                        const selectedMinute = this.endDate.getMinutes();
                        this.endDate = this.min;
                        this.endDate.setHours(selectedHour);
                        this.endDate.setMinutes(selectedMinute);
                    }
                }
                if (!this.isRange && this.step > 60 * 60 * 1000) {
                    this.startDate.setMinutes(0);
                    this.startDate.setSeconds(0);
                    this.endDate.setMinutes(59);
                    this.endDate.setSeconds(59);
                }
                break;
            // datetime
            default:
            // do nothing
        }
    }
    getRangeMinDate() {
        return this.startDate === undefined ? this.min : this.startDate;
    }
    getRangeMaxDate() {
        return this.endDate === undefined ? this.max : this.endDate;
    }
    /**
     * Round date at a certain time, 10 minutes by Default
     * @param date - Date to Round
     * @param atMinute - round to closest 'atMinute' minute, rounded 10 by default
     * @return the rounded date
     */
    getRoundedDate(date, atMinute = 10) {
        const coeff = 1000 * 60 * atMinute;
        return new Date(Math.round(date.getTime() / coeff) * coeff);
    }
    /**
     * Get the step (period) definition from the layer dimension tag
     * @param step The step as ISO 8601 example: PT10M for 10 Minutes
     * @return the duration in milliseconds
     */
    getStepDefinition(step) {
        return moment_.duration(step).asMilliseconds();
    }
}
TimeFilterFormComponent.ɵfac = function TimeFilterFormComponent_Factory(t) { return new (t || TimeFilterFormComponent)(i0.ɵɵdirectiveInject(i9.DateAdapter)); };
TimeFilterFormComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TimeFilterFormComponent, selectors: [["igo-time-filter-form"]], viewQuery: function TimeFilterFormComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(MatSlider, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.mySlider = _t.first);
    } }, inputs: { layer: "layer", options: "options", currentValue: "currentValue" }, outputs: { change: "change", yearChange: "yearChange" }, decls: 5, vars: 4, consts: [[4, "ngIf"], ["class", "igo-col igo-col-100 igo-col-100-m mat-typography", 4, "ngIf"], ["class", "igo-col igo-col-100 igo-col-100-m", 4, "ngIf"], [1, "igo-col", "igo-col-100", "igo-col-100-m"], ["matSuffix", "", 3, "for"], ["openOnFocus", "true", "timeInterval", "5", 3, "type"], ["datetimePicker", ""], ["matInput", "", "autocomplete", "false", "readonly", "readonly", 3, "placeholder", "matDatetimepicker", "ngModel", "min", "max", "ngModelChange", "dateChange"], [1, "igo-col", "igo-col-100"], ["minDatetimePicker", ""], ["matInput", "", "autocomplete", "false", "readonly", "readonly", 3, "placeholder", "matDatetimepicker", "ngModel", "min", "max", "ngModelChange", "input", "dateChange"], ["maxDatetimePicker", ""], [3, "placeholder", "ngModel", "ngModelChange", "selectionChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "igo-col", "igo-col-100", "igo-col-100-m", "mat-typography"], ["id", "time-slider", "tickInterval", "auto", "thumbLabel", "", 3, "step", "min", "max", "value", "color", "disabled", "input", "change"], ["class", "date-below", 4, "ngIf"], [1, "igo-layer-actions-container"], ["actions", ""], ["tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", "checked", "disabled", "change"], ["mat-icon-button", "", "color", "primary", 3, "disabled", "click"], [3, "svgIcon"], [1, "date-below"], ["id", "time-slider", "tickInterval", "auto", "thumbLabel", "", 3, "step", "min", "max", "value", "input", "selectionChange"], ["mat-icon-button", "", "color", "primary", 3, "click"]], template: function TimeFilterFormComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TimeFilterFormComponent_div_0_Template, 3, 2, "div", 0);
        i0.ɵɵtemplate(1, TimeFilterFormComponent_div_1_Template, 3, 2, "div", 0);
        i0.ɵɵelement(2, "br");
        i0.ɵɵtemplate(3, TimeFilterFormComponent_div_3_Template, 15, 19, "div", 1);
        i0.ɵɵtemplate(4, TimeFilterFormComponent_div_4_Template, 6, 6, "div", 2);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.style === "calendar" && ctx.type !== "year");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.style === "calendar" && ctx.type === "year");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.isRange && ctx.style === "slider" && ctx.type === "year");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.style === "slider" && ctx.type !== "year");
    } }, directives: [i1$1.NgIf, i12.MatFormField, i4$1.MatDatetimepickerToggle, i12.MatSuffix, i4$1.MatDatetimepicker, i5$1.MatInput, i4$1.MatDatetimepickerInput, i16.DefaultValueAccessor, i16.NgControlStatus, i16.NgModel, i13.MatSelect, i1$1.NgForOf, i9.MatOption, i13$1.MatSlider, i22.MatSlideToggle, i3.MatTooltip, i2.MatButton, i4.MatIcon], pipes: [i7.TranslatePipe], styles: [".igo-layer-filters-container[_ngcontent-%COMP%]{padding-left:5px}mat-slider[_ngcontent-%COMP%]     div.mat-slider-thumb-label{width:32px;height:32px;margin:0 auto}mat-slider[_ngcontent-%COMP%]     span.mat-slider-thumb-label-text{font-size:10px}#time-slider[_ngcontent-%COMP%]{width:70%;margin:0 auto}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){#time-slider[_ngcontent-%COMP%]{width:60%;margin:0 auto}}.date-below[_ngcontent-%COMP%]{margin:0}mat-form-field[_ngcontent-%COMP%]{text-align:center}mat-datetimepicker-toggle[_ngcontent-%COMP%]     .mat-icon{padding-bottom:30px}.igo-layer-actions-container[_ngcontent-%COMP%] > .mat-slide-toggle[_ngcontent-%COMP%]{vertical-align:middle}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TimeFilterFormComponent, [{
        type: Component,
        args: [{
                selector: 'igo-time-filter-form',
                templateUrl: './time-filter-form.component.html',
                styleUrls: ['./time-filter-form.component.scss']
            }]
    }], function () { return [{ type: i9.DateAdapter }]; }, { layer: [{
            type: Input
        }], options: [{
            type: Input
        }], currentValue: [{
            type: Input
        }], change: [{
            type: Output
        }], yearChange: [{
            type: Output
        }], mySlider: [{
            type: ViewChild,
            args: [MatSlider]
        }] }); })();

const _c0$9 = function (a0) { return { disabled: a0 }; };
function TimeFilterItemComponent_mat_list_item_0_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r6 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 10);
    i0.ɵɵlistener("click", function TimeFilterItemComponent_mat_list_item_0_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r6); const ctx_r5 = i0.ɵɵnextContext(2); return ctx_r5.layer.visible = !ctx_r5.layer.visible; });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelement(3, "mat-icon", 11);
    i0.ɵɵpipe(4, "async");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("color", ctx_r4.layer.visible ? "primary" : "default")("matTooltip", ctx_r4.layer.visible ? i0.ɵɵpipeBind1(1, 4, "igo.geo.layer.hideLayer") : i0.ɵɵpipeBind1(2, 6, "igo.geo.layer.showLayer"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(10, _c0$9, i0.ɵɵpipeBind1(4, 8, ctx_r4.inResolutionRange$) === false))("svgIcon", ctx_r4.layer.visible ? "eye" : "eye-off");
} }
const _c1$8 = function (a0) { return { "cursor": a0 }; };
function TimeFilterItemComponent_mat_list_item_0_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-list-item");
    i0.ɵɵelementStart(1, "mat-icon", 7);
    i0.ɵɵlistener("click", function TimeFilterItemComponent_mat_list_item_0_Template_mat_icon_click_1_listener() { i0.ɵɵrestoreView(_r8); const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.toggleFiltersCollapsed(); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(2, "h4", 8);
    i0.ɵɵlistener("click", function TimeFilterItemComponent_mat_list_item_0_Template_h4_click_2_listener() { i0.ɵɵrestoreView(_r8); const ctx_r9 = i0.ɵɵnextContext(); return ctx_r9.toggleLegendOnClick(); });
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(4, TimeFilterItemComponent_mat_list_item_0_button_4_Template, 5, 12, "button", 9);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    const _r1 = i0.ɵɵreference(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("target", _r1)("collapsed", ctx_r0.filtersCollapsed);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(5, _c1$8, ctx_r0.filtersCollapsed ? "default" : "pointer"));
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r0.layer.title);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.header);
} }
function TimeFilterItemComponent_igo_layer_legend_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-layer-legend", 12);
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("layer", ctx_r3.layer);
} }
class TimeFilterItemComponent {
    constructor(timeFilterService) {
        this.timeFilterService = timeFilterService;
        this.color = 'primary';
        this.showLegend$ = new BehaviorSubject(false);
        this.inResolutionRange$ = new BehaviorSubject(true);
        this.filtersCollapsed = false;
        this.header = true;
    }
    get datasource() {
        return this.layer.dataSource;
    }
    ngOnInit() {
        const resolution$ = this.layer.map.viewController.resolution$;
        this.resolution$$ = resolution$.subscribe(() => {
            this.inResolutionRange$.next(this.layer.isInResolutionsRange);
        });
    }
    ngOnDestroy() {
        this.resolution$$.unsubscribe();
    }
    handleYearChange(year) {
        this.timeFilterService.filterByYear(this.datasource, year);
    }
    handleDateChange(date) {
        this.timeFilterService.filterByDate(this.datasource, date);
    }
    toggleLegend(collapsed) {
        this.layer.legendCollapsed = collapsed;
        this.showLegend$.next(!collapsed);
    }
    toggleLegendOnClick() {
        if (!this.filtersCollapsed) {
            this.toggleLegend(this.showLegend$.value);
        }
    }
    setVisible() {
        this.layer.visible = true;
    }
    toggleFiltersCollapsed() {
        this.filtersCollapsed = !this.filtersCollapsed;
    }
}
TimeFilterItemComponent.ɵfac = function TimeFilterItemComponent_Factory(t) { return new (t || TimeFilterItemComponent)(i0.ɵɵdirectiveInject(TimeFilterService)); };
TimeFilterItemComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TimeFilterItemComponent, selectors: [["igo-time-filter-item"]], inputs: { header: "header", layer: "layer" }, decls: 8, vars: 7, consts: [[4, "ngIf"], [1, "igo-datasource-filters-container"], ["filters", ""], [1, "igo-layer-legend-container"], ["legend", ""], [3, "layer", 4, "ngIf"], [3, "layer", "options", "currentValue", "change", "yearChange"], ["mat-list-avatar", "", "igoCollapse", "", "svgIcon", "chevron-up", 1, "igo-chevron", 3, "target", "collapsed", "click"], ["matLine", "", 3, "ngStyle", "click"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "color", "matTooltip", "click", 4, "ngIf"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "color", "matTooltip", "click"], [3, "ngClass", "svgIcon"], [3, "layer"]], template: function TimeFilterItemComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TimeFilterItemComponent_mat_list_item_0_Template, 5, 7, "mat-list-item", 0);
        i0.ɵɵelementStart(1, "div", 1, 2);
        i0.ɵɵelementStart(3, "div", 3, 4);
        i0.ɵɵtemplate(5, TimeFilterItemComponent_igo_layer_legend_5_Template, 1, 1, "igo-layer-legend", 5);
        i0.ɵɵpipe(6, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(7, "igo-time-filter-form", 6);
        i0.ɵɵlistener("change", function TimeFilterItemComponent_Template_igo_time_filter_form_change_7_listener($event) { return ctx.handleDateChange($event); })("yearChange", function TimeFilterItemComponent_Template_igo_time_filter_form_yearChange_7_listener($event) { return ctx.handleYearChange($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.header);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(6, 5, ctx.showLegend$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("layer", ctx.layer)("options", ctx.datasource.options.timeFilter)("currentValue", ctx.datasource.options.params.TIME);
    } }, styles: ["[_nghost-%COMP%]{overflow:hidden}.igo-datasource-filters-container[_ngcontent-%COMP%]{text-align:center;width:100%;display:inline-block;padding-top:5px}.igo-layer-legend-container[_ngcontent-%COMP%]{padding-left:1.125em;width:calc(100% - 18px)}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TimeFilterItemComponent, [{
        type: Component,
        args: [{
                selector: 'igo-time-filter-item',
                templateUrl: './time-filter-item.component.html',
                styleUrls: ['./time-filter-item.component.scss']
            }]
    }], function () { return [{ type: TimeFilterService }]; }, { header: [{
            type: Input
        }], layer: [{
            type: Input
        }] }); })();

function TimeFilterListComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-time-filter-item", 2);
} if (rf & 2) {
    const layer_r1 = ctx.$implicit;
    i0.ɵɵproperty("header", true)("layer", layer_r1);
} }
class TimeFilterListComponent {
    constructor(cdRef) {
        this.cdRef = cdRef;
        this._layers = [];
    }
    get layers() {
        return this._layers;
    }
    set layers(value) {
        this._layers = value;
        this.cdRef.detectChanges();
    }
}
TimeFilterListComponent.ɵfac = function TimeFilterListComponent_Factory(t) { return new (t || TimeFilterListComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
TimeFilterListComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TimeFilterListComponent, selectors: [["igo-time-filter-list"]], inputs: { layers: "layers" }, decls: 3, vars: 6, consts: [[3, "navigation", "selection"], ["ngFor", "", 3, "ngForOf"], ["igoListItem", "", 3, "header", "layer"]], template: function TimeFilterListComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "igo-list", 0);
        i0.ɵɵtemplate(1, TimeFilterListComponent_ng_template_1_Template, 1, 2, "ng-template", 1);
        i0.ɵɵpipe(2, "filterableDataSource");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("navigation", false)("selection", false);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind2(2, 3, ctx.layers, "time"));
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TimeFilterListComponent, [{
        type: Component,
        args: [{
                selector: 'igo-time-filter-list',
                templateUrl: './time-filter-list.component.html',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }]; }, { layers: [{
            type: Input
        }] }); })();

class TimeFilterListBindingDirective {
    constructor(component, mapService) {
        this.mapService = mapService;
        this.component = component;
    }
    ngOnInit() {
        // Override input layers
        this.component.layers = [];
        this.layers$$ = this.mapService.getMap().layers$.subscribe(layers => {
            this.component.layers = layers;
        });
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
    }
}
TimeFilterListBindingDirective.ɵfac = function TimeFilterListBindingDirective_Factory(t) { return new (t || TimeFilterListBindingDirective)(i0.ɵɵdirectiveInject(TimeFilterListComponent, 2), i0.ɵɵdirectiveInject(MapService)); };
TimeFilterListBindingDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TimeFilterListBindingDirective, selectors: [["", "igoTimeFilterListBinding", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TimeFilterListBindingDirective, [{
        type: Directive,
        args: [{
                selector: '[igoTimeFilterListBinding]'
            }]
    }], function () { return [{ type: TimeFilterListComponent, decorators: [{
                type: Self
            }] }, { type: MapService }]; }, null); })();

class WktService {
    constructor() { }
    wktToFeature(wkt, wktProj, featureProj) {
        return new olWKT().readFeature(wkt, {
            dataProjection: wktProj,
            featureProjection: featureProj
        });
    }
    extentToWkt(epsgTO, extent, extentProj) {
        let currentExtent = olproj.transformExtent(extent, extentProj, epsgTO);
        currentExtent = this.roundCoordinateArray(currentExtent, epsgTO, 0);
        const wktPoly = `POLYGON((
      ${extent[0]} ${extent[1]},
      ${extent[0]} ${extent[3]},
      ${extent[2]} ${extent[3]},
      ${extent[2]} ${extent[1]},
      ${extent[0]} ${extent[1]}))`;
        const wktLine = `LINESTRING(
      ${extent[0]} ${extent[1]},
      ${extent[0]} ${extent[3]},
      ${extent[2]} ${extent[3]},
      ${extent[2]} ${extent[1]},
      ${extent[0]} ${extent[1]})`;
        const wktMultiPoints = `MULTIPOINT(
        ${extent[0]} ${extent[1]},
        ${extent[0]} ${extent[3]},
        ${extent[2]} ${extent[3]},
        ${extent[2]} ${extent[1]})`;
        return {
            wktPoly,
            wktLine,
            wktMultiPoints
        };
    }
    roundCoordinateArray(coordinateArray, projection, decimal = 0) {
        const lproj = olproj.get(projection);
        const units = lproj.getUnits();
        const olUnits = ['ft', 'm', 'us-ft'];
        if (olUnits.indexOf(units) !== -1) {
            coordinateArray = this.roundArray(coordinateArray, decimal);
        }
        return coordinateArray;
    }
    roundArray(array, decimal = 0) {
        let x = 0;
        while (x < array.length) {
            array[x] = array[x].toFixed(decimal);
            x++;
        }
        return array;
    }
    snrcToWkt(snrc, epsgTO) {
        snrc = snrc.toLowerCase();
        let wktPoly;
        const ew = {
            1: { from: -56, to: -64 },
            2: { from: -64, to: -72 },
            3: { from: -72, to: -80 },
            4: { from: -80, to: -88 },
            5: { from: -88, to: -96 },
            6: { from: -96, to: -104 },
            7: { from: -104, to: -112 },
            8: { from: -112, to: -120 },
            9: { from: -120, to: -128 },
            10: { from: -128, to: -136 }
        };
        const sn = {
            1: { from: 44, to: 48 },
            2: { from: 48, to: 52 },
            3: { from: 52, to: 56 },
            4: { from: 56, to: 60 },
            5: { from: 60, to: 64 },
            6: { from: 64, to: 68 },
            7: { from: 68, to: 72 },
            8: { from: 72, to: 76 },
            9: { from: 76, to: -128 }
        };
        const snrc250kIndex = [
            ['m', 'n', 'o', 'p'],
            ['l', 'k', 'j', 'i'],
            ['e', 'f', 'g', 'h'],
            ['d', 'c', 'b', 'a']
        ];
        const snrc50kIndex = [
            ['13', '14', '15', '16'],
            ['12', '11', '10', '09'],
            ['05', '06', '07', '08'],
            ['04', '03', '02', '01']
        ];
        const checkSNRC50k = /\d{2,3}[a-p][0,1][0-9]/gi;
        const checkSNRC250k = /\d{2,3}[a-p]/gi;
        const checkSNRC1m = /\d{2,3}/gi;
        let snrc1m = false;
        let snrc250k = false;
        let snrc50k = false;
        if (checkSNRC50k.test(snrc)) {
            snrc50k = true;
        }
        else {
            if (checkSNRC250k.test(snrc)) {
                snrc250k = true;
            }
            else {
                if (checkSNRC1m.test(snrc)) {
                    snrc1m = true;
                }
            }
        }
        if (snrc1m) {
            snrc += 'a01';
        }
        else if (snrc250k) {
            snrc += '01';
        }
        if (/\d{2,3}[a-p][0,1][0-9]/gi.test(snrc)) {
            const regex1m = /(?=[a-p])/gi;
            const ar1m = snrc.split(regex1m);
            const part1m = ar1m[0];
            const part250k = ar1m[1][0];
            const part50k = ar1m[1].split(part250k)[1];
            let separator = 1;
            if (part1m.length === 3) {
                separator = 2;
            }
            const partEW = part1m.substring(0, separator);
            const partSN = part1m.substring(separator);
            const unit1mEW = 8;
            const unit1mSN = 4;
            const unit250kEW = 2;
            const unit250kSN = 1;
            const unit50kEW = 0.5;
            const unit50kSN = 0.25;
            let index250kEW = 0;
            let index250kSN = 0;
            let index50kEW = 0;
            let index50kSN = 0;
            snrc250kIndex.forEach(element => {
                if (element.indexOf(part250k) !== -1) {
                    index250kSN = snrc250kIndex.indexOf(element);
                    index250kEW = element.indexOf(part250k);
                }
            });
            snrc50kIndex.forEach(element => {
                if (element.indexOf(part50k) !== -1) {
                    index50kSN = snrc50kIndex.indexOf(element);
                    index50kEW = element.indexOf(part50k);
                }
            });
            let increment250kEW = 0;
            let increment250kSN = 0;
            let increment50kEW = 0;
            let increment50kSN = 0;
            let unitPerTypeEW = unit1mEW;
            let unitPerTypeSN = unit1mSN;
            if (snrc250k) {
                increment250kEW = index250kEW * unit250kEW;
                increment250kSN = index250kSN * unit250kSN;
                increment50kEW = 0;
                increment50kSN = 0;
                unitPerTypeEW = unit250kEW;
                unitPerTypeSN = unit250kSN;
            }
            else if (snrc50k) {
                increment250kEW = index250kEW * unit250kEW;
                increment250kSN = index250kSN * unit250kSN;
                increment50kEW = index50kEW * unit50kEW;
                increment50kSN = index50kSN * unit50kSN;
                unitPerTypeEW = unit50kEW;
                unitPerTypeSN = unit50kSN;
            }
            const coord = {
                ul: [
                    ew[partEW].to + increment250kEW + increment50kEW,
                    sn[partSN].to - increment250kSN - increment50kSN
                ]
            };
            coord.lr = [
                coord.ul[0] + unitPerTypeEW,
                coord.ul[1] - unitPerTypeSN
            ];
            coord.ur = [coord.ul[0], coord.ul[1] - unitPerTypeSN];
            coord.ll = [coord.ul[0] + unitPerTypeEW, coord.ul[1]];
            coord.ul = olproj.transform([coord.ul[0], coord.ul[1]], 'EPSG:4326', epsgTO);
            coord.lr = olproj.transform([coord.lr[0], coord.lr[1]], 'EPSG:4326', epsgTO);
            coord.ur = olproj.transform([coord.ur[0], coord.ur[1]], 'EPSG:4326', epsgTO);
            coord.ll = olproj.transform([coord.ll[0], coord.ll[1]], 'EPSG:4326', epsgTO);
            // Rounded coordinate to shorten url in get
            coord.ul = this.roundCoordinateArray(coord.ul, epsgTO, 0);
            coord.lr = this.roundCoordinateArray(coord.lr, epsgTO, 0);
            coord.ur = this.roundCoordinateArray(coord.ur, epsgTO, 0);
            coord.ll = this.roundCoordinateArray(coord.ll, epsgTO, 0);
            wktPoly =
                'POLYGON((' +
                    [
                        coord.ul.join(' '),
                        coord.ur.join(' '),
                        coord.lr.join(' '),
                        coord.ll.join(' '),
                        coord.ul.join(' ')
                    ].join(',') +
                    '))';
            const wktLine = 'LINESTRING(' +
                [
                    coord.ul.join(' '),
                    coord.ur.join(' '),
                    coord.lr.join(' '),
                    coord.ll.join(' '),
                    coord.ul.join(' ')
                ].join(',') +
                ')';
            const wktMultiPoints = 'MULTIPOINT(' +
                [
                    coord.ul.join(' '),
                    coord.ur.join(' '),
                    coord.lr.join(' '),
                    coord.ll.join(' ')
                ].join(',') +
                ')';
            return {
                wktPoly,
                wktLine,
                wktMultiPoints
            };
        }
    }
}
WktService.ɵfac = function WktService_Factory(t) { return new (t || WktService)(); };
WktService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: WktService, factory: WktService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(WktService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

function OgcFilterFormComponent_mat_form_field_13_mat_option_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 23);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const field_r12 = ctx.$implicit;
    i0.ɵɵproperty("value", field_r12.alias)("id", field_r12.name)("matTooltip", field_r12.alias);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", field_r12.alias, " ");
} }
function OgcFilterFormComponent_mat_form_field_13_button_12_Template(rf, ctx) { if (rf & 1) {
    const _r14 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 24);
    i0.ɵɵlistener("click", function OgcFilterFormComponent_mat_form_field_13_button_12_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r14); const ctx_r13 = i0.ɵɵnextContext(2); return ctx_r13.clearSelectedField(); });
    i0.ɵɵelement(1, "mat-icon", 25);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("disabled", !ctx_r11.currentFilter.active);
} }
function OgcFilterFormComponent_mat_form_field_13_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 17);
    i0.ɵɵlistener("mouseenter", function OgcFilterFormComponent_mat_form_field_13_Template_mat_form_field_mouseenter_0_listener() { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.inputClearable = "selectField"; })("mouseleave", function OgcFilterFormComponent_mat_form_field_13_Template_mat_form_field_mouseleave_0_listener() { i0.ɵɵrestoreView(_r16); const ctx_r17 = i0.ɵɵnextContext(); return ctx_r17.inputClearable = undefined; });
    i0.ɵɵelementStart(1, "input", 18);
    i0.ɵɵlistener("input", function OgcFilterFormComponent_mat_form_field_13_Template_input_input_1_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18.updateFieldsList($event.target.value); });
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵpipe(3, "async");
    i0.ɵɵpipe(4, "async");
    i0.ɵɵpipe(5, "async");
    i0.ɵɵpipe(6, "async");
    i0.ɵɵpipe(7, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(8, "mat-autocomplete", 19, 20);
    i0.ɵɵlistener("optionSelected", function OgcFilterFormComponent_mat_form_field_13_Template_mat_autocomplete_optionSelected_8_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.changeField($event.option.id); });
    i0.ɵɵtemplate(10, OgcFilterFormComponent_mat_form_field_13_mat_option_10_Template, 2, 4, "mat-option", 21);
    i0.ɵɵpipe(11, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(12, OgcFilterFormComponent_mat_form_field_13_button_12_Template, 2, 1, "button", 22);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r9 = i0.ɵɵreference(9);
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("floatLabel", ctx_r0.floatLabel);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("placeholder", i0.ɵɵpipeBind1(2, 8, "igo.geo.sourceFields.selectField"))("disabled", !ctx_r0.currentFilter.active)("matAutocomplete", _r9)("value", i0.ɵɵpipeBind1(3, 10, ctx_r0.selectedField$) ? i0.ɵɵpipeBind1(4, 12, ctx_r0.selectedField$).alias : "")("matTooltip", i0.ɵɵpipeBind1(5, 14, ctx_r0.selectedField$) ? i0.ɵɵpipeBind1(6, 16, ctx_r0.selectedField$).alias : i0.ɵɵpipeBind1(7, 18, "igo.geo.sourceFields.selectField"));
    i0.ɵɵadvance(9);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(11, 20, ctx_r0.filteredFields$));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.currentFilter.propertyName && ctx_r0.inputClearable === "selectField" && ctx_r0.currentFilter.active);
} }
function OgcFilterFormComponent_mat_option_24_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 3);
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const operator_r20 = ctx.$implicit;
    i0.ɵɵproperty("value", operator_r20.key)("matTooltip", i0.ɵɵpipeBind1(1, 3, "igo.geo.operators.tooltip." + operator_r20.key));
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(3, 5, "igo.geo.operators." + operator_r20.key), " ");
} }
function OgcFilterFormComponent_mat_form_field_27_mat_option_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 29);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const igoSpatialSelector_r22 = ctx.$implicit;
    i0.ɵɵproperty("value", igoSpatialSelector_r22.type);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.spatialSelector." + igoSpatialSelector_r22.type), " ");
} }
function OgcFilterFormComponent_mat_form_field_27_Template(rf, ctx) { if (rf & 1) {
    const _r24 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 26);
    i0.ɵɵelementStart(1, "mat-select", 27);
    i0.ɵɵlistener("selectionChange", function OgcFilterFormComponent_mat_form_field_27_Template_mat_select_selectionChange_1_listener($event) { i0.ɵɵrestoreView(_r24); const ctx_r23 = i0.ɵɵnextContext(); return ctx_r23.changeSpatialSelector($event.value); });
    i0.ɵɵtemplate(2, OgcFilterFormComponent_mat_form_field_27_mat_option_2_Template, 3, 4, "mat-option", 28);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("disabled", !ctx_r2.currentFilter.active)("value", ctx_r2.currentFilter.igoSpatialSelector);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r2.igoSpatialSelectors);
} }
function OgcFilterFormComponent_mat_form_field_29_mat_option_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 33);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const value_r28 = ctx.$implicit;
    i0.ɵɵproperty("value", value_r28)("matTooltip", value_r28);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", value_r28, " ");
} }
function OgcFilterFormComponent_mat_form_field_29_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r30 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 24);
    i0.ɵɵlistener("click", function OgcFilterFormComponent_mat_form_field_29_button_7_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r30); const ctx_r29 = i0.ɵɵnextContext(2); return ctx_r29.clearProperty(); });
    i0.ɵɵelement(1, "mat-icon", 25);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r27 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("disabled", !ctx_r27.currentFilter.active);
} }
function OgcFilterFormComponent_mat_form_field_29_Template(rf, ctx) { if (rf & 1) {
    const _r32 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 30);
    i0.ɵɵlistener("mouseenter", function OgcFilterFormComponent_mat_form_field_29_Template_mat_form_field_mouseenter_0_listener() { i0.ɵɵrestoreView(_r32); const ctx_r31 = i0.ɵɵnextContext(); return ctx_r31.inputClearable = "selectProperty"; })("mouseleave", function OgcFilterFormComponent_mat_form_field_29_Template_mat_form_field_mouseleave_0_listener() { i0.ɵɵrestoreView(_r32); const ctx_r33 = i0.ɵɵnextContext(); return ctx_r33.inputClearable = undefined; });
    i0.ɵɵelementStart(1, "input", 18);
    i0.ɵɵlistener("input", function OgcFilterFormComponent_mat_form_field_29_Template_input_input_1_listener($event) { i0.ɵɵrestoreView(_r32); const ctx_r34 = i0.ɵɵnextContext(); return ctx_r34.updateValuesList($event.target.value); });
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "mat-autocomplete", 19, 31);
    i0.ɵɵlistener("optionSelected", function OgcFilterFormComponent_mat_form_field_29_Template_mat_autocomplete_optionSelected_3_listener($event) { i0.ɵɵrestoreView(_r32); const ctx_r35 = i0.ɵɵnextContext(); return ctx_r35.changeProperty($event.option.value); });
    i0.ɵɵtemplate(5, OgcFilterFormComponent_mat_form_field_29_mat_option_5_Template, 2, 3, "mat-option", 32);
    i0.ɵɵpipe(6, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(7, OgcFilterFormComponent_mat_form_field_29_button_7_Template, 2, 1, "button", 22);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r25 = i0.ɵɵreference(4);
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("floatLabel", ctx_r3.floatLabel);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("placeholder", i0.ɵɵpipeBind1(2, 8, "igo.geo.filter.placeholder"))("disabled", !ctx_r3.currentFilter.active)("matAutocomplete", _r25)("value", ctx_r3.detectProperty() === "expression" ? ctx_r3.currentFilter.expression : ctx_r3.currentFilter.pattern)("matTooltip", ctx_r3.detectProperty() === "expression" ? ctx_r3.currentFilter.expression || "" : ctx_r3.currentFilter.pattern || "");
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(6, 10, ctx_r3.filteredValues$));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.isClearable() && ctx_r3.inputClearable === "selectProperty" && ctx_r3.currentFilter.active);
} }
function OgcFilterFormComponent_mat_form_field_34_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r38 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 24);
    i0.ɵɵlistener("click", function OgcFilterFormComponent_mat_form_field_34_button_3_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r38); const ctx_r37 = i0.ɵɵnextContext(2); return ctx_r37.currentFilter.igoSNRC = ""; });
    i0.ɵɵelement(1, "mat-icon", 25);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r36 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("disabled", !ctx_r36.currentFilter.active && ctx_r36.inputClearable === "selectSNRC" && ctx_r36.currentFilter.active);
} }
function OgcFilterFormComponent_mat_form_field_34_Template(rf, ctx) { if (rf & 1) {
    const _r40 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 34);
    i0.ɵɵlistener("mouseenter", function OgcFilterFormComponent_mat_form_field_34_Template_mat_form_field_mouseenter_0_listener() { i0.ɵɵrestoreView(_r40); const ctx_r39 = i0.ɵɵnextContext(); return ctx_r39.inputClearable = "selectSNRC"; })("mouseleave", function OgcFilterFormComponent_mat_form_field_34_Template_mat_form_field_mouseleave_0_listener() { i0.ɵɵrestoreView(_r40); const ctx_r41 = i0.ɵɵnextContext(); return ctx_r41.inputClearable = undefined; });
    i0.ɵɵelementStart(1, "input", 35);
    i0.ɵɵlistener("input", function OgcFilterFormComponent_mat_form_field_34_Template_input_input_1_listener($event) { i0.ɵɵrestoreView(_r40); const ctx_r42 = i0.ɵɵnextContext(); return ctx_r42.changeSNRC($event.target.value); });
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(3, OgcFilterFormComponent_mat_form_field_34_button_3_Template, 2, 1, "button", 22);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("floatLabel", ctx_r4.floatLabel);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("placeholder", i0.ɵɵpipeBind1(2, 5, "igo.geo.filter.placeholderSnrc"))("value", ctx_r4.currentFilter.igoSNRC)("matTooltip", ctx_r4.currentFilter.igoSNRC ? ctx_r4.currentFilter.igoSNRC : "");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.currentFilter.igoSNRC);
} }
function OgcFilterFormComponent_ng_container_36_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r45 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 37);
    i0.ɵɵlistener("click", function OgcFilterFormComponent_ng_container_36_button_1_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r45); const ctx_r44 = i0.ɵɵnextContext(2); return ctx_r44.changeMapExtentGeometry(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 38);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r43 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("disabled", !ctx_r43.currentFilter.active)("disabled", !ctx_r43.currentFilter.active)("matTooltip", i0.ɵɵpipeBind1(1, 3, "igo.geo.spatialSelector.btnSetExtent"));
} }
function OgcFilterFormComponent_ng_container_36_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, OgcFilterFormComponent_ng_container_36_button_1_Template, 3, 5, "button", 36);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r5.currentFilter.igoSpatialSelector === "fixedExtent");
} }
function OgcFilterFormComponent_mat_form_field_39_mat_option_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 33);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const value_r49 = ctx.$implicit;
    i0.ɵɵproperty("value", value_r49)("matTooltip", value_r49);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", value_r49, " ");
} }
function OgcFilterFormComponent_mat_form_field_39_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r51 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 24);
    i0.ɵɵlistener("click", function OgcFilterFormComponent_mat_form_field_39_button_7_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r51); const ctx_r50 = i0.ɵɵnextContext(2); return ctx_r50.clearProperty(1); });
    i0.ɵɵelement(1, "mat-icon", 25);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r48 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("disabled", !ctx_r48.currentFilter.active);
} }
function OgcFilterFormComponent_mat_form_field_39_Template(rf, ctx) { if (rf & 1) {
    const _r53 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 39);
    i0.ɵɵlistener("mouseenter", function OgcFilterFormComponent_mat_form_field_39_Template_mat_form_field_mouseenter_0_listener() { i0.ɵɵrestoreView(_r53); const ctx_r52 = i0.ɵɵnextContext(); return ctx_r52.inputClearable = "selectProperty1"; })("mouseleave", function OgcFilterFormComponent_mat_form_field_39_Template_mat_form_field_mouseleave_0_listener() { i0.ɵɵrestoreView(_r53); const ctx_r54 = i0.ɵɵnextContext(); return ctx_r54.inputClearable = undefined; });
    i0.ɵɵelementStart(1, "input", 40);
    i0.ɵɵlistener("input", function OgcFilterFormComponent_mat_form_field_39_Template_input_input_1_listener($event) { i0.ɵɵrestoreView(_r53); const ctx_r55 = i0.ɵɵnextContext(); return ctx_r55.updateValuesList($event.target.value, 1); });
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "mat-autocomplete", 19, 41);
    i0.ɵɵlistener("optionSelected", function OgcFilterFormComponent_mat_form_field_39_Template_mat_autocomplete_optionSelected_3_listener($event) { i0.ɵɵrestoreView(_r53); const ctx_r56 = i0.ɵɵnextContext(); return ctx_r56.changeNumericProperty($event.option.value, 1); });
    i0.ɵɵtemplate(5, OgcFilterFormComponent_mat_form_field_39_mat_option_5_Template, 2, 3, "mat-option", 32);
    i0.ɵɵpipe(6, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(7, OgcFilterFormComponent_mat_form_field_39_button_7_Template, 2, 1, "button", 22);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r46 = i0.ɵɵreference(4);
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵproperty("floatLabel", ctx_r6.floatLabel);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("placeholder", i0.ɵɵpipeBind1(2, 7, "igo.geo.filter.placeholder"))("disabled", !ctx_r6.currentFilter.active)("matAutocomplete", _r46)("value", ctx_r6.detectProperty(1) === "lowerBoundary" ? ctx_r6.currentFilter.lowerBoundary : ctx_r6.currentFilter.begin);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(6, 9, ctx_r6.filteredValues$));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r6.isClearable(1) && ctx_r6.inputClearable === "selectProperty1" && ctx_r6.currentFilter.active);
} }
function OgcFilterFormComponent_mat_form_field_40_mat_option_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 33);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const value_r60 = ctx.$implicit;
    i0.ɵɵproperty("value", value_r60)("matTooltip", value_r60);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", value_r60, " ");
} }
function OgcFilterFormComponent_mat_form_field_40_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r62 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 24);
    i0.ɵɵlistener("click", function OgcFilterFormComponent_mat_form_field_40_button_7_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r62); const ctx_r61 = i0.ɵɵnextContext(2); return ctx_r61.clearProperty(2); });
    i0.ɵɵelement(1, "mat-icon", 25);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r59 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("disabled", !ctx_r59.currentFilter.active);
} }
function OgcFilterFormComponent_mat_form_field_40_Template(rf, ctx) { if (rf & 1) {
    const _r64 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 39);
    i0.ɵɵlistener("mouseenter", function OgcFilterFormComponent_mat_form_field_40_Template_mat_form_field_mouseenter_0_listener() { i0.ɵɵrestoreView(_r64); const ctx_r63 = i0.ɵɵnextContext(); return ctx_r63.inputClearable = "selectProperty2"; })("mouseleave", function OgcFilterFormComponent_mat_form_field_40_Template_mat_form_field_mouseleave_0_listener() { i0.ɵɵrestoreView(_r64); const ctx_r65 = i0.ɵɵnextContext(); return ctx_r65.inputClearable = undefined; });
    i0.ɵɵelementStart(1, "input", 40);
    i0.ɵɵlistener("input", function OgcFilterFormComponent_mat_form_field_40_Template_input_input_1_listener($event) { i0.ɵɵrestoreView(_r64); const ctx_r66 = i0.ɵɵnextContext(); return ctx_r66.updateValuesList($event.target.value, 2); });
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "mat-autocomplete", 19, 42);
    i0.ɵɵlistener("optionSelected", function OgcFilterFormComponent_mat_form_field_40_Template_mat_autocomplete_optionSelected_3_listener($event) { i0.ɵɵrestoreView(_r64); const ctx_r67 = i0.ɵɵnextContext(); return ctx_r67.changeNumericProperty($event.option.value, 2); });
    i0.ɵɵtemplate(5, OgcFilterFormComponent_mat_form_field_40_mat_option_5_Template, 2, 3, "mat-option", 32);
    i0.ɵɵpipe(6, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(7, OgcFilterFormComponent_mat_form_field_40_button_7_Template, 2, 1, "button", 22);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r57 = i0.ɵɵreference(4);
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵproperty("floatLabel", ctx_r7.floatLabel);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("placeholder", i0.ɵɵpipeBind1(2, 7, "igo.geo.filter.placeholder"))("disabled", !ctx_r7.currentFilter.active)("matAutocomplete", _r57)("value", ctx_r7.detectProperty(2) === "upperBoundary" ? ctx_r7.currentFilter.upperBoundary : ctx_r7.currentFilter.end);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(6, 9, ctx_r7.filteredValues$));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r7.isClearable(2) && ctx_r7.inputClearable === "selectProperty2" && ctx_r7.currentFilter.active);
} }
function OgcFilterFormComponent_igo_ogc_filter_time_41_Template(rf, ctx) { if (rf & 1) {
    const _r69 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-ogc-filter-time", 43);
    i0.ɵɵlistener("datasourceChange", function OgcFilterFormComponent_igo_ogc_filter_time_41_Template_igo_ogc_filter_time_datasourceChange_0_listener($event) { i0.ɵɵrestoreView(_r69); const ctx_r68 = i0.ɵɵnextContext(); return ctx_r68.datasource = $event; })("currentFilterChange", function OgcFilterFormComponent_igo_ogc_filter_time_41_Template_igo_ogc_filter_time_currentFilterChange_0_listener($event) { i0.ɵɵrestoreView(_r69); const ctx_r70 = i0.ɵɵnextContext(); return ctx_r70.currentFilter = $event; })("changeProperty", function OgcFilterFormComponent_igo_ogc_filter_time_41_Template_igo_ogc_filter_time_changeProperty_0_listener($event) { i0.ɵɵrestoreView(_r69); const ctx_r71 = i0.ɵɵnextContext(); return ctx_r71.changeProperty($event.value, $event.pos); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext();
    i0.ɵɵproperty("datasource", ctx_r8.datasource)("currentFilter", ctx_r8.currentFilter);
} }
const _c0$8 = function (a0, a1) { return { "logical": a0, "logicalHidden": a1 }; };
const _c1$7 = function (a0, a1) { return { "operator": a0, "dualInput": a1 }; };
const _c2$3 = function () { return ["expression", "pattern"]; };
const _c3$1 = function () { return ["lowerBoundary", "begin"]; };
const _c4 = function () { return ["upperBoundary", "end"]; };
class OgcFilterFormComponent {
    constructor(wktService) {
        this.wktService = wktService;
        this.ogcFilterOperator = OgcFilterOperator;
        this.ogcFilterOperators$ = new BehaviorSubject(undefined);
        this.value = '';
        this.selectedField$ = new BehaviorSubject(undefined);
        this.fields$ = new BehaviorSubject([]);
        this.color = 'primary';
        this.currentFilterIsSpatial$ = new BehaviorSubject(false);
        this.defaultStepMillisecond = 6000;
        this._snrc = '';
        this.floatLabel = 'never';
        // TODO: Filter permitted operator based on wfscapabilities
        // Need to work on regex on XML capabilities because
        // comaparison operator's name varies between WFS servers...
        // Ex: IsNull vs PropertyIsNull vs IsNil ...
        this.allOgcFilterOperators = new OgcFilterWriter().operators;
        this.ogcFilterOperators$.next(this.allOgcFilterOperators);
        this.igoSpatialSelectors = [
            {
                type: 'fixedExtent'
            },
            {
                type: 'snrc'
            }
        ];
        // TODO: selectFeature & drawFeature
    }
    set snrc(value) {
        const checkSNRC50k = /^\d{2}[a-l][0,1][0-9]$/gi;
        const checkSNRC250k = /^\d{2}[a-p]$/gi;
        const checkSNRC1m = /^\d{2}$/gi;
        if (checkSNRC1m.test(value) ||
            checkSNRC250k.test(value) ||
            checkSNRC50k.test(value)) {
            this._snrc = value;
            this.currentFilter.igoSNRC = value;
        }
    }
    get snrc() {
        return this._snrc;
    }
    get activeFilters() {
        return this.datasource.options.ogcFilters.interfaceOgcFilters.filter((f) => f.active === true);
    }
    get allowedOperators() {
        return new OgcFilterWriter().computeAllowedOperators(this.fields$.value, this.currentFilter.propertyName, this.datasource.options.ogcFilters.allowedOperatorsType);
    }
    ngOnInit() {
        if (this.datasource.options.sourceFields) {
            const sFields = this.datasource.options.sourceFields.filter((sf) => sf.excludeFromOgcFilters === undefined || !sf.excludeFromOgcFilters);
            sFields.map((sfs) => {
                if (sfs.values) {
                    sfs.values.sort();
                }
            });
            this.fields$.next(sFields);
        }
        this.updateFieldsList();
        this.selectedField$.next(this.fields$.value.find((f) => f.name === this.currentFilter.propertyName));
        this.updateValuesList();
        this.selectedField$.subscribe((f) => {
            this.ogcFilterOperators$.next(this.allowedOperators);
            if (Object.keys(this.allowedOperators).indexOf(this.currentFilter.operator) === -1) {
                this.currentFilter.operator = Object.keys(this.allowedOperators)[0];
                this.currentFilter.operator = Object.keys(this.allowedOperators)[0];
            }
            this.updateValuesList();
        });
        this.currentFilterIsSpatial();
    }
    updateFieldsList(value) {
        this.filteredFields$ =
            value && value.length > 0 ? of(this._filterFields(value)) : this.fields$;
        if (this.fields$.value.find((f) => f.name === value)) {
            this.changeField(value);
        }
    }
    updateValuesList(value, pos) {
        this.filteredValues$ =
            value && value.length > 0
                ? of(this._filterValues(value))
                : this.selectedField$.value
                    ? of(this.selectedField$.value.values)
                    : of([]);
        if (value && value.length >= 1) {
            this.changeProperty(value, pos);
        }
    }
    _filterFields(value) {
        const keywordRegex = new RegExp(value.normalize('NFD').replace(/[\u0300-\u036f]/g, ''), 'gi');
        return this.fields$.value.filter((val) => keywordRegex.test(val.alias.normalize('NFD').replace(/[\u0300-\u036f]/g, '')));
    }
    _filterValues(value) {
        const keywordRegex = new RegExp(value
            .toString()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, ''), 'gi');
        return this.selectedField$.value.values.filter((val) => val && keywordRegex.test(val
            .toString()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')));
    }
    clearSelectedField() {
        this.currentFilter.propertyName = '';
        this.selectedField$.next(undefined);
        this.clearProperty();
    }
    isClearable(pos) {
        const detectedProperty = this.detectProperty(pos);
        if (detectedProperty) {
            return this.currentFilter[detectedProperty];
        }
    }
    clearProperty(pos) {
        // this.autoCompleteInputValues.closePanel();
        const detectedProperty = this.detectProperty(pos);
        if (detectedProperty) {
            return (this.currentFilter[detectedProperty] = '');
        }
    }
    toggleFilterState(event) {
        this.datasource.options.ogcFilters.interfaceOgcFilters.find((f) => f.filterid === this.currentFilter.filterid).active = event.checked;
        this.refreshFilters();
    }
    deleteFilter() {
        const ogcFilters = this.datasource.options.ogcFilters;
        ogcFilters.interfaceOgcFilters = ogcFilters.interfaceOgcFilters.filter((f) => f.filterid !== this.currentFilter.filterid);
        this.refreshFilters();
    }
    changeLogical(logical) {
        this.currentFilter.parentLogical = logical;
        this.refreshFilters();
    }
    changeOperator(operator) {
        this.currentFilter.operator = operator;
        this.currentFilterIsSpatial();
        if (this.currentFilterIsSpatial$.value &&
            this.currentFilter.wkt_geometry.length === 0) {
            this.changeSpatialSelector(this.currentFilter.igoSpatialSelector);
        }
        else {
            this.refreshFilters();
        }
    }
    changeField(field) {
        this.currentFilter.propertyName = field;
        this.selectedField$.next(this.fields$.value.find((f) => f.name === this.currentFilter.propertyName));
        this.refreshFilters();
    }
    // Issue with mapserver 7.2 and Postgis layers. Fixed in 7.4
    // Due to this issue, the checkbox is hide.
    changeCaseSensitive(matchCase) {
        this.currentFilter.matchCase = matchCase.checked;
        this.refreshFilters();
    }
    changeProperty(value, pos, refreshFilter = true) {
        const detectedProperty = this.detectProperty(pos);
        if (detectedProperty) {
            this.datasource.options.ogcFilters.interfaceOgcFilters.find((f) => f.filterid === this.currentFilter.filterid)[detectedProperty] = value;
            if (refreshFilter) {
                this.refreshFilters();
            }
        }
    }
    changeNumericProperty(value, pos) {
        this.changeProperty(parseFloat(value), pos);
    }
    changeSpatialSelector(value) {
        this.currentFilter.igoSpatialSelector = value;
        if (value === 'fixedExtent') {
            this.changeMapExtentGeometry(false);
        }
        this.currentFilterIsSpatial();
        this.refreshFilters();
    }
    changeSNRC(value) {
        this.snrc = value;
        this.changeSNRCGeometry();
    }
    changeSNRCGeometry() {
        const interfaceOgcFilter = this.datasource.options.ogcFilters.interfaceOgcFilters.find((f) => f.filterid === this.currentFilter.filterid);
        if (!interfaceOgcFilter) {
            return;
        }
        if (this.snrc && this.currentFilter.igoSpatialSelector === 'snrc') {
            this.currentFilter.wkt_geometry = this.wktService.snrcToWkt(this.snrc, this.map.projection).wktPoly;
        }
        this.refreshFilters();
    }
    changeMapExtentGeometry(refresh = true) {
        const interfaceOgcFilter = this.datasource.options.ogcFilters.interfaceOgcFilters.find((f) => f.filterid === this.currentFilter.filterid);
        if (!interfaceOgcFilter) {
            return;
        }
        if (this.currentFilter.igoSpatialSelector === 'fixedExtent') {
            this.currentFilter.wkt_geometry = this.wktService.extentToWkt(this.map.projection, this.map.viewController.getExtent(), this.map.projection).wktPoly;
        }
        if (refresh) {
            this.refreshFilters();
        }
    }
    detectProperty(pos) {
        switch (this.currentFilter.operator) {
            case OgcFilterOperator.PropertyIsNotEqualTo:
            case OgcFilterOperator.PropertyIsEqualTo:
            case OgcFilterOperator.PropertyIsGreaterThan:
            case OgcFilterOperator.PropertyIsGreaterThanOrEqualTo:
            case OgcFilterOperator.PropertyIsLessThan:
            case OgcFilterOperator.PropertyIsLessThanOrEqualTo:
                return 'expression';
            case OgcFilterOperator.PropertyIsLike:
                return 'pattern';
            case OgcFilterOperator.PropertyIsBetween:
                return pos && pos === 1
                    ? 'lowerBoundary'
                    : pos && pos === 2
                        ? 'upperBoundary'
                        : undefined;
            case OgcFilterOperator.During:
                return pos && pos === 1
                    ? 'begin'
                    : pos && pos === 2
                        ? 'end'
                        : undefined;
            default:
                return;
        }
    }
    currentFilterIsSpatial() {
        let isSpatial = false;
        if (this.currentFilter) {
            isSpatial =
                [
                    OgcFilterOperator.Contains,
                    OgcFilterOperator.Intersects,
                    OgcFilterOperator.Within
                ].indexOf(this.currentFilter.operator) !== -1;
        }
        this.currentFilterIsSpatial$.next(isSpatial);
    }
    isTemporalOperator() {
        return (this.currentFilter.operator.toLowerCase() ===
            this.ogcFilterOperator.During.toLowerCase());
    }
}
OgcFilterFormComponent.ɵfac = function OgcFilterFormComponent_Factory(t) { return new (t || OgcFilterFormComponent)(i0.ɵɵdirectiveInject(WktService)); };
OgcFilterFormComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OgcFilterFormComponent, selectors: [["igo-ogc-filter-form"]], inputs: { refreshFilters: "refreshFilters", datasource: "datasource", map: "map", currentFilter: "currentFilter", floatLabel: "floatLabel" }, decls: 42, vars: 76, consts: [["tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "checked", "click", "change"], [3, "ngClass"], ["tooltip-position", "above", "matTooltipShowDelay", "500", 3, "disabled", "value", "matTooltip", "selectionChange"], ["tooltip-position", "above", "matTooltipShowDelay", "500", 3, "value", "matTooltip"], ["class", "field", 3, "floatLabel", "mouseenter", "mouseleave", 4, "ngIf"], [3, "ngClass", "floatLabel"], ["tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "disabled", "value", "selectionChange"], ["tooltip-position", "above", "matTooltipShowDelay", "500", 3, "value", "matTooltip", 4, "ngFor", "ngForOf"], ["class", "spatialSelector", 4, "ngIf"], ["class", "singleInput", 3, "floatLabel", "mouseenter", "mouseleave", 4, "ngIf"], [1, "igo-layer-button-group"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "warn", 3, "matTooltip", "click"], ["svgIcon", "delete"], ["class", "snrc", 3, "floatLabel", "mouseenter", "mouseleave", 4, "ngIf"], [4, "ngIf"], ["class", "dualInput", 3, "floatLabel", "mouseenter", "mouseleave", 4, "ngIf"], [3, "datasource", "currentFilter", "datasourceChange", "currentFilterChange", "changeProperty", 4, "ngIf"], [1, "field", 3, "floatLabel", "mouseenter", "mouseleave"], ["matInput", "", "tooltip-position", "above", "matTooltipShowDelay", "500", 3, "placeholder", "disabled", "matAutocomplete", "value", "matTooltip", "input"], [3, "optionSelected"], ["autoCompleteField", "matAutocomplete"], ["matTooltipShowDelay", "500", 3, "value", "id", "matTooltip", 4, "ngFor", "ngForOf"], ["mat-button", "", "matSuffix", "", "mat-icon-button", "", "aria-label", "Clear", 3, "disabled", "click", 4, "ngIf"], ["matTooltipShowDelay", "500", 3, "value", "id", "matTooltip"], ["mat-button", "", "matSuffix", "", "mat-icon-button", "", "aria-label", "Clear", 3, "disabled", "click"], ["svgIcon", "close"], [1, "spatialSelector"], [3, "disabled", "value", "selectionChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "singleInput", 3, "floatLabel", "mouseenter", "mouseleave"], ["autoCompleteValues", "matAutocomplete"], ["matTooltipShowDelay", "500", 3, "value", "matTooltip", 4, "ngFor", "ngForOf"], ["matTooltipShowDelay", "500", 3, "value", "matTooltip"], [1, "snrc", 3, "floatLabel", "mouseenter", "mouseleave"], ["matInput", "", "tooltip-position", "above", "matTooltipShowDelay", "500", 3, "placeholder", "value", "matTooltip", "input"], ["mat-button", "", "matSuffix", "", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "disabled", "matTooltip", "click", 4, "ngIf"], ["mat-button", "", "matSuffix", "", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "disabled", "matTooltip", "click"], ["svgIcon", "arrow-expand-all"], [1, "dualInput", 3, "floatLabel", "mouseenter", "mouseleave"], ["matInput", "", "type", "number", 3, "placeholder", "disabled", "matAutocomplete", "value", "input"], ["autoDualValueOperator1", "matAutocomplete"], ["autoDualValueOperator2", "matAutocomplete"], [3, "datasource", "currentFilter", "datasourceChange", "currentFilterChange", "changeProperty"]], template: function OgcFilterFormComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-checkbox", 0);
        i0.ɵɵlistener("click", function OgcFilterFormComponent_Template_mat_checkbox_click_0_listener($event) { return $event.stopPropagation(); })("change", function OgcFilterFormComponent_Template_mat_checkbox_change_0_listener($event) { return ctx.toggleFilterState($event); });
        i0.ɵɵpipe(1, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(2, "mat-form-field", 1);
        i0.ɵɵelementStart(3, "mat-select", 2);
        i0.ɵɵlistener("selectionChange", function OgcFilterFormComponent_Template_mat_select_selectionChange_3_listener($event) { return ctx.changeLogical($event.value); });
        i0.ɵɵpipe(4, "translate");
        i0.ɵɵelementStart(5, "mat-option", 3);
        i0.ɵɵpipe(6, "translate");
        i0.ɵɵtext(7);
        i0.ɵɵpipe(8, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(9, "mat-option", 3);
        i0.ɵɵpipe(10, "translate");
        i0.ɵɵtext(11);
        i0.ɵɵpipe(12, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(13, OgcFilterFormComponent_mat_form_field_13_Template, 13, 22, "mat-form-field", 4);
        i0.ɵɵpipe(14, "async");
        i0.ɵɵpipe(15, "async");
        i0.ɵɵpipe(16, "async");
        i0.ɵɵpipe(17, "async");
        i0.ɵɵelementStart(18, "mat-form-field", 5);
        i0.ɵɵpipe(19, "async");
        i0.ɵɵpipe(20, "async");
        i0.ɵɵelementStart(21, "mat-select", 6);
        i0.ɵɵlistener("selectionChange", function OgcFilterFormComponent_Template_mat_select_selectionChange_21_listener($event) { return ctx.changeOperator($event.value); });
        i0.ɵɵpipe(22, "translate");
        i0.ɵɵpipe(23, "translate");
        i0.ɵɵtemplate(24, OgcFilterFormComponent_mat_option_24_Template, 4, 7, "mat-option", 7);
        i0.ɵɵpipe(25, "keyvalue");
        i0.ɵɵpipe(26, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(27, OgcFilterFormComponent_mat_form_field_27_Template, 3, 3, "mat-form-field", 8);
        i0.ɵɵpipe(28, "async");
        i0.ɵɵtemplate(29, OgcFilterFormComponent_mat_form_field_29_Template, 8, 12, "mat-form-field", 9);
        i0.ɵɵelementStart(30, "div", 10);
        i0.ɵɵelementStart(31, "button", 11);
        i0.ɵɵlistener("click", function OgcFilterFormComponent_Template_button_click_31_listener() { return ctx.deleteFilter(); });
        i0.ɵɵpipe(32, "translate");
        i0.ɵɵelement(33, "mat-icon", 12);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(34, OgcFilterFormComponent_mat_form_field_34_Template, 4, 7, "mat-form-field", 13);
        i0.ɵɵpipe(35, "async");
        i0.ɵɵtemplate(36, OgcFilterFormComponent_ng_container_36_Template, 2, 1, "ng-container", 14);
        i0.ɵɵpipe(37, "async");
        i0.ɵɵelement(38, "br");
        i0.ɵɵtemplate(39, OgcFilterFormComponent_mat_form_field_39_Template, 8, 11, "mat-form-field", 15);
        i0.ɵɵtemplate(40, OgcFilterFormComponent_mat_form_field_40_Template, 8, 11, "mat-form-field", 15);
        i0.ɵɵtemplate(41, OgcFilterFormComponent_igo_ogc_filter_time_41_Template, 1, 2, "igo-ogc-filter-time", 16);
    } if (rf & 2) {
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 27, "igo.geo.filter.toggleFilterState"))("checked", ctx.currentFilter.active);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(67, _c0$8, ctx.activeFilters.indexOf(ctx.currentFilter) !== 0 && ctx.currentFilter.active === true, ctx.activeFilters.indexOf(ctx.currentFilter) === 0 || ctx.currentFilter.active !== true));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("disabled", !ctx.currentFilter.active)("value", ctx.currentFilter.parentLogical)("matTooltip", ctx.currentFilter.parentLogical ? i0.ɵɵpipeBind1(4, 29, "igo.geo.operators.tooltip." + ctx.currentFilter.parentLogical) : "");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", ctx.ogcFilterOperator.And)("matTooltip", i0.ɵɵpipeBind1(6, 31, "igo.geo.operators.tooltip.And"));
        i0.ɵɵadvance(2);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(8, 33, "igo.geo.operators.And"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", ctx.ogcFilterOperator.Or)("matTooltip", i0.ɵɵpipeBind1(10, 35, "igo.geo.operators.tooltip.Or"));
        i0.ɵɵadvance(2);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(12, 37, "igo.geo.operators.Or"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(14, 39, ctx.currentFilterIsSpatial$) === false && i0.ɵɵpipeBind1(15, 41, ctx.fields$) && i0.ɵɵpipeBind1(16, 43, ctx.fields$).length > 0 && i0.ɵɵpipeBind1(17, 45, ctx.fields$)[0].name !== "");
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(70, _c1$7, i0.ɵɵpipeBind1(19, 47, ctx.currentFilterIsSpatial$) === false, i0.ɵɵpipeBind1(20, 49, ctx.currentFilterIsSpatial$)))("floatLabel", ctx.floatLabel);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("matTooltip", ctx.currentFilter.operator ? i0.ɵɵpipeBind1(22, 51, "igo.geo.operators.tooltip." + ctx.currentFilter.operator) : i0.ɵɵpipeBind1(23, 53, "igo.geo.filter.selectOperator"))("disabled", !ctx.currentFilter.active)("value", ctx.currentFilter.operator);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(25, 55, i0.ɵɵpipeBind1(26, 57, ctx.ogcFilterOperators$)));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(28, 59, ctx.currentFilterIsSpatial$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpureFunction0(73, _c2$3).indexOf(ctx.detectProperty()) !== -1);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(32, 61, "igo.geo.filter.removeFilter"));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(35, 63, ctx.currentFilterIsSpatial$) && ctx.currentFilter.igoSpatialSelector === "snrc");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(37, 65, ctx.currentFilterIsSpatial$) && ctx.currentFilter.igoSpatialSelector === "fixedExtent");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.isTemporalOperator() && i0.ɵɵpureFunction0(74, _c3$1).indexOf(ctx.detectProperty(1)) !== -1);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx.isTemporalOperator() && i0.ɵɵpureFunction0(75, _c4).indexOf(ctx.detectProperty(2)) !== -1);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.isTemporalOperator());
    } }, styles: ["[_nghost-%COMP%]{width:100%;padding:5px 10px}  .mat-form-field .mat-icon svg{width:1em;height:1em;color:#d3d3d3}.mat-form-field[_ngcontent-%COMP%]{width:100%}.mat-select-arrow[_ngcontent-%COMP%]{visibility:hidden}.mat-slide-toggle[_ngcontent-%COMP%]{margin-top:10px}.logical[_ngcontent-%COMP%]{flex-flow:column nowrap;width:10%;max-width:45px;margin-left:5px}.logicalHidden[_ngcontent-%COMP%]{flex-flow:column nowrap;width:10%;visibility:hidden;max-width:45px;margin-left:5px}  .logical .mat-select-arrow{visibility:hidden}  .logicalHidden .mat-select-arrow{visibility:hidden}.field[_ngcontent-%COMP%]{width:20%;margin-left:5px}  .field .mat-select-arrow{visibility:hidden}.operator[_ngcontent-%COMP%]{width:12%;margin-left:10px;text-align:center}  .operator .mat-select-arrow{visibility:hidden}.spatialSelector[_ngcontent-%COMP%]{width:15%;margin-left:5px}  .spatialSelector .mat-select-arrow{visibility:hidden}.singleInput[_ngcontent-%COMP%]{width:30%;margin-left:5px}.snrc[_ngcontent-%COMP%]{width:20%;margin-left:5px}  .singleInput .mat-select-arrow{visibility:hidden}.dualInput[_ngcontent-%COMP%]{width:20%;margin-left:5px}  .dualInput .mat-select-arrow{visibility:hidden}.igo-layer-button-group[_ngcontent-%COMP%]{display:flex;float:right;padding-top:5px}.container[_ngcontent-%COMP%]{display:flex}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OgcFilterFormComponent, [{
        type: Component,
        args: [{
                selector: 'igo-ogc-filter-form',
                templateUrl: './ogc-filter-form.component.html',
                styleUrls: ['./ogc-filter-form.component.scss']
            }]
    }], function () { return [{ type: WktService }]; }, { refreshFilters: [{
            type: Input
        }], datasource: [{
            type: Input
        }], map: [{
            type: Input
        }], currentFilter: [{
            type: Input
        }], floatLabel: [{
            type: Input
        }] }); })();

function OgcFilterableFormComponent_igo_ogc_filter_selection_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-ogc-filter-selection", 2);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("refreshFilters", ctx_r0.refreshFunc)("datasource", ctx_r0.datasource)("map", ctx_r0.map)("currentFilter", ctx_r0.currentFilter);
} }
function OgcFilterableFormComponent_1_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-ogc-filter-form", 4);
} if (rf & 2) {
    const currentFilter_r3 = ctx.$implicit;
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("currentFilter", currentFilter_r3)("refreshFilters", ctx_r2.refreshFunc)("datasource", ctx_r2.datasource)("map", ctx_r2.map);
} }
function OgcFilterableFormComponent_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, OgcFilterableFormComponent_1_ng_template_0_Template, 1, 4, "ng-template", 3);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngForOf", ctx_r1.datasource.options.ogcFilters.interfaceOgcFilters);
} }
class OgcFilterableFormComponent {
    constructor() {
        this.color = 'primary';
    }
    get refreshFunc() {
        return this.refreshFilters;
    }
    get advancedOgcFilters() {
        if (this.datasource.options.ogcFilters) {
            return this.datasource.options.ogcFilters.advancedOgcFilters;
        }
        return;
    }
    get currentFilter() {
        return this.datasource.options.ogcFilters.interfaceOgcFilters ?
            this.datasource.options.ogcFilters.interfaceOgcFilters[0] : undefined;
    }
}
OgcFilterableFormComponent.ɵfac = function OgcFilterableFormComponent_Factory(t) { return new (t || OgcFilterableFormComponent)(); };
OgcFilterableFormComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OgcFilterableFormComponent, selectors: [["igo-ogc-filterable-form"]], inputs: { datasource: "datasource", map: "map", refreshFilters: "refreshFilters" }, decls: 2, vars: 2, consts: [["igoListItem", "", 3, "refreshFilters", "datasource", "map", "currentFilter", 4, "ngIf"], [4, "ngIf"], ["igoListItem", "", 3, "refreshFilters", "datasource", "map", "currentFilter"], ["ngFor", "", 3, "ngForOf"], [3, "currentFilter", "refreshFilters", "datasource", "map"]], template: function OgcFilterableFormComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, OgcFilterableFormComponent_igo_ogc_filter_selection_0_Template, 1, 4, "igo-ogc-filter-selection", 0);
        i0.ɵɵtemplate(1, OgcFilterableFormComponent_1_Template, 1, 1, undefined, 1);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", !ctx.advancedOgcFilters);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.advancedOgcFilters && ctx.datasource.options.ogcFilters.editable);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OgcFilterableFormComponent, [{
        type: Component,
        args: [{
                selector: 'igo-ogc-filterable-form',
                templateUrl: './ogc-filterable-form.component.html'
            }]
    }], function () { return []; }, { datasource: [{
            type: Input
        }], map: [{
            type: Input
        }], refreshFilters: [{
            type: Input
        }] }); })();

function OgcFilterableItemComponent_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-icon", 8);
    i0.ɵɵlistener("click", function OgcFilterableItemComponent_mat_icon_1_Template_mat_icon_click_0_listener() { i0.ɵɵrestoreView(_r8); const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.toggleFiltersCollapsed(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    const _r4 = i0.ɵɵreference(6);
    i0.ɵɵproperty("target", _r4)("collapsed", ctx_r0.filtersCollapsed);
} }
const _c0$7 = function (a0) { return { "cursor": a0 }; };
function OgcFilterableItemComponent_h4_2_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "h4", 9);
    i0.ɵɵlistener("click", function OgcFilterableItemComponent_h4_2_Template_h4_click_0_listener() { i0.ɵɵrestoreView(_r10); const ctx_r9 = i0.ɵɵnextContext(); return ctx_r9.toggleLegendOnClick(); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(3, _c0$7, ctx_r1.filtersCollapsed ? "default" : "pointer"))("matTooltip", ctx_r1.layer.title);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r1.layer.title);
} }
function OgcFilterableItemComponent_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 10);
    i0.ɵɵlistener("click", function OgcFilterableItemComponent_button_3_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r12); const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.addFilterToSequence(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 11);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("disabled", ctx_r2.addFilterDisabled())("matTooltip", i0.ɵɵpipeBind1(1, 3, "igo.geo.filter.addFilter"))("color", ctx_r2.color);
} }
const _c1$6 = function (a0) { return { disabled: a0 }; };
function OgcFilterableItemComponent_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r14 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 12);
    i0.ɵɵlistener("click", function OgcFilterableItemComponent_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r14); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.layer.visible = !ctx_r13.layer.visible; });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelement(3, "mat-icon", 13);
    i0.ɵɵpipe(4, "async");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("color", ctx_r3.layer.visible ? "primary" : "default")("matTooltip", ctx_r3.layer.visible ? i0.ɵɵpipeBind1(1, 4, "igo.geo.layer.hideLayer") : i0.ɵɵpipeBind1(2, 6, "igo.geo.layer.showLayer"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(10, _c1$6, i0.ɵɵpipeBind1(4, 8, ctx_r3.inResolutionRange$) === false))("svgIcon", ctx_r3.layer.visible ? "eye" : "eye-off");
} }
function OgcFilterableItemComponent_div_7_igo_layer_legend_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-layer-legend", 17);
} if (rf & 2) {
    const ctx_r16 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("layer", ctx_r16.layer);
} }
function OgcFilterableItemComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 14, 15);
    i0.ɵɵtemplate(2, OgcFilterableItemComponent_div_7_igo_layer_legend_2_Template, 1, 1, "igo-layer-legend", 16);
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(3, 1, ctx_r5.showLegend$));
} }
function OgcFilterableItemComponent_section_9_Template(rf, ctx) { if (rf & 1) {
    const _r18 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "section", 18);
    i0.ɵɵelement(1, "mat-divider");
    i0.ɵɵelementStart(2, "mat-checkbox", 19);
    i0.ɵɵlistener("change", function OgcFilterableItemComponent_section_9_Template_mat_checkbox_change_2_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r17 = i0.ɵɵnextContext(); return ctx_r17.changeOgcFilterType($event); })("ngModelChange", function OgcFilterableItemComponent_section_9_Template_mat_checkbox_ngModelChange_2_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.datasource.options.ogcFilters.advancedOgcFilters = $event; });
    i0.ɵɵtext(3);
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngModel", ctx_r6.datasource.options.ogcFilters.advancedOgcFilters);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(4, 2, "igo.geo.filter.advancedOgcFilters"), " ");
} }
class OgcFilterableItemComponent {
    constructor(ogcFilterService) {
        this.ogcFilterService = ogcFilterService;
        this.color = 'primary';
        this.defaultLogicalParent = OgcFilterOperator.And;
        this.hasActiveSpatialFilter = false;
        this.filtersAreEditable = true;
        this.filtersCollapsed = true;
        this.hasSelector = false;
        this.showLegend$ = new BehaviorSubject(false);
        this.inResolutionRange$ = new BehaviorSubject(true);
        this.header = true;
        this.ogcFilterWriter = new OgcFilterWriter();
    }
    get refreshFunc() {
        return this.refreshFilters.bind(this);
    }
    get datasource() {
        return this.layer.dataSource;
    }
    ngOnInit() {
        const ogcFilters = this.datasource.options.ogcFilters;
        if ((ogcFilters.pushButtons && ogcFilters.pushButtons.bundles.length > 0) ||
            (ogcFilters.checkboxes && ogcFilters.checkboxes.bundles.length > 0) ||
            (ogcFilters.radioButtons && ogcFilters.radioButtons.bundles.length > 0) ||
            (ogcFilters.select && ogcFilters.select.bundles.length > 0)) {
            if (ogcFilters.advancedOgcFilters === undefined) {
                ogcFilters.advancedOgcFilters = false;
            }
            this.hasSelector = true;
        }
        switch (this.datasource.options.type) {
            case 'wms':
                this.ogcFilterService.setOgcWMSFiltersOptions(this.datasource);
                break;
            case 'wfs':
                this.ogcFilterService.setOgcWFSFiltersOptions(this.datasource);
                break;
            default:
                break;
        }
        if (ogcFilters) {
            if (ogcFilters.interfaceOgcFilters) {
                this.lastRunOgcFilter = JSON.parse(JSON.stringify(ogcFilters.interfaceOgcFilters));
                if (ogcFilters.interfaceOgcFilters.filter(f => f.wkt_geometry).length >= 1) {
                    this.hasActiveSpatialFilter = true;
                }
            }
            this.filtersAreEditable = ogcFilters.editable
                ? ogcFilters.editable
                : false;
        }
        const resolution$ = this.layer.map.viewController.resolution$;
        this.resolution$$ = resolution$.subscribe(() => {
            this.inResolutionRange$.next(this.layer.isInResolutionsRange);
        });
    }
    ngOnDestroy() {
        this.resolution$$.unsubscribe();
    }
    addFilterToSequence() {
        this.filtersCollapsed = false;
        const interfaceOgcFilters = this.datasource
            .options.ogcFilters.interfaceOgcFilters;
        const arr = interfaceOgcFilters || [];
        const lastLevel = arr.length === 0 ? 0 : arr[arr.length - 1].level;
        let firstFieldName = '';
        const includedFields = this.datasource.options.sourceFields.filter(f => !f.excludeFromOgcFilters);
        if (includedFields.length > 0) {
            firstFieldName =
                includedFields[0].name === undefined ? '' : includedFields[0].name;
        }
        let fieldNameGeometry;
        const datasourceOptions = this.datasource
            .options;
        if (datasourceOptions.fieldNameGeometry) {
            fieldNameGeometry = datasourceOptions.fieldNameGeometry;
        }
        else if (this.datasource.options.paramsWFS &&
            this.datasource.options.paramsWFS.fieldNameGeometry) {
            fieldNameGeometry = this.datasource.options.paramsWFS
                .fieldNameGeometry;
        }
        const allowedOperators = this.ogcFilterWriter.computeAllowedOperators(this.datasource.options.sourceFields, firstFieldName, this.datasource.options.ogcFilters.allowedOperatorsType);
        const firstOperatorName = Object.keys(allowedOperators)[0];
        arr.push(this.ogcFilterWriter.addInterfaceFilter({
            propertyName: firstFieldName,
            operator: firstOperatorName,
            active: true,
            igoSpatialSelector: 'fixedExtent',
            srsName: this.map.projection,
        }, fieldNameGeometry, lastLevel, this.defaultLogicalParent));
        this.datasource.options.ogcFilters.interfaceOgcFilters = arr;
    }
    refreshFilters(force) {
        if (force === true) {
            this.lastRunOgcFilter = undefined;
        }
        const ogcFilters = this.datasource.options.ogcFilters;
        const activeFilters = ogcFilters.interfaceOgcFilters ?
            ogcFilters.interfaceOgcFilters.filter(f => f.active === true) : [];
        if (activeFilters.length === 0) {
            ogcFilters.filters = undefined;
            ogcFilters.filtered = false;
        }
        if (activeFilters.length > 1) {
            activeFilters[0].parentLogical = activeFilters[1].parentLogical;
        }
        if (activeFilters.filter(af => ['Contains', 'Intersects', 'Within'].indexOf(af.operator) !== -1).length === 0) {
            this.hasActiveSpatialFilter = false;
        }
        else {
            this.hasActiveSpatialFilter = true;
        }
        if (!(JSON.stringify(this.lastRunOgcFilter) === JSON.stringify(activeFilters))) {
            if (this.layer.dataSource.options.type === 'wfs') {
                const ogcDataSource = this.layer.dataSource;
                const ogcLayer = ogcDataSource.options.ogcFilters;
                ogcLayer.filters = this.ogcFilterWriter.rebuiltIgoOgcFilterObjectFromSequence(activeFilters);
                this.layer.dataSource.ol.refresh();
            }
            else if (this.layer.dataSource.options.type === 'wms' &&
                ogcFilters.enabled) {
                let rebuildFilter = '';
                if (activeFilters.length >= 1) {
                    const ogcDataSource = this.layer.dataSource;
                    const ogcLayer = ogcDataSource.options.ogcFilters;
                    ogcLayer.filters = this.ogcFilterWriter.rebuiltIgoOgcFilterObjectFromSequence(activeFilters);
                    rebuildFilter = this.ogcFilterWriter.buildFilter(ogcLayer.filters, undefined, undefined, this.layer.dataSource.options.fieldNameGeometry, ogcDataSource.options);
                }
                this.ogcFilterService.filterByOgc(this.datasource, rebuildFilter);
                this.datasource.options.ogcFilters.filtered =
                    activeFilters.length === 0 ? false : true;
            }
            this.lastRunOgcFilter = JSON.parse(JSON.stringify(activeFilters));
        }
        else {
            // identical filter. Nothing triggered
        }
        this.layer.dataSource.setOgcFilters(ogcFilters, true);
    }
    setVisible() {
        this.layer.visible = true;
    }
    isAdvancedOgcFilters() {
        return this.datasource.options.ogcFilters.advancedOgcFilters;
    }
    addFilterDisabled() {
        return (!this.datasource.options.sourceFields ||
            this.datasource.options.sourceFields.length === 0);
    }
    changeOgcFiltersAdvancedOgcFilters(value) {
        this.datasource.options.ogcFilters.advancedOgcFilters = value;
    }
    changeOgcFilterType(isAdvancedOgcFilters) {
        this.changeOgcFiltersAdvancedOgcFilters(isAdvancedOgcFilters.checked);
        if (isAdvancedOgcFilters.checked) {
            this.refreshFilters(true);
        }
    }
    toggleLegend(collapsed) {
        this.layer.legendCollapsed = collapsed;
        this.showLegend$.next(!collapsed);
    }
    toggleLegendOnClick() {
        if (!this.filtersCollapsed) {
            this.toggleLegend(this.showLegend$.value);
        }
    }
    toggleFiltersCollapsed() {
        this.filtersCollapsed = !this.filtersCollapsed;
    }
}
OgcFilterableItemComponent.ɵfac = function OgcFilterableItemComponent_Factory(t) { return new (t || OgcFilterableItemComponent)(i0.ɵɵdirectiveInject(OGCFilterService)); };
OgcFilterableItemComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OgcFilterableItemComponent, selectors: [["igo-ogc-filterable-item"]], inputs: { layer: "layer", map: "map", header: "header" }, decls: 10, vars: 9, consts: [["class", "igo-chevron", "mat-list-avatar", "", "igoCollapse", "", "svgIcon", "chevron-up", 3, "target", "collapsed", "click", 4, "ngIf"], ["matLine", "", "matTooltipShowDelay", "500", 3, "ngStyle", "matTooltip", "click", 4, "ngIf"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "disabled", "matTooltip", "color", "click", 4, "ngIf"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "color", "matTooltip", "click", 4, "ngIf"], ["ogcFilters", ""], ["class", "igo-layer-legend-container", 4, "ngIf"], [3, "datasource", "map", "refreshFilters"], ["class", "mat-typography advancedOgcFilters", 4, "ngIf"], ["mat-list-avatar", "", "igoCollapse", "", "svgIcon", "chevron-up", 1, "igo-chevron", 3, "target", "collapsed", "click"], ["matLine", "", "matTooltipShowDelay", "500", 3, "ngStyle", "matTooltip", "click"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "disabled", "matTooltip", "color", "click"], ["svgIcon", "plus"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "color", "matTooltip", "click"], [3, "ngClass", "svgIcon"], [1, "igo-layer-legend-container"], ["legend", ""], [3, "layer", 4, "ngIf"], [3, "layer"], [1, "mat-typography", "advancedOgcFilters"], ["labelPosition", "before", 3, "ngModel", "change", "ngModelChange"]], template: function OgcFilterableItemComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-list-item");
        i0.ɵɵtemplate(1, OgcFilterableItemComponent_mat_icon_1_Template, 1, 2, "mat-icon", 0);
        i0.ɵɵtemplate(2, OgcFilterableItemComponent_h4_2_Template, 2, 5, "h4", 1);
        i0.ɵɵtemplate(3, OgcFilterableItemComponent_button_3_Template, 3, 5, "button", 2);
        i0.ɵɵtemplate(4, OgcFilterableItemComponent_button_4_Template, 5, 12, "button", 3);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(5, "div", null, 4);
        i0.ɵɵtemplate(7, OgcFilterableItemComponent_div_7_Template, 4, 3, "div", 5);
        i0.ɵɵelement(8, "igo-ogc-filterable-form", 6);
        i0.ɵɵtemplate(9, OgcFilterableItemComponent_section_9_Template, 5, 4, "section", 7);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.header);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.header);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.isAdvancedOgcFilters() && ctx.filtersAreEditable);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.header);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.header);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("datasource", ctx.datasource)("map", ctx.map)("refreshFilters", ctx.refreshFunc);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.hasSelector && ctx.filtersAreEditable);
    } }, styles: ["[_nghost-%COMP%]{overflow:hidden}.advancedOgcFilters[_ngcontent-%COMP%]{text-align:center;width:100%;display:inline-block}.mat-list-item[_ngcontent-%COMP%]{height:auto}.igo-layer-legend-container[_ngcontent-%COMP%]{padding-left:1.125em;width:calc(100% - 18px)}mat-icon.disabled[_ngcontent-%COMP%]{color:#00000061}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OgcFilterableItemComponent, [{
        type: Component,
        args: [{
                selector: 'igo-ogc-filterable-item',
                templateUrl: './ogc-filterable-item.component.html',
                styleUrls: ['./ogc-filterable-item.component.scss']
            }]
    }], function () { return [{ type: OGCFilterService }]; }, { layer: [{
            type: Input
        }], map: [{
            type: Input
        }], header: [{
            type: Input
        }] }); })();

function OgcFilterableListComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-ogc-filterable-item", 2);
} if (rf & 2) {
    const layer_r1 = ctx.$implicit;
    i0.ɵɵproperty("header", true)("layer", layer_r1)("map", layer_r1.map);
} }
class OgcFilterableListComponent {
    constructor() { }
}
OgcFilterableListComponent.ɵfac = function OgcFilterableListComponent_Factory(t) { return new (t || OgcFilterableListComponent)(); };
OgcFilterableListComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OgcFilterableListComponent, selectors: [["igo-ogc-filterable-list"]], inputs: { layers: "layers", map: "map" }, decls: 3, vars: 6, consts: [[3, "navigation", "selection"], ["ngFor", "", 3, "ngForOf"], ["igoListItem", "", 3, "header", "layer", "map"]], template: function OgcFilterableListComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "igo-list", 0);
        i0.ɵɵtemplate(1, OgcFilterableListComponent_ng_template_1_Template, 1, 3, "ng-template", 1);
        i0.ɵɵpipe(2, "filterableDataSource");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("navigation", false)("selection", false);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind2(2, 3, ctx.layers, "ogc"));
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OgcFilterableListComponent, [{
        type: Component,
        args: [{
                selector: 'igo-ogc-filterable-list',
                templateUrl: './ogc-filterable-list.component.html',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { layers: [{
            type: Input
        }], map: [{
            type: Input
        }] }); })();

class OgcFilterableListBindingDirective {
    constructor(component, mapService) {
        this.mapService = mapService;
        this.component = component;
    }
    ngOnInit() {
        // Override input layers
        this.component.layers = [];
        this.layers$$ = this.mapService.getMap().layers$.subscribe(layers => {
            this.component.layers = layers.filter(layer => layer.showInLayerList);
        });
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
    }
}
OgcFilterableListBindingDirective.ɵfac = function OgcFilterableListBindingDirective_Factory(t) { return new (t || OgcFilterableListBindingDirective)(i0.ɵɵdirectiveInject(OgcFilterableListComponent, 2), i0.ɵɵdirectiveInject(MapService)); };
OgcFilterableListBindingDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: OgcFilterableListBindingDirective, selectors: [["", "igoOgcFilterableListBinding", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OgcFilterableListBindingDirective, [{
        type: Directive,
        args: [{
                selector: '[igoOgcFilterableListBinding]'
            }]
    }], function () { return [{ type: OgcFilterableListComponent, decorators: [{
                type: Self
            }] }, { type: MapService }]; }, null); })();

function OgcFilterButtonComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 2);
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 3);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 3, "igo.geo.filter.filterBy"))("color", ctx_r0.color);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matBadge", ctx_r0.badge);
} }
function OgcFilterButtonComponent_div_1_igo_ogc_filterable_item_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "igo-ogc-filterable-item", 7);
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("header", false)("map", ctx_r3.layer.map)("layer", ctx_r3.layer);
} }
function OgcFilterButtonComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 4, 5);
    i0.ɵɵtemplate(2, OgcFilterButtonComponent_div_1_igo_ogc_filterable_item_2_Template, 1, 3, "igo-ogc-filterable-item", 6);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r1.ogcFilterCollapse && ctx_r1.options.ogcFilters.enabled);
} }
class OgcFilterButtonComponent {
    constructor() {
        this.color = 'primary';
        this.ogcFilterCollapse = false;
    }
    get badge() {
        const filter = this.options.ogcFilters;
        let cnt = 0;
        if (filter && !filter.advancedOgcFilters) {
            if (filter.pushButtons) {
                const pushButtons = filter.pushButtons;
                const currentPushButtonGroup = pushButtons.groups.find(gr => gr.enabled);
                let cntPushButtons = 0;
                if (currentPushButtonGroup) {
                    currentPushButtonGroup.computedSelectors.map(cb => cntPushButtons += cb.selectors.filter(button => button.enabled).length);
                }
                cnt += cntPushButtons;
            }
            if (filter.checkboxes) {
                const checkboxes = filter.checkboxes;
                const currentCheckboxGroup = checkboxes.groups.find(gr => gr.enabled);
                let cntCheckboxes = 0;
                if (currentCheckboxGroup) {
                    currentCheckboxGroup.computedSelectors.map(cb => cntCheckboxes += cb.selectors.filter(checkbox => checkbox.enabled).length);
                }
                cnt += cntCheckboxes;
            }
            if (filter.radioButtons) {
                const radioButtons = filter.radioButtons;
                const currentRadioButtonsGroup = radioButtons.groups.find(gr => gr.enabled);
                let cntRadioButtons = 0;
                if (currentRadioButtonsGroup) {
                    currentRadioButtonsGroup.computedSelectors.map(cb => cntRadioButtons += cb.selectors.filter(radio => radio.enabled).length);
                }
                cnt += cntRadioButtons;
            }
            if (filter.select) {
                const select = filter.select;
                const currentSelectGroup = select.groups.find(gr => gr.enabled);
                let cntSelect = 0;
                if (currentSelectGroup) {
                    currentSelectGroup.computedSelectors.map(cb => cntSelect += cb.selectors.filter(multi => multi.enabled).length);
                }
                cnt += cntSelect;
            }
        }
        else if (filter && filter.filters && !filter.filters.filters) {
            return 1;
        }
        else if (filter && filter.filters && filter.filters.filters) {
            return filter.filters.filters.length;
        }
        if (filter.filters && filter.filters.operator === 'During' && filter.filters.active &&
            filter.interfaceOgcFilters && filter.interfaceOgcFilters[0].active) {
            const filterActiveValue = filter.interfaceOgcFilters[0];
            if (filter.filters.calendarModeYear) {
                // year mode check just year
                if ((filterActiveValue.begin.substring(0, 4) !== this.options.minDate.substring(0, 4)) ||
                    (filterActiveValue.end.substring(0, 4) !== this.options.maxDate.substring(0, 4))) {
                    cnt += 1;
                }
            }
            else if ((filterActiveValue.begin !== this.options.minDate) || (filterActiveValue.end !== this.options.maxDate)) {
                cnt += 1;
            }
        }
        return cnt > 0 ? cnt : undefined;
    }
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
        if (value) {
            this.options = this.layer.dataSource.options;
        }
    }
    ngOnInit() {
        this.options = this.layer.dataSource.options;
    }
}
OgcFilterButtonComponent.ɵfac = function OgcFilterButtonComponent_Factory(t) { return new (t || OgcFilterButtonComponent)(); };
OgcFilterButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OgcFilterButtonComponent, selectors: [["igo-ogc-filter-button"]], inputs: { layer: "layer", map: "map", color: "color", header: "header" }, decls: 2, vars: 2, consts: [["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", 4, "ngIf"], ["class", "igo-layer-actions-container", 4, "ngIf"], ["mat-icon-button", "", "collapsibleButton", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color"], ["matBadgeColor", "warn", "matBadgeSize", "medium", "svgIcon", "filter", 3, "matBadge"], [1, "igo-layer-actions-container"], ["ogcFilter", ""], ["igoListItem", "", 3, "header", "map", "layer", 4, "ngIf"], ["igoListItem", "", 3, "header", "map", "layer"]], template: function OgcFilterButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, OgcFilterButtonComponent_button_0_Template, 3, 5, "button", 0);
        i0.ɵɵtemplate(1, OgcFilterButtonComponent_div_1_Template, 3, 1, "div", 1);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.header && ctx.options.ogcFilters && ctx.options.ogcFilters.enabled && (ctx.options.ogcFilters.pushButtons || ctx.options.ogcFilters.checkboxes || ctx.options.ogcFilters.radioButtons || ctx.options.ogcFilters.select || ctx.options.ogcFilters.editable));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.options.ogcFilters && ctx.options.ogcFilters.enabled && (ctx.options.ogcFilters.pushButtons || ctx.options.ogcFilters.checkboxes || ctx.options.ogcFilters.radioButtons || ctx.options.ogcFilters.select || ctx.options.ogcFilters.editable));
    } }, styles: [""], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OgcFilterButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-ogc-filter-button',
                templateUrl: './ogc-filter-button.component.html',
                styleUrls: ['./ogc-filter-button.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { layer: [{
            type: Input
        }], map: [{
            type: Input
        }], color: [{
            type: Input
        }], header: [{
            type: Input
        }] }); })();

const moment$2 = moment_;
class OGCFilterTimeService {
    constructor() {
        this.defaultStepMillisecond = 60000;
    }
    step(datasource, currentFilter) {
        return datasource.options.stepDate
            ? datasource.options.stepDate
            : currentFilter.step;
    }
    stepMillisecond(dataSource, currentFilter) {
        const step = moment$2.duration(this.step(dataSource, currentFilter)).asMilliseconds();
        return step === 0 ? this.defaultStepMillisecond : step;
    }
    stepIsYearDuration(step) {
        const year = moment$2.duration(step);
        return (year.years() !== 0 &&
            year.months() === 0 &&
            year.weeks() === 0 &&
            year.days() === 0 &&
            year.hours() === 0 &&
            year.minutes() === 0);
    }
    stepIsMonthDuration(step) {
        const month = moment$2.duration(step);
        return (month.months() !== 0 &&
            month.weeks() === 0 &&
            month.days() === 0 &&
            month.hours() === 0 &&
            month.minutes() === 0);
    }
    stepIsWeekDuration(step) {
        const week = moment$2.duration(step);
        return (week.weeks() !== 0 &&
            week.days() === 7 &&
            week.hours() === 0 &&
            week.minutes() === 0);
    }
    stepIsDayDuration(step) {
        const day = moment$2.duration(step);
        return day.days() !== 0 && day.hours() === 0 && day.minutes() === 0;
    }
    stepIsHourDuration(step) {
        const hour = moment$2.duration(step);
        return hour.hours() !== 0 && hour.minutes() === 0;
    }
    stepIsMinuteDuration(step) {
        const minute = moment$2.duration(step);
        return minute.minutes() !== 0;
    }
    dateToNumber(date) {
        let newDate = new Date();
        if (date) {
            newDate = new Date(date);
        }
        return newDate.getTime();
    }
    addStep(value, stepMillisecond) {
        return moment$2(value).add(stepMillisecond, 'milliseconds').toDate();
    }
    subtractStep(value, stepMillisecond) {
        return moment$2(value).subtract(stepMillisecond, 'milliseconds').toDate();
    }
}
OGCFilterTimeService.ɵfac = function OGCFilterTimeService_Factory(t) { return new (t || OGCFilterTimeService)(); };
OGCFilterTimeService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: OGCFilterTimeService, factory: OGCFilterTimeService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OGCFilterTimeService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const _c0$6 = ["selection"];
function OgcFilterSelectionComponent_div_1_div_1_div_2_mat_option_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 12);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const selectorGroup_r10 = ctx.$implicit;
    i0.ɵɵproperty("value", selectorGroup_r10);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", selectorGroup_r10.title, " ");
} }
function OgcFilterSelectionComponent_div_1_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵelementStart(1, "mat-form-field");
    i0.ɵɵelementStart(2, "mat-select", 10);
    i0.ɵɵlistener("valueChange", function OgcFilterSelectionComponent_div_1_div_1_div_2_Template_mat_select_valueChange_2_listener($event) { i0.ɵɵrestoreView(_r12); const ctx_r11 = i0.ɵɵnextContext(3); return ctx_r11.currentPushButtonsGroup = $event; });
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵtemplate(4, OgcFilterSelectionComponent_div_1_div_1_div_2_mat_option_4_Template, 2, 2, "mat-option", 11);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(3, 3, "igo.geo.layer.legend.selectStyle"))("value", ctx_r7.currentPushButtonsGroup);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r7.getPushButtonsGroups());
} }
function OgcFilterSelectionComponent_div_1_div_1_ng_container_3_mat_button_toggle_4_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-button-toggle", 15);
    i0.ɵɵlistener("change", function OgcFilterSelectionComponent_div_1_div_1_ng_container_3_mat_button_toggle_4_Template_mat_button_toggle_change_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r17); const ogcPushButton_r15 = restoredCtx.$implicit; const selector_r2 = i0.ɵɵnextContext(3).$implicit; const ctx_r16 = i0.ɵɵnextContext(); return ctx_r16.onSelectionChange(ogcPushButton_r15, selector_r2.selectorType); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ogcPushButton_r15 = ctx.$implicit;
    const ctx_r14 = i0.ɵɵnextContext(4);
    i0.ɵɵproperty("matTooltip", ctx_r14.getToolTip(ogcPushButton_r15))("ngStyle", ctx_r14.getButtonColor(ogcPushButton_r15))("checked", ogcPushButton_r15.enabled)("value", ogcPushButton_r15);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ogcPushButton_r15.title, " ");
} }
function OgcFilterSelectionComponent_div_1_div_1_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "h4");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "mat-button-toggle-group", 13);
    i0.ɵɵtemplate(4, OgcFilterSelectionComponent_div_1_div_1_ng_container_3_mat_button_toggle_4_Template, 2, 5, "mat-button-toggle", 14);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const bundle_r13 = ctx.$implicit;
    const ctx_r8 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(bundle_r13.title);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("vertical", ctx_r8.bundleIsVertical(bundle_r13));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", bundle_r13.selectors);
} }
function OgcFilterSelectionComponent_div_1_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 7);
    i0.ɵɵelement(1, "mat-divider");
    i0.ɵɵtemplate(2, OgcFilterSelectionComponent_div_1_div_1_div_2_Template, 5, 5, "div", 8);
    i0.ɵɵtemplate(3, OgcFilterSelectionComponent_div_1_div_1_ng_container_3_Template, 5, 3, "ng-container", 1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.getPushButtonsGroups().length > 1);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r3.currentPushButtonsGroup.computedSelectors);
} }
function OgcFilterSelectionComponent_div_1_div_2_div_2_mat_option_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 12);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const selectorGroup_r22 = ctx.$implicit;
    i0.ɵɵproperty("value", selectorGroup_r22);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", selectorGroup_r22.title, " ");
} }
function OgcFilterSelectionComponent_div_1_div_2_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r24 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵelementStart(1, "mat-form-field");
    i0.ɵɵelementStart(2, "mat-select", 17);
    i0.ɵɵlistener("valueChange", function OgcFilterSelectionComponent_div_1_div_2_div_2_Template_mat_select_valueChange_2_listener($event) { i0.ɵɵrestoreView(_r24); const ctx_r23 = i0.ɵɵnextContext(3); return ctx_r23.currentCheckboxesGroup = $event; });
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵtemplate(4, OgcFilterSelectionComponent_div_1_div_2_div_2_mat_option_4_Template, 2, 2, "mat-option", 11);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r19 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(3, 3, "igo.geo.layer.legend.selectStyle"))("value", ctx_r19.currentCheckboxesGroup);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r19.getCheckboxesGroups());
} }
function OgcFilterSelectionComponent_div_1_div_2_ng_container_3_mat_checkbox_4_Template(rf, ctx) { if (rf & 1) {
    const _r30 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-checkbox", 20);
    i0.ɵɵlistener("change", function OgcFilterSelectionComponent_div_1_div_2_ng_container_3_mat_checkbox_4_Template_mat_checkbox_change_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r30); const ogcCheckbox_r28 = restoredCtx.$implicit; const selector_r2 = i0.ɵɵnextContext(3).$implicit; const ctx_r29 = i0.ɵɵnextContext(); return ctx_r29.onSelectionChange(ogcCheckbox_r28, selector_r2.selectorType); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ogcCheckbox_r28 = ctx.$implicit;
    const ctx_r26 = i0.ɵɵnextContext(4);
    i0.ɵɵproperty("matTooltip", ctx_r26.getToolTip(ogcCheckbox_r28))("checked", ogcCheckbox_r28.enabled)("value", ogcCheckbox_r28);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ogcCheckbox_r28.title, " ");
} }
function OgcFilterSelectionComponent_div_1_div_2_ng_container_3_p_5_u_1_Template(rf, ctx) { if (rf & 1) {
    const _r35 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "u", 23);
    i0.ɵɵlistener("click", function OgcFilterSelectionComponent_div_1_div_2_ng_container_3_p_5_u_1_Template_u_click_0_listener() { i0.ɵɵrestoreView(_r35); const ctx_r34 = i0.ɵɵnextContext(5); return ctx_r34.displayLessResults("checkbox"); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", i0.ɵɵpipeBind1(2, 1, "igo.geo.filter.displayLessResults"), " ");
} }
function OgcFilterSelectionComponent_div_1_div_2_ng_container_3_p_5_u_2_Template(rf, ctx) { if (rf & 1) {
    const _r37 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "u", 24);
    i0.ɵɵlistener("click", function OgcFilterSelectionComponent_div_1_div_2_ng_container_3_p_5_u_2_Template_u_click_0_listener() { i0.ɵɵrestoreView(_r37); const ctx_r36 = i0.ɵɵnextContext(5); return ctx_r36.displayMoreResults("checkbox"); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", i0.ɵɵpipeBind1(2, 1, "igo.geo.filter.displayMoreResults"), " ");
} }
function OgcFilterSelectionComponent_div_1_div_2_ng_container_3_p_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p");
    i0.ɵɵtemplate(1, OgcFilterSelectionComponent_div_1_div_2_ng_container_3_p_5_u_1_Template, 3, 3, "u", 21);
    i0.ɵɵtemplate(2, OgcFilterSelectionComponent_div_1_div_2_ng_container_3_p_5_u_2_Template, 3, 3, "u", 22);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const bundle_r25 = i0.ɵɵnextContext().$implicit;
    const ctx_r27 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r27.isLessResults(bundle_r25, "checkbox"));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r27.isMoreResults(bundle_r25, "checkbox"));
} }
function OgcFilterSelectionComponent_div_1_div_2_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "h4");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "div", 18);
    i0.ɵɵtemplate(4, OgcFilterSelectionComponent_div_1_div_2_ng_container_3_mat_checkbox_4_Template, 2, 4, "mat-checkbox", 19);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(5, OgcFilterSelectionComponent_div_1_div_2_ng_container_3_p_5_Template, 3, 2, "p", 2);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const bundle_r25 = ctx.$implicit;
    const ctx_r20 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(bundle_r25.title);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", bundle_r25.selectors);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r20.isLessResults(bundle_r25, "checkbox") || ctx_r20.isMoreResults(bundle_r25, "checkbox"));
} }
function OgcFilterSelectionComponent_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 16);
    i0.ɵɵelement(1, "mat-divider");
    i0.ɵɵtemplate(2, OgcFilterSelectionComponent_div_1_div_2_div_2_Template, 5, 5, "div", 8);
    i0.ɵɵtemplate(3, OgcFilterSelectionComponent_div_1_div_2_ng_container_3_Template, 6, 3, "ng-container", 1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.getCheckboxesGroups().length > 1);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r4.currentCheckboxesGroup.computedSelectors);
} }
function OgcFilterSelectionComponent_div_1_div_3_div_2_mat_option_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 12);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const selectorGroup_r42 = ctx.$implicit;
    i0.ɵɵproperty("value", selectorGroup_r42);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", selectorGroup_r42.title, " ");
} }
function OgcFilterSelectionComponent_div_1_div_3_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r44 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵelementStart(1, "mat-form-field");
    i0.ɵɵelementStart(2, "mat-select", 26);
    i0.ɵɵlistener("valueChange", function OgcFilterSelectionComponent_div_1_div_3_div_2_Template_mat_select_valueChange_2_listener($event) { i0.ɵɵrestoreView(_r44); const ctx_r43 = i0.ɵɵnextContext(3); return ctx_r43.currentRadioButtonsGroup = $event; });
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵtemplate(4, OgcFilterSelectionComponent_div_1_div_3_div_2_mat_option_4_Template, 2, 2, "mat-option", 11);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r39 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(3, 3, "igo.geo.layer.legend.selectStyle"))("value", ctx_r39.currentRadioButtonsGroup);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r39.getRadioButtonsGroups());
} }
function OgcFilterSelectionComponent_div_1_div_3_ng_container_3_mat_radio_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r50 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-radio-button", 29);
    i0.ɵɵlistener("change", function OgcFilterSelectionComponent_div_1_div_3_ng_container_3_mat_radio_button_4_Template_mat_radio_button_change_0_listener() { i0.ɵɵrestoreView(_r50); const ctx_r49 = i0.ɵɵnextContext(4); return ctx_r49.emptyRadioButtons(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 2, "igo.geo.filter.resetFilters"));
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("", i0.ɵɵpipeBind1(3, 4, "igo.geo.filter.resetFilters"), " ");
} }
function OgcFilterSelectionComponent_div_1_div_3_ng_container_3_mat_radio_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r53 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-radio-button", 20);
    i0.ɵɵlistener("change", function OgcFilterSelectionComponent_div_1_div_3_ng_container_3_mat_radio_button_5_Template_mat_radio_button_change_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r53); const ogcRadioButton_r51 = restoredCtx.$implicit; const selector_r2 = i0.ɵɵnextContext(3).$implicit; const ctx_r52 = i0.ɵɵnextContext(); return ctx_r52.onSelectionChange(ogcRadioButton_r51, selector_r2.selectorType); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ogcRadioButton_r51 = ctx.$implicit;
    const ctx_r47 = i0.ɵɵnextContext(4);
    i0.ɵɵproperty("matTooltip", ctx_r47.getToolTip(ogcRadioButton_r51))("checked", ogcRadioButton_r51.enabled)("value", ogcRadioButton_r51);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ogcRadioButton_r51.title, " ");
} }
function OgcFilterSelectionComponent_div_1_div_3_ng_container_3_p_6_u_1_Template(rf, ctx) { if (rf & 1) {
    const _r58 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "u", 23);
    i0.ɵɵlistener("click", function OgcFilterSelectionComponent_div_1_div_3_ng_container_3_p_6_u_1_Template_u_click_0_listener() { i0.ɵɵrestoreView(_r58); const ctx_r57 = i0.ɵɵnextContext(5); return ctx_r57.displayLessResults("radio"); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", i0.ɵɵpipeBind1(2, 1, "igo.geo.filter.displayLessResults"), " ");
} }
function OgcFilterSelectionComponent_div_1_div_3_ng_container_3_p_6_u_2_Template(rf, ctx) { if (rf & 1) {
    const _r60 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "u", 24);
    i0.ɵɵlistener("click", function OgcFilterSelectionComponent_div_1_div_3_ng_container_3_p_6_u_2_Template_u_click_0_listener() { i0.ɵɵrestoreView(_r60); const ctx_r59 = i0.ɵɵnextContext(5); return ctx_r59.displayMoreResults("radio"); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", i0.ɵɵpipeBind1(2, 1, "igo.geo.filter.displayMoreResults"), " ");
} }
function OgcFilterSelectionComponent_div_1_div_3_ng_container_3_p_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p");
    i0.ɵɵtemplate(1, OgcFilterSelectionComponent_div_1_div_3_ng_container_3_p_6_u_1_Template, 3, 3, "u", 21);
    i0.ɵɵtemplate(2, OgcFilterSelectionComponent_div_1_div_3_ng_container_3_p_6_u_2_Template, 3, 3, "u", 22);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const bundle_r45 = i0.ɵɵnextContext().$implicit;
    const ctx_r48 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r48.isLessResults(bundle_r45, "radio"));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r48.isMoreResults(bundle_r45, "radio"));
} }
function OgcFilterSelectionComponent_div_1_div_3_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "h4");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "mat-radio-group", 27);
    i0.ɵɵtemplate(4, OgcFilterSelectionComponent_div_1_div_3_ng_container_3_mat_radio_button_4_Template, 4, 6, "mat-radio-button", 28);
    i0.ɵɵtemplate(5, OgcFilterSelectionComponent_div_1_div_3_ng_container_3_mat_radio_button_5_Template, 2, 4, "mat-radio-button", 19);
    i0.ɵɵtemplate(6, OgcFilterSelectionComponent_div_1_div_3_ng_container_3_p_6_Template, 3, 2, "p", 2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const bundle_r45 = ctx.$implicit;
    const ctx_r40 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(bundle_r45.title);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", bundle_r45.unfiltered);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", bundle_r45.selectors);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r40.isLessResults(bundle_r45, "radio") || ctx_r40.isMoreResults(bundle_r45, "radio"));
} }
function OgcFilterSelectionComponent_div_1_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 25);
    i0.ɵɵelement(1, "mat-divider");
    i0.ɵɵtemplate(2, OgcFilterSelectionComponent_div_1_div_3_div_2_Template, 5, 5, "div", 8);
    i0.ɵɵtemplate(3, OgcFilterSelectionComponent_div_1_div_3_ng_container_3_Template, 7, 4, "ng-container", 1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.getRadioButtonsGroups().length > 1);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r5.currentRadioButtonsGroup.computedSelectors);
} }
function OgcFilterSelectionComponent_div_1_div_4_div_2_mat_option_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 12);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const selectorGroup_r65 = ctx.$implicit;
    i0.ɵɵproperty("value", selectorGroup_r65);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", selectorGroup_r65.title, " ");
} }
function OgcFilterSelectionComponent_div_1_div_4_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r67 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵelementStart(1, "mat-form-field");
    i0.ɵɵelementStart(2, "mat-select", 31);
    i0.ɵɵlistener("valueChange", function OgcFilterSelectionComponent_div_1_div_4_div_2_Template_mat_select_valueChange_2_listener($event) { i0.ɵɵrestoreView(_r67); const ctx_r66 = i0.ɵɵnextContext(3); return ctx_r66.currentSelectGroup = $event; });
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵtemplate(4, OgcFilterSelectionComponent_div_1_div_4_div_2_mat_option_4_Template, 2, 2, "mat-option", 11);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r62 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(3, 3, "igo.geo.layer.legend.selectStyle"))("value", ctx_r62.currentSelectGroup);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r62.getSelectGroups());
} }
function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_mat_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r74 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-button", 35);
    i0.ɵɵlistener("click", function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_mat_button_4_Template_mat_button_click_0_listener() { i0.ɵɵrestoreView(_r74); const ctx_r73 = i0.ɵɵnextContext(4); return ctx_r73.emptySelect(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 36);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.filter.resetFilters"));
} }
const _c1$5 = function () { return { standalone: true }; };
function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_div_6_mat_checkbox_4_Template(rf, ctx) { if (rf & 1) {
    const _r79 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-checkbox", 41);
    i0.ɵɵlistener("ngModelChange", function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_div_6_mat_checkbox_4_Template_mat_checkbox_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r79); const ctx_r78 = i0.ɵɵnextContext(5); return ctx_r78.allSelected = $event; })("change", function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_div_6_mat_checkbox_4_Template_mat_checkbox_change_0_listener() { i0.ɵɵrestoreView(_r79); const ctx_r80 = i0.ɵɵnextContext(5); return ctx_r80.toggleAllSelection(); });
    i0.ɵɵtext(1, "Tous ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r76 = i0.ɵɵnextContext(5);
    i0.ɵɵproperty("ngModel", ctx_r76.allSelected)("ngModelOptions", i0.ɵɵpureFunction0(2, _c1$5));
} }
function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_div_6_mat_option_5_Template(rf, ctx) { if (rf & 1) {
    const _r83 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-option", 42);
    i0.ɵɵlistener("onSelectionChange", function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_div_6_mat_option_5_Template_mat_option_onSelectionChange_0_listener() { i0.ɵɵrestoreView(_r83); const ctx_r82 = i0.ɵɵnextContext(5); return ctx_r82.optionClick(); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ogcSelect_r81 = ctx.$implicit;
    const ctx_r77 = i0.ɵɵnextContext(5);
    i0.ɵɵproperty("matTooltip", ctx_r77.getToolTip(ogcSelect_r81))("value", ogcSelect_r81);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ogcSelect_r81.title, " ");
} }
function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r85 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelementStart(1, "mat-select", 37, 38);
    i0.ɵɵlistener("ngModelChange", function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_div_6_Template_mat_select_ngModelChange_1_listener($event) { i0.ɵɵrestoreView(_r85); const ctx_r84 = i0.ɵɵnextContext(4); return ctx_r84.enableds = $event; });
    i0.ɵɵelementStart(3, "div", 18);
    i0.ɵɵtemplate(4, OgcFilterSelectionComponent_div_1_div_4_ng_container_3_div_6_mat_checkbox_4_Template, 2, 3, "mat-checkbox", 39);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(5, OgcFilterSelectionComponent_div_1_div_4_ng_container_3_div_6_mat_option_5_Template, 2, 3, "mat-option", 40);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const bundle_r68 = i0.ɵɵnextContext().$implicit;
    const ctx_r70 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("multiple", bundle_r68.multiple)("placeholder", bundle_r68.title)("formControl", ctx_r70.select)("ngModel", ctx_r70.enableds);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", bundle_r68.multiple);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", bundle_r68.selectors);
} }
function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_ng_template_7_mat_option_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 45);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ogcSelect_r88 = ctx.$implicit;
    const ctx_r87 = i0.ɵɵnextContext(5);
    i0.ɵɵproperty("matTooltip", ctx_r87.getToolTip(ogcSelect_r88))("value", ogcSelect_r88);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ogcSelect_r88.title, " ");
} }
function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    const _r90 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-select", 43);
    i0.ɵɵlistener("ngModelChange", function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_ng_template_7_Template_mat_select_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r90); const ctx_r89 = i0.ɵɵnextContext(4); return ctx_r89.enabled = $event; });
    i0.ɵɵtemplate(1, OgcFilterSelectionComponent_div_1_div_4_ng_container_3_ng_template_7_mat_option_1_Template, 2, 3, "mat-option", 44);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const bundle_r68 = i0.ɵɵnextContext().$implicit;
    const ctx_r72 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("placeholder", bundle_r68.title)("formControl", ctx_r72.select)("ngModel", ctx_r72.enabled);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", bundle_r68.selectors);
} }
function OgcFilterSelectionComponent_div_1_div_4_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "h4");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "div", 9);
    i0.ɵɵtemplate(4, OgcFilterSelectionComponent_div_1_div_4_ng_container_3_mat_button_4_Template, 3, 3, "mat-button", 32);
    i0.ɵɵelementStart(5, "mat-form-field");
    i0.ɵɵtemplate(6, OgcFilterSelectionComponent_div_1_div_4_ng_container_3_div_6_Template, 6, 6, "div", 33);
    i0.ɵɵtemplate(7, OgcFilterSelectionComponent_div_1_div_4_ng_container_3_ng_template_7_Template, 2, 4, "ng-template", null, 34, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const bundle_r68 = ctx.$implicit;
    const _r71 = i0.ɵɵreference(8);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(bundle_r68.title);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", bundle_r68.unfiltered && !bundle_r68.multiple);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", bundle_r68.multiple)("ngIfElse", _r71);
} }
function OgcFilterSelectionComponent_div_1_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 30);
    i0.ɵɵelement(1, "mat-divider");
    i0.ɵɵtemplate(2, OgcFilterSelectionComponent_div_1_div_4_div_2_Template, 5, 5, "div", 8);
    i0.ɵɵtemplate(3, OgcFilterSelectionComponent_div_1_div_4_ng_container_3_Template, 9, 4, "ng-container", 1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r6.getSelectGroups().length > 1);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r6.currentSelectGroup.computedSelectors);
} }
function OgcFilterSelectionComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtemplate(1, OgcFilterSelectionComponent_div_1_div_1_Template, 4, 2, "div", 3);
    i0.ɵɵtemplate(2, OgcFilterSelectionComponent_div_1_div_2_Template, 4, 2, "div", 4);
    i0.ɵɵtemplate(3, OgcFilterSelectionComponent_div_1_div_3_Template, 4, 2, "div", 5);
    i0.ɵɵtemplate(4, OgcFilterSelectionComponent_div_1_div_4_Template, 4, 2, "div", 6);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const selector_r2 = ctx.$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", selector_r2.selectorType === "pushButton");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", selector_r2.selectorType === "checkbox");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", selector_r2.selectorType === "radioButton");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", selector_r2.selectorType === "select");
} }
function OgcFilterSelectionComponent_div_2_h4_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "h4");
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(2, 1, "igo.geo.filter.reportingDate"));
} }
function OgcFilterSelectionComponent_div_2_h4_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "h4");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r93 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r93.currentFilter.title);
} }
function OgcFilterSelectionComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r95 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵelement(1, "mat-divider");
    i0.ɵɵtemplate(2, OgcFilterSelectionComponent_div_2_h4_2_Template, 3, 3, "h4", 2);
    i0.ɵɵtemplate(3, OgcFilterSelectionComponent_div_2_h4_3_Template, 2, 1, "h4", 2);
    i0.ɵɵelementStart(4, "igo-ogc-filter-time", 46);
    i0.ɵɵlistener("datasourceChange", function OgcFilterSelectionComponent_div_2_Template_igo_ogc_filter_time_datasourceChange_4_listener($event) { i0.ɵɵrestoreView(_r95); const ctx_r94 = i0.ɵɵnextContext(); return ctx_r94.datasource = $event; })("currentFilterChange", function OgcFilterSelectionComponent_div_2_Template_igo_ogc_filter_time_currentFilterChange_4_listener($event) { i0.ɵɵrestoreView(_r95); const ctx_r96 = i0.ɵɵnextContext(); return ctx_r96.currentFilter = $event; })("changeProperty", function OgcFilterSelectionComponent_div_2_Template_igo_ogc_filter_time_changeProperty_4_listener($event) { i0.ɵɵrestoreView(_r95); const ctx_r97 = i0.ɵɵnextContext(); return ctx_r97.changeProperty($event.value, $event.pos); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r1.currentFilter.title);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r1.currentFilter.title);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("datasource", ctx_r1.datasource)("currentFilter", ctx_r1.currentFilter);
} }
class OgcFilterSelectionComponent {
    constructor(ogcFilterService, formBuilder) {
        this.ogcFilterService = ogcFilterService;
        this.formBuilder = formBuilder;
        this.checkboxesIndex = 5;
        this.radioButtonsIndex = 5;
        this.baseIndex = 5;
        this.ogcFilterOperator = OgcFilterOperator;
        this.color = 'primary';
        this.allSelected = false;
        this.select = new FormControl();
        this.enabled$ = new BehaviorSubject(undefined);
        this.enableds$ = new BehaviorSubject([]);
        this.ogcFilterWriter = new OgcFilterWriter();
        this.buildForm();
    }
    get currentFilter() {
        return this._currentFilter;
    }
    set currentFilter(value) {
        var _a;
        this._currentFilter = value;
        if ((_a = this._currentFilter) === null || _a === void 0 ? void 0 : _a.sliderOptions) {
            this._currentFilter.sliderOptions.enabled = false; // remove slider toggle (animation temporelle)
        }
    }
    get ogcFiltersSelectors() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        const ogcSelector = [];
        if ((_c = (_b = (_a = this.datasource) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.ogcFilters) === null || _c === void 0 ? void 0 : _c.pushButtons) {
            ogcSelector.push((_f = (_e = (_d = this.datasource) === null || _d === void 0 ? void 0 : _d.options) === null || _e === void 0 ? void 0 : _e.ogcFilters) === null || _f === void 0 ? void 0 : _f.pushButtons);
        }
        if ((_j = (_h = (_g = this.datasource) === null || _g === void 0 ? void 0 : _g.options) === null || _h === void 0 ? void 0 : _h.ogcFilters) === null || _j === void 0 ? void 0 : _j.checkboxes) {
            ogcSelector.push((_m = (_l = (_k = this.datasource) === null || _k === void 0 ? void 0 : _k.options) === null || _l === void 0 ? void 0 : _l.ogcFilters) === null || _m === void 0 ? void 0 : _m.checkboxes);
        }
        if ((_q = (_p = (_o = this.datasource) === null || _o === void 0 ? void 0 : _o.options) === null || _p === void 0 ? void 0 : _p.ogcFilters) === null || _q === void 0 ? void 0 : _q.radioButtons) {
            ogcSelector.push((_t = (_s = (_r = this.datasource) === null || _r === void 0 ? void 0 : _r.options) === null || _s === void 0 ? void 0 : _s.ogcFilters) === null || _t === void 0 ? void 0 : _t.radioButtons);
        }
        if ((_w = (_v = (_u = this.datasource) === null || _u === void 0 ? void 0 : _u.options) === null || _v === void 0 ? void 0 : _v.ogcFilters) === null || _w === void 0 ? void 0 : _w.select) {
            ogcSelector.push((_z = (_y = (_x = this.datasource) === null || _x === void 0 ? void 0 : _x.options) === null || _y === void 0 ? void 0 : _y.ogcFilters) === null || _z === void 0 ? void 0 : _z.select);
        }
        ogcSelector.sort((a, b) => {
            if (a.order < b.order) {
                return -1;
            }
            if (a.order > b.order) {
                return 1;
            }
            return 0;
        });
        return ogcSelector;
    }
    get currentPushButtonsGroup() {
        return this.form.get('pushButtonsGroup').value;
    }
    set currentPushButtonsGroup(value) {
        this.form.patchValue({ pushButtonsGroup: value });
    }
    get currentCheckboxesGroup() {
        return this.form.get('checkboxesGroup').value;
    }
    set currentCheckboxesGroup(value) {
        this.form.patchValue({ checkboxesGroup: value });
    }
    get currentRadioButtonsGroup() {
        return this.form.get('radioButtonsGroup').value;
    }
    set currentRadioButtonsGroup(value) {
        this.form.patchValue({ radioButtonsGroup: value });
    }
    get currentSelectGroup() {
        return this.form.get('selectGroup').value;
    }
    set currentSelectGroup(value) {
        this.form.patchValue({ selectGroup: value });
    }
    get enabled() {
        return this.enabled$.value;
    }
    set enabled(value) {
        this.enabled$.next(value);
        clearTimeout(this.applyFiltersTimeout);
        this.currentSelectGroup.computedSelectors.forEach(compSelect => {
            compSelect.selectors.forEach(selector => {
                value === selector ? selector.enabled = true : selector.enabled = false;
            });
        });
        this.applyFiltersTimeout = setTimeout(() => {
            this.applyFilters();
        }, 750);
    }
    get enableds() {
        return this.enableds$.value;
    }
    set enableds(value) {
        this.enableds$.next(value);
        clearTimeout(this.applyFiltersTimeout);
        this.currentSelectGroup.computedSelectors.forEach(compSelect => {
            compSelect.selectors.forEach(selector => {
                value.includes(selector) ? selector.enabled = true : selector.enabled = false;
            });
        });
        this.applyFiltersTimeout = setTimeout(() => {
            this.applyFilters();
        }, 750);
    }
    buildForm() {
        this.form = this.formBuilder.group({
            pushButtons: ['', [Validators.required]],
            radioButtons: ['', [Validators.required]],
            pushButtonsGroup: ['', [Validators.required]],
            checkboxesGroup: ['', [Validators.required]],
            radioButtonsGroup: ['', [Validators.required]],
            selectGroup: ['', [Validators.required]],
        });
    }
    getPushButtonsGroups() {
        var _a, _b, _c;
        if ((_c = (_b = (_a = this.datasource) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.ogcFilters) === null || _c === void 0 ? void 0 : _c.pushButtons) {
            return this.datasource.options.ogcFilters.pushButtons.groups;
        }
    }
    getCheckboxesGroups() {
        var _a, _b, _c;
        if ((_c = (_b = (_a = this.datasource) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.ogcFilters) === null || _c === void 0 ? void 0 : _c.checkboxes) {
            return this.datasource.options.ogcFilters.checkboxes.groups;
        }
    }
    getRadioButtonsGroups() {
        var _a, _b, _c;
        if ((_c = (_b = (_a = this.datasource) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.ogcFilters) === null || _c === void 0 ? void 0 : _c.radioButtons) {
            return this.datasource.options.ogcFilters.radioButtons.groups;
        }
    }
    getSelectGroups() {
        var _a, _b, _c;
        if ((_c = (_b = (_a = this.datasource) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.ogcFilters) === null || _c === void 0 ? void 0 : _c.select) {
            return this.datasource.options.ogcFilters.select.groups;
        }
    }
    ngOnInit() {
        if (this.datasource.options.ogcFilters) {
            if (this.datasource.options.ogcFilters.pushButtons) {
                this.currentPushButtonsGroup =
                    this.datasource.options.ogcFilters.pushButtons.groups.find(group => group.enabled) ||
                        this.datasource.options.ogcFilters.pushButtons.groups[0];
            }
            if (this.datasource.options.ogcFilters.checkboxes) {
                this.currentCheckboxesGroup =
                    this.datasource.options.ogcFilters.checkboxes.groups.find(group => group.enabled) ||
                        this.datasource.options.ogcFilters.checkboxes.groups[0];
            }
            if (this.datasource.options.ogcFilters.radioButtons) {
                this.currentRadioButtonsGroup =
                    this.datasource.options.ogcFilters.radioButtons.groups.find(group => group.enabled) ||
                        this.datasource.options.ogcFilters.radioButtons.groups[0];
            }
            if (this.datasource.options.ogcFilters.select) {
                this.currentSelectGroup =
                    this.datasource.options.ogcFilters.select.groups.find(group => group.enabled) ||
                        this.datasource.options.ogcFilters.select.groups[0];
                this.getSelectEnabled();
            }
            this.applyFilters();
        }
        this.form
            .get('pushButtonsGroup')
            .valueChanges
            .pipe(debounceTime(750))
            .subscribe(() => {
            this.onPushButtonsChangeGroup();
            this.applyFilters();
        });
        this.form
            .get('checkboxesGroup')
            .valueChanges
            .pipe(debounceTime(750))
            .subscribe(() => {
            this.onCheckboxesChangeGroup();
            this.applyFilters();
        });
        this.form
            .get('radioButtonsGroup')
            .valueChanges
            .pipe(debounceTime(750))
            .subscribe(() => {
            this.onRadioButtonsChangeGroup();
            this.applyFilters();
        });
        this.form
            .get('selectGroup')
            .valueChanges
            .pipe(debounceTime(750))
            .subscribe(() => {
            this.onSelectChangeGroup();
            this.applyFilters();
        });
        this.form
            .get('pushButtons')
            .valueChanges
            .pipe(debounceTime(750))
            .subscribe(() => {
            this.applyFilters();
        });
        this.form
            .get('radioButtons')
            .valueChanges
            .pipe(debounceTime(750))
            .subscribe(() => {
            this.applyFilters();
        });
    }
    getSelectEnabled() {
        const enableds = [];
        let enabled;
        this.currentSelectGroup.computedSelectors.forEach(compSelect => {
            if (compSelect.multiple) {
                compSelect.selectors.forEach(selector => {
                    if (selector.enabled) {
                        enableds.push(selector);
                    }
                });
                this.enableds = enableds;
            }
            else {
                compSelect.selectors.forEach(selector => {
                    if (selector.enabled) {
                        enabled = selector;
                    }
                });
                this.enabled = enabled;
            }
        });
    }
    getToolTip(selector) {
        let toolTip;
        if (selector.tooltip) {
            if (Array.isArray(selector.tooltip)) {
                toolTip = selector.tooltip.join('\n');
            }
            else {
                toolTip = selector.tooltip;
            }
        }
        return toolTip || '';
    }
    // getButtonStyle(pb: OgcPushButton): {} {
    //   let styles;
    //   if (pb.color) {
    //     styles = {
    //       'background-color': pb.enabled ? `rgba(${pb.color})` : `rgba(255,255,255,0)`
    //     };
    //   } else {
    //     styles = {
    //       'background-color': pb.enabled ? 'accent': `rgba(255,255,255,0)`,
    //       'color': pb.enabled ? `rgba(0,0,0,0.9)` : `rgba(33,33,33,0.38)`
    //     }
    //   }
    //   return styles;
    // }
    getButtonColor(pushButton) {
        let styles;
        if (pushButton.color && pushButton.enabled) {
            styles = {
                'background-color': `rgba(${pushButton.color})`
            };
        }
        return styles;
    }
    bundleIsVertical(bundle) {
        return bundle.vertical ? bundle.vertical : false;
    }
    onPushButtonsChangeGroup() {
        this.getPushButtonsGroups().map(group => group.enabled = false);
        this.getPushButtonsGroups().find(group => group === this.currentPushButtonsGroup).enabled = true;
    }
    onCheckboxesChangeGroup() {
        this.getCheckboxesGroups().map(group => group.enabled = false);
        this.getCheckboxesGroups().find(group => group === this.currentCheckboxesGroup).enabled = true;
    }
    onRadioButtonsChangeGroup() {
        this.getRadioButtonsGroups().map(group => group.enabled = false);
        this.getRadioButtonsGroups().find(group => group === this.currentRadioButtonsGroup).enabled = true;
    }
    onSelectChangeGroup() {
        this.getSelectGroups().map(group => group.enabled = false);
        this.getSelectGroups().find(group => group === this.currentSelectGroup).enabled = true;
    }
    onSelectionChange(currentOgcSelection, selectorType) {
        clearTimeout(this.applyFiltersTimeout);
        if (selectorType === 'radioButton') {
            this.emptyRadioButtons();
        }
        if (currentOgcSelection) {
            currentOgcSelection.enabled = !currentOgcSelection.enabled;
        }
        this.applyFiltersTimeout = setTimeout(() => {
            this.applyFilters();
        }, 750);
    }
    emptyRadioButtons() {
        this.currentRadioButtonsGroup.computedSelectors.forEach(compSelect => {
            compSelect.selectors.map(selector => selector.enabled = false);
            this.applyFiltersTimeout = setTimeout(() => {
                this.applyFilters();
            }, 750);
        });
    }
    emptySelect() {
        this.enabled = [];
    }
    toggleAllSelection() {
        if (this.allSelected) {
            this.sel.options.forEach((item) => item.select());
        }
        else {
            this.sel.options.forEach((item) => item.deselect());
        }
    }
    optionClick() {
        let newStatus = true;
        this.sel.options.forEach((item) => {
            if (!item.selected) {
                newStatus = false;
            }
        });
        this.allSelected = newStatus;
    }
    applyFilters() {
        let filterQueryString = '';
        const conditions = [];
        const currentGroups = [this.currentPushButtonsGroup, this.currentCheckboxesGroup,
            this.currentRadioButtonsGroup, this.currentSelectGroup];
        for (const currentGroup of currentGroups) {
            if (currentGroup.computedSelectors) {
                currentGroup.computedSelectors.map(selectorBundle => {
                    const bundleCondition = [];
                    selectorBundle.selectors
                        .filter(ogcSelector => ogcSelector.enabled === true)
                        .forEach(enabledSelector => bundleCondition.push(enabledSelector.filters));
                    if (bundleCondition.length >= 1) {
                        if (bundleCondition.length === 1) {
                            conditions.push(bundleCondition[0]);
                        }
                        else {
                            conditions.push({ logical: selectorBundle.logical, filters: bundleCondition });
                        }
                    }
                });
            }
        }
        if (this.isTemporalOperator() && this._currentFilter.active) {
            conditions.push(this.datasource.options.ogcFilters.interfaceOgcFilters[0]);
        }
        if (conditions.length >= 1) {
            filterQueryString = this.ogcFilterWriter
                .buildFilter(conditions.length === 1 ?
                conditions[0] : { logical: 'And', filters: conditions });
        }
        if (this.datasource.options.type === 'wms') {
            this.ogcFilterService.filterByOgc(this.datasource, filterQueryString);
        }
        if (this.datasource.options.type === 'wfs') {
            // TODO: Check how to prevent wfs to refresh when filter icon is pushed...
            this.datasource.ol.refresh();
        }
        this.datasource.setOgcFilters(this.datasource.options.ogcFilters, true);
    }
    isMoreResults(bundle, type) {
        let selectorsLength = 0;
        for (const selectors of bundle.selectors) {
            selectorsLength++;
        }
        const index = type === 'radio' ? this.radioButtonsIndex : this.checkboxesIndex;
        return selectorsLength > index;
    }
    displayMoreResults(type) {
        type === 'radio' ? this.radioButtonsIndex += 5 : this.checkboxesIndex += 5;
        return;
    }
    isLessResults(bundle, type) {
        let selectorsLength = 0;
        for (const selectors of bundle.selectors) {
            selectorsLength++;
        }
        const index = type === 'radio' ? this.radioButtonsIndex : this.checkboxesIndex;
        return this.baseIndex !== index && selectorsLength > this.baseIndex;
    }
    displayLessResults(type) {
        type === 'radio' ? this.radioButtonsIndex = this.baseIndex : this.checkboxesIndex = this.baseIndex;
        return;
    }
    isTemporalOperator() {
        var _a, _b;
        return (((_b = (_a = this.currentFilter) === null || _a === void 0 ? void 0 : _a.operator) === null || _b === void 0 ? void 0 : _b.toLowerCase()) ===
            this.ogcFilterOperator.During.toLowerCase());
    }
    changeProperty(value, pos, refreshFilter = true) {
        const detectedProperty = this.detectProperty(pos);
        if (detectedProperty) {
            this.datasource.options.ogcFilters.interfaceOgcFilters.find(filter => filter.filterid === this.currentFilter.filterid)[detectedProperty] = value;
            if (refreshFilter) {
                this.applyFilters();
            }
        }
    }
    detectProperty(pos) {
        switch (this.currentFilter.operator) {
            case OgcFilterOperator.PropertyIsNotEqualTo:
            case OgcFilterOperator.PropertyIsEqualTo:
            case OgcFilterOperator.PropertyIsGreaterThan:
            case OgcFilterOperator.PropertyIsGreaterThanOrEqualTo:
            case OgcFilterOperator.PropertyIsLessThan:
            case OgcFilterOperator.PropertyIsLessThanOrEqualTo:
                return 'expression';
            case OgcFilterOperator.PropertyIsLike:
                return 'pattern';
            case OgcFilterOperator.PropertyIsBetween:
                return pos && pos === 1
                    ? 'lowerBoundary'
                    : pos && pos === 2
                        ? 'upperBoundary'
                        : undefined;
            case OgcFilterOperator.During:
                return pos && pos === 1
                    ? 'begin'
                    : pos && pos === 2
                        ? 'end'
                        : undefined;
            default:
                return;
        }
    }
}
OgcFilterSelectionComponent.ɵfac = function OgcFilterSelectionComponent_Factory(t) { return new (t || OgcFilterSelectionComponent)(i0.ɵɵdirectiveInject(OGCFilterService), i0.ɵɵdirectiveInject(i16.FormBuilder)); };
OgcFilterSelectionComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OgcFilterSelectionComponent, selectors: [["igo-ogc-filter-selection"]], viewQuery: function OgcFilterSelectionComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$6, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sel = _t.first);
    } }, inputs: { refreshFilters: "refreshFilters", datasource: "datasource", map: "map", checkboxesIndex: "checkboxesIndex", radioButtonsIndex: "radioButtonsIndex", baseIndex: "baseIndex", currentFilter: "currentFilter" }, decls: 3, vars: 3, consts: [[3, "formGroup"], [4, "ngFor", "ngForOf"], [4, "ngIf"], ["class", "pushButtonGroups", 4, "ngIf"], ["class", "checkboxGroups", 4, "ngIf"], ["class", "radioButtonGroups", 4, "ngIf"], ["class", "selectGroups", 4, "ngIf"], [1, "pushButtonGroups"], ["class", "groupsSelector", 4, "ngIf"], [1, "groupsSelector"], ["formControlName", "pushButtonsGroup", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "value", "valueChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], ["formControlName", "pushButtons", "appearance", "legacy", "multiple", "true", 1, "mat-typography", 3, "vertical"], ["tooltip-position", "below", "matTooltipShowDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "ngStyle", "checked", "value", "change", 4, "ngFor", "ngForOf"], ["tooltip-position", "below", "matTooltipShowDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "ngStyle", "checked", "value", "change"], [1, "checkboxGroups"], ["formControlName", "checkboxesGroup", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "value", "valueChange"], [1, "checkboxes", "mat-typography"], ["tooltip-position", "below", "matTooltipShowDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "checked", "value", "change", 4, "ngFor", "ngForOf"], ["tooltip-position", "below", "matTooltipShowDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "checked", "value", "change"], ["class", "lessResults mat-typography", 3, "click", 4, "ngIf"], ["class", "moreResults mat-typography", 3, "click", 4, "ngIf"], [1, "lessResults", "mat-typography", 3, "click"], [1, "moreResults", "mat-typography", 3, "click"], [1, "radioButtonGroups"], ["formControlName", "radioButtonsGroup", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "value", "valueChange"], ["formControlName", "radioButtons", 1, "mat-typography"], ["tooltip-position", "below", "matTooltipShowDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "change", 4, "ngIf"], ["tooltip-position", "below", "matTooltipShowDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "change"], [1, "selectGroups"], ["formControlName", "selectGroup", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "value", "valueChange"], ["mat-icon-button", "", "color", "warn", "tooltip-position", "below", "matTooltipShowDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "click", 4, "ngIf"], [4, "ngIf", "ngIfElse"], ["notMulti", ""], ["mat-icon-button", "", "color", "warn", "tooltip-position", "below", "matTooltipShowDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "click"], ["svgIcon", "filter-remove"], [3, "multiple", "placeholder", "formControl", "ngModel", "ngModelChange"], ["selection", ""], [3, "ngModel", "ngModelOptions", "ngModelChange", "change", 4, "ngIf"], ["tooltip-position", "below", "matTooltipDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "value", "onSelectionChange", 4, "ngFor", "ngForOf"], [3, "ngModel", "ngModelOptions", "ngModelChange", "change"], ["tooltip-position", "below", "matTooltipDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "value", "onSelectionChange"], [3, "placeholder", "formControl", "ngModel", "ngModelChange"], ["tooltip-position", "below", "matTooltipDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "value", 4, "ngFor", "ngForOf"], ["tooltip-position", "below", "matTooltipDelay", "500", "matTooltipClass", "material-tooltip", 3, "matTooltip", "value"], [3, "datasource", "currentFilter", "datasourceChange", "currentFilterChange", "changeProperty"]], template: function OgcFilterSelectionComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "form", 0);
        i0.ɵɵtemplate(1, OgcFilterSelectionComponent_div_1_Template, 5, 4, "div", 1);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(2, OgcFilterSelectionComponent_div_2_Template, 5, 4, "div", 2);
    } if (rf & 2) {
        i0.ɵɵproperty("formGroup", ctx.form);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.ogcFiltersSelectors);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.isTemporalOperator());
    } }, styles: [".mat-button-toggle-group[_ngcontent-%COMP%]{margin:5px;flex-wrap:wrap;box-shadow:none}.checkboxes[_ngcontent-%COMP%]{flex-wrap:wrap;box-shadow:none}.groupsSelector[_ngcontent-%COMP%]{text-align:center}mat-button-toggle[_ngcontent-%COMP%]{display:inline-flex;border:1.5px solid black;border-radius:5px;margin:5px;white-space:normal;min-height:40px;height:auto;width:150px}mat-button-toggle[_ngcontent-%COMP%]     .mat-button-toggle-label-content{line-height:unset;font-size:small;display:block}  .material-tooltip{white-space:pre-wrap}mat-checkbox[_ngcontent-%COMP%], mat-radio-button[_ngcontent-%COMP%]{margin:7px;width:95%;display:inline-flex;font-size:larger}mat-checkbox[_ngcontent-%COMP%]     label, mat-radio-button[_ngcontent-%COMP%]     label{white-space:normal}mat-checkbox[_ngcontent-%COMP%]{vertical-align:middle}mat-button[_ngcontent-%COMP%]{padding-right:10px}h4[_ngcontent-%COMP%]{margin:7px;text-align:left}u[_ngcontent-%COMP%]{cursor:pointer;color:#00f;margin:5px}p[_ngcontent-%COMP%]{margin:unset}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OgcFilterSelectionComponent, [{
        type: Component,
        args: [{
                selector: 'igo-ogc-filter-selection',
                templateUrl: './ogc-filter-selection.component.html',
                styleUrls: ['./ogc-filter-selection.component.scss']
            }]
    }], function () { return [{ type: OGCFilterService }, { type: i16.FormBuilder }]; }, { sel: [{
            type: ViewChild,
            args: ['selection']
        }], refreshFilters: [{
            type: Input
        }], datasource: [{
            type: Input
        }], map: [{
            type: Input
        }], checkboxesIndex: [{
            type: Input
        }], radioButtonsIndex: [{
            type: Input
        }], baseIndex: [{
            type: Input
        }], currentFilter: [{
            type: Input
        }] }); })();

function SpatialFilterTypeComponent_mat_option_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 10);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const queryType_r1 = ctx.$implicit;
    i0.ɵɵproperty("value", queryType_r1);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.terrapi." + queryType_r1), " ");
} }
/**
 * Spatial Filter Type
 */
class SpatialFilterTypeComponent {
    constructor() {
        this.queryType = ['Arrond', 'CircFed', 'CircProv', 'DirReg', 'Mun', 'MRC', 'AdmRegion', 'RegTour'];
        this.selectedTypeIndex = new FormControl(0);
        /**
         * Reference to the SpatialFIlterType enum
         * @internal
         */
        this.spatialType = SpatialFilterType;
        this.activeDrawType = this.spatialType.Polygon;
        this.layers = [];
        this.eventType = new EventEmitter();
        this.eventQueryType = new EventEmitter();
        this.zoneChange = new EventEmitter();
        this.zoneWithBufferChange = new EventEmitter();
        this.bufferChange = new EventEmitter();
        this.measureUnitChange = new EventEmitter();
    }
    get store() {
        return this._store;
    }
    set store(store) {
        this._store = store;
    }
    ngOnInit() {
        if (this.selectedTypeIndex.value === 0) {
            this.type = this.spatialType.Predefined;
        }
        if (this.selectedTypeIndex.value === 1) {
            this.type = this.activeDrawType;
        }
        this.eventType.emit(this.type);
    }
    onTypeChange(event) {
        if (this.selectedTypeIndex.value === 0) {
            this.type = SpatialFilterType.Predefined;
        }
        if (this.selectedTypeIndex.value === 1) {
            this.type = this.activeDrawType;
        }
        this.eventType.emit(this.type);
    }
    onDrawTypeChange(spatialType) {
        this.activeDrawType = spatialType;
        this.eventType.emit(this.activeDrawType);
    }
    onSelectionChange() {
        this.eventQueryType.emit(this.selectedQueryType);
        this.zoneChange.emit(undefined);
    }
}
SpatialFilterTypeComponent.ɵfac = function SpatialFilterTypeComponent_Factory(t) { return new (t || SpatialFilterTypeComponent)(); };
SpatialFilterTypeComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SpatialFilterTypeComponent, selectors: [["igo-spatial-filter-type"]], inputs: { store: "store", selectedQueryType: "selectedQueryType", zone: "zone", layers: "layers" }, outputs: { eventType: "eventType", eventQueryType: "eventQueryType", zoneChange: "zoneChange", zoneWithBufferChange: "zoneWithBufferChange", bufferChange: "bufferChange", measureUnitChange: "measureUnitChange" }, decls: 20, vars: 25, consts: [[3, "selectedIndex", "selectedIndexChange", "selectedTabChange"], [3, "label"], [3, "value", "selectionChange", "valueChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "store", "queryType", "zone", "layers", "zoneChange", "zoneWithBufferChange", "bufferChange", "measureUnitChange"], [1, "spatial-type-toggle"], [3, "value", "change"], [3, "value", "matTooltip"], ["svgIcon", "pentagon-outline"], ["svgIcon", "record-circle-outline"], [3, "value"]], template: function SpatialFilterTypeComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-tab-group", 0);
        i0.ɵɵlistener("selectedIndexChange", function SpatialFilterTypeComponent_Template_mat_tab_group_selectedIndexChange_0_listener($event) { return ctx.selectedTypeIndex.setValue($event); })("selectedTabChange", function SpatialFilterTypeComponent_Template_mat_tab_group_selectedTabChange_0_listener($event) { return ctx.onTypeChange($event); });
        i0.ɵɵelementStart(1, "mat-tab", 1);
        i0.ɵɵpipe(2, "translate");
        i0.ɵɵelementStart(3, "mat-form-field");
        i0.ɵɵelementStart(4, "mat-label");
        i0.ɵɵtext(5);
        i0.ɵɵpipe(6, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(7, "mat-select", 2);
        i0.ɵɵlistener("selectionChange", function SpatialFilterTypeComponent_Template_mat_select_selectionChange_7_listener() { return ctx.onSelectionChange(); })("valueChange", function SpatialFilterTypeComponent_Template_mat_select_valueChange_7_listener($event) { return ctx.selectedQueryType = $event; });
        i0.ɵɵtemplate(8, SpatialFilterTypeComponent_mat_option_8_Template, 3, 4, "mat-option", 3);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(9, "igo-spatial-filter-list", 4);
        i0.ɵɵlistener("zoneChange", function SpatialFilterTypeComponent_Template_igo_spatial_filter_list_zoneChange_9_listener($event) { return ctx.zoneChange.emit($event); })("zoneWithBufferChange", function SpatialFilterTypeComponent_Template_igo_spatial_filter_list_zoneWithBufferChange_9_listener($event) { return ctx.zoneWithBufferChange.emit($event); })("bufferChange", function SpatialFilterTypeComponent_Template_igo_spatial_filter_list_bufferChange_9_listener($event) { return ctx.bufferChange.emit($event); })("measureUnitChange", function SpatialFilterTypeComponent_Template_igo_spatial_filter_list_measureUnitChange_9_listener($event) { return ctx.measureUnitChange.emit($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(10, "mat-tab", 1);
        i0.ɵɵpipe(11, "translate");
        i0.ɵɵelementStart(12, "div", 5);
        i0.ɵɵelementStart(13, "mat-button-toggle-group", 6);
        i0.ɵɵlistener("change", function SpatialFilterTypeComponent_Template_mat_button_toggle_group_change_13_listener($event) { return ctx.onDrawTypeChange($event.value); });
        i0.ɵɵelementStart(14, "mat-button-toggle", 7);
        i0.ɵɵpipe(15, "translate");
        i0.ɵɵelement(16, "mat-icon", 8);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(17, "mat-button-toggle", 7);
        i0.ɵɵpipe(18, "translate");
        i0.ɵɵelement(19, "mat-icon", 9);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("selectedIndex", ctx.selectedTypeIndex.value);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("label", i0.ɵɵpipeBind1(2, 15, "igo.geo.spatialFilter.predefined"));
        i0.ɵɵadvance(4);
        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(6, 17, "igo.geo.spatialFilter.searchLabel"));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", ctx.selectedQueryType);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.queryType);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("store", ctx.store)("queryType", ctx.selectedQueryType)("zone", ctx.zone)("layers", ctx.layers);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("label", i0.ɵɵpipeBind1(11, 19, "igo.geo.spatialFilter.draw"));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("value", ctx.activeDrawType);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("value", ctx.spatialType.Polygon)("matTooltip", i0.ɵɵpipeBind1(15, 21, "igo.geo.spatialFilter.drawPolygon"));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("value", ctx.spatialType.Point)("matTooltip", i0.ɵɵpipeBind1(18, 23, "igo.geo.spatialFilter.drawCircle"));
    } }, styles: [".mat-form-field[_ngcontent-%COMP%]{padding:5px;width:95%;margin-left:2px}.mat-tab-group[_ngcontent-%COMP%]     .mat-tab-body-content{overflow:hidden}.mat-tab-group[_ngcontent-%COMP%]     .mat-tab-label{padding:10px}.mat-tab-group[_ngcontent-%COMP%]     .mat-tab-body-wrapper{margin-top:5px}.spatial-type-toggle[_ngcontent-%COMP%]{padding:10px;text-align:center}.spatial-type-toggle[_ngcontent-%COMP%]   mat-button-toggle-group[_ngcontent-%COMP%]{width:50%}.spatial-type-toggle[_ngcontent-%COMP%]   mat-button-toggle-group[_ngcontent-%COMP%]   mat-button-toggle[_ngcontent-%COMP%]{width:50%}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SpatialFilterTypeComponent, [{
        type: Component,
        args: [{
                selector: 'igo-spatial-filter-type',
                templateUrl: './spatial-filter-type.component.html',
                styleUrls: ['./spatial-filter-type.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { store: [{
            type: Input
        }], selectedQueryType: [{
            type: Input
        }], zone: [{
            type: Input
        }], layers: [{
            type: Input
        }], eventType: [{
            type: Output
        }], eventQueryType: [{
            type: Output
        }], zoneChange: [{
            type: Output
        }], zoneWithBufferChange: [{
            type: Output
        }], bufferChange: [{
            type: Output
        }], measureUnitChange: [{
            type: Output
        }] }); })();

function SpatialFilterListComponent_mat_option_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 13);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const entities_r4 = ctx.$implicit;
    i0.ɵɵproperty("value", entities_r4);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", entities_r4.properties.nom, " ");
} }
function SpatialFilterListComponent_mat_option_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 13);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const measureUnit_r5 = ctx.$implicit;
    i0.ɵɵproperty("value", measureUnit_r5);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.measure." + measureUnit_r5), " ");
} }
class SpatialFilterListComponent {
    constructor(spatialFilterService, messageService, languageService) {
        this.spatialFilterService = spatialFilterService;
        this.messageService = messageService;
        this.languageService = languageService;
        this.layers = [];
        this.measureUnit = MeasureLengthUnit.Meters;
        this.formControl = new FormControl();
        this.bufferFormControl = new FormControl();
        this.zoneChange = new EventEmitter();
        this.zoneWithBufferChange = new EventEmitter();
        this.bufferChange = new EventEmitter();
        this.measureUnitChange = new EventEmitter();
    }
    get store() {
        return this._store;
    }
    set store(store) {
        this._store = store;
    }
    get queryType() {
        return this._queryType;
    }
    set queryType(queryType) {
        this.formControl.setValue('');
        this._queryType = queryType;
    }
    get zone() {
        return this._zone;
    }
    set zone(value) {
        this._zone = value;
        if (!value) {
            this.zoneWithBuffer = undefined;
            this.bufferFormControl.setValue(0);
        }
    }
    /**
     * Available measure units for the measure type given
     * @internal
     */
    get measureUnits() {
        return [MeasureLengthUnit.Meters, MeasureLengthUnit.Kilometers];
    }
    ngOnInit() {
        this.formValueChanges$$ = this.formControl.valueChanges.subscribe((value) => {
            if (value.length) {
                this.store.view.filter((feature) => {
                    const filterNormalized = value.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                    const featureNameNormalized = feature.properties.nom.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                    return featureNameNormalized.includes(filterNormalized);
                });
            }
        });
        this.bufferValueChanges$$ = this.bufferFormControl.valueChanges
            .pipe(debounceTime(500), distinctUntilChanged())
            .subscribe((value) => {
            if (this.measureUnit === MeasureLengthUnit.Meters && value > 0 && value <= 100000) {
                this.bufferChange.emit(value);
                this.spatialFilterService.loadBufferGeometry(this.selectedZone, SpatialFilterType.Predefined, value, this.queryType).subscribe((featureGeom) => {
                    this.zoneWithBuffer = featureGeom;
                    this.zoneWithBufferChange.emit(this.zoneWithBuffer);
                });
            }
            else if (this.measureUnit === MeasureLengthUnit.Kilometers && value > 0 && value <= 100) {
                this.bufferChange.emit(value);
                this.spatialFilterService.loadBufferGeometry(this.selectedZone, SpatialFilterType.Predefined, value * 1000, this.queryType).subscribe((featureGeom) => {
                    this.zoneWithBuffer = featureGeom;
                    this.zoneWithBufferChange.emit(this.zoneWithBuffer);
                });
            }
            else if (value === 0 && this.layers.length > 0) {
                this.bufferChange.emit(value);
                this.zoneWithBufferChange.emit(this.selectedZone);
            }
            else if (value < 0 ||
                (this.measureUnit === MeasureLengthUnit.Meters && value > 100000) ||
                (this.measureUnit === MeasureLengthUnit.Kilometers && value > 100)) {
                this.bufferFormControl.setValue(0);
                this.messageService.alert(this.languageService.translate.instant('igo.geo.spatialFilter.bufferAlert'), this.languageService.translate.instant('igo.geo.spatialFilter.warning'));
            }
        });
    }
    ngOnDestroy() {
        this.formValueChanges$$.unsubscribe();
    }
    displayFn(feature) {
        return feature ? feature.properties.nom : undefined;
    }
    onZoneChange(feature) {
        if (feature && this.queryType) {
            this.spatialFilterService.loadItemById(feature, this.queryType)
                .subscribe((featureGeom) => {
                this.selectedZone = featureGeom;
                this.zoneChange.emit(featureGeom);
            });
        }
    }
    /**
     * Set the measure unit
     * @internal
     */
    onMeasureUnitChange(unit) {
        if (unit === this.measureUnit) {
            return;
        }
        else {
            this.measureUnit = unit;
            this.measureUnitChange.emit(this.measureUnit);
            this.measureUnit === MeasureLengthUnit.Meters ?
                this.bufferFormControl.setValue(this.bufferFormControl.value * 1000) :
                this.bufferFormControl.setValue(this.bufferFormControl.value / 1000);
        }
    }
}
SpatialFilterListComponent.ɵfac = function SpatialFilterListComponent_Factory(t) { return new (t || SpatialFilterListComponent)(i0.ɵɵdirectiveInject(SpatialFilterService), i0.ɵɵdirectiveInject(i2$1.MessageService), i0.ɵɵdirectiveInject(i2$1.LanguageService)); };
SpatialFilterListComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SpatialFilterListComponent, selectors: [["igo-spatial-filter-list"]], inputs: { store: "store", queryType: "queryType", zone: "zone", layers: "layers" }, outputs: { zoneChange: "zoneChange", zoneWithBufferChange: "zoneWithBufferChange", bufferChange: "bufferChange", measureUnitChange: "measureUnitChange" }, decls: 18, vars: 17, consts: [[1, "form-list"], [1, "zone-list"], ["type", "text", "matInput", "", 3, "placeholder", "formControl", "matAutocomplete"], ["input", ""], [3, "displayWith", "optionSelected"], ["auto", "matAutocomplete"], [3, "value", 4, "ngFor", "ngForOf"], [1, "buffer-div"], [1, "buffer-form"], [1, "buffer"], ["type", "number", "matInput", "", 3, "placeholder", "formControl", "value", "readonly"], [1, "unit-field"], [3, "value", "selectionChange"], [3, "value"]], template: function SpatialFilterListComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "form", 0);
        i0.ɵɵelementStart(1, "mat-form-field", 1);
        i0.ɵɵelement(2, "input", 2, 3);
        i0.ɵɵpipe(4, "translate");
        i0.ɵɵelementStart(5, "mat-autocomplete", 4, 5);
        i0.ɵɵlistener("optionSelected", function SpatialFilterListComponent_Template_mat_autocomplete_optionSelected_5_listener($event) { return ctx.onZoneChange($event.option.value); });
        i0.ɵɵtemplate(7, SpatialFilterListComponent_mat_option_7_Template, 2, 2, "mat-option", 6);
        i0.ɵɵpipe(8, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(9, "form");
        i0.ɵɵelementStart(10, "div", 7);
        i0.ɵɵelementStart(11, "form", 8);
        i0.ɵɵelementStart(12, "mat-form-field", 9);
        i0.ɵɵelement(13, "input", 10);
        i0.ɵɵpipe(14, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(15, "mat-form-field", 11);
        i0.ɵɵelementStart(16, "mat-select", 12);
        i0.ɵɵlistener("selectionChange", function SpatialFilterListComponent_Template_mat_select_selectionChange_16_listener($event) { return ctx.onMeasureUnitChange($event.value); });
        i0.ɵɵtemplate(17, SpatialFilterListComponent_mat_option_17_Template, 3, 4, "mat-option", 6);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1 = i0.ɵɵreference(6);
        i0.ɵɵadvance(2);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(4, 11, "igo.geo.spatialFilter.listLabel"));
        i0.ɵɵproperty("formControl", ctx.formControl)("matAutocomplete", _r1);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("displayWith", ctx.displayFn);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(8, 13, ctx.store.view.all$()));
        i0.ɵɵadvance(6);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(14, 15, "igo.geo.spatialFilter.buffer"));
        i0.ɵɵproperty("formControl", ctx.bufferFormControl)("value", 0)("readonly", !ctx.zone);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("value", ctx.measureUnit);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.measureUnits);
    } }, directives: [i16.ɵNgNoValidate, i16.NgControlStatusGroup, i16.NgForm, i12.MatFormField, i5$1.MatInput, i16.DefaultValueAccessor, i6$1.MatAutocompleteTrigger, i16.NgControlStatus, i16.FormControlDirective, i6$1.MatAutocomplete, i1$1.NgForOf, i16.NumberValueAccessor, i13.MatSelect, i9.MatOption], pipes: [i7.TranslatePipe, i1$1.AsyncPipe], styles: [".buffer-div[_ngcontent-%COMP%]{display:flex;width:100%;margin-left:2px;padding:5px}.zone-list[_ngcontent-%COMP%]{padding:5px;width:95%;margin-left:2px}.buffer[_ngcontent-%COMP%]{display:flex;flex-flow:column nowrap;width:110%}.unit-field[_ngcontent-%COMP%]{width:110px;margin-left:30px}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SpatialFilterListComponent, [{
        type: Component,
        args: [{
                selector: 'igo-spatial-filter-list',
                templateUrl: './spatial-filter-list.component.html',
                styleUrls: ['./spatial-filter-list.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: SpatialFilterService }, { type: i2$1.MessageService }, { type: i2$1.LanguageService }]; }, { store: [{
            type: Input
        }], queryType: [{
            type: Input
        }], zone: [{
            type: Input
        }], layers: [{
            type: Input
        }], zoneChange: [{
            type: Output
        }], zoneWithBufferChange: [{
            type: Output
        }], bufferChange: [{
            type: Output
        }], measureUnitChange: [{
            type: Output
        }] }); })();

function SpatialFilterItemComponent_mat_slide_toggle_5_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-slide-toggle", 17);
    i0.ɵɵlistener("change", function SpatialFilterItemComponent_mat_slide_toggle_5_Template_mat_slide_toggle_change_0_listener() { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.onDrawControlChange(); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("checked", ctx_r0.drawControlIsActive)("labelPosition", "before");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 3, "igo.geo.spatialFilter.drawControl"), " ");
} }
function SpatialFilterItemComponent_mat_slide_toggle_6_Template(rf, ctx) { if (rf & 1) {
    const _r13 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-slide-toggle", 17);
    i0.ɵɵlistener("change", function SpatialFilterItemComponent_mat_slide_toggle_6_Template_mat_slide_toggle_change_0_listener() { i0.ɵɵrestoreView(_r13); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.onfreehandControlChange(); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("checked", ctx_r1.freehandDrawIsActive)("labelPosition", "before");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 3, "igo.geo.spatialFilter.freehandControl"), " ");
} }
function SpatialFilterItemComponent_div_7_mat_option_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 6);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const measureUnit_r15 = ctx.$implicit;
    i0.ɵɵproperty("value", measureUnit_r15);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.measure." + measureUnit_r15), " ");
} }
function SpatialFilterItemComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 18);
    i0.ɵɵelementStart(1, "form", 19);
    i0.ɵɵelementStart(2, "mat-form-field", 20);
    i0.ɵɵelement(3, "input", 21);
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(5, "mat-form-field", 22);
    i0.ɵɵelementStart(6, "mat-select", 23);
    i0.ɵɵlistener("selectionChange", function SpatialFilterItemComponent_div_7_Template_mat_select_selectionChange_6_listener($event) { i0.ɵɵrestoreView(_r17); const ctx_r16 = i0.ɵɵnextContext(); return ctx_r16.onMeasureUnitChange($event.value); });
    i0.ɵɵtemplate(7, SpatialFilterItemComponent_div_7_mat_option_7_Template, 3, 4, "mat-option", 24);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(4, 6, "igo.geo.spatialFilter.buffer"));
    i0.ɵɵproperty("formControl", ctx_r2.bufferFormControl)("value", 0)("readonly", ctx_r2.formControl.value === null);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("value", ctx_r2.measureUnit);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r2.measureUnits);
} }
function SpatialFilterItemComponent_div_8_mat_option_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 6);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const measureUnit_r19 = ctx.$implicit;
    i0.ɵɵproperty("value", measureUnit_r19);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.measure." + measureUnit_r19), " ");
} }
function SpatialFilterItemComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r21 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 25);
    i0.ɵɵelementStart(1, "form", 26);
    i0.ɵɵelementStart(2, "mat-form-field", 27);
    i0.ɵɵelementStart(3, "input", 28);
    i0.ɵɵlistener("input", function SpatialFilterItemComponent_div_8_Template_input_input_3_listener() { i0.ɵɵrestoreView(_r21); const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.getRadius(); });
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(5, "mat-form-field", 22);
    i0.ɵɵelementStart(6, "mat-select", 23);
    i0.ɵɵlistener("selectionChange", function SpatialFilterItemComponent_div_8_Template_mat_select_selectionChange_6_listener($event) { i0.ɵɵrestoreView(_r21); const ctx_r22 = i0.ɵɵnextContext(); return ctx_r22.onMeasureUnitChange($event.value); });
    i0.ɵɵtemplate(7, SpatialFilterItemComponent_div_8_mat_option_7_Template, 3, 4, "mat-option", 24);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(4, 6, "igo.geo.spatialFilter.radius"));
    i0.ɵɵproperty("formControl", ctx_r3.radiusFormControl)("value", 1000)("readonly", ctx_r3.freehandDrawIsActive && ctx_r3.formControl.value === null);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("value", ctx_r3.measureUnit);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r3.measureUnits);
} }
function SpatialFilterItemComponent_mat_radio_button_13_Template(rf, ctx) { if (rf & 1) {
    const _r25 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-radio-button", 29);
    i0.ɵɵlistener("change", function SpatialFilterItemComponent_mat_radio_button_13_Template_mat_radio_button_change_0_listener($event) { i0.ɵɵrestoreView(_r25); const ctx_r24 = i0.ɵɵnextContext(); return ctx_r24.onItemTypeChange($event); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r23 = ctx.$implicit;
    i0.ɵɵproperty("value", item_r23);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.spatialFilter." + item_r23), " ");
} }
function SpatialFilterItemComponent_div_14_mat_header_cell_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-header-cell", 40);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(2, 1, "igo.geo.spatialFilter.Thematics"));
} }
function SpatialFilterItemComponent_div_14_mat_header_cell_5_Template(rf, ctx) { if (rf & 1) {
    const _r33 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-header-cell", 41);
    i0.ɵɵelementStart(1, "mat-checkbox", 42);
    i0.ɵɵlistener("change", function SpatialFilterItemComponent_div_14_mat_header_cell_5_Template_mat_checkbox_change_1_listener($event) { i0.ɵɵrestoreView(_r33); const ctx_r32 = i0.ɵɵnextContext(2); return $event ? ctx_r32.masterToggle() : null; });
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r27 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("checked", ctx_r27.isAllSelected())("indeterminate", ctx_r27.selectedThematics.hasValue() && !ctx_r27.isAllSelected());
} }
function SpatialFilterItemComponent_div_14_mat_header_row_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-header-row");
} }
function SpatialFilterItemComponent_div_14_mat_row_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-row");
} }
function SpatialFilterItemComponent_div_14_mat_tree_node_9_Template(rf, ctx) { if (rf & 1) {
    const _r38 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-tree-node", 43);
    i0.ɵɵelementStart(1, "li", 44);
    i0.ɵɵelement(2, "button", 45);
    i0.ɵɵtext(3);
    i0.ɵɵelementStart(4, "mat-checkbox", 46);
    i0.ɵɵlistener("click", function SpatialFilterItemComponent_div_14_mat_tree_node_9_Template_mat_checkbox_click_4_listener($event) { return $event.stopPropagation(); })("change", function SpatialFilterItemComponent_div_14_mat_tree_node_9_Template_mat_checkbox_change_4_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r38); const node_r35 = restoredCtx.$implicit; const ctx_r37 = i0.ɵɵnextContext(2); return $event ? ctx_r37.onToggleChange(node_r35) : null; });
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r35 = ctx.$implicit;
    const ctx_r30 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1(" ", node_r35.name, " ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("checked", ctx_r30.selectedThematics.isSelected(node_r35));
} }
function SpatialFilterItemComponent_div_14_mat_nested_tree_node_10_Template(rf, ctx) { if (rf & 1) {
    const _r41 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-nested-tree-node");
    i0.ɵɵelementStart(1, "div", 44);
    i0.ɵɵelementStart(2, "button", 47);
    i0.ɵɵlistener("click", function SpatialFilterItemComponent_div_14_mat_nested_tree_node_10_Template_button_click_2_listener() { const restoredCtx = i0.ɵɵrestoreView(_r41); const node_r39 = restoredCtx.$implicit; const ctx_r40 = i0.ɵɵnextContext(2); return ctx_r40.onToggleClick(node_r39); });
    i0.ɵɵelement(3, "mat-icon", 48);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4);
    i0.ɵɵelementStart(5, "mat-checkbox", 49);
    i0.ɵɵlistener("change", function SpatialFilterItemComponent_div_14_mat_nested_tree_node_10_Template_mat_checkbox_change_5_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r41); const node_r39 = restoredCtx.$implicit; const ctx_r42 = i0.ɵɵnextContext(2); return $event ? ctx_r42.childrensToggle(node_r39) : null; });
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(6, "ul", 50);
    i0.ɵɵelementContainer(7, 51);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r39 = ctx.$implicit;
    const ctx_r31 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("svgIcon", ctx_r31.treeControl.isExpanded(node_r39) ? "chevron-down" : "chevron-right");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", node_r39.name, " ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("checked", ctx_r31.isAllSelected(node_r39))("indeterminate", ctx_r31.hasChildrenSelected(node_r39) && !ctx_r31.isAllSelected(node_r39));
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("example-tree-invisible", !ctx_r31.treeControl.isExpanded(node_r39));
} }
function SpatialFilterItemComponent_div_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 30);
    i0.ɵɵelementStart(1, "mat-table");
    i0.ɵɵelementContainerStart(2, 31);
    i0.ɵɵtemplate(3, SpatialFilterItemComponent_div_14_mat_header_cell_3_Template, 3, 3, "mat-header-cell", 32);
    i0.ɵɵelementContainerEnd();
    i0.ɵɵelementContainerStart(4, 33);
    i0.ɵɵtemplate(5, SpatialFilterItemComponent_div_14_mat_header_cell_5_Template, 2, 2, "mat-header-cell", 34);
    i0.ɵɵelementContainerEnd();
    i0.ɵɵtemplate(6, SpatialFilterItemComponent_div_14_mat_header_row_6_Template, 1, 0, "mat-header-row", 35);
    i0.ɵɵtemplate(7, SpatialFilterItemComponent_div_14_mat_row_7_Template, 1, 0, "mat-row", 36);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(8, "mat-tree", 37);
    i0.ɵɵtemplate(9, SpatialFilterItemComponent_div_14_mat_tree_node_9_Template, 5, 2, "mat-tree-node", 38);
    i0.ɵɵtemplate(10, SpatialFilterItemComponent_div_14_mat_nested_tree_node_10_Template, 8, 6, "mat-nested-tree-node", 39);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵadvance(6);
    i0.ɵɵproperty("matHeaderRowDef", ctx_r5.displayedColumns);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matRowDefColumns", ctx_r5.displayedColumns);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("dataSource", ctx_r5.dataSource)("treeControl", ctx_r5.treeControl);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTreeNodeDefWhen", ctx_r5.hasChild);
} }
function SpatialFilterItemComponent_button_16_Template(rf, ctx) { if (rf & 1) {
    const _r44 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 52);
    i0.ɵɵlistener("click", function SpatialFilterItemComponent_button_16_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r44); const ctx_r43 = i0.ɵɵnextContext(); return ctx_r43.clearSearch(); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵproperty("disabled", ctx_r6.disabledClearSearch());
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.spatialFilter.clearSearch"), " ");
} }
function SpatialFilterItemComponent_button_17_Template(rf, ctx) { if (rf & 1) {
    const _r46 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 53);
    i0.ɵɵlistener("click", function SpatialFilterItemComponent_button_17_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r46); const ctx_r45 = i0.ɵɵnextContext(); return ctx_r45.clearDrawZone(); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵproperty("disabled", ctx_r7.formControl.value === null);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.spatialFilter.clearForm"), " ");
} }
function SpatialFilterItemComponent_button_27_Template(rf, ctx) { if (rf & 1) {
    const _r48 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 54);
    i0.ɵɵlistener("click", function SpatialFilterItemComponent_button_27_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r48); const ctx_r47 = i0.ɵɵnextContext(); return ctx_r47.toggleVisibleList(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 55);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.spatialFilter.showSearchResults"));
} }
function SpatialFilterItemComponent_div_28_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r51 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 59);
    i0.ɵɵlistener("click", function SpatialFilterItemComponent_div_28_button_1_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r51); const ctx_r50 = i0.ɵɵnextContext(2); return ctx_r50.toggleVisibleList(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 60);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.spatialFilter.hideSearchResults"));
} }
function SpatialFilterItemComponent_div_28_Template(rf, ctx) { if (rf & 1) {
    const _r53 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 56);
    i0.ɵɵtemplate(1, SpatialFilterItemComponent_div_28_button_1_Template, 3, 3, "button", 57);
    i0.ɵɵelementStart(2, "igo-entity-table", 58);
    i0.ɵɵlistener("entitySelectChange", function SpatialFilterItemComponent_div_28_Template_igo_entity_table_entitySelectChange_2_listener($event) { i0.ɵɵrestoreView(_r53); const ctx_r52 = i0.ɵɵnextContext(); return ctx_r52.entityChange.emit($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r9.listIsVisible);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("template", ctx_r9.tableTemplate)("store", ctx_r9.store);
} }
/**
 * Spatial-Filter-Item (search parameters)
 */
class SpatialFilterItemComponent {
    constructor(cdRef, spatialFilterService, messageService, languageService) {
        this.cdRef = cdRef;
        this.spatialFilterService = spatialFilterService;
        this.messageService = messageService;
        this.languageService = languageService;
        this.layers = [];
        this.allLayers = [];
        this.toggleSearch = new EventEmitter();
        this.itemTypeChange = new EventEmitter();
        this.thematicChange = new EventEmitter();
        this.drawZoneEvent = new EventEmitter();
        this.bufferEvent = new EventEmitter();
        this.zoneWithBufferChange = new EventEmitter();
        this.measureUnitChange = new EventEmitter();
        this.radiusEvent = new EventEmitter();
        this.freehandControl = new EventEmitter();
        this.clearButtonEvent = new EventEmitter();
        this.clearSearchEvent = new EventEmitter();
        this.export = new EventEmitter();
        this.openWorkspace = new EventEmitter();
        this.entityChange = new EventEmitter();
        this.itemType = [SpatialFilterItemType.Address, SpatialFilterItemType.Thematics];
        this.selectedItemType = SpatialFilterItemType.Address;
        this.treeControl = new NestedTreeControl(node => node.children);
        // For thematics and results tables
        this.displayedColumns = ['name', 'select'];
        this.childrens = [];
        this.groups = [];
        this.thematics = [];
        this.dataSource = new MatTreeNestedDataSource();
        this.selectedThematics = new SelectionModel(true, []);
        // For geometry form field input
        this.value$ = new BehaviorSubject(undefined);
        this.drawGuide$ = new BehaviorSubject(null);
        this.overlayStyle$ = new BehaviorSubject(undefined);
        this.drawStyle$ = new BehaviorSubject(undefined);
        this.formControl = new FormControl();
        this.geometryTypeField = false;
        this.geometryTypes = ['Point', 'Polygon'];
        this.drawGuideField = false;
        this.drawGuide = null;
        this.drawGuidePlaceholder = '';
        this.measure = false;
        this.drawControlIsActive = true;
        this.freehandDrawIsActive = false;
        this.buffer = 0;
        this.radiusFormControl = new FormControl();
        this.bufferFormControl = new FormControl();
        this.measureUnit = MeasureLengthUnit.Meters;
        this.listIsVisible = true;
    }
    get type() {
        return this._type;
    }
    set type(type) {
        this._type = type;
        const index = this.geometryTypes.findIndex(geom => geom === this.type);
        this.geometryType = this.geometryTypes[index];
        this.formControl.reset();
        this.radius = undefined;
        this.drawGuide$.next(null);
        this.drawStyle$.next(undefined);
        // Necessary to keep reference to the geometry form field input
        if (this.type === SpatialFilterType.Predefined) {
            const geojson = {
                type: 'Point',
                coordinates: ''
            };
            this.formControl.setValue(geojson);
        }
        // Necessary to apply the right style when geometry type is Point
        if (this.type === SpatialFilterType.Point) {
            this.radius = 1000; // Base radius
            this.radiusFormControl.setValue(this.radius);
            this.PointStyle = (feature, resolution) => {
                const geom = feature.getGeometry();
                const coordinates = olproj.transform(geom.getCoordinates(), this.map.projection, 'EPSG:4326');
                return new olstyle.Style({
                    image: new olstyle.Circle({
                        radius: this.radius / (Math.cos((Math.PI / 180) * coordinates[1])) / resolution,
                        stroke: new olstyle.Stroke({
                            width: 2,
                            color: 'rgba(0, 153, 255)'
                        }),
                        fill: new olstyle.Fill({
                            color: 'rgba(0, 153, 255, 0.2)'
                        })
                    })
                });
            };
            this.overlayStyle = this.PointStyle;
            this.drawStyle$.next(this.overlayStyle);
        }
        else {
            // If geometry types is Polygon
            this.radius = undefined;
            this.PolyStyle = () => {
                return new olstyle.Style({
                    stroke: new olstyle.Stroke({
                        width: 2,
                        color: 'rgba(0, 153, 255)'
                    }),
                    fill: new olstyle.Fill({
                        color: 'rgba(0, 153, 255, 0.2)'
                    })
                });
            };
            const color = [0, 153, 255];
            const drawStyle = () => {
                return new olstyle.Style({
                    image: new olstyle.Circle({
                        radius: 8,
                        stroke: new olstyle.Stroke({
                            width: 2,
                            color: 'rgba(0, 153, 255)'
                        }),
                        fill: new olstyle.Fill({
                            color: 'rgba(0, 153, 255, 0.2)'
                        })
                    }),
                    stroke: new olstyle.Stroke({
                        color: color.concat([1]),
                        width: 2
                    }),
                    fill: new olstyle.Fill({
                        color: color.concat([0.2])
                    })
                });
            };
            this.overlayStyle = this.PolyStyle;
            this.drawStyle$.next(drawStyle);
        }
        this.overlayStyle$.next(this.overlayStyle);
    }
    get store() {
        return this._store;
    }
    set store(store) {
        this._store = store;
        this._store.entities$.subscribe(() => { this.cdRef.detectChanges(); });
    }
    /**
     * Available measure units for the measure type given
     * @internal
     */
    get measureUnits() {
        return [MeasureLengthUnit.Meters, MeasureLengthUnit.Kilometers];
    }
    get thematicLength() {
        return this._thematicLength;
    }
    set thematicLength(value) {
        this._thematicLength = value;
    }
    ngOnInit() {
        this.spatialFilterService.loadThematicsList()
            .subscribe((items) => {
            for (const item of items) {
                this.childrens.push(item);
                this.childrens.sort((a, b) => {
                    return a.name.localeCompare(b.name);
                });
            }
            this.groups.push(this.languageService.translate.instant('igo.geo.terrapi.limites'));
            const limits = {
                name: this.groups[0],
                children: []
            };
            this.thematics.push(limits);
            this.childrens.forEach(child => {
                if (child.group && (this.groups.indexOf(child.group) === -1)) {
                    this.groups.push(child.group);
                    const thematic = {
                        name: child.group,
                        children: []
                    };
                    this.thematics.push(thematic);
                }
                if (!child.group) {
                    if (child.name === this.languageService.translate.instant('igo.geo.terrapi.AdmRegion') ||
                        child.name === this.languageService.translate.instant('igo.geo.terrapi.Mun') ||
                        child.name === this.languageService.translate.instant('igo.geo.terrapi.Arrond') ||
                        child.name === this.languageService.translate.instant('igo.geo.terrapi.CircFed') ||
                        child.name === this.languageService.translate.instant('igo.geo.terrapi.CircProv') ||
                        child.name === this.languageService.translate.instant('igo.geo.terrapi.DirReg') ||
                        child.name === this.languageService.translate.instant('igo.geo.terrapi.MRC') ||
                        child.name === this.languageService.translate.instant('igo.geo.terrapi.RegTour')) {
                        child.group = limits.name;
                    }
                    else if (child.name === this.languageService.translate.instant('igo.geo.terrapi.routes')) {
                        child.group = this.languageService.translate.instant('igo.geo.spatialFilter.group.transport');
                    }
                    else {
                        const thematic = {
                            name: child.name,
                            children: [],
                            source: child.source
                        };
                        this.thematics.push(thematic);
                    }
                }
                this.thematics.sort((a, b) => {
                    return a.name.localeCompare(b.name);
                });
            });
            this.thematics.forEach(thematic => {
                for (const child of this.childrens) {
                    if (child.group === thematic.name) {
                        thematic.children.push(child);
                    }
                }
            });
        });
        this.dataSource.data = this.thematics;
        this.drawGuide$.next(null);
        this.value$.next(this.formControl.value ? this.formControl.value : undefined);
        this.value$$ = this.formControl.valueChanges.subscribe((value) => {
            if (value) {
                this.value$.next(value);
                this.drawZone = this.formControl.value;
                if (this.buffer !== 0) {
                    this.drawZoneEvent.emit(this.drawZone);
                    this.bufferFormControl.setValue(this.buffer);
                }
            }
            else {
                this.value$.next(undefined);
                this.drawZone = undefined;
            }
        });
        this.value$.subscribe(() => {
            this.getRadius();
            this.cdRef.detectChanges();
        });
        this.radiusChanges$$ = this.radiusFormControl.valueChanges.subscribe(() => {
            this.getRadius();
            this.cdRef.detectChanges();
        });
        this.bufferChanges$$ = this.bufferFormControl.valueChanges
            .pipe(debounceTime(500))
            .subscribe((value) => {
            if (this.measureUnit === MeasureLengthUnit.Meters && value > 0 && value <= 100000) {
                this.buffer = value;
                this.bufferEvent.emit(value);
                this.spatialFilterService.loadBufferGeometry(this.drawZone, SpatialFilterType.Polygon, value).subscribe((featureGeom) => {
                    this.zoneWithBuffer = featureGeom;
                    this.zoneWithBufferChange.emit(this.zoneWithBuffer);
                });
            }
            else if (this.measureUnit === MeasureLengthUnit.Kilometers && value > 0 && value <= 100) {
                this.buffer = value;
                this.bufferEvent.emit(value);
                this.spatialFilterService.loadBufferGeometry(this.drawZone, SpatialFilterType.Polygon, value * 1000).subscribe((featureGeom) => {
                    this.zoneWithBuffer = featureGeom;
                    this.zoneWithBufferChange.emit(this.zoneWithBuffer);
                });
            }
            else if (value === 0) {
                this.buffer = value;
                this.bufferEvent.emit(value);
                this.drawZoneEvent.emit(this.drawZone);
            }
            else if (value < 0 ||
                (this.measureUnit === MeasureLengthUnit.Meters && value > 100000) ||
                (this.measureUnit === MeasureLengthUnit.Kilometers && value > 100)) {
                this.bufferFormControl.setValue(0);
                this.buffer = 0;
                this.messageService.alert(this.languageService.translate.instant('igo.geo.spatialFilter.bufferAlert'), this.languageService.translate.instant('igo.geo.spatialFilter.warning'));
            }
        });
        const selectedRecordStrategy = new EntityStoreFilterSelectionStrategy({});
        const selectionStrategy = new FeatureStoreSelectionStrategy({
            layer: new VectorLayer({
                zIndex: 300,
                source: new FeatureDataSource(),
                style: undefined,
                showInLayerList: false,
                exportable: false,
                browsable: false
            }),
            map: this.map,
            hitTolerance: 15,
            motion: FeatureMotion.Default,
            many: true,
            dragBox: true
        });
        this.store.addStrategy(selectionStrategy, true);
        this.store.addStrategy(selectedRecordStrategy, false);
    }
    /**
     * Unsubscribe to the value stream
     * @internal
     */
    ngOnDestroy() {
        this.value$$.unsubscribe();
        this.radiusChanges$$.unsubscribe();
        this.bufferChanges$$.unsubscribe();
        this.cdRef.detach();
        if (this.radiusChanges$$) {
            this.radiusChanges$$.unsubscribe();
        }
        if (this.value$$) {
            this.value$$.unsubscribe();
        }
    }
    onItemTypeChange(event) {
        this.selectedItemType = event.value;
        this.itemTypeChange.emit(this.selectedItemType);
    }
    /**
     * Set the measure unit
     * @internal
     */
    onMeasureUnitChange(unit) {
        if (unit === this.measureUnit) {
            return;
        }
        else {
            this.measureUnit = unit;
            this.measureUnitChange.emit(this.measureUnit);
            if (this.isPolygon()) {
                this.measureUnit === MeasureLengthUnit.Meters ?
                    this.bufferFormControl.setValue(this.bufferFormControl.value * 1000) :
                    this.bufferFormControl.setValue(this.bufferFormControl.value / 1000);
            }
            else if (this.isPoint()) {
                this.measureUnit === MeasureLengthUnit.Meters ?
                    this.radiusFormControl.setValue(this.radiusFormControl.value * 1000) :
                    this.radiusFormControl.setValue(this.radiusFormControl.value / 1000);
            }
        }
    }
    isPredefined() {
        return this.type === SpatialFilterType.Predefined;
    }
    isPolygon() {
        return this.type === SpatialFilterType.Polygon;
    }
    isPoint() {
        return this.type === SpatialFilterType.Point;
    }
    hasChild(_, node) {
        if (node.children) {
            return node.children.length;
        }
        return false;
    }
    onToggleClick(node) {
        this.treeControl.isExpanded(node) ? this.treeControl.collapse(node) : this.treeControl.expand(node);
    }
    isAllSelected(node) {
        let numSelected;
        let numNodes = 0;
        if (!node) {
            numSelected = this.selectedThematics.selected.length;
            this.thematics.forEach(thematic => {
                if (this.groups.indexOf(thematic.name) === -1) {
                    numNodes++;
                }
            });
            this.childrens.forEach(children => {
                if (!this.thematics.find(thematic => thematic.source === children.source)) {
                    numNodes++;
                }
            });
        }
        else {
            numSelected = node.children.length;
            node.children.forEach(children => {
                if (this.selectedThematics.selected.find(thematic => thematic === children)) {
                    numNodes++;
                }
            });
        }
        if (numNodes >= 1) {
            return numSelected === numNodes;
        }
        else {
            return false;
        }
    }
    hasChildrenSelected(node) {
        let bool = false;
        node.children.forEach(child => {
            if (this.selectedThematics.selected.find(thematic => thematic.source === child.source)) {
                bool = true;
            }
        });
        return bool;
    }
    /**
     * Apply header checkbox
     */
    masterToggle() {
        this.isAllSelected() ?
            this.selectedThematics.clear() :
            this.selectAll();
        const selectedThematicsName = [];
        for (const thematic of this.selectedThematics.selected) {
            selectedThematicsName.push(thematic);
        }
        if (this.isAllSelected()) {
            this.thematics.forEach(thematic => {
                if (this.hasChild(0, thematic)) {
                    this.treeControl.expand(thematic);
                }
            });
        }
        else {
            this.thematics.forEach(thematic => {
                if (this.hasChild(0, thematic)) {
                    this.treeControl.collapse(thematic);
                }
            });
        }
        this.thematicChange.emit(selectedThematicsName);
    }
    selectAll(node) {
        if (!node) {
            this.thematics.forEach(thematic => {
                if (this.groups.indexOf(thematic.name) === -1) {
                    this.selectedThematics.select(thematic);
                }
            });
            this.childrens.forEach(children => {
                if (!this.selectedThematics.selected.find(thematic => thematic.source === children.source)) {
                    this.selectedThematics.select(children);
                }
            });
        }
        else {
            if (this.hasChild(0, node)) {
                node.children.forEach(children => this.selectedThematics.select(children));
            }
        }
    }
    childrensToggle(node) {
        this.isAllSelected(node) ?
            node.children.forEach(child => this.selectedThematics.deselect(child)) :
            this.selectAll(node);
        const selectedThematicsName = [];
        for (const thematic of this.selectedThematics.selected) {
            selectedThematicsName.push(thematic);
        }
        this.treeControl.expand(node);
        this.thematicChange.emit(selectedThematicsName);
    }
    /**
     * Apply changes to the thematics selected tree and emit event
     */
    onToggleChange(nodeSelected) {
        let selected = false;
        if (this.selectedThematics.selected.find(thematic => thematic.source === nodeSelected.source) !== undefined) {
            selected = true;
        }
        this.childrens.forEach(children => {
            if (children === nodeSelected && selected === false) {
                this.selectedThematics.select(children);
            }
            if (children === nodeSelected && selected === true) {
                this.selectedThematics.deselect(children);
            }
        });
        this.thematics.forEach(thematic => {
            if (thematic === nodeSelected && selected === false) {
                this.selectedThematics.select(thematic);
            }
            if (thematic === nodeSelected && selected === true) {
                this.selectedThematics.deselect(thematic);
            }
        });
        const selectedThematicsName = [];
        for (const thematic of this.selectedThematics.selected) {
            selectedThematicsName.push(thematic);
        }
        this.thematicChange.emit(selectedThematicsName);
    }
    onDrawControlChange() {
        this.drawControlIsActive = !this.drawControlIsActive;
    }
    onfreehandControlChange() {
        this.freehandDrawIsActive = !this.freehandDrawIsActive;
        this.freehandControl.emit(this.freehandDrawIsActive);
    }
    /**
     * Launch search button
     */
    toggleSearchButton() {
        if (!this.isPredefined()) {
            if (this.buffer > 0) {
                this.zoneWithBuffer.meta = {
                    id: undefined,
                    title: 'Zone'
                };
                this.zoneWithBuffer.properties = {
                    nom: 'Zone',
                    type: this.type
                };
                this.drawZoneEvent.emit(this.zoneWithBuffer);
            }
            else {
                this.drawZone.meta = {
                    id: undefined,
                    title: 'Zone'
                };
                this.drawZone.properties = {
                    nom: 'Zone',
                    type: this.type
                };
                this.drawZoneEvent.emit(this.drawZone);
            }
        }
        if (this.isPoint()) {
            this.radiusEvent.emit(this.radius);
        }
        else if (this.isPolygon()) {
            this.bufferEvent.emit(this.buffer);
        }
        this.toggleSearch.emit();
        this.store.entities$.pipe(debounceTime(500)).subscribe((value) => {
            if (value.length && this.layers.length === this.thematicLength + 1) {
                this.openWorkspace.emit();
                this.createTableTemplate();
            }
        });
    }
    /**
     * Launch clear button (clear store and map layers)
     */
    clearButton() {
        this.loading = true;
        if (this.store) {
            this.store.clear();
        }
        if (this.isPoint() || this.isPolygon()) {
            this.drawZone = undefined;
            this.formControl.reset();
        }
        this.bufferFormControl.setValue(0);
        this.buffer = 0;
        this.bufferEvent.emit(0);
        this.clearButtonEvent.emit();
        this.loading = false;
        this.tableTemplate = undefined;
    }
    clearDrawZone() {
        this.formControl.reset();
        this.bufferFormControl.setValue(0);
        this.buffer = 0;
    }
    /**
     * Launch clear search (clear field if type is predefined)
     */
    clearSearch() {
        this.selectedThematics.clear();
        this.bufferFormControl.setValue(0);
        this.buffer = 0;
        this.bufferEvent.emit(0);
        this.thematicChange.emit([]);
        this.clearSearchEvent.emit();
    }
    /**
     * Verify conditions of incomplete fields or busy service
     */
    disableSearchButton() {
        if (this.type === SpatialFilterType.Predefined) {
            if (this.selectedItemType === SpatialFilterItemType.Address) {
                if (this.queryType !== undefined && this.zone !== undefined) {
                    return this.loading;
                }
            }
            if (this.selectedItemType === SpatialFilterItemType.Thematics) {
                if (this.queryType !== undefined && this.zone !== undefined && this.selectedThematics.selected.length > 0) {
                    return this.loading;
                }
            }
        }
        if (this.type === SpatialFilterType.Polygon || this.type === SpatialFilterType.Point) {
            if (this.selectedItemType === SpatialFilterItemType.Address && this.formControl.value !== null) {
                return this.loading;
            }
            if (this.selectedItemType === SpatialFilterItemType.Thematics) {
                if (this.selectedThematics.selected.length > 0 && this.formControl.value !== null) {
                    return this.loading;
                }
            }
        }
        return true;
    }
    disabledClearSearch() {
        let disable = true;
        this.selectedItemType === SpatialFilterItemType.Address ?
            disable = this.queryType === undefined :
            disable = this.queryType === undefined && this.selectedThematics.selected.length === 0;
        return disable;
    }
    /**
     * Manage radius value at user change
     */
    getRadius() {
        let formValue;
        if (this.formControl.value !== null) {
            this.measureUnit === MeasureLengthUnit.Meters ?
                formValue = this.formControl.value.radius :
                formValue = this.formControl.value.radius / 1000;
        }
        else {
            formValue = undefined;
        }
        if (this.type === SpatialFilterType.Point) {
            if (!this.freehandDrawIsActive) {
                if (this.radiusFormControl.value < 0 ||
                    (this.measureUnit === MeasureLengthUnit.Meters && this.radiusFormControl.value >= 100000) ||
                    (this.measureUnit === MeasureLengthUnit.Kilometers && this.radiusFormControl.value >= 100)) {
                    this.messageService.alert(this.languageService.translate.instant('igo.geo.spatialFilter.radiusAlert'), this.languageService.translate.instant('igo.geo.spatialFilter.warning'));
                    this.radius = 1000;
                    this.measureUnit === MeasureLengthUnit.Meters ?
                        this.radiusFormControl.setValue(this.radius) :
                        this.radiusFormControl.setValue(this.radius / 1000);
                    this.drawGuide$.next(this.radius);
                    return;
                }
            }
            else {
                if (formValue) {
                    if (formValue >= 100000) {
                        this.messageService.alert(this.languageService.translate.instant('igo.geo.spatialFilter.radiusAlert'), this.languageService.translate.instant('igo.geo.spatialFilter.warning'));
                        this.formControl.reset();
                        return;
                    }
                    if (formValue !== this.radiusFormControl.value) {
                        this.radiusFormControl.setValue(formValue);
                        return;
                    }
                }
            }
            if (this.measureUnit === MeasureLengthUnit.Meters) {
                this.radius = this.radiusFormControl.value;
                this.drawGuide$.next(this.radius);
            }
            else {
                this.radius = this.radiusFormControl.value * 1000;
                this.drawGuide$.next(this.radius * 1000);
            }
            this.overlayStyle$.next(this.PointStyle);
            this.drawStyle$.next(this.PointStyle);
        }
    }
    toggleVisibleList() {
        this.listIsVisible = !this.listIsVisible;
    }
    createTableTemplate() {
        const typeColumn = {
            name: 'meta.title',
            title: this.languageService.translate.instant('igo.geo.spatialFilter.type'),
            renderer: EntityTableColumnRenderer.UnsanitizedHTML
        };
        const nameColumn = {
            name: 'properties.nom',
            title: this.languageService.translate.instant('igo.geo.spatialFilter.searchResults'),
            renderer: EntityTableColumnRenderer.UnsanitizedHTML
        };
        const columns = [typeColumn, nameColumn];
        this.tableTemplate = {
            selection: true,
            sort: true,
            columns
        };
    }
}
SpatialFilterItemComponent.ɵfac = function SpatialFilterItemComponent_Factory(t) { return new (t || SpatialFilterItemComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(SpatialFilterService), i0.ɵɵdirectiveInject(i2$1.MessageService), i0.ɵɵdirectiveInject(i2$1.LanguageService)); };
SpatialFilterItemComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SpatialFilterItemComponent, selectors: [["igo-spatial-filter-item"]], inputs: { map: "map", type: "type", queryType: "queryType", zone: "zone", loading: "loading", store: "store", layers: "layers", allLayers: "allLayers", thematicLength: "thematicLength" }, outputs: { toggleSearch: "toggleSearch", itemTypeChange: "itemTypeChange", thematicChange: "thematicChange", drawZoneEvent: "drawZoneEvent", bufferEvent: "bufferEvent", zoneWithBufferChange: "zoneWithBufferChange", measureUnitChange: "measureUnitChange", radiusEvent: "radiusEvent", freehandControl: "freehandControl", clearButtonEvent: "clearButtonEvent", clearSearchEvent: "clearSearchEvent", export: "export", openWorkspace: "openWorkspace", entityChange: "entityChange" }, decls: 29, vars: 42, consts: [[3, "formControl", "map", "geometryType", "drawGuide", "measure", "drawControlIsActive", "freehandDrawIsActive", "drawStyle", "overlayStyle", "radius"], [1, "header"], [3, "checked", "labelPosition", "change", 4, "ngIf"], ["class", "buffer-unit", 4, "ngIf"], ["class", "radius-unit", 4, "ngIf"], [1, "title", "mat-typography"], [3, "value"], [3, "value", "change", 4, "ngFor", "ngForOf"], ["class", "thematics", 4, "ngIf"], [1, "buttons"], ["mat-raised-button", "", "class", "clear-search-button", 3, "disabled", "click", 4, "ngIf"], ["mat-raised-button", "", "class", "clear-form-button", 3, "disabled", "click", 4, "ngIf"], ["mat-raised-button", "", "color", "primary", 1, "search-button", 3, "disabled", "click"], ["mat-raised-button", "", 1, "remove-button", 3, "disabled", "click"], ["mat-raised-button", "", 1, "export-button", 3, "disabled", "click"], ["class", "chevron-down", "mat-icon-button", "", "matTooltipShowDelay", "500", 3, "matTooltip", "click", 4, "ngIf"], ["class", "results", 4, "ngIf"], [3, "checked", "labelPosition", "change"], [1, "buffer-unit"], [1, "buffer-form"], [1, "buffer"], ["type", "number", "matInput", "", 3, "placeholder", "formControl", "value", "readonly"], [1, "unit-field"], [3, "value", "selectionChange"], [3, "value", 4, "ngFor", "ngForOf"], [1, "radius-unit"], [1, "radius-form"], [1, "radius"], ["type", "number", "matInput", "", 3, "placeholder", "formControl", "value", "readonly", "input"], [3, "value", "change"], [1, "thematics"], ["matColumnDef", "name"], ["class", "thematics-header", 4, "matHeaderCellDef"], ["matColumnDef", "select"], ["class", "checks-header", 4, "matHeaderCellDef"], [4, "matHeaderRowDef"], [4, "matRowDef", "matRowDefColumns"], [3, "dataSource", "treeControl"], ["matTreeNodeToggle", "", 4, "matTreeNodeDef"], [4, "matTreeNodeDef", "matTreeNodeDefWhen"], [1, "thematics-header"], [1, "checks-header"], [3, "checked", "indeterminate", "change"], ["matTreeNodeToggle", ""], [1, "mat-tree-node"], ["mat-icon-button", "", "disabled", ""], [1, "tree-check", 3, "checked", "click", "change"], ["mat-icon-button", "", 3, "click"], [3, "svgIcon"], [1, "tree-check-2", 3, "checked", "indeterminate", "change"], [1, "tree-ul"], ["matTreeNodeOutlet", ""], ["mat-raised-button", "", 1, "clear-search-button", 3, "disabled", "click"], ["mat-raised-button", "", 1, "clear-form-button", 3, "disabled", "click"], ["mat-icon-button", "", "matTooltipShowDelay", "500", 1, "chevron-down", 3, "matTooltip", "click"], ["svgIcon", "chevron-down"], [1, "results"], ["mat-icon-button", "", "matTooltipShowDelay", "500", 3, "matTooltip", "click", 4, "ngIf"], [1, "results-list", 3, "template", "store", "entitySelectChange"], ["mat-icon-button", "", "matTooltipShowDelay", "500", 3, "matTooltip", "click"], ["svgIcon", "chevron-up"]], template: function SpatialFilterItemComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelement(0, "igo-geometry-form-field-input", 0);
        i0.ɵɵpipe(1, "async");
        i0.ɵɵpipe(2, "async");
        i0.ɵɵpipe(3, "async");
        i0.ɵɵelementStart(4, "div", 1);
        i0.ɵɵtemplate(5, SpatialFilterItemComponent_mat_slide_toggle_5_Template, 3, 5, "mat-slide-toggle", 2);
        i0.ɵɵtemplate(6, SpatialFilterItemComponent_mat_slide_toggle_6_Template, 3, 5, "mat-slide-toggle", 2);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(7, SpatialFilterItemComponent_div_7_Template, 8, 8, "div", 3);
        i0.ɵɵtemplate(8, SpatialFilterItemComponent_div_8_Template, 8, 8, "div", 4);
        i0.ɵɵelementStart(9, "mat-label", 5);
        i0.ɵɵtext(10);
        i0.ɵɵpipe(11, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(12, "mat-radio-group", 6);
        i0.ɵɵtemplate(13, SpatialFilterItemComponent_mat_radio_button_13_Template, 3, 4, "mat-radio-button", 7);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(14, SpatialFilterItemComponent_div_14_Template, 11, 5, "div", 8);
        i0.ɵɵelementStart(15, "div", 9);
        i0.ɵɵtemplate(16, SpatialFilterItemComponent_button_16_Template, 3, 4, "button", 10);
        i0.ɵɵtemplate(17, SpatialFilterItemComponent_button_17_Template, 3, 4, "button", 11);
        i0.ɵɵelementStart(18, "button", 12);
        i0.ɵɵlistener("click", function SpatialFilterItemComponent_Template_button_click_18_listener() { return ctx.toggleSearchButton(); });
        i0.ɵɵtext(19);
        i0.ɵɵpipe(20, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(21, "button", 13);
        i0.ɵɵlistener("click", function SpatialFilterItemComponent_Template_button_click_21_listener() { return ctx.clearButton(); });
        i0.ɵɵtext(22);
        i0.ɵɵpipe(23, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(24, "button", 14);
        i0.ɵɵlistener("click", function SpatialFilterItemComponent_Template_button_click_24_listener() { return ctx.export.emit(); });
        i0.ɵɵtext(25);
        i0.ɵɵpipe(26, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(27, SpatialFilterItemComponent_button_27_Template, 3, 3, "button", 15);
        i0.ɵɵtemplate(28, SpatialFilterItemComponent_div_28_Template, 3, 3, "div", 16);
    } if (rf & 2) {
        i0.ɵɵproperty("formControl", ctx.formControl)("map", ctx.map)("geometryType", ctx.geometryType)("drawGuide", i0.ɵɵpipeBind1(1, 28, ctx.drawGuide$))("measure", ctx.measure)("drawControlIsActive", ctx.drawControlIsActive)("freehandDrawIsActive", ctx.freehandDrawIsActive)("drawStyle", i0.ɵɵpipeBind1(2, 30, ctx.drawStyle$))("overlayStyle", i0.ɵɵpipeBind1(3, 32, ctx.overlayStyle$))("radius", ctx.radius);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", !ctx.isPredefined());
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx.isPredefined());
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.isPolygon());
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.isPoint());
        i0.ɵɵadvance(2);
        i0.ɵɵtextInterpolate1("", i0.ɵɵpipeBind1(11, 34, "igo.geo.spatialFilter.search"), " : ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", ctx.selectedItemType);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.itemType);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.selectedItemType === "Thematics" && !ctx.tableTemplate || ctx.selectedItemType === "Thematics" && ctx.tableTemplate && !ctx.listIsVisible);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.isPredefined());
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.isPolygon() || ctx.isPoint());
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("disabled", ctx.disableSearchButton());
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(20, 36, "igo.geo.spatialFilter.goSearch"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("disabled", ctx.allLayers.length === 0);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(23, 38, "igo.geo.spatialFilter.removeLayer"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("disabled", !ctx.store.entities$.getValue().length);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(26, 40, "igo.geo.spatialFilter.exportLayer"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.store.all().length && ctx.tableTemplate && !ctx.listIsVisible);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.store.all().length && ctx.tableTemplate && ctx.listIsVisible);
    } }, styles: [".header[_ngcontent-%COMP%]{margin-top:5px;width:100%}.mat-slide-toggle[_ngcontent-%COMP%]{padding:5px;margin-bottom:15px;width:98%}.mat-slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-content{width:calc(100% - 20px)}.title[_ngcontent-%COMP%]{margin-left:5px;font-size:medium;font-size:initial}.mat-radio-group[_ngcontent-%COMP%]{display:flex;flex-direction:column;padding-top:10px}.mat-radio-button[_ngcontent-%COMP%]{display:inline-flex;position:relative;margin-left:16px;margin-top:10px}.mat-form-field[_ngcontent-%COMP%]{margin-top:5px}.mat-column-select[_ngcontent-%COMP%]{overflow:auto}.buttons[_ngcontent-%COMP%]{margin-top:15px}.search-button[_ngcontent-%COMP%]{left:15px;width:46%}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.search-button[_ngcontent-%COMP%]{left:10px;width:45%;min-height:35px;white-space:normal;line-height:normal}}.export-button[_ngcontent-%COMP%]{left:15px;width:46%;margin-bottom:5px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.export-button[_ngcontent-%COMP%]{left:10px;margin-top:10px;width:45%;min-height:35px;white-space:normal;line-height:normal}}.remove-button[_ngcontent-%COMP%]{margin-top:12px;left:5px;width:46%}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.remove-button[_ngcontent-%COMP%]{margin:0;width:45%;min-height:35px;white-space:normal;line-height:normal}}.clear-form-button[_ngcontent-%COMP%]{left:5px;width:46%}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.clear-form-button[_ngcontent-%COMP%]{width:45%;min-height:35px;white-space:normal;line-height:normal}}.clear-search-button[_ngcontent-%COMP%]{left:5px;width:46%}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.clear-search-button[_ngcontent-%COMP%]{width:45%;min-height:35px;white-space:normal;line-height:normal}}.thematics[_ngcontent-%COMP%]{max-height:35%;overflow:auto;margin-top:5px;width:98%}.results[_ngcontent-%COMP%]{overflow:auto;max-height:250px;width:98%}.mat-column-typeResults[_ngcontent-%COMP%]{max-width:100px;margin-right:5px}.buffer-unit[_ngcontent-%COMP%], .radius-unit[_ngcontent-%COMP%]{display:flex;width:100%;margin-left:2px;padding:5px}.radius[_ngcontent-%COMP%], .buffer[_ngcontent-%COMP%]{display:flex;flex-flow:column nowrap;width:110%}.unit-field[_ngcontent-%COMP%]{width:110px;margin-left:30px}.example-tree-invisible[_ngcontent-%COMP%]{display:none}.tree-ul[_ngcontent-%COMP%]{margin:0;padding:0 0 0 20px;list-style-type:none}.tree-check[_ngcontent-%COMP%], .tree-check-2[_ngcontent-%COMP%]{position:relative;margin-left:auto;margin-right:5px}.thematics-header[_ngcontent-%COMP%]{max-width:250px}.checks-header[_ngcontent-%COMP%]{padding:none;max-width:calc(100% - 316px);overflow:hidden}.mat-checkbox[_ngcontent-%COMP%]{padding:5px}.mat-tree-node[_ngcontent-%COMP%]{position:relative;min-height:42px;width:280px}.mat-header-cell[_ngcontent-%COMP%]{height:56px}.results[_ngcontent-%COMP%]{max-height:45%;width:98%}.results[_ngcontent-%COMP%]   igo-entity-table[_ngcontent-%COMP%]     div.table-container{overflow:unset}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SpatialFilterItemComponent, [{
        type: Component,
        args: [{
                selector: 'igo-spatial-filter-item',
                templateUrl: './spatial-filter-item.component.html',
                styleUrls: ['./spatial-filter-item.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: SpatialFilterService }, { type: i2$1.MessageService }, { type: i2$1.LanguageService }]; }, { map: [{
            type: Input
        }], type: [{
            type: Input
        }], queryType: [{
            type: Input
        }], zone: [{
            type: Input
        }], loading: [{
            type: Input
        }], store: [{
            type: Input
        }], layers: [{
            type: Input
        }], allLayers: [{
            type: Input
        }], thematicLength: [{
            type: Input
        }], toggleSearch: [{
            type: Output
        }], itemTypeChange: [{
            type: Output
        }], thematicChange: [{
            type: Output
        }], drawZoneEvent: [{
            type: Output
        }], bufferEvent: [{
            type: Output
        }], zoneWithBufferChange: [{
            type: Output
        }], measureUnitChange: [{
            type: Output
        }], radiusEvent: [{
            type: Output
        }], freehandControl: [{
            type: Output
        }], clearButtonEvent: [{
            type: Output
        }], clearSearchEvent: [{
            type: Output
        }], export: [{
            type: Output
        }], openWorkspace: [{
            type: Output
        }], entityChange: [{
            type: Output
        }] }); })();

const _c0$5 = ["endDatepickerTime"];
const _c1$4 = ["beginDatepickerTime"];
const _c2$2 = ["beginTime"];
const _c3 = ["endTime"];
function OgcFilterTimeComponent_mat_slide_toggle_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-slide-toggle", 4);
    i0.ɵɵlistener("ngModelChange", function OgcFilterTimeComponent_mat_slide_toggle_1_Template_mat_slide_toggle_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.sliderMode = $event; })("change", function OgcFilterTimeComponent_mat_slide_toggle_1_Template_mat_slide_toggle_change_0_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.modeChange($event); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngModel", ctx_r0.sliderMode);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.filter.sliderModeTitle"), " ");
} }
function OgcFilterTimeComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵelementStart(1, "igo-ogc-filter-time-slider", 6);
    i0.ɵɵlistener("changeProperty", function OgcFilterTimeComponent_div_2_Template_igo_ogc_filter_time_slider_changeProperty_1_listener($event) { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.changePropertyByPass($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("begin", ctx_r1.beginValue)("max", ctx_r1.restrictedToStep() ? ctx_r1.maxDate : ctx_r1.endValue)("currentFilter", ctx_r1.currentFilter)("datasource", ctx_r1.datasource);
} }
function OgcFilterTimeComponent_div_3_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r15 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵelementStart(1, "mat-form-field", 10);
    i0.ɵɵelementStart(2, "mat-label");
    i0.ɵɵtext(3);
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(5, "input", 11);
    i0.ɵɵlistener("change", function OgcFilterTimeComponent_div_3_div_1_Template_input_change_5_listener($event) { i0.ɵɵrestoreView(_r15); const _r10 = i0.ɵɵreference(8); const ctx_r14 = i0.ɵɵnextContext(2); return ctx_r14.yearOnlyInputChange($event, _r10, "begin"); });
    i0.ɵɵelementEnd();
    i0.ɵɵelement(6, "mat-datepicker-toggle", 12);
    i0.ɵɵelementStart(7, "mat-datepicker", 13, 14);
    i0.ɵɵlistener("yearSelected", function OgcFilterTimeComponent_div_3_div_1_Template_mat_datepicker_yearSelected_7_listener($event) { i0.ɵɵrestoreView(_r15); const _r10 = i0.ɵɵreference(8); const ctx_r16 = i0.ɵɵnextContext(2); return ctx_r16.yearSelected($event, _r10, "begin"); });
    i0.ɵɵelementEnd();
    i0.ɵɵelement(9, "input", 15, 16);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(11, "mat-form-field", 10);
    i0.ɵɵelementStart(12, "mat-label");
    i0.ɵɵtext(13);
    i0.ɵɵpipe(14, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(15, "input", 11);
    i0.ɵɵlistener("change", function OgcFilterTimeComponent_div_3_div_1_Template_input_change_15_listener($event) { i0.ɵɵrestoreView(_r15); const _r12 = i0.ɵɵreference(18); const ctx_r17 = i0.ɵɵnextContext(2); return ctx_r17.yearOnlyInputChange($event, _r12, "end"); });
    i0.ɵɵelementEnd();
    i0.ɵɵelement(16, "mat-datepicker-toggle", 12);
    i0.ɵɵelementStart(17, "mat-datepicker", 13, 17);
    i0.ɵɵlistener("yearSelected", function OgcFilterTimeComponent_div_3_div_1_Template_mat_datepicker_yearSelected_17_listener($event) { i0.ɵɵrestoreView(_r15); const _r12 = i0.ɵɵreference(18); const ctx_r18 = i0.ɵɵnextContext(2); return ctx_r18.yearSelected($event, _r12, "end"); });
    i0.ɵɵelementEnd();
    i0.ɵɵelement(19, "input", 15, 18);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(21, "button", 19);
    i0.ɵɵlistener("click", function OgcFilterTimeComponent_div_3_div_1_Template_button_click_21_listener() { i0.ɵɵrestoreView(_r15); const ctx_r19 = i0.ɵɵnextContext(2); return ctx_r19.resetFilter(); });
    i0.ɵɵpipe(22, "translate");
    i0.ɵɵelement(23, "mat-icon", 20);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(24, "mat-slide-toggle", 21);
    i0.ɵɵlistener("change", function OgcFilterTimeComponent_div_3_div_1_Template_mat_slide_toggle_change_24_listener() { i0.ɵɵrestoreView(_r15); const ctx_r20 = i0.ɵɵnextContext(2); return ctx_r20.toggleFilterState(); });
    i0.ɵɵpipe(25, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r10 = i0.ɵɵreference(8);
    const _r12 = i0.ɵɵreference(18);
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(4, 27, "igo.geo.timeFilter.startYear"));
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("value", ctx_r8.onlyYearBegin);
    i0.ɵɵproperty("disabled", ctx_r8.filterStateDisable);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("for", _r10)("disabled", ctx_r8.filterStateDisable);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("startView", ctx_r8.calendarView())("startAt", ctx_r8.beginValue);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matDatepicker", _r10)("value", ctx_r8.beginValue ? ctx_r8.beginValue : ctx_r8.handleDate(ctx_r8.datasource.options.minDate))("min", ctx_r8.handleDate(ctx_r8.datasource.options.minDate))("max", ctx_r8.endValue && !ctx_r8.restrictedToStep() ? ctx_r8.endValue : ctx_r8.handleDate(ctx_r8.datasource.options.maxDate));
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(14, 29, "igo.geo.timeFilter.endYear"));
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("value", ctx_r8.onlyYearEnd);
    i0.ɵɵproperty("disabled", ctx_r8.filterStateDisable);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("for", _r12)("disabled", ctx_r8.filterStateDisable);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("startView", ctx_r8.calendarView())("startAt", ctx_r8.endValue);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matDatepicker", _r12)("value", ctx_r8.endValue ? ctx_r8.endValue : ctx_r8.handleDate(ctx_r8.datasource.options.maxDate))("min", ctx_r8.beginValue ? ctx_r8.beginValue : ctx_r8.handleDate(ctx_r8.datasource.options.minDate))("max", ctx_r8.handleDate(ctx_r8.datasource.options.maxDate));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(22, 31, "igo.geo.filter.resetFilters"))("disabled", ctx_r8.filterStateDisable);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("svgIcon", ctx_r8.resetIcon);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(25, 33, "igo.geo.filter.toggleFilterState"))("checked", !ctx_r8.filterStateDisable);
} }
function OgcFilterTimeComponent_div_3_div_2_mat_form_field_11_mat_option_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 36);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const hour_r27 = ctx.$implicit;
    i0.ɵɵproperty("value", hour_r27);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(hour_r27);
} }
function OgcFilterTimeComponent_div_3_div_2_mat_form_field_11_Template(rf, ctx) { if (rf & 1) {
    const _r29 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 33);
    i0.ɵɵelementStart(1, "mat-label");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "mat-select", 34);
    i0.ɵɵlistener("selectionChange", function OgcFilterTimeComponent_div_3_div_2_mat_form_field_11_Template_mat_select_selectionChange_4_listener() { i0.ɵɵrestoreView(_r29); i0.ɵɵnextContext(); const _r21 = i0.ɵɵreference(5); const ctx_r28 = i0.ɵɵnextContext(2); return ctx_r28.changeTemporalProperty(_r21.value, 1); });
    i0.ɵɵtemplate(5, OgcFilterTimeComponent_div_3_div_2_mat_form_field_11_mat_option_5_Template, 2, 2, "mat-option", 35);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r23 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 4, "igo.geo.timeFilter.hour"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("formControl", ctx_r23.beginHourFormControl);
    i0.ɵɵattribute("disabled", !ctx_r23.currentFilter.active);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r23.beginHours);
} }
function OgcFilterTimeComponent_div_3_div_2_mat_form_field_12_mat_option_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 36);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const minute_r31 = ctx.$implicit;
    i0.ɵɵproperty("value", minute_r31);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(minute_r31);
} }
function OgcFilterTimeComponent_div_3_div_2_mat_form_field_12_Template(rf, ctx) { if (rf & 1) {
    const _r33 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 37);
    i0.ɵɵelementStart(1, "mat-label");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "mat-select", 34);
    i0.ɵɵlistener("selectionChange", function OgcFilterTimeComponent_div_3_div_2_mat_form_field_12_Template_mat_select_selectionChange_4_listener() { i0.ɵɵrestoreView(_r33); i0.ɵɵnextContext(); const _r21 = i0.ɵɵreference(5); const ctx_r32 = i0.ɵɵnextContext(2); return ctx_r32.changeTemporalProperty(_r21.value, 1); });
    i0.ɵɵtemplate(5, OgcFilterTimeComponent_div_3_div_2_mat_form_field_12_mat_option_5_Template, 2, 2, "mat-option", 35);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 4, "igo.geo.timeFilter.minute"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("formControl", ctx_r24.beginMinuteFormControl);
    i0.ɵɵattribute("disabled", !ctx_r24.currentFilter.active);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r24.beginMinutes);
} }
function OgcFilterTimeComponent_div_3_div_2_div_13_mat_form_field_10_mat_option_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 36);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const hour_r39 = ctx.$implicit;
    i0.ɵɵproperty("value", hour_r39);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(hour_r39);
} }
function OgcFilterTimeComponent_div_3_div_2_div_13_mat_form_field_10_Template(rf, ctx) { if (rf & 1) {
    const _r41 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 33);
    i0.ɵɵelementStart(1, "mat-label");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "mat-select", 34);
    i0.ɵɵlistener("selectionChange", function OgcFilterTimeComponent_div_3_div_2_div_13_mat_form_field_10_Template_mat_select_selectionChange_4_listener() { i0.ɵɵrestoreView(_r41); i0.ɵɵnextContext(); const _r34 = i0.ɵɵreference(4); const ctx_r40 = i0.ɵɵnextContext(3); return ctx_r40.changeTemporalProperty(_r34.value, 2); });
    i0.ɵɵtemplate(5, OgcFilterTimeComponent_div_3_div_2_div_13_mat_form_field_10_mat_option_5_Template, 2, 2, "mat-option", 35);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r36 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 4, "igo.geo.timeFilter.hour"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("formControl", ctx_r36.endHourFormControl);
    i0.ɵɵattribute("disabled", !ctx_r36.currentFilter.active);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r36.endHours);
} }
function OgcFilterTimeComponent_div_3_div_2_div_13_mat_form_field_11_mat_option_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 36);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const minute_r43 = ctx.$implicit;
    i0.ɵɵproperty("value", minute_r43);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(minute_r43);
} }
function OgcFilterTimeComponent_div_3_div_2_div_13_mat_form_field_11_Template(rf, ctx) { if (rf & 1) {
    const _r45 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field", 37);
    i0.ɵɵelementStart(1, "mat-label");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "mat-select", 34);
    i0.ɵɵlistener("selectionChange", function OgcFilterTimeComponent_div_3_div_2_div_13_mat_form_field_11_Template_mat_select_selectionChange_4_listener() { i0.ɵɵrestoreView(_r45); i0.ɵɵnextContext(); const _r34 = i0.ɵɵreference(4); const ctx_r44 = i0.ɵɵnextContext(3); return ctx_r44.changeTemporalProperty(_r34.value, 2); });
    i0.ɵɵtemplate(5, OgcFilterTimeComponent_div_3_div_2_div_13_mat_form_field_11_mat_option_5_Template, 2, 2, "mat-option", 35);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r37 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 4, "igo.geo.timeFilter.minute"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("formControl", ctx_r37.endMinuteFormControl);
    i0.ɵɵattribute("disabled", !ctx_r37.currentFilter.active);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r37.endMinutes);
} }
function OgcFilterTimeComponent_div_3_div_2_div_13_Template(rf, ctx) { if (rf & 1) {
    const _r47 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 23);
    i0.ɵɵelementStart(1, "mat-form-field", 24);
    i0.ɵɵelement(2, "mat-datepicker-toggle", 12);
    i0.ɵɵelementStart(3, "input", 25, 38);
    i0.ɵɵlistener("dateChange", function OgcFilterTimeComponent_div_3_div_2_div_13_Template_input_dateChange_3_listener() { i0.ɵɵrestoreView(_r47); const _r34 = i0.ɵɵreference(4); const ctx_r46 = i0.ɵɵnextContext(3); return ctx_r46.changeTemporalProperty(_r34.value, 2); });
    i0.ɵɵpipe(5, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelement(6, "span", 27);
    i0.ɵɵelementStart(7, "mat-datepicker", 28, 17);
    i0.ɵɵlistener("yearSelected", function OgcFilterTimeComponent_div_3_div_2_div_13_Template_mat_datepicker_yearSelected_7_listener($event) { i0.ɵɵrestoreView(_r47); const _r35 = i0.ɵɵreference(8); const ctx_r48 = i0.ɵɵnextContext(3); return ctx_r48.yearSelected($event, _r35, "end"); })("monthSelected", function OgcFilterTimeComponent_div_3_div_2_div_13_Template_mat_datepicker_monthSelected_7_listener($event) { i0.ɵɵrestoreView(_r47); const _r35 = i0.ɵɵreference(8); const ctx_r49 = i0.ɵɵnextContext(3); return ctx_r49.monthSelected($event, _r35, "end"); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(9, "div", 29);
    i0.ɵɵtemplate(10, OgcFilterTimeComponent_div_3_div_2_div_13_mat_form_field_10_Template, 6, 6, "mat-form-field", 30);
    i0.ɵɵtemplate(11, OgcFilterTimeComponent_div_3_div_2_div_13_mat_form_field_11_Template, 6, 6, "mat-form-field", 31);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r35 = i0.ɵɵreference(8);
    const ctx_r25 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("for", _r35)("disabled", ctx_r25.filterStateDisable);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matDatepicker", _r35)("placeholder", i0.ɵɵpipeBind1(5, 14, "igo.geo.timeFilter.endDate"))("matDatepickerFilter", ctx_r25.dateFilter.bind(ctx_r25, "end"))("value", ctx_r25.endValue ? ctx_r25.endValue : ctx_r25.handleDate(ctx_r25.datasource.options.maxDate))("min", ctx_r25.beginValue ? ctx_r25.beginValue : ctx_r25.handleDate(ctx_r25.datasource.options.minDate))("max", ctx_r25.handleDate(ctx_r25.datasource.options.maxDate))("disabled", ctx_r25.filterStateDisable);
    i0.ɵɵattribute("disabled", !ctx_r25.currentFilter.active);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("startView", ctx_r25.calendarView())("startAt", ctx_r25.endValue);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r25.calendarType() === "datetime");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r25.calendarType() === "datetime");
} }
function OgcFilterTimeComponent_div_3_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r51 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 22);
    i0.ɵɵelementStart(1, "div", 23);
    i0.ɵɵelementStart(2, "mat-form-field", 24);
    i0.ɵɵelement(3, "mat-datepicker-toggle", 12);
    i0.ɵɵelementStart(4, "input", 25, 26);
    i0.ɵɵlistener("dateChange", function OgcFilterTimeComponent_div_3_div_2_Template_input_dateChange_4_listener() { i0.ɵɵrestoreView(_r51); const _r21 = i0.ɵɵreference(5); const ctx_r50 = i0.ɵɵnextContext(2); return ctx_r50.changeTemporalProperty(_r21.value, 1); });
    i0.ɵɵpipe(6, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelement(7, "span", 27);
    i0.ɵɵelementStart(8, "mat-datepicker", 28, 14);
    i0.ɵɵlistener("yearSelected", function OgcFilterTimeComponent_div_3_div_2_Template_mat_datepicker_yearSelected_8_listener($event) { i0.ɵɵrestoreView(_r51); const _r22 = i0.ɵɵreference(9); const ctx_r52 = i0.ɵɵnextContext(2); return ctx_r52.yearSelected($event, _r22, "begin"); })("monthSelected", function OgcFilterTimeComponent_div_3_div_2_Template_mat_datepicker_monthSelected_8_listener($event) { i0.ɵɵrestoreView(_r51); const _r22 = i0.ɵɵreference(9); const ctx_r53 = i0.ɵɵnextContext(2); return ctx_r53.monthSelected($event, _r22, "begin"); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(10, "div", 29);
    i0.ɵɵtemplate(11, OgcFilterTimeComponent_div_3_div_2_mat_form_field_11_Template, 6, 6, "mat-form-field", 30);
    i0.ɵɵtemplate(12, OgcFilterTimeComponent_div_3_div_2_mat_form_field_12_Template, 6, 6, "mat-form-field", 31);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(13, OgcFilterTimeComponent_div_3_div_2_div_13_Template, 12, 16, "div", 32);
    i0.ɵɵelementStart(14, "button", 19);
    i0.ɵɵlistener("click", function OgcFilterTimeComponent_div_3_div_2_Template_button_click_14_listener() { i0.ɵɵrestoreView(_r51); const ctx_r54 = i0.ɵɵnextContext(2); return ctx_r54.resetFilter(); });
    i0.ɵɵpipe(15, "translate");
    i0.ɵɵelement(16, "mat-icon", 20);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(17, "mat-slide-toggle", 21);
    i0.ɵɵlistener("change", function OgcFilterTimeComponent_div_3_div_2_Template_mat_slide_toggle_change_17_listener() { i0.ɵɵrestoreView(_r51); const ctx_r55 = i0.ɵɵnextContext(2); return ctx_r55.toggleFilterState(); });
    i0.ɵɵpipe(18, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r22 = i0.ɵɵreference(9);
    const ctx_r9 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("for", _r22)("disabled", ctx_r9.filterStateDisable);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matDatepicker", _r22)("placeholder", i0.ɵɵpipeBind1(6, 20, "igo.geo.timeFilter.startDate"))("matDatepickerFilter", ctx_r9.dateFilter.bind(ctx_r9, "begin"))("value", ctx_r9.beginValue ? ctx_r9.beginValue : ctx_r9.handleDate(ctx_r9.datasource.options.minDate))("min", ctx_r9.handleDate(ctx_r9.datasource.options.minDate))("max", ctx_r9.endValue && !ctx_r9.restrictedToStep() ? ctx_r9.endValue : ctx_r9.handleDate(ctx_r9.datasource.options.maxDate))("disabled", ctx_r9.filterStateDisable);
    i0.ɵɵattribute("disabled", !ctx_r9.currentFilter.active);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("startView", ctx_r9.calendarView())("startAt", ctx_r9.beginValue);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r9.calendarType() === "datetime");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r9.calendarType() === "datetime");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !ctx_r9.restrictedToStep());
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(15, 22, "igo.geo.filter.resetFilters"))("disabled", ctx_r9.filterStateDisable);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("svgIcon", ctx_r9.resetIcon);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(18, 24, "igo.geo.filter.toggleFilterState"))("checked", !ctx_r9.filterStateDisable);
} }
function OgcFilterTimeComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtemplate(1, OgcFilterTimeComponent_div_3_div_1_Template, 26, 35, "div", 7);
    i0.ɵɵtemplate(2, OgcFilterTimeComponent_div_3_div_2_Template, 19, 26, "div", 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.calendarTypeYear);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.calendarType() !== "year");
} }
const moment$1 = moment_;
class OgcFilterTimeComponent {
    constructor(ogcFilterTimeService) {
        this.ogcFilterTimeService = ogcFilterTimeService;
        this.changeProperty = new EventEmitter();
        this.beginHourFormControl = new FormControl();
        this.beginMinuteFormControl = new FormControl();
        this.endHourFormControl = new FormControl();
        this.endMinuteFormControl = new FormControl();
        this._defaultMin = '1900-01-01';
        this._defaultMax = '2052-01-06';
        this._defaultDisplayFormat = 'DD/MM/YYYY HH:mm A';
        this._defaultSliderModeEnabled = true;
        this.ogcFilterOperator = OgcFilterOperator;
        this.sliderMode = false;
        this.defaultStepMillisecond = 60000;
        this.calendarTypeYear = false;
        this.resetIcon = 'replay';
    }
    get step() {
        return this.datasource.options.stepDate
            ? this.datasource.options.stepDate
            : this.currentFilter.step;
    }
    get stepMilliseconds() {
        const step = moment$1.duration(this.step).asMilliseconds();
        return step === 0 ? this.defaultStepMillisecond : step;
    }
    set beginValue(begin) {
        this._beginValue = begin;
    }
    get beginValue() {
        return this._beginValue;
    }
    set endValue(end) {
        this._endValue = end;
    }
    get endValue() {
        return this._endValue;
    }
    get sliderInterval() {
        return this.currentFilter.sliderInterval === undefined
            ? 2000
            : this.currentFilter.sliderInterval;
    }
    get maxDate() {
        return this.datasource.options.maxDate ? this.datasource.options.maxDate : this._defaultMax;
    }
    get displayFormat() {
        return this.currentFilter.displayFormat ? this.currentFilter.displayFormat : this._defaultDisplayFormat;
    }
    ngOnInit() {
        if (this.currentFilter.sliderOptions) {
            this.currentFilter.sliderOptions.enabled = this.currentFilter.sliderOptions.enabled !== undefined ?
                this.currentFilter.sliderOptions.enabled : this._defaultSliderModeEnabled;
        }
        this.beginValue = this.parseFilter(this.handleMin());
        this.endValue = this.parseFilter(this.handleMax());
        this.onlyYearBegin = this.beginValue.getUTCFullYear();
        this.onlyYearEnd = this.endValue.getUTCFullYear();
        this.calendarTypeYear = this.isCalendarYearMode();
        this.setFilterStateDisable();
        this.updateHoursMinutesArray();
        // update value for now value
        this.updateValues();
    }
    parseFilter(filter) {
        if (!filter) {
            return new Date();
        }
        else if (isNaN(new Date(filter).getTime())) {
            if (filter.search('now') >= 0) {
                const interval = filter.match(/years|months|weeks|days|hours|seconds/);
                if (filter.match(/\+/)) {
                    const intervalInt = parseInt(filter.substring(filter.search('+') + 1, interval.index), 10);
                    return moment$1().add(intervalInt, interval[0]).toDate();
                }
                if (filter.match(/\-/)) {
                    const intervalInt = parseInt(filter.substring(filter.search('-') + 1, interval.index), 10);
                    return moment$1().subtract(intervalInt, interval[0]).toDate();
                }
                return new Date();
            }
            if (filter.search('today') >= 0) {
                const _now = moment$1().endOf('day').toDate();
                const interval = filter.match(/years|months|weeks|days|hours|seconds/);
                if (filter.match(/\+/)) {
                    const intervalInt = parseInt(filter.substring(filter.search('+') + 1, interval.index), 10);
                    return moment$1(_now).add(intervalInt, interval[0]).toDate();
                }
                if (filter.match(/\-/)) {
                    const intervalInt = parseInt(filter.substring(filter.search('-') + 1, interval.index), 10);
                    return moment$1(_now).subtract(intervalInt, interval[0]).toDate();
                }
                return _now;
            }
            return new Date();
        }
        if (this.currentFilter.calendarModeYear) {
            const date = this.getDateFromStringWithoutTime(filter);
            return date;
        }
        else {
            return filter ? new Date(filter) : new Date();
        }
    }
    changeTemporalProperty(value, position, refreshFilter = true) {
        let valueTmp = this.getDateTime(value, position);
        if (this.isCalendarYearMode()) {
            let dateStringFromYearNotime;
            if (position === 1) {
                this.beginValue = value;
                this.onlyYearBegin = this.beginValue.getFullYear();
                dateStringFromYearNotime = `${this.onlyYearBegin}-01-01`;
            }
            else {
                this.endValue = value;
                this.onlyYearEnd = this.endValue.getFullYear();
                dateStringFromYearNotime = `${this.onlyYearEnd}-01-01`;
            }
            // call service with string date without time
            this.changeProperty.next({ value: dateStringFromYearNotime, pos: position, refreshFilter });
            return;
        }
        if (position === 2 && this.calendarType() === 'date' && !this.sliderMode) {
            /* Above month: see yearSelected or monthSelected */
            valueTmp = moment$1(valueTmp).endOf('day').toDate();
        }
        if (position === 1) {
            this.beginValue = valueTmp;
            if (this.restrictedToStep()) {
                this.changeTemporalProperty(this.ogcFilterTimeService.addStep(valueTmp, this.stepMilliseconds), 2, refreshFilter);
            }
        }
        else {
            this.endValue = valueTmp;
        }
        this.updateHoursMinutesArray();
        this.changeProperty.next({ value: valueTmp.toISOString(), pos: position, refreshFilter });
    }
    handleDate(value) {
        if (!value || value === '') {
            return undefined;
        }
        if (typeof (value) === 'string' && this.currentFilter.calendarModeYear) {
            return this.getDateFromStringWithoutTime(value);
        }
        return new Date(value);
    }
    calendarType() {
        if (this.currentFilter.calendarModeYear) {
            return 'year';
        }
        if (this.stepMilliseconds < 86400000) {
            return 'datetime';
        }
        return 'date';
    }
    isCalendarYearMode() {
        if (this.calendarType() === 'year') {
            return true;
        }
        else {
            return false;
        }
    }
    yearOnlyInputChange(changeEvent, datePicker, property) {
        const year = changeEvent.target.value;
        const date = this.getDateFromStringWithoutTime(year);
        this.yearSelected(date, datePicker, property);
    }
    yearSelected(year, datePicker, property, refreshFilter = true) {
        if (this.ogcFilterTimeService.stepIsYearDuration(this.step)) {
            if (datePicker) {
                datePicker.close();
            }
            if (property === 'end') {
                // change value 01 jan to 31 dec same year
                year = moment$1(year).endOf('year').toDate();
            }
            else if (property === 'begin' && this.restrictedToStep() && !this.calendarTypeYear) {
                this.yearSelected(year, undefined, 'end');
            }
            this.changeTemporalProperty(year, property === 'begin' ? 1 : 2, refreshFilter);
        }
    }
    monthSelected(month, datePicker, property, refreshFilter = true) {
        if (this.ogcFilterTimeService.stepIsMonthDuration(this.step)) {
            if (datePicker) {
                datePicker.close();
            }
            if (property === 'end') {
                month = moment$1(month).endOf('month').toDate();
            }
            else if (property === 'begin' && this.restrictedToStep()) {
                this.monthSelected(month, undefined, 'end');
            }
            this.changeTemporalProperty(month, property === 'begin' ? 1 : 2, refreshFilter);
        }
    }
    calendarView() {
        const test = this.stepMilliseconds;
        const diff = Math.abs(this.parseFilter(this.currentFilter.end).getTime() -
            this.parseFilter(this.currentFilter.begin).getTime());
        if (this.ogcFilterTimeService.stepIsYearDuration(this.step)) {
            return 'multi-year';
        }
        else if (this.ogcFilterTimeService.stepIsMonthDuration(this.step)) {
            return 'year';
        }
        else if (test < 86400000 && diff < 86400000) {
            return 'clock';
        }
        else {
            return 'month';
        }
    }
    dateFilter(type, date) {
        const dateValue = new Date(date);
        const diff = dateValue.getTime() - new Date(this.handleMin()).getTime();
        if (this.ogcFilterTimeService.stepIsYearDuration(this.step)) {
            const monthDiff = moment$1(dateValue).diff(moment$1(this.handleMin()), 'years', true);
            if (type === 'end') {
                const dateValuePlus1 = moment$1(dateValue).add(1, 'd');
                const monthDiffPlus1 = moment$1(dateValuePlus1).diff(moment$1(this.handleMin()), 'years', true);
                return (monthDiffPlus1 % moment$1.duration(this.step).asYears()) === 0;
            }
            else if (type === 'begin') {
                return (monthDiff % moment$1.duration(this.step).asYears()) === 0;
            }
        }
        else if (this.ogcFilterTimeService.stepIsMonthDuration(this.step)) {
            const monthDiff = moment$1(dateValue).diff(moment$1(this.handleMin()), 'months', true);
            if (type === 'end') {
                const dateValuePlus1 = moment$1(dateValue).add(1, 'd');
                const monthDiffPlus1 = moment$1(dateValuePlus1).diff(moment$1(this.handleMin()), 'months', true);
                return (monthDiffPlus1 % moment$1.duration(this.step).asMonths()) === 0;
            }
            else if (type === 'begin') {
                return (monthDiff % moment$1.duration(this.step).asMonths()) === 0;
            }
        }
        else if (this.ogcFilterTimeService.stepIsWeekDuration(this.step)) {
            const weekDiff = moment$1(dateValue).diff(moment$1(this.handleMin()), 'weeks', true);
            if (type === 'end') {
                const dateValuePlus1 = moment$1(dateValue).add(1, 'd');
                const weekDiffPlus1 = moment$1(dateValuePlus1).diff(moment$1(this.handleMin()), 'weeks', true);
                return (weekDiffPlus1 % moment$1.duration(this.step).asWeeks()) === 0;
            }
            else if (type === 'begin') {
                return (weekDiff % moment$1.duration(this.step).asWeeks()) === 0;
            }
        }
        else if (this.ogcFilterTimeService.stepIsDayDuration(this.step)) {
            const dayDiff = moment$1(dateValue).diff(moment$1(this.handleMin()), 'days', true);
            if (type === 'end') {
                const dateValuePlus1 = moment$1(dateValue).add(1, 'd');
                const dayDiffPlus1 = moment$1(dateValuePlus1).diff(moment$1(this.handleMin()), 'days', true);
                const _mod = (dayDiffPlus1 % moment$1.duration(this.step).asDays());
                return (_mod < 0.0000001 && _mod > -0.0000001) || _mod === 0; // 1 millisecond = 1.1574074074074076e-8
            }
            else if (type === 'begin') {
                const _mod = ((dayDiff % moment$1.duration(this.step).asDays()) + 1);
                return (_mod < 0.0000001 && _mod > -0.0000001 && _mod !== 0) || _mod === 1; // 1 millisecond = 1.1574074074074076e-8
            }
        }
        else if (this.ogcFilterTimeService.stepIsHourDuration(this.step)) {
            const hourDiff = moment$1(dateValue).diff(moment$1(this.handleMin()), 'hours', true);
            return (hourDiff % moment$1.duration(this.step).asHours()) === 0;
        }
        else if (this.ogcFilterTimeService.stepIsMinuteDuration(this.step)) {
            return true;
        }
        return diff % this.stepMilliseconds === 0;
    }
    getDateTime(date, pos) {
        const valuetmp = new Date(date);
        let valuetmp2;
        if (!this.sliderMode) {
            switch (pos) {
                case 1: {
                    if (this.currentFilter.calendarModeYear) {
                        valuetmp2 = valuetmp.setHours(0, 0);
                        break;
                    }
                    else {
                        valuetmp2 = valuetmp.setHours(this.beginHourFormControl.value, this.beginMinuteFormControl.value);
                        break;
                    }
                }
                case 2: {
                    if (this.currentFilter.calendarModeYear) {
                        valuetmp2 = valuetmp.setHours(0, 0);
                        break;
                    }
                    else {
                        valuetmp2 = valuetmp.setHours(this.endHourFormControl.value, this.endMinuteFormControl.value);
                        break;
                    }
                }
            }
        }
        return new Date(valuetmp2 ? valuetmp2 : valuetmp);
    }
    handleMinuteIncrement() {
        if (this.ogcFilterTimeService.stepIsMinuteDuration(this.step)) {
            if (this.stepMilliseconds < 3600000) {
                return this.stepMilliseconds / 1000 === 60 ? 1 : this.stepMilliseconds / 1000;
            }
            else {
                return (this.stepMilliseconds % 3600000) / 60;
            }
        }
        else if (this.ogcFilterTimeService.stepIsHourDuration(this.step)) {
            return 60;
        }
        return 1;
    }
    handleHourIncrement() {
        if (this.ogcFilterTimeService.stepIsHourDuration(this.step)) {
            return this.stepMilliseconds / 1000 / 60 / 60;
        }
        return 1;
    }
    fullBeginHoursArray(checkEndValue) {
        if (checkEndValue) {
            this.beginHours = Array.from({
                length: (this.endHourFormControl.value - 0) / this.handleHourIncrement() + 1
            }, (_, i) => 0 + i * this.handleHourIncrement());
        }
        else {
            this.beginHours = Array.from({ length: (23 - 0) / this.handleHourIncrement() + 1 }, (_, i) => 0 + i * this.handleHourIncrement());
        }
        this.beginHourFormControl.setValue(this.beginValue.getHours());
    }
    fullEndHoursArray(checkEndValue) {
        if (checkEndValue) {
            this.endHours = Array.from({
                length: (23 - this.beginHourFormControl.value) /
                    this.handleHourIncrement() +
                    1
            }, (_, i) => this.beginHourFormControl.value + i * this.handleHourIncrement());
        }
        else {
            this.endHours = Array.from({ length: (23 - 0) / this.handleHourIncrement() + 1 }, (_, i) => 0 + i * this.handleHourIncrement());
        }
        this.endHourFormControl.setValue(this.endValue.getHours());
    }
    fullBeginMinutesArray(checkEndValue) {
        if (checkEndValue) {
            this.beginMinutes = Array.from({
                length: (this.endMinuteFormControl.value - 0) /
                    this.handleMinuteIncrement() +
                    1
            }, (_, i) => 0 + i * this.handleMinuteIncrement());
        }
        else {
            this.beginMinutes = Array.from({ length: (59 - 0) / this.handleMinuteIncrement() + 1 }, (_, i) => 0 + i * this.handleMinuteIncrement());
        }
        this.beginMinuteFormControl.setValue(this.beginValue.getMinutes());
    }
    fullEndMinutesArray(checkEndValue) {
        if (checkEndValue) {
            this.endMinutes = Array.from({
                length: (59 - this.beginMinuteFormControl.value) /
                    this.handleMinuteIncrement() +
                    1
            }, (_, i) => this.beginMinuteFormControl.value + i * this.handleMinuteIncrement());
        }
        else {
            this.endMinutes = Array.from({ length: (59 - 0) / this.handleMinuteIncrement() + 1 }, (_, i) => 0 + i * this.handleMinuteIncrement());
        }
        this.endMinuteFormControl.setValue(this.endValue.getMinutes());
    }
    updateHoursMinutesArray() {
        const beginTmp = new Date(this.beginValue);
        const endTmp = new Date(this.endValue);
        if (beginTmp.setHours(0, 0) === endTmp.setHours(0, 0)) {
            this.fullBeginHoursArray(true);
            this.fullEndHoursArray(true);
            if (this.beginValue.getHours() === this.endValue.getHours()) {
                this.fullBeginMinutesArray(true);
                this.fullEndMinutesArray(true);
            }
        }
        else {
            this.fullBeginHoursArray();
            this.fullEndHoursArray();
            this.fullBeginMinutesArray();
            this.fullEndMinutesArray();
        }
    }
    updateValues() {
        this.changeTemporalProperty(this.beginValue, 1, false);
        this.changeTemporalProperty(this.endValue, 2, true);
    }
    restrictedToStep() {
        return this.currentFilter.restrictToStep
            ? this.currentFilter.restrictToStep : false;
    }
    handleMin() {
        return this.currentFilter.begin ? this.currentFilter.begin :
            (this.datasource.options.minDate ? this.datasource.options.minDate : this._defaultMin);
    }
    handleMax() {
        return this.currentFilter.end ? this.currentFilter.end :
            (this.datasource.options.maxDate ? this.datasource.options.maxDate : this._defaultMax);
    }
    changePropertyByPass(event) {
        this.changeProperty.next(event);
    }
    modeChange(event) {
        if (!event.checked) {
            this.updateValues();
        }
    }
    setFilterStateDisable() {
        if (this.currentFilter) {
            this.filterStateDisable = !this.currentFilter.active;
        }
        else {
            this.filterStateDisable = false;
        }
        if (this.calendarType() === 'datetime') {
            if (this.filterStateDisable === true) {
                this.beginHourFormControl.disable();
                this.beginMinuteFormControl.disable();
                this.endHourFormControl.disable();
                this.endMinuteFormControl.disable();
            }
            else {
                this.beginHourFormControl.enable();
                this.beginMinuteFormControl.enable();
                this.endHourFormControl.enable();
                this.endMinuteFormControl.enable();
            }
        }
    }
    getDateFromStringWithoutTime(stringDate) {
        // warning create date with no time make a date UTC with TZ and the date create maybe not the same year, month and day
        // exemple:
        // new Date('2022-01-01') -> Fri Dec 31 2021 19:00:00 GMT-0500 (heure normale de l’Est nord-américain)
        // to create same date as string, add time 00 in the creation
        // new Date('2022-01-01 00:00:00') -> Sat Jan 01 2022 00:00:00 GMT-0500 (heure normale de l’Est nord-américain)
        let year;
        let month = '01';
        let day = '01';
        if (stringDate.length === 10) {
            const dateItems = stringDate.split('-');
            if (dateItems.length !== 3) {
                throw new Error('Error in config date begin-end for ogcFilter: Date without time format need to be YYYY-MM-DD or YYYY');
            }
            else {
                year = dateItems[0];
                month = dateItems[1];
                day = dateItems[2];
            }
        }
        else if (stringDate.length === 4) {
            year = stringDate;
        }
        else {
            return new Date(stringDate);
        }
        return new Date(`${year}-${month}-${day} 00:00:00`);
    }
    resetFilter() {
        let filterOriginConfig = this.datasource.options.ogcFilters.filters;
        let minDefaultDate;
        let maxDefaultDate;
        let minDefaultISOString;
        let maxDefaultISOString;
        if (this.calendarTypeYear) {
            if (filterOriginConfig.end === 'today') {
                let todayDateStringNoTime = new Date().toLocaleDateString('en-CA'); // '2022-02-13'
                maxDefaultISOString = `${todayDateStringNoTime.substring(0, 4)}-01-01`;
            }
            else {
                maxDefaultISOString = `${filterOriginConfig.end.substring(0, 4)}-01-01`;
            }
            minDefaultISOString = `${filterOriginConfig.begin.substring(0, 4)}-01-01`;
            minDefaultDate = this.getDateFromStringWithoutTime(minDefaultISOString);
            maxDefaultDate = this.getDateFromStringWithoutTime(maxDefaultISOString);
        }
        else {
            minDefaultDate = this.parseFilter(filterOriginConfig.begin);
            maxDefaultDate = this.parseFilter(filterOriginConfig.end);
            minDefaultISOString = minDefaultDate.toISOString();
            maxDefaultISOString = maxDefaultDate.toISOString();
        }
        if ((this.currentFilter.begin !== minDefaultISOString) ||
            (this.currentFilter.end !== maxDefaultISOString)) {
            this.beginValue = minDefaultDate;
            this.endValue = maxDefaultDate;
            this.updateValues();
        }
    }
    toggleFilterState() {
        if (this.currentFilter.active === true) {
            this.currentFilter.active = false;
        }
        else {
            this.currentFilter.active = true;
        }
        this.setFilterStateDisable();
        this.updateValues();
    }
}
OgcFilterTimeComponent.ɵfac = function OgcFilterTimeComponent_Factory(t) { return new (t || OgcFilterTimeComponent)(i0.ɵɵdirectiveInject(OGCFilterTimeService)); };
OgcFilterTimeComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OgcFilterTimeComponent, selectors: [["igo-ogc-filter-time"]], viewQuery: function OgcFilterTimeComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$5, 5);
        i0.ɵɵviewQuery(_c1$4, 5);
        i0.ɵɵviewQuery(_c2$2, 5);
        i0.ɵɵviewQuery(_c3, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.endDatepickerTime = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.beginDatepickerTime = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.beginTime = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.endTime = _t.first);
    } }, inputs: { datasource: "datasource", currentFilter: "currentFilter" }, outputs: { changeProperty: "changeProperty" }, decls: 4, vars: 3, consts: [[1, "datetime-container"], [3, "ngModel", "ngModelChange", "change", 4, "ngIf"], ["class", "slider-container", 4, "ngIf"], [4, "ngIf"], [3, "ngModel", "ngModelChange", "change"], [1, "slider-container"], [3, "begin", "max", "currentFilter", "datasource", "changeProperty"], ["class", "year-input-container", 4, "ngIf"], ["class", "datetime-input-container", 4, "ngIf"], [1, "year-input-container"], [1, "year-input"], ["matInput", "", 1, "year-input-only-year", 3, "value", "disabled", "change"], ["matSuffix", "", 3, "for", "disabled"], ["panelClass", "datepicker-year", 3, "startView", "startAt", "yearSelected"], ["beginDatepicker", ""], ["matInput", "", "enabled", "false", "readonly", "true", 1, "year-input-hide", 3, "matDatepicker", "value", "min", "max"], ["beginYear", ""], ["endDatepicker", ""], ["endYear", ""], ["mat-icon-button", "", "color", "primary", 1, "reset-button", 3, "matTooltip", "disabled", "click"], [3, "svgIcon"], ["tooltip-position", "below", "matTooltipShowDelay", "500", 1, "toggle-filter-state", 3, "matTooltip", "checked", "change"], [1, "datetime-input-container"], [1, "datetime-input"], [1, "date-input"], ["matInput", "", 3, "matDatepicker", "placeholder", "matDatepickerFilter", "value", "min", "max", "disabled", "dateChange"], ["begin", ""], [1, "filler"], [3, "startView", "startAt", "yearSelected", "monthSelected"], [1, "time-input"], ["class", "hour-input", 4, "ngIf"], ["class", "minute-input", 4, "ngIf"], ["class", "datetime-input", 4, "ngIf"], [1, "hour-input"], [3, "formControl", "selectionChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "minute-input"], ["end", ""]], template: function OgcFilterTimeComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtemplate(1, OgcFilterTimeComponent_mat_slide_toggle_1_Template, 3, 4, "mat-slide-toggle", 1);
        i0.ɵɵtemplate(2, OgcFilterTimeComponent_div_2_Template, 2, 4, "div", 2);
        i0.ɵɵtemplate(3, OgcFilterTimeComponent_div_3_Template, 3, 2, "div", 3);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.currentFilter.sliderOptions == null ? null : ctx.currentFilter.sliderOptions.enabled);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.sliderMode);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx.sliderMode);
    } }, styles: ["input{text-align:center!important;margin:auto 5px!important}.slider-container[_ngcontent-%COMP%]{text-align:center}.datetime-input[_ngcontent-%COMP%]{display:inline-block;width:117px;margin:10px 0 5px 10px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.datetime-input[_ngcontent-%COMP%]{width:36%;margin:0}}.date-input[_ngcontent-%COMP%]{width:100px;margin-right:25px}.time-input[_ngcontent-%COMP%]{margin-right:25px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.time-input[_ngcontent-%COMP%]{margin-right:5px}}.hour-input[_ngcontent-%COMP%], .minute-input[_ngcontent-%COMP%]{width:35px;margin-left:7px}.year-input[_ngcontent-%COMP%]{width:98px;margin:10px 18px 5px 12px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.year-input[_ngcontent-%COMP%]{width:33%;margin:0 0 0 10px}}.year-input-hide[_ngcontent-%COMP%]{width:120px;margin-right:25px;display:none}.year-input-only-year[_ngcontent-%COMP%]{width:120px;margin-right:25px}.reset-button[_ngcontent-%COMP%]{width:25px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.reset-button[_ngcontent-%COMP%]{padding-left:6px}}.toggle-filter-state[_ngcontent-%COMP%]{padding-left:15px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.toggle-filter-state[_ngcontent-%COMP%]{padding-left:7px}}  .datepicker-year   .mat-calendar-arrow{display:none}  .datepicker-year   .mat-calendar-period-button{pointer-events:none}  .datepicker-year   .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover{background-color:#0000001f;border-radius:999px}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OgcFilterTimeComponent, [{
        type: Component,
        args: [{
                selector: 'igo-ogc-filter-time',
                templateUrl: './ogc-filter-time.component.html',
                styleUrls: ['./ogc-filter-time.component.scss']
            }]
    }], function () { return [{ type: OGCFilterTimeService }]; }, { datasource: [{
            type: Input
        }], currentFilter: [{
            type: Input
        }], changeProperty: [{
            type: Output
        }], endDatepickerTime: [{
            type: ViewChild,
            args: ['endDatepickerTime']
        }], beginDatepickerTime: [{
            type: ViewChild,
            args: ['beginDatepickerTime']
        }], beginTime: [{
            type: ViewChild,
            args: ['beginTime']
        }], endTime: [{
            type: ViewChild,
            args: ['endTime']
        }] }); })();

const moment = moment_;
class OgcFilterTimeSliderComponent {
    constructor(ogcFilterTimeService) {
        this.ogcFilterTimeService = ogcFilterTimeService;
        this.changeProperty = new EventEmitter();
        this.sliderValue = 1;
        this.calculatedStep = 0;
        this._defaultDisplayFormat = 'DD/MM/YYYY HH:mm A';
        this._defaultSliderInterval = 2000;
        this.playIcon = 'play-circle';
        this.resetIcon = 'replay';
        this.sliderDisplayWith = this.sliderDisplayWith.bind(this);
    }
    get sliderInterval() {
        return this.currentFilter.sliderInterval === undefined
            ? this._defaultSliderInterval
            : this.currentFilter.sliderInterval;
    }
    get displayFormat() {
        var _a;
        if ((_a = this.currentFilter.sliderOptions) === null || _a === void 0 ? void 0 : _a.displayFormat) {
            return this.currentFilter.sliderOptions.displayFormat;
        }
        if (this.currentFilter.displayFormat) {
            return this.currentFilter.displayFormat;
        }
        return this._defaultDisplayFormat;
    }
    get beginMillisecond() {
        return this.ogcFilterTimeService.dateToNumber(this.begin);
    }
    get maxMillisecond() {
        return this.ogcFilterTimeService.dateToNumber(this.max);
    }
    get stepMillisecond() {
        return this.ogcFilterTimeService.stepMillisecond(this.datasource, this.currentFilter);
    }
    ngOnInit() {
        this.calculateStep();
        this.handleSliderInput({ value: 1 });
    }
    sliderDisplayWith(value) {
        let dateTmp = new Date(this.beginMillisecond + ((value - 1) * this.stepMillisecond));
        if (this.ogcFilterTimeService.stepIsYearDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))) {
            const toAdd = moment.duration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter)).years();
            dateTmp = moment(this.beginMillisecond).add((value - 1) * toAdd, 'year').toDate();
        }
        else if (this.ogcFilterTimeService.stepIsMonthDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))) {
            const toAdd = moment.duration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter)).months();
            dateTmp = moment(this.beginMillisecond).add((value - 1) * toAdd, 'month').toDate();
        }
        return moment(dateTmp).format(this.displayFormat);
    }
    playFilter(event) {
        if (this.interval) {
            this.stopFilter();
        }
        else {
            this.playIcon = 'pause-circle';
            this.interval = setInterval(that => {
                if (this.slider.value < this.calculatedStep) {
                    const _increment = '_increment';
                    const _emitInputEvent = '_emitInputEvent';
                    this.slider[_increment](1);
                    this.slider[_emitInputEvent]();
                }
                else {
                    this.stopFilter();
                }
            }, this.sliderInterval, this);
        }
    }
    stopFilter() {
        if (this.interval) {
            clearInterval(this.interval);
        }
        this.interval = undefined;
        this.playIcon = 'play-circle';
    }
    resetFilter(event) {
        if (this.interval) {
            clearInterval(this.interval);
        }
        this.interval = undefined;
        this.playIcon = 'play-circle';
        this.slider.value = 1;
        const _increment = '_increment';
        const _emitInputEvent = '_emitInputEvent';
        this.slider[_emitInputEvent]();
    }
    handleSliderInput(matSliderChange) {
        if (matSliderChange) {
            if (this.ogcFilterTimeService.stepIsYearDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))) {
                const toAdd = moment.duration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter)).years();
                const dateBeginTmp = moment(this.beginMillisecond).add((matSliderChange.value - 1) * toAdd, 'year').toDate();
                const dateEndTmp = moment(dateBeginTmp).add(toAdd, 'year').toDate();
                this.changeProperty.next({ value: moment(dateBeginTmp).toDate().toISOString(),
                    pos: 1, refreshFilter: false });
                this.changeProperty.next({ value: moment(dateEndTmp).toDate().toISOString(),
                    pos: 2, refreshFilter: true });
            }
            else if (this.ogcFilterTimeService.stepIsMonthDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))) {
                const toAdd = moment.duration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter)).months();
                const dateBeginTmp = moment(this.beginMillisecond).add((matSliderChange.value - 1) * toAdd, 'month').toDate();
                const dateEndTmp = moment(dateBeginTmp).add(toAdd, 'month').toDate();
                this.changeProperty.next({ value: moment(dateBeginTmp).startOf('month').toDate().toISOString(),
                    pos: 1, refreshFilter: false });
                this.changeProperty.next({ value: moment(dateEndTmp).toDate().toISOString(),
                    pos: 2, refreshFilter: true });
            }
            else if (this.ogcFilterTimeService.stepIsDayDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter)) ||
                this.ogcFilterTimeService.stepIsHourDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter)) ||
                this.ogcFilterTimeService.stepIsMinuteDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))) {
                const dateTmp = new Date(this.beginMillisecond + (this.stepMillisecond * (matSliderChange.value - 1)));
                this.changeProperty.next({ value: dateTmp.toISOString(), pos: 1, refreshFilter: false });
                this.changeProperty.next({ value: new Date(this.ogcFilterTimeService.addStep(dateTmp.toISOString(), this.stepMillisecond)).toISOString(),
                    pos: 2, refreshFilter: true });
            }
        }
    }
    calculateStep() {
        for (let i = 1; (this.maxMillisecond - (this.beginMillisecond + (i * this.stepMillisecond))) >= -1; i++) {
            this.calculatedStep = i;
        }
    }
}
OgcFilterTimeSliderComponent.ɵfac = function OgcFilterTimeSliderComponent_Factory(t) { return new (t || OgcFilterTimeSliderComponent)(i0.ɵɵdirectiveInject(OGCFilterTimeService)); };
OgcFilterTimeSliderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OgcFilterTimeSliderComponent, selectors: [["igo-ogc-filter-time-slider"]], viewQuery: function OgcFilterTimeSliderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(MatSlider, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.slider = _t.first);
    } }, inputs: { currentFilter: "currentFilter", begin: "begin", max: "max", datasource: "datasource" }, outputs: { changeProperty: "changeProperty" }, decls: 6, vars: 7, consts: [[1, "slider-container"], ["id", "time-slider", "thumbLabel", "", 3, "step", "min", "max", "ngModel", "displayWith", "ngModelChange", "input"], ["mat-icon-button", "", "color", "primary", 3, "click"], [3, "svgIcon"]], template: function OgcFilterTimeSliderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelementStart(1, "mat-slider", 1);
        i0.ɵɵlistener("ngModelChange", function OgcFilterTimeSliderComponent_Template_mat_slider_ngModelChange_1_listener($event) { return ctx.sliderValue = $event; })("input", function OgcFilterTimeSliderComponent_Template_mat_slider_input_1_listener($event) { return ctx.handleSliderInput($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(2, "button", 2);
        i0.ɵɵlistener("click", function OgcFilterTimeSliderComponent_Template_button_click_2_listener($event) { return ctx.playFilter($event); });
        i0.ɵɵelement(3, "mat-icon", 3);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(4, "button", 2);
        i0.ɵɵlistener("click", function OgcFilterTimeSliderComponent_Template_button_click_4_listener($event) { return ctx.resetFilter($event); });
        i0.ɵɵelement(5, "mat-icon", 3);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("step", 1)("min", 1)("max", ctx.calculatedStep)("ngModel", ctx.sliderValue)("displayWith", ctx.sliderDisplayWith);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("svgIcon", ctx.playIcon);
        i0.ɵɵadvance(2);
        i0.ɵɵpropertyInterpolate("svgIcon", ctx.resetIcon);
    } }, directives: [i13$1.MatSlider, i16.NgControlStatus, i16.NgModel, i2.MatButton, i4.MatIcon], styles: ["input{text-align:center!important;margin:auto 5px!important}  .mat-slider-thumb{transform:scale(0)!important}  .mat-slider-thumb-label{transform:rotate(45deg)!important;border-radius:50% 50% 0!important;background-color:#ffd740!important}  .mat-slider-thumb-label-text{opacity:1!important;transform:rotate(135deg)!important}  .mat-slider-horizontal .mat-slider-thumb-label{top:10px!important;transform:rotate(225deg)!important}  .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(225deg)!important}.datetime-container[_ngcontent-%COMP%]{text-align:center}.slider-container[_ngcontent-%COMP%]{text-align:center}.datetime-input[_ngcontent-%COMP%]{display:inline-block;margin:5px 25px}.date-input[_ngcontent-%COMP%]{width:120px;margin-right:25px}.time-input[_ngcontent-%COMP%]{display:inherit;margin-right:25px}.hour-input[_ngcontent-%COMP%], .minute-input[_ngcontent-%COMP%]{width:40px}.minute-input[_ngcontent-%COMP%]{margin-left:10px}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OgcFilterTimeSliderComponent, [{
        type: Component,
        args: [{
                selector: 'igo-ogc-filter-time-slider',
                templateUrl: './ogc-filter-time-slider.component.html',
                styleUrls: ['./ogc-filter-time-slider.component.scss']
            }]
    }], function () { return [{ type: OGCFilterTimeService }]; }, { currentFilter: [{
            type: Input
        }], begin: [{
            type: Input
        }], max: [{
            type: Input
        }], datasource: [{
            type: Input
        }], changeProperty: [{
            type: Output
        }], slider: [{
            type: ViewChild,
            args: [MatSlider]
        }] }); })();

class IgoFilterModule {
    static forRoot() {
        return {
            ngModule: IgoFilterModule,
            providers: [
                {
                    provide: MAT_DATE_LOCALE,
                    useValue: 'fr-FR'
                }
            ]
        };
    }
}
IgoFilterModule.ɵfac = function IgoFilterModule_Factory(t) { return new (t || IgoFilterModule)(); };
IgoFilterModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoFilterModule });
IgoFilterModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [TimeFilterService, OGCFilterService, OGCFilterTimeService, SpatialFilterService], imports: [[
            CommonModule,
            FormsModule,
            ReactiveFormsModule,
            MatAutocompleteModule,
            MatIconModule,
            MatButtonModule,
            MatTabsModule,
            MatRadioModule,
            MatMenuModule,
            MatTableModule,
            MatTreeModule,
            MatButtonToggleModule,
            MatCheckboxModule,
            MatSliderModule,
            MatSlideToggleModule,
            MatFormFieldModule,
            MatInputModule,
            MatOptionModule,
            MatSelectModule,
            MatListModule,
            MatTooltipModule,
            MatDatepickerModule,
            MatNativeDateModule,
            MatDatetimepickerModule,
            MatNativeDatetimeModule,
            IgoLanguageModule,
            IgoLayerModule,
            IgoCollapsibleModule,
            IgoListModule,
            IgoEntityModule,
            IgoKeyValueModule,
            IgoGeometryModule,
            MatBadgeModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoFilterModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MatAutocompleteModule,
                    MatIconModule,
                    MatButtonModule,
                    MatTabsModule,
                    MatRadioModule,
                    MatMenuModule,
                    MatTableModule,
                    MatTreeModule,
                    MatButtonToggleModule,
                    MatCheckboxModule,
                    MatSliderModule,
                    MatSlideToggleModule,
                    MatFormFieldModule,
                    MatInputModule,
                    MatOptionModule,
                    MatSelectModule,
                    MatListModule,
                    MatTooltipModule,
                    MatDatepickerModule,
                    MatNativeDateModule,
                    MatDatetimepickerModule,
                    MatNativeDatetimeModule,
                    IgoLanguageModule,
                    IgoLayerModule,
                    IgoCollapsibleModule,
                    IgoListModule,
                    IgoEntityModule,
                    IgoKeyValueModule,
                    IgoGeometryModule,
                    MatBadgeModule
                ],
                exports: [
                    FilterableDataSourcePipe,
                    TimeFilterButtonComponent,
                    TimeFilterFormComponent,
                    TimeFilterItemComponent,
                    TimeFilterListComponent,
                    TimeFilterListBindingDirective,
                    OgcFilterFormComponent,
                    OgcFilterButtonComponent,
                    OgcFilterSelectionComponent,
                    OgcFilterableFormComponent,
                    OgcFilterableItemComponent,
                    OgcFilterableListComponent,
                    OgcFilterableListBindingDirective,
                    SpatialFilterTypeComponent,
                    SpatialFilterListComponent,
                    SpatialFilterItemComponent,
                    OgcFilterTimeComponent,
                    OgcFilterTimeSliderComponent
                ],
                declarations: [
                    FilterableDataSourcePipe,
                    TimeFilterButtonComponent,
                    TimeFilterFormComponent,
                    TimeFilterItemComponent,
                    TimeFilterListComponent,
                    TimeFilterListBindingDirective,
                    OgcFilterFormComponent,
                    OgcFilterButtonComponent,
                    OgcFilterSelectionComponent,
                    OgcFilterableFormComponent,
                    OgcFilterableItemComponent,
                    OgcFilterableListComponent,
                    OgcFilterableListBindingDirective,
                    SpatialFilterTypeComponent,
                    SpatialFilterListComponent,
                    SpatialFilterItemComponent,
                    OgcFilterTimeComponent,
                    OgcFilterTimeSliderComponent
                ],
                providers: [TimeFilterService, OGCFilterService, OGCFilterTimeService, SpatialFilterService]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoFilterModule, { declarations: [FilterableDataSourcePipe,
        TimeFilterButtonComponent,
        TimeFilterFormComponent,
        TimeFilterItemComponent,
        TimeFilterListComponent,
        TimeFilterListBindingDirective,
        OgcFilterFormComponent,
        OgcFilterButtonComponent,
        OgcFilterSelectionComponent,
        OgcFilterableFormComponent,
        OgcFilterableItemComponent,
        OgcFilterableListComponent,
        OgcFilterableListBindingDirective,
        SpatialFilterTypeComponent,
        SpatialFilterListComponent,
        SpatialFilterItemComponent,
        OgcFilterTimeComponent,
        OgcFilterTimeSliderComponent], imports: [CommonModule,
        FormsModule,
        ReactiveFormsModule,
        MatAutocompleteModule,
        MatIconModule,
        MatButtonModule,
        MatTabsModule,
        MatRadioModule,
        MatMenuModule,
        MatTableModule,
        MatTreeModule,
        MatButtonToggleModule,
        MatCheckboxModule,
        MatSliderModule,
        MatSlideToggleModule,
        MatFormFieldModule,
        MatInputModule,
        MatOptionModule,
        MatSelectModule,
        MatListModule,
        MatTooltipModule,
        MatDatepickerModule,
        MatNativeDateModule,
        MatDatetimepickerModule,
        MatNativeDatetimeModule,
        IgoLanguageModule,
        IgoLayerModule,
        IgoCollapsibleModule,
        IgoListModule,
        IgoEntityModule,
        IgoKeyValueModule,
        IgoGeometryModule,
        MatBadgeModule], exports: [FilterableDataSourcePipe,
        TimeFilterButtonComponent,
        TimeFilterFormComponent,
        TimeFilterItemComponent,
        TimeFilterListComponent,
        TimeFilterListBindingDirective,
        OgcFilterFormComponent,
        OgcFilterButtonComponent,
        OgcFilterSelectionComponent,
        OgcFilterableFormComponent,
        OgcFilterableItemComponent,
        OgcFilterableListComponent,
        OgcFilterableListBindingDirective,
        SpatialFilterTypeComponent,
        SpatialFilterListComponent,
        SpatialFilterItemComponent,
        OgcFilterTimeComponent,
        OgcFilterTimeSliderComponent] }); })();
i0.ɵɵsetComponentScope(TimeFilterButtonComponent, [i1$1.NgIf, i2.MatButton, i3.MatTooltip, i4.MatIcon, i9$1.MatBadge, TimeFilterItemComponent, i6.ListItemDirective], [i7.TranslatePipe]);
i0.ɵɵsetComponentScope(TimeFilterItemComponent, [i1$1.NgIf, i1$3.MatListItem, i4.MatIcon, i1$3.MatListAvatarCssMatStyler, i6.CollapseDirective, i9.MatLine, i1$1.NgStyle, i2.MatButton, i3.MatTooltip, i1$1.NgClass, LayerLegendComponent, TimeFilterFormComponent], [i7.TranslatePipe, i1$1.AsyncPipe]);
i0.ɵɵsetComponentScope(TimeFilterListComponent, [i6.ListComponent, i1$1.NgForOf, TimeFilterItemComponent, i6.ListItemDirective], [FilterableDataSourcePipe]);
i0.ɵɵsetComponentScope(OgcFilterFormComponent, [i11.MatCheckbox, i3.MatTooltip, i12.MatFormField, i1$1.NgClass, i13.MatSelect, i9.MatOption, i1$1.NgIf, i5$1.MatInput, i6$1.MatAutocompleteTrigger, i6$1.MatAutocomplete, i1$1.NgForOf, i2.MatButton, i12.MatSuffix, i4.MatIcon, OgcFilterTimeComponent], [i7.TranslatePipe, i1$1.AsyncPipe, i6.KeyValuePipe]);
i0.ɵɵsetComponentScope(OgcFilterButtonComponent, [i1$1.NgIf, i2.MatButton, i3.MatTooltip, i4.MatIcon, i9$1.MatBadge, OgcFilterableItemComponent, i6.ListItemDirective], [i7.TranslatePipe]);
i0.ɵɵsetComponentScope(OgcFilterSelectionComponent, [i16.ɵNgNoValidate, i16.NgControlStatusGroup, i16.FormGroupDirective, i1$1.NgForOf, i1$1.NgIf, i10.MatDivider, i12.MatFormField, i13.MatSelect, i16.NgControlStatus, i16.FormControlName, i3.MatTooltip, i9.MatOption, i18.MatButtonToggleGroup, i18.MatButtonToggle, i1$1.NgStyle, i11.MatCheckbox, i19.MatRadioGroup, i19.MatRadioButton, i4.MatIcon, i16.FormControlDirective, i16.NgModel, OgcFilterTimeComponent], [i7.TranslatePipe]);
i0.ɵɵsetComponentScope(OgcFilterableFormComponent, [i1$1.NgIf, OgcFilterSelectionComponent, i6.ListItemDirective, i1$1.NgForOf, OgcFilterFormComponent], []);
i0.ɵɵsetComponentScope(OgcFilterableItemComponent, [i1$3.MatListItem, i1$1.NgIf, i4.MatIcon, i1$3.MatListAvatarCssMatStyler, i6.CollapseDirective, i9.MatLine, i1$1.NgStyle, i3.MatTooltip, i2.MatButton, i1$1.NgClass, LayerLegendComponent, OgcFilterableFormComponent, i10.MatDivider, i11.MatCheckbox, i16.NgControlStatus, i16.NgModel], [i7.TranslatePipe, i1$1.AsyncPipe]);
i0.ɵɵsetComponentScope(OgcFilterableListComponent, [i6.ListComponent, i1$1.NgForOf, OgcFilterableItemComponent, i6.ListItemDirective], [FilterableDataSourcePipe]);
i0.ɵɵsetComponentScope(SpatialFilterTypeComponent, [i20.MatTabGroup, i20.MatTab, i12.MatFormField, i12.MatLabel, i13.MatSelect, i1$1.NgForOf, i9.MatOption, SpatialFilterListComponent, i18.MatButtonToggleGroup, i18.MatButtonToggle, i3.MatTooltip, i4.MatIcon], [i7.TranslatePipe]);
i0.ɵɵsetComponentScope(SpatialFilterItemComponent, [GeometryFormFieldInputComponent, i16.NgControlStatus, i16.FormControlDirective, i1$1.NgIf, i22.MatSlideToggle, i16.ɵNgNoValidate, i16.NgControlStatusGroup, i16.NgForm, i12.MatFormField, i16.NumberValueAccessor, i5$1.MatInput, i16.DefaultValueAccessor, i13.MatSelect, i1$1.NgForOf, i9.MatOption, i12.MatLabel, i19.MatRadioGroup, i19.MatRadioButton, i23.MatTable, i23.MatColumnDef, i23.MatHeaderCellDef, i23.MatHeaderCell, i11.MatCheckbox, i23.MatHeaderRowDef, i23.MatHeaderRow, i23.MatRowDef, i23.MatRow, i24.MatTree, i24.MatTreeNodeDef, i24.MatTreeNode, i24.MatTreeNodeToggle, i2.MatButton, i24.MatNestedTreeNode, i4.MatIcon, i24.MatTreeNodeOutlet, i3.MatTooltip, i6.EntityTableComponent], [i1$1.AsyncPipe, i7.TranslatePipe]);
i0.ɵɵsetComponentScope(OgcFilterTimeComponent, [i1$1.NgIf, i22.MatSlideToggle, i16.NgControlStatus, i16.NgModel, OgcFilterTimeSliderComponent, i12.MatFormField, i12.MatLabel, i5$1.MatInput, i25.MatDatepickerToggle, i12.MatSuffix, i25.MatDatepicker, i25.MatDatepickerInput, i2.MatButton, i3.MatTooltip, i4.MatIcon, i13.MatSelect, i16.FormControlDirective, i1$1.NgForOf, i9.MatOption], [i7.TranslatePipe]);

function ExportButtonComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 1);
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 2, "igo.geo.download.action"))("color", ctx_r0.color);
} }
class ExportButtonComponent {
    constructor() {
        this._color = 'primary';
    }
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    get options() {
        if (!this.layer) {
            return;
        }
        return this.layer.dataSource.options;
    }
    layerIsExportable() {
        var _a, _b;
        if ((this.layer instanceof VectorLayer && this.layer.exportable === true) ||
            (this.layer.dataSource.options.download && this.layer.dataSource.options.download.url) ||
            (((_a = this.layer.options.workspace) === null || _a === void 0 ? void 0 : _a.enabled) &&
                ((_b = this.layer.options.workspace) === null || _b === void 0 ? void 0 : _b.workspaceId) !== this.layer.id)) {
            return true;
        }
        return false;
    }
}
ExportButtonComponent.ɵfac = function ExportButtonComponent_Factory(t) { return new (t || ExportButtonComponent)(); };
ExportButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ExportButtonComponent, selectors: [["igo-export-button"]], inputs: { layer: "layer", color: "color" }, decls: 1, vars: 1, consts: [["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", 4, "ngIf"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color"], ["svgIcon", "file-export"]], template: function ExportButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, ExportButtonComponent_button_0_Template, 3, 4, "button", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.layerIsExportable());
    } }, directives: [i1$1.NgIf, i2.MatButton, i3.MatTooltip, i4.MatIcon], pipes: [i7.TranslatePipe], styles: [""], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ExportButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-export-button',
                templateUrl: './export-button.component.html',
                styleUrls: ['./export-button.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { layer: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

class ExportError extends Error {
}
class ExportInvalidFileError extends ExportError {
    constructor() {
        super('Invalid file');
        Object.setPrototypeOf(this, ExportInvalidFileError.prototype);
    }
}
class ExportNothingToExportError extends ExportError {
    constructor() {
        super('Nothing to export');
        Object.setPrototypeOf(this, ExportNothingToExportError.prototype);
    }
}

function handleFileExportError(error, messageService, languageService) {
    if (error instanceof ExportNothingToExportError) {
        handleNothingToExportError(messageService, languageService);
        return;
    }
    const translate = languageService.translate;
    const title = translate.instant('igo.geo.export.failed.title');
    const message = translate.instant('igo.geo.export.failed.text');
    messageService.error(message, title);
}
function handleFileExportSuccess(messageService, languageService) {
    const translate = languageService.translate;
    const title = translate.instant('igo.geo.export.success.title');
    const message = translate.instant('igo.geo.export.success.text');
    messageService.success(message, title);
}
function handleNothingToExportError(messageService, languageService) {
    const translate = languageService.translate;
    const title = translate.instant('igo.geo.export.nothing.title');
    const message = translate.instant('igo.geo.export.nothing.text');
    messageService.error(message, title);
}
/**
 * Export array to CSV
 *
 * @param rows Array of arrays to export as CSV
 * @param separator Cell separator
 */
function exportToCSV(rows, fileName, separator = ';') {
    const lines = rows.map((row, index) => row.join(separator));
    const csvContent = lines.join('\n');
    downloadContent(csvContent, 'text/csv;charset=utf-8', fileName);
}
/**
 * Return an array of values from an array of entities.
 *
 * @param entities Array of entities
 * @param scolumns Columns definition of the output data
 */
function entitiesToRowData(entities, columns) {
    return entities.map((entity) => {
        return columns.map((column) => {
            let valueAccessor;
            if (column.renderer === undefined || column.renderer === EntityTableColumnRenderer.Default) {
                valueAccessor = column.valueAccessor;
            }
            valueAccessor = valueAccessor ? valueAccessor : getEntityProperty;
            return valueAccessor(entity, column.name);
        });
    });
}

const ExportFormat = strEnum(['URL', 'GeoJSON', 'GML', 'GPX', 'KML', 'Shapefile', 'CSVcomma', 'CSVsemicolon']);
const EncodingFormat = strEnum(['UTF8', 'LATIN1']);

class ExportService {
    constructor(config) {
        this.config = config;
        this.aggregateInComment = true;
        this.ogreUrl = this.config.getConfig('importExport.url');
        const gpxAggregateInComment = this.config.getConfig('importExport.gpxAggregateInComment');
        if (gpxAggregateInComment !== undefined) {
            this.aggregateInComment = gpxAggregateInComment;
        }
    }
    export(olFeatures, format, title, encoding, projectionIn = 'EPSG:4326', projectionOut = 'EPSG:4326') {
        const exportOlFeatures = this.generateFeature(olFeatures, format);
        return this.exportAsync(exportOlFeatures, format, title, encoding, projectionIn, projectionOut);
    }
    generateFeature(olFeatures, format) {
        if (format === ExportFormat.GPX && this.aggregateInComment) {
            return this.generateAggregatedFeature(olFeatures);
        }
        return olFeatures.map((olFeature) => {
            const keys = olFeature
                .getKeys()
                .filter((key) => !key.startsWith('_'));
            const properties = keys.reduce((acc, key) => {
                acc[key] = olFeature.get(key);
                return acc;
            }, { geometry: olFeature.getGeometry() });
            return new OlFeature(properties);
        });
    }
    generateAggregatedFeature(olFeatures) {
        return olFeatures.map((olFeature) => {
            const keys = olFeature.getKeys().filter((key) => !key.startsWith('_'));
            let comment = '';
            const properties = keys.reduce((acc, key) => {
                if (key && key !== 'geometry') {
                    key === 'id' && olFeature.get('draw') ? comment += key + ':' + olFeature.get('draw') + '   \r\n'
                        : comment += key + ':' + olFeature.get(key) + '   \r\n';
                }
                acc[key] = olFeature.get(key);
                return acc;
            }, {
                geometry: olFeature.getGeometry()
            });
            const newFeature = new OlFeature(properties);
            newFeature.set('name', olFeature.getId());
            newFeature.set('cmt', comment);
            return newFeature;
        });
    }
    exportAsync(olFeatures, format, title, encoding, projectionIn, projectionOut) {
        const doExport = (observer) => {
            const nothingToExport = this.nothingToExport(olFeatures, format);
            if (nothingToExport) {
                observer.error(new ExportNothingToExportError());
                return;
            }
            const ogreFormats = Object.keys(ExportService.ogreFormats);
            if (ogreFormats.indexOf(format) >= 0) {
                if (!this.ogreUrl) {
                    if (ExportService.noOgreFallbacks.indexOf(format) >= 0) {
                        this.exportToFile(olFeatures, observer, format, title, projectionIn, projectionOut);
                    }
                    else {
                        observer.error(new ExportInvalidFileError());
                    }
                    return;
                }
                this.exportWithOgre(olFeatures, observer, format, title, encoding, projectionIn, projectionOut);
            }
            else {
                this.exportToFile(olFeatures, observer, format, title, projectionIn, projectionOut);
            }
        };
        return new Observable(doExport);
    }
    exportToFile(olFeatures, observer, format, title, projectionIn, projectionOut) {
        const olFormat = new olformat[format]();
        const featuresText = olFormat.writeFeatures(olFeatures, {
            dataProjection: projectionOut,
            featureProjection: projectionIn,
            featureType: 'feature',
            featureNS: 'http://example.com/feature'
        });
        const fileName = `${title}.${format.toLowerCase()}`;
        downloadContent(featuresText, 'text/plain;charset=utf-8', fileName);
        observer.complete();
    }
    exportWithOgre(olFeatures, observer, format, title, encodingType, projectionIn, projectionOut) {
        const featuresText = new olformat.GeoJSON().writeFeatures(olFeatures, {
            dataProjection: projectionOut,
            featureProjection: projectionIn
        });
        const url = `${this.ogreUrl}/convertJson`;
        const form = document.createElement('form');
        form.style.display = 'none';
        document.body.appendChild(form);
        form.setAttribute('method', 'post');
        form.setAttribute('target', '_blank');
        form.setAttribute('action', url);
        if (encodingType === EncodingFormat.UTF8) {
            form.acceptCharset = 'UTF-8';
            form.enctype = 'application/x-www-form-urlencoded; charset=utf-8;';
        }
        else if (encodingType === EncodingFormat.LATIN1) {
            const enctype = 'ISO-8859-1';
            const encoding = document.createElement('input');
            encoding.setAttribute('type', 'hidden');
            encoding.setAttribute('name', 'encoding');
            encoding.setAttribute('value', enctype);
            form.appendChild(encoding);
        }
        if (format === 'CSVsemicolon') {
            const options = document.createElement('input');
            options.setAttribute('type', 'hidden');
            options.setAttribute('name', 'lco');
            options.setAttribute('value', 'SEPARATOR=SEMICOLON');
            form.appendChild(options);
        }
        const geojsonField = document.createElement('input');
        geojsonField.setAttribute('type', 'hidden');
        geojsonField.setAttribute('name', 'json');
        geojsonField.setAttribute('value', featuresText);
        form.appendChild(geojsonField);
        const outputNameField = document.createElement('input');
        let outputName = format === 'Shapefile' ? `${title}.zip` : `${title}.${format.toLowerCase()}`;
        if (format === 'CSVcomma' || format === 'CSVsemicolon') {
            outputName = `${title}.csv`;
        }
        outputName = outputName.replace(' ', '_');
        outputName = outputName.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        outputNameField.setAttribute('type', 'hidden');
        outputNameField.setAttribute('name', 'outputName');
        outputNameField.setAttribute('value', outputName);
        form.appendChild(outputNameField);
        let ogreFormat = ExportService.ogreFormats[format];
        if (format === 'CSVcomma' || format === 'CSVsemicolon') {
            ogreFormat = 'CSV';
        }
        const outputFormatField = document.createElement('input');
        outputFormatField.setAttribute('type', 'hidden');
        outputFormatField.setAttribute('name', 'format');
        outputFormatField.setAttribute('value', ogreFormat);
        form.appendChild(outputFormatField);
        form.submit();
        document.body.removeChild(form);
        observer.complete();
    }
    nothingToExport(olFeatures, format) {
        if (olFeatures.length === 0) {
            return true;
        }
        if (format === 'GPX') {
            const pointOrLine = olFeatures.find(olFeature => {
                return (['Point', 'LineString', 'MultiLineString'].indexOf(olFeature.getGeometry().getType()) >= 0);
            });
            return pointOrLine === undefined;
        }
        return false;
    }
}
ExportService.ogreFormats = {
    GML: 'gml',
    GPX: 'gpx',
    KML: 'kml',
    Shapefile: 'ESRI Shapefile',
    CSVcomma: 'CSVcomma',
    CSVsemicolon: 'CSVsemicolon'
};
ExportService.noOgreFallbacks = ['GML', 'GPX', 'KML'];
ExportService.ɵfac = function ExportService_Factory(t) { return new (t || ExportService)(i0.ɵɵinject(i2$1.ConfigService)); };
ExportService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ExportService, factory: ExportService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ExportService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i2$1.ConfigService }]; }, null); })();

function addLayerAndFeaturesToMap(features, map, layerTitle) {
    const olFeatures = features.map((feature) => featureToOl(feature, map.projection));
    const r = Math.floor(Math.random() * 255);
    const g = Math.floor(Math.random() * 255);
    const b = Math.floor(Math.random() * 255);
    const stroke = new olstyle.Stroke({
        color: [r, g, b, 1],
        width: 2
    });
    const fill = new olstyle.Fill({
        color: [r, g, b, 0.4]
    });
    const sourceOptions = {
        type: 'vector',
        queryable: true
    };
    const source = new FeatureDataSource(sourceOptions);
    source.ol.addFeatures(olFeatures);
    const layer = new VectorLayer({
        title: layerTitle,
        source,
        style: new olstyle.Style({
            stroke,
            fill,
            image: new olstyle.Circle({
                radius: 5,
                stroke,
                fill
            })
        })
    });
    map.addLayer(layer);
    moveToOlFeatures(map, olFeatures);
    return layer;
}
function addLayerAndFeaturesStyledToMap(features, map, layerTitle, styleListService, styleService) {
    const olFeatures = features.map((feature) => featureToOl(feature, map.projection));
    let style;
    let distance;
    if (styleListService.getStyleList(layerTitle.toString() + '.styleByAttribute')) {
        const styleByAttribute = styleListService.getStyleList(layerTitle.toString() + '.styleByAttribute');
        style = feature => {
            return styleService.createStyleByAttribute(feature, styleByAttribute);
        };
    }
    else if (styleListService.getStyleList(layerTitle.toString() + '.clusterStyle')) {
        const clusterParam = styleListService.getStyleList(layerTitle.toString() + '.clusterParam');
        distance = styleListService.getStyleList(layerTitle.toString() + '.distance');
        const baseStyle = styleService.createStyle(styleListService.getStyleList(layerTitle.toString() + '.clusterStyle'));
        style = feature => {
            return styleService.createClusterStyle(feature, clusterParam, baseStyle);
        };
    }
    else if (styleListService.getStyleList(layerTitle.toString() + '.style')) {
        style = styleService.createStyle(styleListService.getStyleList(layerTitle.toString() + '.style'));
    }
    else if (styleListService.getStyleList('default.clusterStyle') &&
        features[0].geometry.type === 'Point') {
        const clusterParam = styleListService.getStyleList('default.clusterParam');
        distance = styleListService.getStyleList('default.distance');
        const baseStyle = styleService.createStyle(styleListService.getStyleList('default.clusterStyle'));
        style = feature => {
            return styleService.createClusterStyle(feature, clusterParam, baseStyle);
        };
    }
    else {
        style = styleService.createStyle(styleListService.getStyleList('default.style'));
    }
    let source;
    if (styleListService.getStyleList(layerTitle.toString() + '.clusterStyle')) {
        const sourceOptions = {
            distance,
            type: 'cluster',
            queryable: true
        };
        source = new ClusterDataSource(sourceOptions);
        source.ol.source.addFeatures(olFeatures);
    }
    else if (styleListService.getStyleList(layerTitle.toString())) {
        const sourceOptions = {
            type: 'vector',
            queryable: true
        };
        source = new FeatureDataSource(sourceOptions);
        source.ol.addFeatures(olFeatures);
    }
    else if (styleListService.getStyleList('default.clusterStyle') &&
        features[0].geometry.type === 'Point') {
        const sourceOptions = {
            distance,
            type: 'cluster',
            queryable: true
        };
        source = new ClusterDataSource(sourceOptions);
        source.ol.source.addFeatures(olFeatures);
    }
    else {
        const sourceOptions = {
            type: 'vector',
            queryable: true
        };
        source = new FeatureDataSource(sourceOptions);
        source.ol.addFeatures(olFeatures);
    }
    const layer = new VectorLayer({
        title: layerTitle,
        source,
        style
    });
    map.addLayer(layer);
    moveToOlFeatures(map, olFeatures);
    return layer;
}
function handleFileImportSuccess(file, features, map, messageService, languageService, styleListService, styleService) {
    if (features.length === 0) {
        handleNothingToImportError(file, messageService, languageService);
        return;
    }
    const layerTitle = computeLayerTitleFromFile(file);
    if (!styleListService) {
        addLayerAndFeaturesToMap(features, map, layerTitle);
    }
    else {
        addLayerAndFeaturesStyledToMap(features, map, layerTitle, styleListService, styleService);
    }
    const translate = languageService.translate;
    const messageTitle = translate.instant('igo.geo.dropGeoFile.success.title');
    const message = translate.instant('igo.geo.dropGeoFile.success.text', {
        value: layerTitle
    });
    messageService.success(message, messageTitle);
}
function handleFileImportError(file, error, messageService, languageService, sizeMb) {
    sizeMb = sizeMb ? sizeMb : 30;
    const errMapping = {
        'Invalid file': handleInvalidFileImportError,
        'File is too large': handleSizeFileImportError,
        'Failed to read file': handleUnreadbleFileImportError,
        'Invalid SRS definition': handleSRSImportError,
        'Error 500 with OGRE': handleOgreServerImportError
    };
    errMapping[error.message](file, error, messageService, languageService, sizeMb);
}
function handleInvalidFileImportError(file, error, messageService, languageService) {
    const translate = languageService.translate;
    const title = translate.instant('igo.geo.dropGeoFile.invalid.title');
    const message = translate.instant('igo.geo.dropGeoFile.invalid.text', {
        value: file.name,
        mimeType: file.type
    });
    messageService.error(message, title);
}
function handleUnreadbleFileImportError(file, error, messageService, languageService) {
    const translate = languageService.translate;
    const title = translate.instant('igo.geo.dropGeoFile.unreadable.title');
    const message = translate.instant('igo.geo.dropGeoFile.unreadable.text', {
        value: file.name
    });
    messageService.error(message, title);
}
function handleSizeFileImportError(file, error, messageService, languageService, sizeMb) {
    const translate = languageService.translate;
    const title = translate.instant('igo.geo.dropGeoFile.tooLarge.title');
    const message = translate.instant('igo.geo.dropGeoFile.tooLarge.text', {
        value: file.name,
        size: sizeMb
    });
    messageService.error(message, title);
}
function handleNothingToImportError(file, messageService, languageService) {
    const translate = languageService.translate;
    const title = translate.instant('igo.geo.dropGeoFile.empty.title');
    const message = translate.instant('igo.geo.dropGeoFile.empty.text', {
        value: file.name,
        mimeType: file.type
    });
    messageService.error(message, title);
}
function handleSRSImportError(file, messageService, languageService) {
    const translate = languageService.translate;
    const title = translate.instant('igo.geo.dropGeoFile.invalidSRS.title');
    const message = translate.instant('igo.geo.dropGeoFile.invalidSRS.text', {
        value: file.name,
        mimeType: file.type
    });
    messageService.error(message, title);
}
function handleOgreServerImportError(file, error, messageService, languageService) {
    const title = languageService.translate.instant('igo.geo.dropGeoFile.ogreServer.title');
    const message = languageService.translate.instant('igo.geo.dropGeoFile.ogreServer.text');
    messageService.error(message, title);
}
function getFileExtension(file) {
    return file.name
        .split('.')
        .pop()
        .toLowerCase();
}
function computeLayerTitleFromFile(file) {
    return file.name.substr(0, file.name.lastIndexOf('.'));
}

class ImportError extends Error {
}
class ImportInvalidFileError extends ImportError {
    constructor() {
        super('Invalid file');
        Object.setPrototypeOf(this, ImportInvalidFileError.prototype);
    }
}
class ImportUnreadableFileError extends ImportError {
    constructor() {
        super('Failed to read file');
        Object.setPrototypeOf(this, ImportUnreadableFileError.prototype);
    }
}
class ImportNothingToImportError extends ImportError {
    constructor() {
        super('Nothing to import');
        Object.setPrototypeOf(this, ImportNothingToImportError.prototype);
    }
}
class ImportSizeError extends ImportError {
    constructor() {
        super('File is too large');
        Object.setPrototypeOf(this, ImportNothingToImportError.prototype);
    }
}
class ImportSRSError extends ImportError {
    constructor() {
        super('Invalid SRS definition');
        Object.setPrototypeOf(this, ImportNothingToImportError.prototype);
    }
}
class ImportOgreServerError extends ImportError {
    constructor() {
        super('Error 500 with OGRE');
        Object.setPrototypeOf(this, ImportOgreServerError.prototype);
    }
}

class ImportService {
    constructor(http, config) {
        this.http = http;
        this.config = config;
        this.ogreUrl = this.config.getConfig('importExport.url');
        const configFileSizeMb = this.config.getConfig('importExport.clientSideFileSizeMaxMb');
        this.clientSideFileSizeMax = (configFileSizeMb ? configFileSizeMb : 30) * Math.pow(1024, 2);
    }
    import(file, projectionIn = 'EPSG:4326', projectionOut = 'EPSG:4326') {
        return this.importAsync(file, projectionIn, projectionOut);
    }
    getFileImporter(file) {
        const extension = getFileExtension(file);
        const mimeType = file.type;
        const allowedMimeTypes = [
            ...ImportService.allowedMimeTypes,
            ...ImportService.allowedZipMimeTypes
        ];
        const allowedExtensions = ImportService.allowedExtensions;
        if (allowedMimeTypes.indexOf(mimeType) < 0 &&
            allowedExtensions.indexOf(extension) < 0) {
            return undefined;
        }
        else if (mimeType === 'application/json' ||
            ['json', 'geojson', 'kml', 'gpx'].indexOf(extension) >= 0) {
            return this.importFile;
        }
        else if (this.ogreUrl !== undefined) {
            return this.importFileWithOgre;
        }
        return undefined;
    }
    importAsync(file, projectionIn, projectionOut) {
        const doImport = (observer) => {
            if (file.size >= this.clientSideFileSizeMax) {
                observer.error(new ImportSizeError());
                return;
            }
            const importer = this.getFileImporter(file);
            if (importer === undefined) {
                observer.error(new ImportInvalidFileError());
                return;
            }
            importer.call(this, file, observer, projectionIn, projectionOut);
        };
        return new Observable(doImport);
    }
    importFile(file, observer, projectionIn, projectionOut) {
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const features = this.parseFeaturesFromFile(file, event.target.result, projectionIn, projectionOut);
                observer.next(features);
            }
            catch (e) {
                observer.error(new ImportUnreadableFileError());
            }
            observer.complete();
        };
        reader.onerror = evt => {
            observer.error(new ImportUnreadableFileError());
        };
        reader.readAsText(file, 'UTF-8');
    }
    importFileWithOgre(file, observer, projectionIn, projectionOut) {
        const url = `${this.ogreUrl}/convert`;
        const formData = new FormData();
        formData.append('upload', file);
        formData.append('sourceSrs', projectionIn);
        formData.append('targetSrs', projectionOut);
        formData.append('formatOutput', 'GEOJSON');
        formData.append('skipFailures', '');
        this.http.post(url, formData, { headers: new HttpHeaders() })
            .subscribe((response) => {
            if (response === null) {
                observer.error(new ImportUnreadableFileError());
                return;
            }
            const errors = response.errors || [];
            if (errors.length > 0) {
                observer.error(new ImportUnreadableFileError());
            }
            else {
                const features = this.parseFeaturesFromGeoJSON(file, response, projectionOut);
                observer.next(features);
                observer.complete();
            }
        }, (error) => {
            error.error.caught = true;
            const errMsg = error.error.msg || '';
            if (errMsg === 'No valid files found') {
                observer.error(new ImportInvalidFileError());
            }
            else if (errMsg && errMsg.startWith('ERROR 1: Failed to process SRS definition')) {
                observer.error(new ImportSRSError());
            }
            else if (error.status === 500) {
                observer.error(new ImportOgreServerError());
            }
            else {
                observer.error(new ImportUnreadableFileError());
            }
        });
    }
    parseFeaturesFromFile(file, data, projectionIn, projectionOut) {
        const extension = getFileExtension(file);
        const mimeType = file.type;
        const GeoJSON = new olformat.GeoJSON();
        let format;
        if (mimeType === 'application/vnd.google-earth.kml+xml') {
            format = new olformat.KML();
        }
        else if (mimeType === 'application/gml+xml') {
            format = new olformat.GML();
        }
        else if (mimeType === 'application/gpx+xml') {
            format = new olformat.GPX();
        }
        else {
            switch (extension) {
                case 'kml':
                    format = new olformat.KML();
                    break;
                case 'gpx':
                    format = new olformat.GPX();
                    break;
                case 'gml':
                    format = new olformat.GML();
                    break;
                default:
                    format = GeoJSON;
                    break;
            }
        }
        const olFeatures = format.readFeatures(data, {
            dataProjection: projectionIn,
            featureProjection: projectionOut
        });
        const features = olFeatures.map((olFeature) => {
            return Object.assign(GeoJSON.writeFeatureObject(olFeature), {
                projection: projectionOut,
                meta: {
                    id: uuid(),
                    title: computeLayerTitleFromFile(file)
                }
            });
        });
        return features;
    }
    parseFeaturesFromGeoJSON(file, data, projectionOut) {
        const olFormat = new olformat.GeoJSON();
        const olFeatures = olFormat.readFeatures(data);
        const features = olFeatures.map((olFeature) => {
            return Object.assign(olFormat.writeFeatureObject(olFeature), {
                projection: projectionOut,
                meta: {
                    id: uuid(),
                    title: computeLayerTitleFromFile(file)
                }
            });
        });
        return features;
    }
}
ImportService.allowedMimeTypes = [
    'application/gml+xml',
    'application/vnd.google-earth.kml+xml',
    'application/gpx+xml',
    'application/json'
];
ImportService.allowedZipMimeTypes = [
    'application/zip',
    'application/x-zip-compressed',
    'application/x-zip'
];
ImportService.allowedExtensions = ['geojson', 'kml', 'gpx', 'json', 'gml'];
ImportService.ɵfac = function ImportService_Factory(t) { return new (t || ImportService)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.ConfigService)); };
ImportService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ImportService, factory: ImportService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ImportService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.ConfigService }]; }, null); })();

class StyleListService {
    constructor(injector) {
        this.injector = injector;
        this.styleList = {};
    }
    /**
     * Use to get the data found in styleList file
     */
    getStyleList(key) {
        return ObjectUtils.resolve(this.styleList, key);
    }
    /**
     * This method loads "[path]" to get all styleList's variables
     */
    load(options) {
        const baseStyleList = options.default || {};
        if (!options.path) {
            this.styleList = baseStyleList;
            return true;
        }
        const http = this.injector.get(HttpClient);
        return new Promise((resolve, _reject) => {
            http
                .get(options.path)
                .pipe(catchError((error) => {
                console.log(`StyleList file ${options.path} could not be read`);
                resolve(true);
                return throwError(error.error || 'Server error');
            }))
                .subscribe((styleListResponse) => {
                this.styleList = ObjectUtils.mergeDeep(baseStyleList, styleListResponse);
                resolve(true);
            });
        });
    }
}
StyleListService.ɵfac = function StyleListService_Factory(t) { return new (t || StyleListService)(i0.ɵɵinject(i0.Injector)); };
StyleListService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: StyleListService, factory: StyleListService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(StyleListService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i0.Injector }]; }, null); })();

function ImportExportComponent_form_8_mat_option_7_p_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 16);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const projection_r6 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(2, 1, "igo.geo.importExportForm.projections." + projection_r6.translateKey, projection_r6));
} }
function ImportExportComponent_form_8_mat_option_7_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 16);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const projection_r6 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(projection_r6.alias);
} }
function ImportExportComponent_form_8_mat_option_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 14);
    i0.ɵɵlistener("click", function ImportExportComponent_form_8_mat_option_7_Template_mat_option_click_0_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵtemplate(1, ImportExportComponent_form_8_mat_option_7_p_1_Template, 3, 4, "p", 15);
    i0.ɵɵtemplate(2, ImportExportComponent_form_8_mat_option_7_p_2_Template, 2, 1, "p", 15);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const projection_r6 = ctx.$implicit;
    i0.ɵɵproperty("value", projection_r6);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", projection_r6.translateKey);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !projection_r6.translateKey);
} }
function ImportExportComponent_form_8_Template(rf, ctx) { if (rf & 1) {
    const _r13 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "form", 5);
    i0.ɵɵelementStart(1, "div", 6);
    i0.ɵɵelementStart(2, "mat-form-field");
    i0.ɵɵelementStart(3, "mat-label");
    i0.ɵɵtext(4);
    i0.ɵɵpipe(5, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(6, "mat-select", 7);
    i0.ɵɵlistener("valueChange", function ImportExportComponent_form_8_Template_mat_select_valueChange_6_listener($event) { i0.ɵɵrestoreView(_r13); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.inputProj = $event; });
    i0.ɵɵtemplate(7, ImportExportComponent_form_8_mat_option_7_Template, 3, 3, "mat-option", 8);
    i0.ɵɵpipe(8, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(9, "div", 9);
    i0.ɵɵpipe(10, "translate");
    i0.ɵɵpipe(11, "translate");
    i0.ɵɵelementStart(12, "button", 10);
    i0.ɵɵlistener("click", function ImportExportComponent_form_8_Template_button_click_12_listener() { i0.ɵɵrestoreView(_r13); const _r5 = i0.ɵɵreference(19); return _r5.click(); });
    i0.ɵɵpipe(13, "async");
    i0.ɵɵtext(14);
    i0.ɵɵpipe(15, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelement(16, "igo-spinner", 11);
    i0.ɵɵpipe(17, "async");
    i0.ɵɵelementStart(18, "input", 12, 13);
    i0.ɵɵlistener("click", function ImportExportComponent_form_8_Template_input_click_18_listener() { i0.ɵɵrestoreView(_r13); const _r5 = i0.ɵɵreference(19); return _r5.value = null; })("change", function ImportExportComponent_form_8_Template_input_change_18_listener($event) { i0.ɵɵrestoreView(_r13); const ctx_r16 = i0.ɵɵnextContext(); return ctx_r16.importFiles($event.target.files); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("formGroup", ctx_r0.importForm);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(5, 10, "igo.geo.importExportForm.importProjPlaceholder"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("value", ctx_r0.inputProj);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(8, 12, ctx_r0.projections$));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTooltip", ctx_r0.importForm.invalid ? i0.ɵɵpipeBind1(10, 14, "igo.geo.importExportForm.projections.choose") : i0.ɵɵpipeBind1(11, 16, "igo.geo.importExportForm.importButton"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("disabled", ctx_r0.importForm.invalid || i0.ɵɵpipeBind1(13, 18, ctx_r0.loading$));
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(15, 20, "igo.geo.importExportForm.importButton"), " ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("shown", i0.ɵɵpipeBind1(17, 22, ctx_r0.loading$));
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("display", "none");
} }
const _c0$4 = function (a0) { return { size: a0 }; };
function ImportExportComponent_section_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "section", 17);
    i0.ɵɵelementStart(1, "h4");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "ul");
    i0.ɵɵelementStart(5, "li");
    i0.ɵɵtext(6);
    i0.ɵɵpipe(7, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(8, "li");
    i0.ɵɵtext(9);
    i0.ɵɵpipe(10, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(11, "li");
    i0.ɵɵtext(12);
    i0.ɵɵpipe(13, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 4, "igo.geo.importExportForm.importClarifications"));
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(7, 6, "igo.geo.importExportForm.importSizeMax", i0.ɵɵpureFunction1(13, _c0$4, ctx_r1.fileSizeMb)));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(10, 9, "igo.geo.importExportForm.importFormatAuthorized"));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(13, 11, "igo.geo.importExportForm.importShpZip"));
} }
function ImportExportComponent_section_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "section", 17);
    i0.ɵɵelementStart(1, "h4");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 1, "igo.geo.importExportForm.exportNoLayersExportable"));
} }
function ImportExportComponent_form_12_span_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 29);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r17 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate2(" (+", ctx_r17.layers.length - 1, " ", i0.ɵɵpipeBind1(2, 2, (ctx_r17.layers == null ? null : ctx_r17.layers.length) === 2 ? "igo.geo.importExportForm.other" : "igo.geo.importExportForm.others"), ") ");
} }
function ImportExportComponent_form_12_mat_option_10_mat_slide_toggle_4_Template(rf, ctx) { if (rf & 1) {
    const _r30 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-slide-toggle", 32);
    i0.ɵɵlistener("click", function ImportExportComponent_form_12_mat_option_10_mat_slide_toggle_4_Template_mat_slide_toggle_click_0_listener($event) { i0.ɵɵrestoreView(_r30); const layer_r26 = i0.ɵɵnextContext().$implicit; const ctx_r28 = i0.ɵɵnextContext(2); return ctx_r28.onlySelectedClick($event, layer_r26.id); })("checked", function ImportExportComponent_form_12_mat_option_10_mat_slide_toggle_4_Template_mat_slide_toggle_checked_0_listener() { i0.ɵɵrestoreView(_r30); const layer_r26 = i0.ɵɵnextContext().$implicit; const ctx_r31 = i0.ɵɵnextContext(2); return ctx_r31.inLayersIdToExportSelectionOnly(layer_r26); })("change", function ImportExportComponent_form_12_mat_option_10_mat_slide_toggle_4_Template_mat_slide_toggle_change_0_listener($event) { i0.ɵɵrestoreView(_r30); const layer_r26 = i0.ɵɵnextContext().$implicit; const ctx_r33 = i0.ɵɵnextContext(2); return ctx_r33.onlySelected($event, layer_r26.id); });
    i0.ɵɵelementStart(1, "small");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("labelPosition", "after");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 2, "igo.geo.importExportForm.exportSelectedFeature"));
} }
const _c1$3 = function (a0) { return { "igo-export-layer-mat-option": a0 }; };
function ImportExportComponent_form_12_mat_option_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 30);
    i0.ɵɵlistener("click", function ImportExportComponent_form_12_mat_option_10_Template_mat_option_click_0_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵelementStart(1, "p", 16);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "p", 16);
    i0.ɵɵtemplate(4, ImportExportComponent_form_12_mat_option_10_mat_slide_toggle_4_Template, 4, 4, "mat-slide-toggle", 31);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const layer_r26 = ctx.$implicit;
    const ctx_r18 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(4, _c1$3, ctx_r18.layerHasSelectedFeatures(layer_r26)))("value", layer_r26.id);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(layer_r26.title);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r18.layerHasSelectedFeatures(layer_r26));
} }
function ImportExportComponent_form_12_ng_container_18_mat_option_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 2);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const format_r37 = ctx.$implicit;
    i0.ɵɵproperty("value", format_r37.key);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.export.format." + format_r37.value), " ");
} }
function ImportExportComponent_form_12_ng_container_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, ImportExportComponent_form_12_ng_container_18_mat_option_1_Template, 3, 4, "mat-option", 33);
    i0.ɵɵpipe(2, "keyvalue");
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r19 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(2, 1, i0.ɵɵpipeBind1(3, 3, ctx_r19.formats$)));
} }
function ImportExportComponent_form_12_mat_option_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 34);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 1, "igo.geo.export.noFormat.title"), " ");
} }
function ImportExportComponent_form_12_div_22_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 6);
    i0.ɵɵelementStart(1, "mat-form-field");
    i0.ɵɵelement(2, "input", 35);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(3, 1, "igo.geo.importExportForm.exportFileNamePlaceholder"));
} }
function ImportExportComponent_form_12_div_23_ng_container_6_mat_option_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 2);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const encoding_r40 = ctx.$implicit;
    i0.ɵɵproperty("value", encoding_r40.key);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.export.encoding." + encoding_r40.value), " ");
} }
function ImportExportComponent_form_12_div_23_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, ImportExportComponent_form_12_div_23_ng_container_6_mat_option_1_Template, 3, 4, "mat-option", 33);
    i0.ɵɵpipe(2, "keyvalue");
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r38 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(2, 1, i0.ɵɵpipeBind1(3, 3, ctx_r38.encodings$)));
} }
function ImportExportComponent_form_12_div_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 6);
    i0.ɵɵelementStart(1, "mat-form-field");
    i0.ɵɵelementStart(2, "mat-label");
    i0.ɵɵtext(3);
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(5, "mat-select", 36);
    i0.ɵɵtemplate(6, ImportExportComponent_form_12_div_23_ng_container_6_Template, 4, 5, "ng-container", 22);
    i0.ɵɵpipe(7, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r22 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(4, 2, "igo.geo.importExportForm.encodingPlaceholder"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(7, 4, ctx_r22.encodings$).length !== 0);
} }
function ImportExportComponent_form_12_div_24_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 37);
    i0.ɵɵelementStart(1, "mat-slide-toggle", 38);
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("labelPosition", "before");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(3, 2, "igo.geo.importExportForm.exportCombineResults"), " ");
} }
function ImportExportComponent_form_12_div_25_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 39);
    i0.ɵɵelementStart(1, "mat-slide-toggle", 40);
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("labelPosition", "before");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(3, 2, "igo.geo.importExportForm.exportSeparator"), " ");
} }
function ImportExportComponent_form_12_div_26_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 41);
    i0.ɵɵelementStart(1, "mat-slide-toggle", 42);
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("labelPosition", "before");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(3, 2, "igo.geo.importExportForm.exportFeatureInExtent"), " ");
} }
function ImportExportComponent_form_12_Template(rf, ctx) { if (rf & 1) {
    const _r42 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "form", 5);
    i0.ɵɵelementStart(1, "div", 6);
    i0.ɵɵelementStart(2, "mat-form-field");
    i0.ɵɵelementStart(3, "mat-label");
    i0.ɵɵtext(4);
    i0.ɵɵpipe(5, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(6, "mat-select", 18);
    i0.ɵɵlistener("valueChange", function ImportExportComponent_form_12_Template_mat_select_valueChange_6_listener($event) { i0.ɵɵrestoreView(_r42); const ctx_r41 = i0.ɵɵnextContext(); return ctx_r41.layers = $event; });
    i0.ɵɵelementStart(7, "mat-select-trigger");
    i0.ɵɵtext(8);
    i0.ɵɵtemplate(9, ImportExportComponent_form_12_span_9_Template, 3, 4, "span", 19);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(10, ImportExportComponent_form_12_mat_option_10_Template, 5, 6, "mat-option", 20);
    i0.ɵɵpipe(11, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(12, "div", 6);
    i0.ɵɵelementStart(13, "mat-form-field");
    i0.ɵɵelementStart(14, "mat-label");
    i0.ɵɵtext(15);
    i0.ɵɵpipe(16, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(17, "mat-select", 21);
    i0.ɵɵtemplate(18, ImportExportComponent_form_12_ng_container_18_Template, 4, 5, "ng-container", 22);
    i0.ɵɵpipe(19, "async");
    i0.ɵɵtemplate(20, ImportExportComponent_form_12_mat_option_20_Template, 3, 3, "mat-option", 23);
    i0.ɵɵpipe(21, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(22, ImportExportComponent_form_12_div_22_Template, 4, 3, "div", 24);
    i0.ɵɵtemplate(23, ImportExportComponent_form_12_div_23_Template, 8, 6, "div", 24);
    i0.ɵɵtemplate(24, ImportExportComponent_form_12_div_24_Template, 4, 4, "div", 25);
    i0.ɵɵtemplate(25, ImportExportComponent_form_12_div_25_Template, 4, 4, "div", 26);
    i0.ɵɵtemplate(26, ImportExportComponent_form_12_div_26_Template, 4, 4, "div", 27);
    i0.ɵɵelementStart(27, "div", 28);
    i0.ɵɵelementStart(28, "button", 10);
    i0.ɵɵlistener("click", function ImportExportComponent_form_12_Template_button_click_28_listener() { i0.ɵɵrestoreView(_r42); const ctx_r43 = i0.ɵɵnextContext(); return ctx_r43.handleExportFormSubmit(ctx_r43.form.value); });
    i0.ɵɵpipe(29, "async");
    i0.ɵɵtext(30);
    i0.ɵɵpipe(31, "translate");
    i0.ɵɵpipe(32, "translate");
    i0.ɵɵpipe(33, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelement(34, "igo-spinner", 11);
    i0.ɵɵpipe(35, "async");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("formGroup", ctx_r3.form);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(5, 17, "igo.geo.importExportForm.exportLayerPlaceholder"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("value", ctx_r3.layers);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", ctx_r3.layers.length ? ctx_r3.getLayerTitleById(ctx_r3.layers[0]) : "", " ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r3.layers.length > 1);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(11, 19, ctx_r3.exportableLayers$));
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(16, 21, "igo.geo.importExportForm.exportFormatPlaceholder"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(19, 23, ctx_r3.formats$).length !== 0);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(21, 25, ctx_r3.formats$).length === 0);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.forceNaming && ctx_r3.form.value.format !== "URL");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r3.form.value.format === "CSVcomma" || ctx_r3.form.value.format === "CSVsemicolon");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r3.layers.length > 1 && (ctx_r3.form.value.format === "CSVcomma" || ctx_r3.form.value.format === "CSVsemicolon"));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r3.layers.length > 1 && (ctx_r3.form.value.format === "CSVcomma" || ctx_r3.form.value.format === "CSVsemicolon") && ctx_r3.form.value.combineLayers);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r3.form.value.format !== "URL");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("disabled", !ctx_r3.form.valid || i0.ɵɵpipeBind1(29, 27, ctx_r3.loading$));
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", ctx_r3.form.value.format !== "URL" ? i0.ɵɵpipeBind1(31, 29, "igo.geo.importExportForm.exportButton") : ctx_r3.form.value.layers.length > 1 ? i0.ɵɵpipeBind1(32, 31, "igo.geo.importExportForm.exportButtonLinks") : i0.ɵɵpipeBind1(33, 33, "igo.geo.importExportForm.exportButtonLink"), " ");
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("shown", i0.ɵɵpipeBind1(35, 35, ctx_r3.loading$));
} }
class ImportExportComponent {
    constructor(importService, exportService, languageService, messageService, styleListService, styleService, formBuilder, config, cdRef, storageService, downloadService) {
        this.importService = importService;
        this.exportService = exportService;
        this.languageService = languageService;
        this.messageService = messageService;
        this.styleListService = styleListService;
        this.styleService = styleService;
        this.formBuilder = formBuilder;
        this.config = config;
        this.cdRef = cdRef;
        this.storageService = storageService;
        this.downloadService = downloadService;
        this.formats$ = new BehaviorSubject(undefined);
        this.encodings$ = new BehaviorSubject(undefined);
        this.exportableLayers$ = new BehaviorSubject([]);
        this.loading$ = new BehaviorSubject(false);
        this.forceNaming = false;
        this.controlFormat = 'format';
        this.espgCodeRegex = new RegExp('^\\d{4,6}');
        this.projections$ = new BehaviorSubject([]);
        this.popupChecked = false;
        this.previousLayerSpecs$ = new BehaviorSubject(undefined);
        this.selectFirstProj = false;
        this._projectionsLimitations = {};
        this.selectedMode = 'import';
        this.selectMode = new EventEmitter();
        this.exportOptions$ = new BehaviorSubject(undefined);
        this.exportOptionsChange = new EventEmitter();
        this.loadConfig();
        this.buildForm();
        this.computeProjections();
    }
    set projectionsLimitations(value) {
        this._projectionsLimitations = value;
        this.computeProjections();
    }
    get projectionsLimitations() {
        return this._projectionsLimitations || {};
    }
    get layers() {
        return this.form.get('layers').value;
    }
    set layers(value) {
        this.form.patchValue({ layers: value });
    }
    get inputProj() {
        return this.importForm.get('inputProj').value;
    }
    set inputProj(value) {
        this.importForm.patchValue({ inputProj: value });
    }
    get popupAllowed() {
        return this.storageService.get('importExportPopupAllowed') || false;
    }
    set popupAllowed(value) {
        this.storageService.set('importExportPopupAllowed', value);
    }
    ngOnInit() {
        this.layers$$ = this.map.layers$.subscribe((layers) => {
            this.exportableLayers$.next(layers.filter((layer) => {
                return ((layer instanceof VectorLayer && layer.exportable === true) ||
                    (layer.dataSource.options.download &&
                        layer.dataSource.options.download.url));
            }));
        });
        const configFileSizeMb = this.config.getConfig('importExport.clientSideFileSizeMaxMb');
        this.clientSideFileSizeMax =
            (configFileSizeMb ? configFileSizeMb : 30) * Math.pow(1024, 2);
        this.fileSizeMb = this.clientSideFileSizeMax / Math.pow(1024, 2);
        this.exportOptions$$ = this.exportOptions$
            .pipe(skipWhile((exportOptions) => !exportOptions))
            .subscribe((exportOptions) => {
            this.form.patchValue(exportOptions, { emitEvent: true });
            if (exportOptions.layers) {
                this.computeFormats(exportOptions.layers.map((l) => this.map.getLayerById(l)));
            }
        });
        this.formLayer$$ = this.form
            .get('format')
            .valueChanges
            .subscribe((format) => {
            var _a;
            const ogreFormats = Object.keys(ExportService.ogreFormats);
            if (!this.popupChecked &&
                ((_a = this.form.get('layers').value) === null || _a === void 0 ? void 0 : _a.length) > 1 &&
                (ogreFormats.indexOf(format) >= 0 || format === ExportFormat.URL)) {
                if (!this.handlePopup(true)) {
                    this.form.patchValue({ format: undefined }, { emitEvent: false });
                }
            }
        });
        this.formLayer$$ = this.form
            .get('layers')
            .valueChanges.subscribe((layersId) => {
            this.handlePreviousLayerSpecs();
            const selectedLayers = layersId instanceof Array ? layersId : [layersId];
            this.form.patchValue({ layers: selectedLayers }, { emitEvent: false });
            const layers = selectedLayers.map((l) => this.map.getLayerById(l));
            this.computeFormats(layers);
            if (Object.keys(this.formats$.value).indexOf(this.form.value.format) ===
                -1) {
                this.form.patchValue({ format: undefined });
            }
            this.loading$.next(true);
            const previousSpecs = [];
            layers.forEach((layer) => {
                if (layer instanceof VectorLayer &&
                    layer.dataSource.ol.getFeatures().length === 0) {
                    previousSpecs.push({
                        id: layer.id,
                        visible: layer.visible,
                        opacity: layer.opacity,
                        queryable: layer.queryable
                    });
                    layer.opacity = 0;
                    layer.visible = true;
                }
            });
            this.previousLayerSpecs$.next(previousSpecs);
            setTimeout(() => {
                this.loading$.next(false);
            }, 500);
        });
        this.formats$$ = this.formats$
            .pipe(skipWhile((formats) => !formats))
            .subscribe((formats) => {
            if (Object.keys(formats).length === 1) {
                this.form.patchValue({ format: formats[Object.keys(formats)[0]] });
            }
        });
        this.encodings$$ = this.encodings$
            .pipe(skipWhile((encodings) => !encodings))
            .subscribe((encodings) => {
            if (Object.keys(encodings).length === 1) {
                this.form.patchValue({ encoding: encodings[Object.keys(encodings)[0]] });
            }
        });
        this.exportableLayers$$ = this.exportableLayers$
            .pipe(skipWhile((layers) => !layers))
            .subscribe((layers) => {
            if (layers.length === 1) {
                this.form.patchValue({ layers: layers[0].id });
            }
        });
        this.form.controls[this.controlFormat].valueChanges.subscribe((format) => {
            if (format === ExportFormat.CSVcomma || format === ExportFormat.CSVsemicolon) {
                this.form.patchValue({ encoding: EncodingFormat.LATIN1 });
            }
            else {
                this.form.patchValue({ encoding: EncodingFormat.UTF8 });
            }
            this.cdRef.detectChanges();
        });
        if (this.selectFirstProj) {
            if (this.projections$.value.length === 0) {
                this.importForm.patchValue({ inputProj: { translateKey: 'nad83', alias: 'NAD83', code: 'EPSG:4326', zone: '' } });
            }
            else {
                this.importForm.patchValue({ inputProj: this.projections$.value[0] });
            }
        }
        else {
            this.importForm.patchValue({ inputProj: undefined });
        }
    }
    computeProjections() {
        this.projectionsConstraints = computeProjectionsConstraints(this.projectionsLimitations);
        const projections = [];
        if (this.projectionsConstraints.nad83) {
            projections.push({ translateKey: 'nad83', alias: 'NAD83', code: 'EPSG:4269', zone: '' });
        }
        if (this.projectionsConstraints.wgs84) {
            projections.push({ translateKey: 'wgs84', alias: 'WGS84', code: 'EPSG:4326', zone: '' });
        }
        if (this.projectionsConstraints.webMercator) {
            projections.push({ translateKey: 'webMercator', alias: 'Web Mercator', code: 'EPSG:3857', zone: '' });
        }
        if (this.projectionsConstraints.mtm) {
            // all mtm zones
            const minZone = this.projectionsConstraints.mtmZone.minZone;
            const maxZone = this.projectionsConstraints.mtmZone.maxZone;
            for (let mtmZone = minZone; mtmZone <= maxZone; mtmZone++) {
                const code = mtmZone < 10 ? `EPSG:3218${mtmZone}` : `EPSG:321${80 + mtmZone}`;
                projections.push({ translateKey: 'mtm', alias: `MTM ${mtmZone}`, code, zone: `${mtmZone}` });
            }
        }
        if (this.projectionsConstraints.utm) {
            // all utm zones
            const minZone = this.projectionsConstraints.utmZone.minZone;
            const maxZone = this.projectionsConstraints.utmZone.maxZone;
            for (let utmZone = minZone; utmZone <= maxZone; utmZone++) {
                const code = utmZone < 10 ? `EPSG:3260${utmZone}` : `EPSG:326${utmZone}`;
                projections.push({ translateKey: 'utm', alias: `UTM ${utmZone}`, code, zone: `${utmZone}` });
            }
        }
        let configProjection = [];
        if (this.projectionsConstraints.projFromConfig) {
            configProjection = this.config.getConfig('projections') || [];
        }
        this.projections$.next(configProjection.concat(projections));
    }
    getWorkspaceByLayerId(id) {
        const wksFromLayerId = this.store
            .all()
            .find(workspace => workspace.layer.id === id);
        if (wksFromLayerId) {
            return wksFromLayerId;
        }
        return;
    }
    getLayerTitleById(id) {
        var _a;
        return (_a = this.map.getLayerById(id)) === null || _a === void 0 ? void 0 : _a.title;
    }
    layerHasSelectedFeatures(layer) {
        const wksFromLayer = this.getWorkspaceByLayerId(layer.id);
        if (wksFromLayer) {
            const recs = wksFromLayer.entityStore.stateView
                .firstBy((record) => {
                return record.state.selected === true;
            });
            return recs ? true : false;
        }
    }
    onlySelected(event, id) {
        let layersWithSelection = this.form.value.layersWithSelection;
        if (event.checked) {
            layersWithSelection.push(id);
        }
        else {
            layersWithSelection = layersWithSelection.filter(layerId => layerId !== id);
        }
        this.form.patchValue({ layersWithSelection });
    }
    onlySelectedClick(event, id) {
        if (this.form.value.layers.find(layerId => layerId === id)) {
            event.stopPropagation();
        }
    }
    inLayersIdToExportSelectionOnly(layer) {
        return this.form.value.layersWithSelection.find(layerId => layerId === layer.id) ? true : false;
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
        this.exportableLayers$$.unsubscribe();
        this.formats$$.unsubscribe();
        this.encodings$$.unsubscribe();
        this.formLayer$$.unsubscribe();
        if (this.exportOptions$$) {
            this.exportOptions$$.unsubscribe();
        }
        this.exportOptionsChange.emit(this.form.value);
        this.handlePreviousLayerSpecs();
    }
    handlePreviousLayerSpecs() {
        const previousSpecs = this.previousLayerSpecs$.value;
        if (previousSpecs && previousSpecs.length) {
            previousSpecs.forEach((specs) => {
                const previousLayer = this.map.getLayerById(specs.id);
                previousLayer.visible = specs.visible;
                previousLayer.opacity = specs.opacity;
                previousLayer.queryable = specs.queryable;
            });
        }
        this.previousLayerSpecs$.next(undefined);
    }
    importFiles(files) {
        let inputProj = this.inputProj.code;
        if (this.espgCodeRegex.test(inputProj)) {
            inputProj = `EPSG:${inputProj}`;
        }
        this.loading$.next(true);
        for (const file of files) {
            this.importService.import(file, inputProj).subscribe((features) => this.onFileImportSuccess(file, features), (error) => this.onFileImportError(file, error), () => {
                this.loading$.next(false);
            });
        }
    }
    handlePopup(preCheck = true) {
        const p1 = window.open('', 'popup', 'width=1, height=1');
        p1.close();
        const p2 = window.open('', 'popup', 'width=1, height=1');
        if (!p2 || p2.closed || typeof p2.closed === 'undefined' || p2 === null) {
            this.onPopupBlockedError(preCheck);
            this.popupAllowed = false;
        }
        else {
            p2.close();
            this.popupAllowed = true;
            this.popupChecked = true;
        }
        return this.popupAllowed;
    }
    handleExportFormSubmit(data) {
        this.loading$.next(true);
        const ogreFormats = Object.keys(ExportService.ogreFormats);
        if (!this.popupChecked && data.layers.length > 1 &&
            (ogreFormats.indexOf(data.format) >= 0 || data.format === ExportFormat.URL) && !this.popupAllowed) {
            this.handlePopup();
        }
        let geomTypesCSV = [];
        let featuresCSV = [];
        let filename = "";
        for (const [layerIndex, layer] of data.layers.entries()) {
            const lay = this.map.getLayerById(layer);
            if (!(data.format === ExportFormat.CSVsemicolon || data.format === ExportFormat.CSVcomma)
                || !data.combineLayers || data.layers.length === 1) {
                filename = lay.title;
                if (data.name) {
                    filename = data.name;
                }
            }
            else {
                filename = this.languageService.translate.instant('igo.geo.export.combinedLayers');
            }
            const dSOptions = lay.dataSource.options;
            if (data.format === ExportFormat.URL && dSOptions.download && (dSOptions.download.url || dSOptions.download.dynamicUrl)) {
                setTimeout(() => {
                    // better look an feel
                    const url = dSOptions.download.url || dSOptions.download.dynamicUrl;
                    url.match(/service=wfs/gi) ? this.downloadService.open(lay) : window.open(url, '_blank');
                    this.loading$.next(false);
                }, 500);
                return;
            }
            const wks = this.getWorkspaceByLayerId(layer);
            let olFeatures;
            if (wks && wks.entityStore && wks.entityStore.stateView.all().length) {
                if (data.layersWithSelection.indexOf(layer) !== -1 && data.featureInMapExtent) {
                    // Only export selected feature && into map extent
                    olFeatures = wks.entityStore.stateView.all()
                        .filter((e) => e.state.inMapExtent && e.state.selected).map(e => e.entity.ol);
                }
                else if (data.layersWithSelection.indexOf(layer) !== -1 && !data.featureInMapExtent) {
                    // Only export selected feature &&  (into map extent OR not)
                    olFeatures = wks.entityStore.stateView.all()
                        .filter((e) => e.state.selected).map(e => e.entity.ol);
                }
                else if (data.featureInMapExtent) {
                    // Only into map extent
                    olFeatures = wks.entityStore.stateView.all()
                        .filter((e) => e.state.inMapExtent).map(e => e.entity.ol);
                }
                else {
                    // All features
                    olFeatures = wks.entityStore.stateView.all().map(e => e.entity.ol);
                }
            }
            else {
                const ol = lay.dataSource.ol;
                if (data.featureInMapExtent) {
                    olFeatures = ol.getFeaturesInExtent(lay.map.viewController.getExtent());
                }
                else {
                    olFeatures = ol.getFeatures();
                }
                if (lay.dataSource instanceof ClusterDataSource) {
                    olFeatures = olFeatures.flatMap((cluster) => cluster.get('features'));
                }
            }
            const translate = this.languageService.translate;
            let geomTypes = [];
            if (data.format === ExportFormat.Shapefile || data.format === ExportFormat.GPX) {
                olFeatures.forEach((olFeature) => {
                    const featureGeomType = olFeature.getGeometry().getType();
                    const currentGeomType = geomTypes.find(geomType => geomType.geometryType === featureGeomType);
                    if (currentGeomType) {
                        currentGeomType.features.push(olFeature);
                    }
                    else {
                        geomTypes.push({ geometryType: featureGeomType, features: [olFeature] });
                    }
                });
            }
            else {
                geomTypes = [{ geometryType: '', features: olFeatures }];
            }
            geomTypes.forEach(geomType => {
                geomType.features.forEach(feature => {
                    const radius = feature.get('rad');
                    if (radius) {
                        const center4326 = [feature.get('longitude'), feature.get('latitude')];
                        const circle = circular(center4326, radius, 500);
                        circle.transform('EPSG:4326', feature.get('_projection'));
                        feature.setGeometry(circle);
                    }
                });
            });
            if (data.format === ExportFormat.GPX) {
                const gpxFeatureCnt = geomTypes.length;
                geomTypes = geomTypes.filter(geomType => ['LineString', 'Point'].includes(geomType.geometryType));
                const gpxFeatureCntPointOrPoly = geomTypes.length;
                if (gpxFeatureCnt > gpxFeatureCntPointOrPoly) {
                    const title = translate.instant('igo.geo.export.gpx.error.poly.title');
                    const message = translate.instant('igo.geo.export.gpx.error.poly.text');
                    this.messageService.error(message, title, { timeOut: 20000 });
                }
            }
            else if ((data.format === ExportFormat.CSVsemicolon || data.format === ExportFormat.CSVcomma) && data.combineLayers) {
                geomTypes.forEach(geomType => geomTypesCSV.push(geomType));
                if (layerIndex !== data.layers.length - 1) {
                    continue;
                }
                else {
                    let previousFeature = undefined;
                    geomTypesCSV.forEach(geomType => {
                        geomType.features.forEach(currentFeature => {
                            if (data.separator) {
                                if (previousFeature) {
                                    if (currentFeature.get('_featureStore').layer.options.title !==
                                        previousFeature.get('_featureStore').layer.options.title) {
                                        const titleEmptyRows = this.createTitleEmptyRows(previousFeature, currentFeature);
                                        featuresCSV.push(titleEmptyRows[2]);
                                        featuresCSV.push(titleEmptyRows[0]);
                                        featuresCSV.push(titleEmptyRows[1]);
                                    }
                                }
                                else {
                                    const titleEmptyRows = this.createTitleEmptyRows(currentFeature, currentFeature);
                                    featuresCSV.push(titleEmptyRows[0]);
                                }
                            }
                            featuresCSV.push(currentFeature);
                            previousFeature = currentFeature;
                        });
                    });
                }
            }
            if (geomTypes.length === 0) {
                this.loading$.next(false);
                const title = translate.instant('igo.geo.export.nothing.title');
                const message = translate.instant('igo.geo.export.nothing.text');
                this.messageService.error(message, title, { timeOut: 20000 });
            }
            else {
                if (!(data.format === ExportFormat.CSVsemicolon || data.format === ExportFormat.CSVcomma) || !data.combineLayers) {
                    geomTypes.map(geomType => this.exportService.export(geomType.features, data.format, filename + geomType.geometryType, data.encoding, this.map.projection)
                        .subscribe(() => { }, (error) => this.onFileExportError(error), () => {
                        this.onFileExportSuccess();
                        geomType.features.forEach(feature => {
                            this.circleToPoint(feature);
                        });
                        this.loading$.next(false);
                    }));
                }
            }
        }
        ;
        if ((data.format === ExportFormat.CSVsemicolon || data.format === ExportFormat.CSVcomma) && data.combineLayers) {
            this.exportService.export(featuresCSV, data.format, filename, data.encoding, this.map.projection)
                .subscribe(() => { }, (error) => this.onFileExportError(error), () => {
                this.onFileExportSuccess();
                featuresCSV.forEach(feature => {
                    this.circleToPoint(feature);
                });
                this.loading$.next(false);
            });
        }
    }
    createTitleEmptyRows(previousFeature, currentFeature) {
        const titleRow = currentFeature.clone();
        const headerRow = currentFeature.clone();
        const emptyRow = currentFeature.clone();
        const previousFeatureKeys = previousFeature.getKeys();
        let firstKeyPrevious = '';
        for (const key in previousFeatureKeys) {
            if (previousFeatureKeys[key] !== 'geometry') {
                firstKeyPrevious = previousFeatureKeys[key];
                break;
            }
        }
        const currentFeatureKeys = currentFeature.getKeys();
        let firstKeyCurrent = '';
        for (const key in currentFeatureKeys) {
            if (currentFeatureKeys[key] !== 'geometry') {
                firstKeyCurrent = currentFeatureKeys[key];
                break;
            }
        }
        const allKeys = currentFeature.getKeys();
        previousFeatureKeys.forEach(previousKey => {
            if (allKeys.includes(previousKey) && previousKey !== firstKeyPrevious) {
                allKeys.push(previousKey);
            }
        });
        allKeys.unshift(firstKeyPrevious);
        let firstKeyAll = '';
        for (const key in allKeys) {
            if (allKeys[key] !== 'geometry') {
                firstKeyAll = allKeys[key];
                break;
            }
        }
        allKeys.forEach(key => {
            const sameKeys = previousFeatureKeys.length === currentFeatureKeys.length &&
                previousFeatureKeys.every((value, index) => value === currentFeatureKeys[index]);
            if (key === firstKeyAll && !sameKeys) {
                titleRow.set(key, currentFeature.get('_featureStore').layer.options.title + " ===============>", true);
                headerRow.set(key, key, true);
                emptyRow.unset(key, true);
            }
            else if (key === firstKeyAll && sameKeys) {
                titleRow.set(key, currentFeature.get('_featureStore').layer.options.title, true);
                headerRow.set(key, key, true);
                emptyRow.unset(key, true);
            }
            else if (key === firstKeyCurrent) {
                titleRow.set(key, currentFeature.get('_featureStore').layer.options.title, true);
                headerRow.set(key, key, true);
                emptyRow.unset(key, true);
            }
            else if (key !== 'geometry') {
                titleRow.unset(key, true);
                headerRow.set(key, key, true);
                emptyRow.unset(key, true);
            }
            else {
                titleRow.unset(key, true);
                emptyRow.unset(key, true);
            }
            if (!(currentFeatureKeys.includes(key))) {
                headerRow.unset(key, true);
            }
        });
        const titleEmptyRows = [titleRow, headerRow, emptyRow];
        return titleEmptyRows;
    }
    circleToPoint(feature) {
        const radius = feature.get('rad');
        if (radius) {
            const point = new OlPoint([feature.get('longitude'), feature.get('latitude')]);
            point.transform('EPSG:4326', feature.get('_projection'));
            feature.setGeometry(point);
        }
    }
    buildForm() {
        this.importForm = this.formBuilder.group({
            inputProj: ['', [Validators.required]]
        });
        if (this.forceNaming) {
            this.form = this.formBuilder.group({
                format: ['', [Validators.required]],
                layers: [[], [Validators.required]],
                layersWithSelection: [[]],
                encoding: [EncodingFormat.UTF8, [Validators.required]],
                combineLayers: [true, [Validators.required]],
                separator: [false, [Validators.required]],
                featureInMapExtent: [false, [Validators.required]],
                name: ['', [Validators.required]]
            });
        }
        else {
            this.form = this.formBuilder.group({
                format: ['', [Validators.required]],
                layers: [[], [Validators.required]],
                layersWithSelection: [[]],
                encoding: [EncodingFormat.UTF8, [Validators.required]],
                combineLayers: [true, [Validators.required]],
                separator: [false, [Validators.required]],
                featureInMapExtent: [false, [Validators.required]],
            });
        }
    }
    onFileImportSuccess(file, features) {
        if (!this.config.getConfig('importWithStyle')) {
            handleFileImportSuccess(file, features, this.map, this.messageService, this.languageService);
        }
        else {
            handleFileImportSuccess(file, features, this.map, this.messageService, this.languageService, this.styleListService, this.styleService);
        }
    }
    onFileImportError(file, error) {
        this.loading$.next(false);
        handleFileImportError(file, error, this.messageService, this.languageService, this.fileSizeMb);
    }
    onPopupBlockedError(preCheck = true) {
        this.loading$.next(false);
        const translate = this.languageService.translate;
        const title = translate.instant('igo.geo.export.popupBlocked.title');
        const extraMessage = preCheck ?
            translate.instant('igo.geo.export.popupBlocked.selectAgain') :
            translate.instant('igo.geo.export.popupBlocked.retry');
        const message = translate.instant('igo.geo.export.popupBlocked.text', { extraMessage });
        this.messageService.error(message, title, { timeOut: 20000 });
    }
    onFileExportError(error) {
        this.loading$.next(false);
        handleFileExportError(error, this.messageService, this.languageService);
    }
    loadConfig() {
        if (this.config.getConfig('importExport.forceNaming') !== undefined) {
            this.forceNaming = this.config.getConfig('importExport.forceNaming');
        }
        this.computeFormats();
        this.loadEncodings();
    }
    encodingDefaultValue(format) {
        if (format === ExportFormat.CSVcomma || format === ExportFormat.CSVsemicolon) {
            this.form.patchValue({ encoding: EncodingFormat.LATIN1 });
            return EncodingFormat.LATIN1;
        }
        else {
            this.form.patchValue({ encoding: EncodingFormat.UTF8 });
            return EncodingFormat.UTF8;
        }
    }
    loadEncodings() {
        this.encodings$.next(EncodingFormat);
    }
    computeFormats(layers) {
        let appliedformats = Object.keys(ExportFormat);
        const formatsType = {
            onlyUrl: false,
            onlyVector: false,
            vectorAndUrl: false,
            customList: false
        };
        const customList = [];
        if (layers && layers.length) {
            layers.forEach((layer) => {
                var _a;
                if (!layer) {
                    return;
                }
                if ((_a = layer.dataSource.options.download) === null || _a === void 0 ? void 0 : _a.allowedFormats) {
                    formatsType.customList = true;
                    customList.push({ layer: layer.title, formats: this.validateListFormat(layer.dataSource.options.download.allowedFormats) });
                }
                else if (!(layer instanceof VectorLayer) &&
                    layer.dataSource.options.download &&
                    layer.dataSource.options.download.url) {
                    formatsType.onlyUrl = true;
                }
                else if (layer.dataSource.options.download &&
                    (layer.dataSource.options.download.url || layer.dataSource.options.download.dynamicUrl)) {
                    formatsType.vectorAndUrl = true;
                }
                else if (layer instanceof VectorLayer) {
                    formatsType.onlyVector = true;
                }
            });
            if (formatsType.onlyUrl === true && formatsType.onlyVector === false) {
                appliedformats = ['URL'];
            }
            else if (formatsType.onlyVector === true &&
                formatsType.onlyUrl === false) {
                this.computeFormats(); // reset
                if (ExportFormat.URL in this.formats$.value) {
                    const keys = Object.keys(this.formats$.value).filter((key) => key !== 'URL');
                    appliedformats = keys;
                }
            }
            else if (formatsType.vectorAndUrl === true &&
                formatsType.onlyUrl === false &&
                formatsType.onlyVector === false) {
                this.computeFormats(); // reset
                if (!(ExportFormat.URL in this.formats$.value)) {
                    const keys = Object.keys(this.formats$.value);
                    keys.push('URL');
                    appliedformats = keys;
                }
            }
        }
        if (this.config.getConfig('importExport.formats') !== undefined) {
            const validatedListFormat = this.validateListFormat(this.config.getConfig('importExport.formats'));
            appliedformats = validatedListFormat;
        }
        if (formatsType.customList) {
            let commonFormats;
            const layersWithCustomFormats = [];
            let previousCustomListFormats = customList[0].formats;
            customList.map(list => {
                layersWithCustomFormats.push(list.layer);
                commonFormats = list.formats.filter(value => previousCustomListFormats.includes(value));
                previousCustomListFormats = list.formats;
            });
            const finalFormats = commonFormats.filter(value => appliedformats.includes(value));
            if (finalFormats.length > 0) {
                this.formats$.next(strEnum(finalFormats));
                if (layers && layers.length) {
                    if (layers.length > 1) {
                        this.messageService.alert(this.languageService.translate.instant('igo.geo.export.customList.text', { value: layersWithCustomFormats.join() }), this.languageService.translate.instant('igo.geo.export.customList.title'));
                    }
                }
            }
            else {
                this.formats$.next([]);
                this.messageService.alert(this.languageService.translate.instant('igo.geo.export.noFormat.text'), this.languageService.translate.instant('igo.geo.export.noFormat.title'));
            }
            return;
        }
        else {
            this.formats$.next(strEnum(appliedformats));
        }
    }
    validateListFormat(formats) {
        return formats
            .filter((format) => {
            if (format.toUpperCase() === ExportFormat.CSVcomma.toUpperCase() ||
                format.toUpperCase() === ExportFormat.CSVsemicolon.toUpperCase() ||
                format.toUpperCase() === ExportFormat.GML.toUpperCase() ||
                format.toUpperCase() === ExportFormat.GPX.toUpperCase() ||
                format.toUpperCase() === ExportFormat.GeoJSON.toUpperCase() ||
                format.toUpperCase() === ExportFormat.KML.toUpperCase() ||
                format.toUpperCase() === ExportFormat.Shapefile.toUpperCase() ||
                format.toUpperCase() === ExportFormat.URL.toUpperCase()) {
                return format;
            }
        })
            .map((format) => {
            if (format.toUpperCase() === ExportFormat.CSVcomma.toUpperCase()) {
                format = ExportFormat.CSVcomma;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.CSVsemicolon.toUpperCase()) {
                format = ExportFormat.CSVsemicolon;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.GML.toUpperCase()) {
                format = ExportFormat.GML;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.GPX.toUpperCase()) {
                format = ExportFormat.GPX;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.GeoJSON.toUpperCase()) {
                format = ExportFormat.GeoJSON;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.KML.toUpperCase()) {
                format = ExportFormat.KML;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.Shapefile.toUpperCase()) {
                format = ExportFormat.Shapefile;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.URL.toUpperCase()) {
                format = ExportFormat.URL;
                return format;
            }
        });
    }
    modeChanged(mode) {
        this.selectMode.emit(mode);
    }
    onFileExportSuccess() {
        handleFileExportSuccess(this.messageService, this.languageService);
    }
    onImportExportChange(event) {
        this.selectedMode = event.value;
    }
}
ImportExportComponent.ɵfac = function ImportExportComponent_Factory(t) { return new (t || ImportExportComponent)(i0.ɵɵdirectiveInject(ImportService), i0.ɵɵdirectiveInject(ExportService), i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(i2$1.MessageService), i0.ɵɵdirectiveInject(StyleListService), i0.ɵɵdirectiveInject(StyleService), i0.ɵɵdirectiveInject(i16.FormBuilder), i0.ɵɵdirectiveInject(i2$1.ConfigService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2$1.StorageService), i0.ɵɵdirectiveInject(DownloadService)); };
ImportExportComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ImportExportComponent, selectors: [["igo-import-export"]], inputs: { selectFirstProj: "selectFirstProj", map: "map", projectionsLimitations: "projectionsLimitations", store: "store", selectedMode: "selectedMode", exportOptions$: "exportOptions$" }, outputs: { selectMode: "selectMode", exportOptionsChange: "exportOptionsChange" }, decls: 14, vars: 17, consts: [[1, "import-export-toggle", "mat-typography"], [3, "value", "change"], [3, "value"], ["class", "igo-form", 3, "formGroup", 4, "ngIf"], ["class", "mat-typography", 4, "ngIf"], [1, "igo-form", 3, "formGroup"], [1, "igo-input-container"], [3, "value", "valueChange"], [3, "value", "click", 4, "ngFor", "ngForOf"], ["tooltip-position", "below", "matTooltipShowDelay", "500", 1, "igo-form-button-group", 3, "matTooltip"], ["mat-raised-button", "", "type", "button", 3, "disabled", "click"], [3, "shown"], ["hidden", "", "type", "file", 3, "click", "change"], ["fileInput", ""], [3, "value", "click"], ["mat-line", "", 4, "ngIf"], ["mat-line", ""], [1, "mat-typography"], ["multiple", "", 3, "value", "valueChange"], ["class", "export-select-trigger", 4, "ngIf"], [3, "ngClass", "value", "click", 4, "ngFor", "ngForOf"], ["formControlName", "format"], [4, "ngIf"], ["disabled", "true", 4, "ngIf"], ["class", "igo-input-container", 4, "ngIf"], ["class", "export-combine-layers mat-typography", 4, "ngIf"], ["class", "export-separator mat-typography", 4, "ngIf"], ["class", "export-options mat-typography", 4, "ngIf"], [1, "igo-form-button-group"], [1, "export-select-trigger"], [3, "ngClass", "value", "click"], [3, "labelPosition", "click", "checked", "change", 4, "ngIf"], [3, "labelPosition", "click", "checked", "change"], [3, "value", 4, "ngFor", "ngForOf"], ["disabled", "true"], ["matInput", "", "formControlName", "name", 3, "placeholder"], ["formControlName", "encoding"], [1, "export-combine-layers", "mat-typography"], ["formControlName", "combineLayers", 3, "labelPosition"], [1, "export-separator", "mat-typography"], ["formControlName", "separator", 3, "labelPosition"], [1, "export-options", "mat-typography"], ["formControlName", "featureInMapExtent", 3, "labelPosition"]], template: function ImportExportComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelementStart(1, "mat-button-toggle-group", 1);
        i0.ɵɵlistener("change", function ImportExportComponent_Template_mat_button_toggle_group_change_1_listener($event) { return ctx.onImportExportChange($event); });
        i0.ɵɵelementStart(2, "mat-button-toggle", 2);
        i0.ɵɵtext(3);
        i0.ɵɵpipe(4, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(5, "mat-button-toggle", 2);
        i0.ɵɵtext(6);
        i0.ɵɵpipe(7, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(8, ImportExportComponent_form_8_Template, 20, 24, "form", 3);
        i0.ɵɵtemplate(9, ImportExportComponent_section_9_Template, 14, 15, "section", 4);
        i0.ɵɵtemplate(10, ImportExportComponent_section_10_Template, 4, 3, "section", 4);
        i0.ɵɵpipe(11, "async");
        i0.ɵɵtemplate(12, ImportExportComponent_form_12_Template, 36, 37, "form", 3);
        i0.ɵɵpipe(13, "async");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("value", ctx.selectedMode);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("value", "import");
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(4, 9, "igo.geo.importExportForm.importTabTitle"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("value", "export");
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(7, 11, "igo.geo.importExportForm.exportTabTitle"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.selectedMode === "import");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.selectedMode === "import");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(11, 13, ctx.exportableLayers$).length === 0 && ctx.selectedMode === "export");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(13, 15, ctx.exportableLayers$).length > 0 && ctx.selectedMode === "export");
    } }, directives: [i18.MatButtonToggleGroup, i18.MatButtonToggle, i1$1.NgIf, i16.ɵNgNoValidate, i16.NgControlStatusGroup, i16.FormGroupDirective, i12.MatFormField, i12.MatLabel, i13.MatSelect, i1$1.NgForOf, i3.MatTooltip, i2.MatButton, i6.SpinnerComponent, i9.MatOption, i13.MatSelectTrigger, i16.NgControlStatus, i16.FormControlName, i1$1.NgClass, i22.MatSlideToggle, i5$1.MatInput, i16.DefaultValueAccessor], pipes: [i7.TranslatePipe, i1$1.AsyncPipe, i6.KeyValuePipe], styles: ["mat-option.igo-export-layer-mat-option[_ngcontent-%COMP%]{height:5em;line-height:1em}.import-export-toggle[_ngcontent-%COMP%]{padding:10px;text-align:center}.import-export-toggle[_ngcontent-%COMP%]   mat-button-toggle-group[_ngcontent-%COMP%]{width:100%}.import-export-toggle[_ngcontent-%COMP%]   mat-button-toggle-group[_ngcontent-%COMP%]   mat-button-toggle[_ngcontent-%COMP%]{width:50%}h4[_ngcontent-%COMP%]{padding:0 5px}.igo-form[_ngcontent-%COMP%]{padding:15px 5px}.igo-input-container[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%]{width:100%}.igo-form-button-group[_ngcontent-%COMP%]{text-align:center;padding-top:10px}igo-spinner[_ngcontent-%COMP%]{position:absolute;padding-left:10px}.export-options[_ngcontent-%COMP%], .export-combine-layers[_ngcontent-%COMP%], .export-separator[_ngcontent-%COMP%]{overflow-x:hidden}.export-options[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%], .export-combine-layers[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%], .export-separator[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]{width:100%;margin:10px}.export-options[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-content, .export-combine-layers[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-content, .export-separator[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-content{width:calc(100% - 60px)}.export-select-trigger[_ngcontent-%COMP%]{opacity:.75;font-size:.75em}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ImportExportComponent, [{
        type: Component,
        args: [{
                selector: 'igo-import-export',
                templateUrl: './import-export.component.html',
                styleUrls: ['./import-export.component.scss']
            }]
    }], function () { return [{ type: ImportService }, { type: ExportService }, { type: i2$1.LanguageService }, { type: i2$1.MessageService }, { type: StyleListService }, { type: StyleService }, { type: i16.FormBuilder }, { type: i2$1.ConfigService }, { type: i0.ChangeDetectorRef }, { type: i2$1.StorageService }, { type: DownloadService }]; }, { selectFirstProj: [{
            type: Input
        }], map: [{
            type: Input
        }], projectionsLimitations: [{
            type: Input
        }], store: [{
            type: Input
        }], selectedMode: [{
            type: Input
        }], selectMode: [{
            type: Output
        }], exportOptions$: [{
            type: Input
        }], exportOptionsChange: [{
            type: Output
        }] }); })();

class DropGeoFileDirective extends DragAndDropDirective {
    constructor(component, importService, languageService, styleListService, styleService, config, messageService) {
        super();
        this.component = component;
        this.importService = importService;
        this.languageService = languageService;
        this.styleListService = styleListService;
        this.styleService = styleService;
        this.config = config;
        this.messageService = messageService;
        this.filesDropped = new EventEmitter();
        this.filesInvalid = new EventEmitter();
        this.epsgCode$ = new BehaviorSubject(undefined);
        this.epsgCode$$ = [];
    }
    get map() {
        return this.component.map;
    }
    ngOnInit() {
        this.filesDropped$$ = this.filesDropped.subscribe((files) => {
            this.onFilesDropped(files);
        });
    }
    ngOnDestroy() {
        this.filesDropped$$.unsubscribe();
    }
    onDragOver(evt) {
        super.onDragOver(evt);
    }
    onDragLeave(evt) {
        super.onDragLeave(evt);
    }
    onDrop(evt) {
        super.onDrop(evt);
    }
    onFilesDropped(files) {
        for (const file of files) {
            this.detectEPSG(file);
            this.epsgCode$$.push(this.epsgCode$.pipe(skipWhile((code) => !code), first(), concatMap(epsgCode => {
                const epsg = epsgCode === 'epsgNotDefined' ? undefined : epsgCode;
                this.epsgCode$.next(undefined);
                return this.importService.import(file, epsg);
            })).subscribe((features) => this.onFileImportSuccess(file, features), (error) => this.onFileImportError(file, error)));
        }
    }
    detectEPSG(file, nbLines = 500) {
        if (!file.name.toLowerCase().endsWith('.geojson') && !file.name.toLowerCase().endsWith('.gml')) {
            this.epsgCode$.next('epsgNotDefined');
            return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
            var _a, _b;
            if (file.name.toLowerCase().endsWith('.geojson')) {
                const geojson = JSON.parse(reader.result);
                if ((_b = (_a = geojson.crs) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.name) {
                    const epsg = geojson.crs.properties.name.match(/EPSG:{1,2}\d{0,6}/gm);
                    if (epsg !== null && epsg.length) {
                        this.epsgCode$.next(epsg[0].replace(/::/g, ':'));
                        return;
                    }
                    else {
                        this.epsgCode$.next('epsgNotDefined');
                        return;
                    }
                }
                else {
                    this.epsgCode$.next('epsgNotDefined');
                    return;
                }
            }
            else if (file.name.toLowerCase().endsWith('.gml')) {
                const text = reader.result;
                const lines = text.split('\n');
                for (let line = 0; line <= nbLines; line++) {
                    const epsg = lines[line].match(/EPSG:\d{0,6}/gm);
                    if (epsg !== null && epsg.length) {
                        this.epsgCode$.next(epsg[0]);
                        break;
                    }
                    else {
                        this.epsgCode$.next(undefined);
                        return;
                    }
                }
            }
            else {
                this.epsgCode$.next('epsgNotDefined');
                return;
            }
        };
        reader.readAsText(file, 'UTF-8');
    }
    onFileImportSuccess(file, features) {
        if (!this.config.getConfig('importWithStyle')) {
            handleFileImportSuccess(file, features, this.map, this.messageService, this.languageService);
        }
        else {
            handleFileImportSuccess(file, features, this.map, this.messageService, this.languageService, this.styleListService, this.styleService);
        }
    }
    onFileImportError(file, error) {
        handleFileImportError(file, error, this.messageService, this.languageService, this.config.getConfig('importExport.clientSideFileSizeMaxMb'));
    }
}
DropGeoFileDirective.ɵfac = function DropGeoFileDirective_Factory(t) { return new (t || DropGeoFileDirective)(i0.ɵɵdirectiveInject(MapBrowserComponent), i0.ɵɵdirectiveInject(ImportService), i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(StyleListService), i0.ɵɵdirectiveInject(StyleService), i0.ɵɵdirectiveInject(i2$1.ConfigService), i0.ɵɵdirectiveInject(i2$1.MessageService)); };
DropGeoFileDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: DropGeoFileDirective, selectors: [["", "igoDropGeoFile", ""]], hostBindings: function DropGeoFileDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("dragover", function DropGeoFileDirective_dragover_HostBindingHandler($event) { return ctx.onDragOver($event); })("dragleave", function DropGeoFileDirective_dragleave_HostBindingHandler($event) { return ctx.onDragLeave($event); })("drop", function DropGeoFileDirective_drop_HostBindingHandler($event) { return ctx.onDrop($event); });
    } }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DropGeoFileDirective, [{
        type: Directive,
        args: [{
                selector: '[igoDropGeoFile]'
            }]
    }], function () { return [{ type: MapBrowserComponent }, { type: ImportService }, { type: i2$1.LanguageService }, { type: StyleListService }, { type: StyleService }, { type: i2$1.ConfigService }, { type: i2$1.MessageService }]; }, { onDragOver: [{
            type: HostListener,
            args: ['dragover', ['$event']]
        }], onDragLeave: [{
            type: HostListener,
            args: ['dragleave', ['$event']]
        }], onDrop: [{
            type: HostListener,
            args: ['drop', ['$event']]
        }] }); })();

let STYLELIST_OPTIONS = new InjectionToken('styleListOptions');
function provideStyleListOptions(options) {
    return {
        provide: STYLELIST_OPTIONS,
        useValue: options
    };
}
function styleListFactory(styleListService, options) {
    return () => styleListService.load(options);
}
function provideStyleListLoader() {
    return {
        provide: APP_INITIALIZER,
        useFactory: styleListFactory,
        multi: true,
        deps: [StyleListService, STYLELIST_OPTIONS]
    };
}

class IgoStyleListModule {
    static forRoot() {
        return {
            ngModule: IgoStyleListModule,
            providers: [provideStyleListOptions({}), provideStyleListLoader()]
        };
    }
}
IgoStyleListModule.ɵfac = function IgoStyleListModule_Factory(t) { return new (t || IgoStyleListModule)(); };
IgoStyleListModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoStyleListModule });
IgoStyleListModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoStyleListModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [],
                exports: []
            }]
    }], null, null); })();

class IgoImportExportModule {
    static forRoot() {
        return {
            ngModule: IgoImportExportModule
        };
    }
}
IgoImportExportModule.ɵfac = function IgoImportExportModule_Factory(t) { return new (t || IgoImportExportModule)(); };
IgoImportExportModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoImportExportModule });
IgoImportExportModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            MatIconModule,
            MatTooltipModule,
            FormsModule,
            ReactiveFormsModule,
            CommonModule,
            MatButtonModule,
            MatButtonToggleModule,
            MatTabsModule,
            MatSelectModule,
            MatOptionModule,
            MatFormFieldModule,
            MatInputModule,
            MatSlideToggleModule,
            IgoLanguageModule,
            IgoSpinnerModule,
            IgoKeyValueModule,
            IgoDrapDropModule,
            IgoStyleListModule.forRoot()
        ], IgoStyleListModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoImportExportModule, [{
        type: NgModule,
        args: [{
                imports: [
                    MatIconModule,
                    MatTooltipModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CommonModule,
                    MatButtonModule,
                    MatButtonToggleModule,
                    MatTabsModule,
                    MatSelectModule,
                    MatOptionModule,
                    MatFormFieldModule,
                    MatInputModule,
                    MatSlideToggleModule,
                    IgoLanguageModule,
                    IgoSpinnerModule,
                    IgoKeyValueModule,
                    IgoDrapDropModule,
                    IgoStyleListModule.forRoot()
                ],
                exports: [ImportExportComponent, DropGeoFileDirective, IgoStyleListModule, ExportButtonComponent],
                declarations: [ImportExportComponent, DropGeoFileDirective, ExportButtonComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoImportExportModule, { declarations: [ImportExportComponent, DropGeoFileDirective, ExportButtonComponent], imports: [MatIconModule,
        MatTooltipModule,
        FormsModule,
        ReactiveFormsModule,
        CommonModule,
        MatButtonModule,
        MatButtonToggleModule,
        MatTabsModule,
        MatSelectModule,
        MatOptionModule,
        MatFormFieldModule,
        MatInputModule,
        MatSlideToggleModule,
        IgoLanguageModule,
        IgoSpinnerModule,
        IgoKeyValueModule,
        IgoDrapDropModule, IgoStyleListModule], exports: [ImportExportComponent, DropGeoFileDirective, IgoStyleListModule, ExportButtonComponent] }); })();

class IgoMapModule {
}
IgoMapModule.ɵfac = function IgoMapModule_Factory(t) { return new (t || IgoMapModule)(); };
IgoMapModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoMapModule });
IgoMapModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            IgoLanguageModule,
            IgoConfirmDialogModule,
            MatIconModule,
            MatButtonModule,
            MatTooltipModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoMapModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    IgoLanguageModule,
                    IgoConfirmDialogModule,
                    MatIconModule,
                    MatButtonModule,
                    MatTooltipModule
                ],
                exports: [
                    MapBrowserComponent,
                    ZoomButtonComponent,
                    GeolocateButtonComponent,
                    HomeExtentButtonComponent,
                    RotationButtonComponent,
                    InfoSectionComponent,
                    BaseLayersSwitcherComponent,
                    MiniBaseMapComponent,
                    MapOfflineDirective,
                    OfflineButtonComponent,
                    PointerPositionDirective,
                    HoverFeatureDirective,
                    SwipeControlComponent,
                    MapCenterComponent,
                    MenuButtonComponent
                ],
                declarations: [
                    MapBrowserComponent,
                    ZoomButtonComponent,
                    GeolocateButtonComponent,
                    HomeExtentButtonComponent,
                    RotationButtonComponent,
                    InfoSectionComponent,
                    BaseLayersSwitcherComponent,
                    MiniBaseMapComponent,
                    MapOfflineDirective,
                    OfflineButtonComponent,
                    PointerPositionDirective,
                    HoverFeatureDirective,
                    SwipeControlComponent,
                    MapCenterComponent,
                    MenuButtonComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoMapModule, { declarations: [MapBrowserComponent,
        ZoomButtonComponent,
        GeolocateButtonComponent,
        HomeExtentButtonComponent,
        RotationButtonComponent,
        InfoSectionComponent,
        BaseLayersSwitcherComponent,
        MiniBaseMapComponent,
        MapOfflineDirective,
        OfflineButtonComponent,
        PointerPositionDirective,
        HoverFeatureDirective,
        SwipeControlComponent,
        MapCenterComponent,
        MenuButtonComponent], imports: [CommonModule,
        IgoLanguageModule,
        IgoConfirmDialogModule,
        MatIconModule,
        MatButtonModule,
        MatTooltipModule], exports: [MapBrowserComponent,
        ZoomButtonComponent,
        GeolocateButtonComponent,
        HomeExtentButtonComponent,
        RotationButtonComponent,
        InfoSectionComponent,
        BaseLayersSwitcherComponent,
        MiniBaseMapComponent,
        MapOfflineDirective,
        OfflineButtonComponent,
        PointerPositionDirective,
        HoverFeatureDirective,
        SwipeControlComponent,
        MapCenterComponent,
        MenuButtonComponent] }); })();
i0.ɵɵsetComponentScope(BaseLayersSwitcherComponent, [i1$1.NgIf, i1$1.NgClass, i2.MatButton, i3.MatTooltip, i4.MatIcon, i1$1.NgForOf, MiniBaseMapComponent], [i7.TranslatePipe]);
i0.ɵɵsetComponentScope(MiniBaseMapComponent, [i1$1.NgIf, MapBrowserComponent], []);

function MeasurerItemComponent_mat_option_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 5);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const measureUnit_r1 = ctx.$implicit;
    i0.ɵɵproperty("value", measureUnit_r1);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.measure." + measureUnit_r1), " ");
} }
/**
 * Measurer item
 */
class MeasurerItemComponent {
    constructor() {
        /**
         * Measure observable
         * @internal
         */
        this.measure$ = new BehaviorSubject(undefined);
        this._auto = false;
        /**
         * Event emitted when the measure unit changes
         */
        this.measureUnitChange = new EventEmitter();
    }
    /**
     * Measure
     */
    set measure(value) {
        this.measure$.next(value);
    }
    get measure() { return this.measure$.value; }
    /**
     * Whther measure units should be automatically determined
     */
    set auto(value) { this.toggleAutoUnit(value); }
    get auto() { return this._auto; }
    /**
     * Available measure units for the measure type given
     * @internal
     */
    get measureUnits() {
        if (this.measureType === MeasureType.Area) {
            return Object.values(MeasureAreaUnit);
        }
        return Object.values(MeasureLengthUnit);
    }
    /**
     * Toggle the auto unit off
     * @internal
     */
    ngOnDestroy() {
        this.toggleAutoUnit(false);
    }
    /**
     * Set the measure unit
     * @internal
     */
    onMeasureUnitChange(unit) {
        this.measureUnit = unit;
        this.measureUnitChange.emit(unit);
    }
    toggleAutoUnit(toggle) {
        if (this.measure$$ !== undefined) {
            this.measure$$.unsubscribe();
        }
        if (toggle === true) {
            this.measure$$ = this.measure$.subscribe((measure) => {
                this.computeBestMeasureUnit(measure);
            });
        }
        this._auto = toggle;
    }
    computeBestMeasureUnit(measure) {
        let measureUnit = this.measureUnit;
        if (this.measureType === MeasureType.Area) {
            measureUnit = computeBestAreaUnit(measure);
        }
        else if (this.measureType === MeasureType.Length) {
            measureUnit = computeBestLengthUnit(measure);
        }
        if (measureUnit !== this.measureUnit) {
            this.onMeasureUnitChange(measureUnit);
        }
    }
}
MeasurerItemComponent.ɵfac = function MeasurerItemComponent_Factory(t) { return new (t || MeasurerItemComponent)(); };
MeasurerItemComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MeasurerItemComponent, selectors: [["igo-measurer-item"]], inputs: { measureType: "measureType", measureUnit: "measureUnit", measure: "measure", auto: "auto", placeholder: "placeholder" }, outputs: { measureUnitChange: "measureUnitChange" }, decls: 9, vars: 11, consts: [["appearance", "outline", "floatLabel", "always", 1, "measure-field"], ["matInput", "", 3, "readonly", "value"], [1, "unit-field"], [3, "value", "disabled", "selectionChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"]], template: function MeasurerItemComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "mat-form-field", 0);
        i0.ɵɵelementStart(1, "mat-label");
        i0.ɵɵtext(2);
        i0.ɵɵelementEnd();
        i0.ɵɵelement(3, "input", 1);
        i0.ɵɵpipe(4, "measureFormat");
        i0.ɵɵpipe(5, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(6, "mat-form-field", 2);
        i0.ɵɵelementStart(7, "mat-select", 3);
        i0.ɵɵlistener("selectionChange", function MeasurerItemComponent_Template_mat_select_selectionChange_7_listener($event) { return ctx.onMeasureUnitChange($event.value); });
        i0.ɵɵtemplate(8, MeasurerItemComponent_mat_option_8_Template, 3, 4, "mat-option", 4);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵtextInterpolate(ctx.placeholder);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("readonly", true)("value", i0.ɵɵpipeBind2(4, 6, i0.ɵɵpipeBind1(5, 9, ctx.measure$) || 0, ctx.measureUnit));
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("value", ctx.measureUnit)("disabled", ctx.auto);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.measureUnits);
    } }, directives: [i12.MatFormField, i12.MatLabel, i5$1.MatInput, i13.MatSelect, i1$1.NgForOf, i9.MatOption], pipes: [MeasureFormatPipe, i1$1.AsyncPipe, i7.TranslatePipe], styles: ["[_nghost-%COMP%]{display:flex;width:100%;padding:5px 10px}.measure-field[_ngcontent-%COMP%]{pointer-events:none;display:flex;flex-flow:column nowrap;width:100%}.unit-field[_ngcontent-%COMP%]{width:50px;margin-left:10px;margin-top:10px}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MeasurerItemComponent, [{
        type: Component,
        args: [{
                selector: 'igo-measurer-item',
                templateUrl: './measurer-item.component.html',
                styleUrls: ['./measurer-item.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { measureType: [{
            type: Input
        }], measureUnit: [{
            type: Input
        }], measure: [{
            type: Input
        }], auto: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], measureUnitChange: [{
            type: Output
        }] }); })();

/**
 * @ignore
 */
class IgoMeasurerModule {
}
IgoMeasurerModule.ɵfac = function IgoMeasurerModule_Factory(t) { return new (t || IgoMeasurerModule)(); };
IgoMeasurerModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoMeasurerModule });
IgoMeasurerModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatButtonModule,
            MatButtonToggleModule,
            MatIconModule,
            MatTooltipModule,
            MatFormFieldModule,
            MatInputModule,
            MatSelectModule,
            MatSlideToggleModule,
            MatDividerModule,
            IgoLanguageModule,
            IgoEntityTableModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoMeasurerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatButtonModule,
                    MatButtonToggleModule,
                    MatIconModule,
                    MatTooltipModule,
                    MatFormFieldModule,
                    MatInputModule,
                    MatSelectModule,
                    MatSlideToggleModule,
                    MatDividerModule,
                    IgoLanguageModule,
                    IgoEntityTableModule
                ],
                declarations: [
                    MeasureFormatPipe,
                    MeasurerItemComponent,
                    MeasurerComponent,
                    MeasurerDialogComponent
                ],
                exports: [
                    MeasureFormatPipe,
                    MeasurerComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoMeasurerModule, { declarations: [MeasureFormatPipe,
        MeasurerItemComponent,
        MeasurerComponent,
        MeasurerDialogComponent], imports: [CommonModule,
        MatButtonModule,
        MatButtonToggleModule,
        MatIconModule,
        MatTooltipModule,
        MatFormFieldModule,
        MatInputModule,
        MatSelectModule,
        MatSlideToggleModule,
        MatDividerModule,
        IgoLanguageModule,
        IgoEntityTableModule], exports: [MeasureFormatPipe,
        MeasurerComponent] }); })();
i0.ɵɵsetComponentScope(MeasurerComponent, [i18.MatButtonToggleGroup, i18.MatButtonToggle, i22.MatSlideToggle, i1$1.NgIf, i10.MatDivider, MeasurerItemComponent, i2.MatButton, i3.MatTooltip, i4.MatIcon, i6.EntityTableComponent], [i7.TranslatePipe, i1$1.AsyncPipe]);
i0.ɵɵsetComponentScope(MeasurerDialogComponent, [i1$1.NgIf], [i7.TranslatePipe, MeasureFormatPipe]);

class IgoMeasureModule {
}
IgoMeasureModule.ɵfac = function IgoMeasureModule_Factory(t) { return new (t || IgoMeasureModule)(); };
IgoMeasureModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoMeasureModule });
IgoMeasureModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[], IgoMeasurerModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoMeasureModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [],
                exports: [
                    IgoMeasurerModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoMeasureModule, { exports: [IgoMeasurerModule] }); })();

var OverlayAction;
(function (OverlayAction) {
    OverlayAction[OverlayAction["None"] = 0] = "None";
    OverlayAction[OverlayAction["Move"] = 1] = "Move";
    OverlayAction[OverlayAction["Zoom"] = 2] = "Zoom";
    OverlayAction[OverlayAction["ZoomIfOutMapExtent"] = 3] = "ZoomIfOutMapExtent";
})(OverlayAction || (OverlayAction = {}));

class OverlayService {
    constructor() {
        this.features$ = new BehaviorSubject([
            [],
            undefined
        ]);
    }
    setFeatures(features, action = OverlayAction.None) {
        this.features$.next([features, action]);
    }
    clear() {
        this.features$.next([[], OverlayAction.None]);
    }
}
OverlayService.ɵfac = function OverlayService_Factory(t) { return new (t || OverlayService)(); };
OverlayService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: OverlayService, factory: OverlayService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OverlayService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

class OverlayDirective {
    constructor(component, overlayService) {
        this.component = component;
        this.overlayService = overlayService;
        this.format = new OlGeoJSON();
    }
    get map() {
        return this.component.map;
    }
    ngOnInit() {
        this.features$$ = this.overlayService.features$.subscribe(res => this.handleFeatures(res[0], res[1]));
    }
    ngOnDestroy() {
        this.features$$.unsubscribe();
    }
    handleFeatures(features, action) { }
}
OverlayDirective.ɵfac = function OverlayDirective_Factory(t) { return new (t || OverlayDirective)(i0.ɵɵdirectiveInject(MapBrowserComponent, 2), i0.ɵɵdirectiveInject(OverlayService)); };
OverlayDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: OverlayDirective, selectors: [["", "igoOverlay", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OverlayDirective, [{
        type: Directive,
        args: [{
                selector: '[igoOverlay]'
            }]
    }], function () { return [{ type: MapBrowserComponent, decorators: [{
                type: Self
            }] }, { type: OverlayService }]; }, null); })();

class IgoOverlayModule {
    static forRoot() {
        return {
            ngModule: IgoOverlayModule
        };
    }
}
IgoOverlayModule.ɵfac = function IgoOverlayModule_Factory(t) { return new (t || IgoOverlayModule)(); };
IgoOverlayModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoOverlayModule });
IgoOverlayModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoOverlayModule, [{
        type: NgModule,
        args: [{
                imports: [],
                exports: [OverlayDirective],
                declarations: [OverlayDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoOverlayModule, { declarations: [OverlayDirective], exports: [OverlayDirective] }); })();

class PrintService {
    constructor(http, messageService, activityService, languageService) {
        this.http = http;
        this.messageService = messageService;
        this.activityService = activityService;
        this.languageService = languageService;
    }
    print(map, options) {
        const status$ = new Subject();
        const paperFormat = options.paperFormat;
        const resolution = +options.resolution; // Default is 96
        const orientation = options.orientation;
        const legendPostion = options.legendPosition;
        this.activityId = this.activityService.register();
        const doc = new jspdf({
            orientation,
            format: paperFormat.toLowerCase()
        });
        const dimensions = [
            doc.internal.pageSize.width,
            doc.internal.pageSize.height
        ];
        const margins = [10, 10, 10, 10];
        const width = dimensions[0] - margins[3] - margins[1];
        const height = dimensions[1] - margins[0] - margins[2];
        const size = [width, height];
        let titleSizeResults = [0, 0];
        if (options.title !== undefined) {
            titleSizeResults = this.getTitleSize(options.title, width, height, doc); // return : size(pt) and left margin (mm)
            this.addTitle(doc, options.title, titleSizeResults[0], margins[3] + titleSizeResults[1], titleSizeResults[0] * (25.4 / 72));
        }
        if (options.subtitle !== undefined) {
            let subtitleSizeResult = 0;
            const titleH = titleSizeResults[0];
            subtitleSizeResult = this.getSubTitleSize(options.subtitle, width, height, doc); // return : size(pt) and left margin (mm)
            this.addSubTitle(doc, options.subtitle, titleH * 0.7, margins[3] + subtitleSizeResult, titleH * 1.7 * (25.4 / 72));
            margins[0] = margins[0] + titleSizeResults[0] * 0.7 * (25.4 / 72);
        }
        if (options.showProjection === true || options.showScale === true) {
            this.addProjScale(doc, map, resolution, options.showProjection, options.showScale);
        }
        if (options.comment !== '') {
            this.addComment(doc, options.comment);
        }
        this.addMap(doc, map, resolution, size, margins).subscribe((status) => __awaiter(this, void 0, void 0, function* () {
            if (status === SubjectStatus.Done) {
                yield this.addScale(doc, map, margins);
                yield this.handleMeasureLayer(doc, map, margins);
                if (options.legendPosition !== 'none') {
                    if (['topleft', 'topright', 'bottomleft', 'bottomright'].indexOf(options.legendPosition) > -1) {
                        yield this.addLegendSamePage(doc, map, margins, resolution, options.legendPosition);
                    }
                    else if (options.legendPosition === 'newpage') {
                        yield this.addLegend(doc, map, margins, resolution);
                    }
                }
                else {
                    yield this.saveDoc(doc);
                }
            }
            if (status === SubjectStatus.Done || status === SubjectStatus.Error) {
                this.activityService.unregister(this.activityId);
                status$.next(SubjectStatus.Done);
            }
        }));
        return status$;
    }
    /**
     * Add measure overlay on the map on the document when the measure layer is present
     * @param  doc - Pdf document where measure tooltip will be added
     * @param  map - Map of the app
     * @param  margins - Page margins
     */
    handleMeasureLayer(doc, map, margins) {
        return __awaiter(this, void 0, void 0, function* () {
            if (map.layers.find(layer => layer.visible && layer.id.startsWith('igo-measures-'))) {
                let canvasOverlayHTMLMeasures;
                const mapOverlayMeasuresHTML = map.ol.getOverlayContainer();
                yield html2canvas(mapOverlayMeasuresHTML, {
                    scale: 1,
                    backgroundColor: null
                }).then(e => {
                    canvasOverlayHTMLMeasures = e;
                });
                this.addCanvas(doc, canvasOverlayHTMLMeasures, margins); // this adds measure overlays
            }
        });
    }
    /**
     * Get html code for all layers legend
     * @param  map IgoMap
     * @param  width The width that the legend need to be
     * @return Html code for the legend
     */
    getLayersLegendHtml(map$1, width, resolution) {
        return new Observable((observer) => {
            let html = '';
            const legends = getLayersLegends(map$1.layers, {
                resolution: map$1.viewController.getResolution(),
                extent: map$1.viewController.getExtent(),
                projection: map$1.viewController.getOlProjection().getCode(),
                scale: map$1.viewController.getScale(resolution),
                size: map$1.ol.getSize()
            });
            if (legends.length === 0) {
                observer.next(html);
                observer.complete();
                return;
            }
            // Define important style to be sure that all container is convert
            // to image not just visible part
            html += '<style media="screen" type="text/css">';
            html += '.html2canvas-container { width: ' + width + 'mm !important; height: 2000px !important; }';
            html += 'table.tableLegend {table-layout: auto;}';
            html += 'div.styleLegend {padding-top: 5px; padding-right:5px;padding-left:5px;padding-bottom:5px;}';
            html += '</style>';
            // The font size will also be lowered afterwards (globally along the legend size)
            // this allows having a good relative font size here and to keep ajusting the legend size
            // while keeping good relative font size
            html += '<font size="3" face="Times" >';
            html += '<div class="styleLegend">';
            html += '<table class="tableLegend" >';
            // For each legend, define an html table cell
            const images$ = legends.map((legend) => this.getDataImage(legend.url).pipe(map((dataImage) => {
                let htmlImg = '<tr><td>' + legend.title.toUpperCase() + '</td></tr>';
                htmlImg += '<tr><td><img src="' + dataImage + '"></td></tr>';
                return htmlImg;
            })));
            forkJoin(images$).subscribe((dataImages) => {
                html = dataImages.reduce((acc, current) => (acc += current), html);
                html += '</table>';
                html += '</div>';
                observer.next(html);
                observer.complete();
            });
        });
    }
    getDataImage(url) {
        const secureIMG = new SecureImagePipe(this.http);
        return secureIMG.transform(url);
    }
    /**
     * Get all the legend in a single image
     * * @param  format - Image format. default value to "png"
     * @return The image of the legend
     */
    getLayersLegendImage(map, format = 'png', doZipFile, resolution) {
        return __awaiter(this, void 0, void 0, function* () {
            const status$ = new Subject();
            // Get html code for the legend
            const width = 200; // milimeters unit, originally define for document pdf
            let html = yield this.getLayersLegendHtml(map, width, resolution).toPromise();
            format = format.toLowerCase();
            // If no legend show No LEGEND in an image
            if (html.length === 0) {
                html = '<font size="12" face="Courier New" >';
                html += '<div align="center"><b>NO LEGEND</b></div>';
            }
            // Create div to contain html code for legend
            const div = window.document.createElement('div');
            div.style.position = 'absolute';
            div.style.top = '0';
            // Add html code to convert in the new window
            window.document.body.appendChild(div);
            div.innerHTML = html;
            yield this.timeout(1);
            const canvas = yield html2canvas(div, { useCORS: true }).catch((e) => {
                console.log(e);
            });
            if (canvas) {
                let status = SubjectStatus.Done;
                try {
                    if (!doZipFile) {
                        // Save the canvas as file
                        this.saveCanvasImageAsFile(canvas, 'legendImage', format);
                    }
                    else {
                        // Add the canvas to zip
                        this.generateCanvaFileToZip(canvas, 'legendImage' + '.' + format);
                    }
                    div.parentNode.removeChild(div); // remove temp div (IE)
                }
                catch (err) {
                    status = SubjectStatus.Error;
                }
                status$.next(status);
            }
            return status$;
        });
    }
    getTitleSize(title, pageWidth, pageHeight, doc) {
        const pdfResolution = 96;
        const titleSize = Math.round(2 * (pageHeight + 145) * 0.05) / 2;
        doc.setFont('Times', 'bold');
        const width = doc.getTextWidth(title);
        const titleWidth = doc.getStringUnitWidth(title) * titleSize / doc.internal.scaleFactor;
        const titleTailleMinimale = Math.round(2 * (pageHeight + 150) * 0.037) / 2;
        let titleFontSize = 0;
        let titleMarginLeft;
        if (titleWidth >= (pageWidth)) {
            titleMarginLeft = 0;
            titleFontSize = Math.round(((pageWidth / title.length) * pdfResolution) / 25.4);
            // If the formula to find the font size gives below the defined minimum size
            if (titleFontSize < titleTailleMinimale) {
                titleFontSize = titleTailleMinimale;
            }
        }
        else {
            titleMarginLeft = (pageWidth - titleWidth) / 2;
            titleFontSize = titleSize;
        }
        return [titleFontSize, titleMarginLeft];
    }
    getSubTitleSize(subtitle, pageWidth, pageHeight, doc) {
        const subtitleSize = 0.7 * Math.round(2 * (pageHeight + 145) * 0.05) / 2; // 70% of the title's font size
        doc.setFont('Times', 'bold');
        const subtitleWidth = doc.getStringUnitWidth(subtitle) * subtitleSize / doc.internal.scaleFactor;
        let subtitleMarginLeft;
        if (subtitleWidth >= (pageWidth)) {
            subtitleMarginLeft = 0;
        }
        else {
            subtitleMarginLeft = (pageWidth - subtitleWidth) / 2;
        }
        return subtitleMarginLeft;
    }
    addTitle(doc, title, titleFontSize, titleMarginLeft, titleMarginTop) {
        doc.setFont('Times', 'bold');
        doc.setFontSize(titleFontSize);
        doc.text(title, titleMarginLeft, titleMarginTop);
    }
    addSubTitle(doc, subtitle, subtitleFontSize, subtitleMarginLeft, subtitleMarginTop) {
        doc.setFont('Times', 'bold');
        doc.setFontSize(subtitleFontSize);
        doc.text(subtitle, subtitleMarginLeft, subtitleMarginTop);
    }
    /**
     * Add comment to the document
     * * @param  doc - pdf document
     * * @param  comment - Comment to add in the document
     * * @param  size - Size of the document
     */
    addComment(doc, comment) {
        const commentSize = 16;
        const commentMarginLeft = 20;
        const marginBottom = 5;
        const heightPixels = doc.internal.pageSize.height - marginBottom;
        doc.setFont('courier');
        doc.setFontSize(commentSize);
        doc.text(comment, commentMarginLeft, heightPixels);
    }
    /**
     * Add projection and/or scale to the document
     * @param  doc - pdf document
     * @param  map - Map of the app
     * @param  dpi - DPI resolution of the document
     * @param  projection - Bool to indicate if projection need to be added
     * @param  scale - Bool to indicate if scale need to be added
     */
    addProjScale(doc, map, dpi, projection, scale) {
        const translate = this.languageService.translate;
        const projScaleSize = 16;
        const projScaleMarginLeft = 20;
        const marginBottom = 15;
        const heightPixels = doc.internal.pageSize.height - marginBottom;
        let textProjScale = '';
        if (projection === true) {
            const projText = translate.instant('igo.geo.printForm.projection');
            textProjScale += projText + ': ' + map.projection;
        }
        if (scale === true) {
            if (projection === true) {
                textProjScale += '   ';
            }
            const scaleText = translate.instant('igo.geo.printForm.scale');
            const mapScale = map.viewController.getScale(dpi);
            textProjScale += scaleText + ': ~ 1 / ' + formatScale(mapScale);
        }
        doc.setFont('courier');
        doc.setFontSize(projScaleSize);
        doc.text(textProjScale, projScaleMarginLeft, heightPixels);
    }
    /**
     * Add the legend to the document
     * @param  doc - Pdf document where legend will be added
     * @param  map - Map of the app
     * @param  margins - Page margins
     */
    addLegend(doc, map, margins, resolution) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get html code for the legend
            const width = doc.internal.pageSize.width;
            const html = yield this.getLayersLegendHtml(map, width, resolution).toPromise();
            // If no legend, save the map directly
            if (html === '') {
                yield this.saveDoc(doc);
                return true;
            }
            // Create div to contain html code for legend
            const div = window.document.createElement('div');
            div.style.position = 'absolute';
            div.style.top = '0';
            // Add html code to convert in the new window
            window.document.body.appendChild(div);
            div.innerHTML = html;
            yield this.timeout(1);
            const canvas = yield html2canvas(div, { useCORS: true }).catch((e) => {
                console.log(e);
            });
            if (canvas) {
                const pourcentageReduction = 0.85;
                const imageSize = [pourcentageReduction * (25.4 * canvas.width) / resolution, pourcentageReduction
                        * (25.4 * canvas.height) / resolution];
                let imgData;
                doc.addPage();
                imgData = canvas.toDataURL('image/png');
                doc.addImage(imgData, 'PNG', 10, 10, imageSize[0], imageSize[1]);
                div.parentNode.removeChild(div); // remove temp div (IE style)
            }
            yield this.saveDoc(doc);
        });
    }
    /**
     * Add the legend to the document
     * @param  doc - Pdf document where legend will be added
     * @param  map - Map of the app
     * @param  margins - Page margins
     */
    addLegendSamePage(doc, map, margins, resolution, legendPosition) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get html code for the legend
            const width = doc.internal.pageSize.width;
            const html = yield this.getLayersLegendHtml(map, width, resolution).toPromise();
            // If no legend, save the map directly
            if (html === '') {
                yield this.saveDoc(doc);
                return true;
            }
            // Create div to contain html code for legend
            const div = window.document.createElement('div');
            div.style.position = 'absolute';
            div.style.top = '0';
            // Add html code to convert in the new window
            window.document.body.appendChild(div);
            div.innerHTML = html;
            yield this.timeout(1);
            const canvas = yield html2canvas(div, { useCORS: true }).catch((e) => {
                console.log(e);
            });
            let marginsLegend;
            if (canvas) {
                const pourcentageReduction = 0.85;
                const imageSize = [pourcentageReduction * (25.4 * canvas.width) / resolution,
                    pourcentageReduction * (25.4 * canvas.height) / resolution];
                // Move the legend to the correct position on the page
                if (legendPosition === 'bottomright') {
                    marginsLegend = [doc.internal.pageSize.height - margins[2] - imageSize[1], margins[1],
                        margins[2], doc.internal.pageSize.width - margins[1] - imageSize[0]];
                }
                else if (legendPosition === 'topright') {
                    marginsLegend = [margins[0], margins[1], doc.internal.pageSize.height - margins[0] - imageSize[1],
                        doc.internal.pageSize.width - margins[1] - imageSize[0]];
                }
                else if (legendPosition === 'bottomleft') {
                    // When the legend is in the bottom left, raise the legend slightly upward so that attributions are visible
                    marginsLegend = [doc.internal.pageSize.height - margins[2] - imageSize[1] - 15,
                        doc.internal.pageSize.width - margins[3] - imageSize[0], margins[2] + 15, margins[3]];
                }
                else if (legendPosition === 'topleft') {
                    marginsLegend = [margins[0], doc.internal.pageSize.width - margins[3] - imageSize[0],
                        doc.internal.pageSize.height - margins[0] - imageSize[1], margins[3]];
                }
                this.addCanvas(doc, canvas, marginsLegend); // this adds the legend
                div.parentNode.removeChild(div); // remove temp div (IE style)
                yield this.saveDoc(doc);
            }
        });
    }
    /**
     * Add scale and attributions on the map on the document
     * @param  doc - Pdf document where legend will be added
     * @param  map - Map of the app
     * @param  margins - Page margins
     */
    addScale(doc, map, margins) {
        return __awaiter(this, void 0, void 0, function* () {
            const mapSize = map.ol.getSize();
            const extent = map.ol.getView().calculateExtent(mapSize);
            // Get the scale and attribution
            // we use cloneNode to modify the nodes to print without modifying it on the page, using deep:true to get children
            let canvasOverlayHTML;
            const mapOverlayHTML = map.ol.getOverlayContainerStopEvent();
            // Remove the UI buttons from the nodes
            const OverlayHTMLButtons = mapOverlayHTML.getElementsByTagName('button');
            const OverlayHTMLButtonsarr = Array.from(OverlayHTMLButtons);
            for (const OverlayHTMLButton of OverlayHTMLButtonsarr) {
                OverlayHTMLButton.setAttribute('data-html2canvas-ignore', 'true');
            }
            // Change the styles of hyperlink in the printed version
            // Transform the Overlay into a canvas
            // scale is necessary to make it in google chrome
            // background as null because otherwise it is white and cover the map
            // allowtaint is to allow rendering images in the attributions
            // useCORS: true pour permettre de renderer les images (ne marche pas en local)
            const canvas = yield html2canvas(mapOverlayHTML, {
                scale: 1,
                backgroundColor: null,
                allowTaint: true,
                useCORS: true,
            }).then(e => {
                canvasOverlayHTML = e;
            });
            this.addCanvas(doc, canvasOverlayHTML, margins); // this adds scales and attributions
        });
    }
    defineNbFileToProcess(nbFileToProcess) {
        this.nbFileToProcess = nbFileToProcess;
    }
    timeout(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    addCanvas(doc, canvas, margins) {
        let image;
        if (canvas) {
            image = canvas.toDataURL('image/png');
        }
        if (image !== undefined) {
            const imageSize = this.getImageSizeToFitPdf(doc, canvas, margins);
            doc.addImage(image, 'PNG', margins[3], margins[0], imageSize[0], imageSize[1]);
            doc.rect(margins[3], margins[0], imageSize[0], imageSize[1]);
        }
    }
    // TODO fix printing with image resolution
    addMap(doc, map, resolution, size, margins) {
        const status$ = new Subject();
        const mapSize = map.ol.getSize();
        const extent = map.ol.getView().calculateExtent(mapSize);
        const widthPixels = Math.round((size[0] * resolution) / 25.4);
        const heightPixels = Math.round((size[1] * resolution) / 25.4);
        let timeout;
        map.ol.once('rendercomplete', (event) => {
            const canvases = event.target.getViewport().getElementsByTagName('canvas');
            const mapStatus$$ = map.status$.subscribe((mapStatus) => {
                clearTimeout(timeout);
                if (mapStatus !== SubjectStatus.Done) {
                    return;
                }
                mapStatus$$.unsubscribe();
                let status = SubjectStatus.Done;
                try {
                    for (const canvas of canvases) {
                        if (canvas.width !== 0) {
                            this.addCanvas(doc, canvas, margins);
                        }
                    }
                }
                catch (err) {
                    status = SubjectStatus.Error;
                    this.messageService.error(this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'));
                }
                this.renderMap(map, mapSize, extent);
                status$.next(status);
            });
            // If no loading as started after 200ms, then probably no loading
            // is required.
            timeout = window.setTimeout(() => {
                mapStatus$$.unsubscribe();
                let status = SubjectStatus.Done;
                try {
                    for (const canvas of canvases) {
                        if (canvas.width !== 0) {
                            this.addCanvas(doc, canvas, margins);
                        }
                    }
                }
                catch (err) {
                    status = SubjectStatus.Error;
                    this.messageService.error(this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'));
                }
                this.renderMap(map, mapSize, extent);
                status$.next(status);
            }, 200);
        });
        this.renderMap(map, [widthPixels, heightPixels], extent);
        return status$;
    }
    /**
     * Download an image of the map with addition of informations
     * @param  map - Map of the app
     * @param  format - Image format. default value to "png"
     * @param  projection - Indicate if projection need to be add. Default to false
     * @param  scale - Indicate if scale need to be add. Default to false
     * @param  legend - Indicate if the legend of layers need to be download. Default to false
     * @param  title - Title to add for the map - Default to blank
     * @param  subtitle - Subtitle to add for the map - Default to blank
     * @param  comment - Comment to add for the map - Default to blank
     * @param  doZipFile - Indicate if we do a zip with the file
     * @return Image file of the map with extension format given as parameter
     */
    downloadMapImage(map, resolution, format = 'png', projection = false, scale = false, legend = false, title = '', subtitle = '', comment = '', doZipFile = true) {
        const status$ = new Subject();
        // const resolution = map.ol.getView().getResolution();
        this.activityId = this.activityService.register();
        const translate = this.languageService.translate;
        map.ol.once('rendercomplete', (event) => {
            format = format.toLowerCase();
            const oldCanvas = event.target
                .getViewport()
                .getElementsByTagName('canvas')[0];
            const newCanvas = document.createElement('canvas');
            const newContext = newCanvas.getContext('2d');
            // Postion in height to set the canvas in new canvas
            let positionHCanvas = 0;
            // Position in width to set the Proj/Scale in new canvas
            let positionWProjScale = 10;
            // Get height/width of map canvas
            const width = oldCanvas.width;
            let height = oldCanvas.height;
            // Set Font to calculate comment width
            newContext.font = '20px Calibri';
            const commentWidth = newContext.measureText(comment).width;
            // Add height for title if defined
            height = title !== '' ? height + 30 : height;
            // Add height for title if defined
            height = subtitle !== '' ? height + 30 : height;
            // Add height for projection or scale (same line) if defined
            height = projection !== false || scale !== false ? height + 30 : height;
            const positionHProjScale = height - 10;
            // Define number of line depending of the comment length
            const commentNbLine = Math.ceil(commentWidth / width);
            // Add height for multiline comment if defined
            height = comment !== '' ? height + commentNbLine * 30 : height;
            let positionHComment = height - commentNbLine * 20 + 5;
            // Set the new canvas with the new calculated size
            newCanvas.width = width;
            newCanvas.height = height;
            // Patch Jpeg default black background to white
            if (format === 'jpeg') {
                newContext.fillStyle = '#ffffff';
                newContext.fillRect(0, 0, width, height);
                newContext.fillStyle = '#000000';
            }
            // If a title need to be added to canvas
            if (title !== '') {
                // Set font for title
                // Adjust according to title length
                newContext.font = '26px Calibri';
                positionHCanvas = 30;
                newContext.textAlign = 'center';
                newContext.fillText(title, width / 2, 20, width * 0.9);
            }
            if (subtitle !== '') {
                // Set font for subtitle
                // Adjust according to title length
                newContext.font = '26px Calibri';
                positionHCanvas = 60;
                newContext.textAlign = 'center';
                newContext.fillText(subtitle, width / 2, 50, width * 0.9);
            }
            // Set font for next section
            newContext.font = '20px Calibri';
            // If projection need to be added to canvas
            if (projection !== false) {
                const projText = translate.instant('igo.geo.printForm.projection');
                newContext.textAlign = 'start';
                newContext.fillText(projText + ': ' + map.projection, positionWProjScale, positionHProjScale);
                positionWProjScale += 200; // Width position change for scale position
            }
            // If scale need to be added to canvas
            if (scale !== false) {
                const scaleText = translate.instant('igo.geo.printForm.scale');
                const mapScale = map.viewController.getScale(resolution);
                newContext.textAlign = 'start';
                newContext.fillText(scaleText + ': ~ 1 / ' + formatScale(mapScale), positionWProjScale, positionHProjScale);
            }
            // If a comment need to be added to canvas
            if (comment !== '') {
                newContext.textAlign = 'center';
                // If only one line, no need to multiline the comment
                if (commentNbLine === 1) {
                    newContext.fillText(comment, width / 2, positionHComment);
                }
                else {
                    // Separate the setenses to be approx. the same length
                    const nbCommentChar = comment.length;
                    const CommentLengthToCut = Math.floor(nbCommentChar / commentNbLine);
                    let commentCurrentLine = '';
                    let positionFirstCutChar = 0;
                    let positionLastBlank;
                    // Loop for the number of line calculated
                    for (let i = 0; i < commentNbLine; i++) {
                        // For all line except last
                        if (commentNbLine - 1 > i) {
                            // Get comment current line to find the right place tu cut comment
                            commentCurrentLine = comment.substr(positionFirstCutChar, CommentLengthToCut);
                            // Cut the setence at blank
                            positionLastBlank = commentCurrentLine.lastIndexOf(' ');
                            newContext.fillText(commentCurrentLine.substr(0, positionLastBlank), width / 2, positionHComment);
                            positionFirstCutChar += positionLastBlank;
                            // Go to next line for insertion
                            positionHComment += 20;
                        }
                        else {
                            // Don't cut last part
                            newContext.fillText(comment.substr(positionFirstCutChar), width / 2, positionHComment);
                        }
                    }
                }
            }
            // Add map to new canvas
            newContext.drawImage(oldCanvas, 0, positionHCanvas);
            let status = SubjectStatus.Done;
            try {
                // Save the canvas as file
                if (!doZipFile) {
                    this.saveCanvasImageAsFile(newCanvas, 'map', format);
                }
                else if (format.toLowerCase() === 'tiff') {
                    // Add the canvas to zip
                    this.generateCanvaFileToZip(newCanvas, 'map' + map.projection.replace(':', '_') + '.' + format);
                }
                else {
                    // Add the canvas to zip
                    this.generateCanvaFileToZip(newCanvas, 'map' + '.' + format);
                }
            }
            catch (err) {
                status = SubjectStatus.Error;
            }
            status$.next(status);
            if (format.toLowerCase() === 'tiff') {
                const tiwContent = this.getWorldFileInformation(map);
                const blob = new Blob([tiwContent], {
                    type: 'text/plain;charset=utf-8'
                });
                if (!doZipFile) {
                    // saveAs automaticly replace ':' for '_'
                    saveAs(blob, 'map' + map.projection + '.tfw');
                    this.saveFileProcessing();
                }
                else {
                    // Add the canvas to zip
                    this.addFileToZip('map' + map.projection.replace(':', '_') + '.tfw', blob);
                }
            }
        });
        map.ol.renderSync();
        return status$;
    }
    renderMap(map, size, extent) {
        map.ol.updateSize();
        map.ol.renderSync();
    }
    /**
     * Save document
     * @param  doc - Document to save
     */
    saveDoc(doc) {
        return __awaiter(this, void 0, void 0, function* () {
            yield doc.save('map.pdf', { returnPromise: true });
        });
    }
    /**
     * Calculate the best Image size to fit in pdf
     * @param doc - Pdf Document
     * @param canvas - Canvas of image
     * @param margins - Page margins
     */
    getImageSizeToFitPdf(doc, canvas, margins) {
        // Define variable to calculate best size to fit in one page
        const pageHeight = doc.internal.pageSize.getHeight() - (margins[0] + margins[2]);
        const pageWidth = doc.internal.pageSize.getWidth() - (margins[1] + margins[3]);
        const canHeight = canvas.height;
        const canWidth = canvas.width;
        const heightRatio = canHeight / pageHeight;
        const widthRatio = canWidth / pageWidth;
        const maxRatio = heightRatio > widthRatio ? heightRatio : widthRatio;
        const imgHeigh = maxRatio > 1 ? canHeight / maxRatio : canHeight;
        const imgWidth = maxRatio > 1 ? canWidth / maxRatio : canWidth;
        return [imgWidth, imgHeigh];
    }
    /**
     * Get a world file information for tiff
     * @param  map - Map of the app
     */
    getWorldFileInformation(map) {
        const currentResolution = map.viewController.getResolution();
        const currentExtent = map.viewController.getExtent(); // Return [minx, miny, maxx, maxy]
        return [
            currentResolution,
            0,
            0,
            -currentResolution,
            currentExtent[0] + currentResolution / 0.5,
            currentExtent[3] - currentResolution / 0.5
        ].join('\n');
    }
    /**
     * Save canvas image as file
     * @param canvas - Canvas to save
     * @param name - Name of the file
     * @param format - file format
     */
    saveCanvasImageAsFile(canvas, name, format) {
        const blobFormat = 'image/' + format;
        const that = this;
        try {
            canvas.toDataURL(); // Just to make the catch trigger wihtout toBlob Error throw not catched
            // If navigator is Internet Explorer
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(canvas.msToBlob(), name + '.' + format);
                this.saveFileProcessing();
            }
            else {
                canvas.toBlob((blob) => {
                    // download image
                    saveAs(blob, name + '.' + format);
                    that.saveFileProcessing();
                }, blobFormat);
            }
        }
        catch (err) {
            this.messageService.error(this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'));
        }
    }
    /**
     * Add file to a zip
     * @param canvas - File to add to the zip
     * @param  name -Name of the fileoverview
     */
    generateCanvaFileToZip(canvas, name) {
        const blobFormat = 'image/' + 'jpeg';
        const that = this;
        if (!this.hasOwnProperty('zipFile') ||
            typeof this.zipFile === 'undefined') {
            this.zipFile = new JSZip();
        }
        try {
            canvas.toDataURL(); // Just to make the catch trigger wihtout toBlob Error throw not catched
            if (navigator.msSaveBlob) {
                this.addFileToZip(name, canvas.msToBlob());
            }
            else {
                canvas.toBlob((blob) => {
                    that.addFileToZip(name, blob);
                }, blobFormat);
            }
        }
        catch (err) {
            this.messageService.error(this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageBody'), this.languageService.translate.instant('igo.geo.printForm.corsErrorMessageHeader'));
        }
    }
    /**
     * Add file to zip, if all file are zipped, download
     * @param name - Name of the files
     * @param blob - Contain of file
     */
    addFileToZip(name, blob) {
        // add file to zip
        this.zipFile.file(name, blob);
        this.nbFileToProcess--;
        // If all files are proccessed
        if (this.nbFileToProcess === 0) {
            // Download zip file
            this.getZipFile();
            // Stop loading
            this.activityService.unregister(this.activityId);
        }
    }
    saveFileProcessing() {
        this.nbFileToProcess--;
        // If all files are proccessed
        if (this.nbFileToProcess === 0) {
            // Stop loading
            this.activityService.unregister(this.activityId);
        }
    }
    /**
     * Get the zipped file
     * @return Retun a zip file
     */
    getZipFile() {
        const that = this;
        this.zipFile.generateAsync({ type: 'blob' }).then((blob) => {
            // 1) generate the zip file
            saveAs(blob, 'map.zip');
            delete that.zipFile;
        });
    }
}
PrintService.ɵfac = function PrintService_Factory(t) { return new (t || PrintService)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.MessageService), i0.ɵɵinject(i2$1.ActivityService), i0.ɵɵinject(i2$1.LanguageService)); };
PrintService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: PrintService, factory: PrintService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PrintService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.MessageService }, { type: i2$1.ActivityService }, { type: i2$1.LanguageService }]; }, null); })();

const PrintOutputFormat = strEnum(['Pdf', 'Image']);
const PrintPaperFormat = strEnum([
    'A0',
    'A1',
    'A2',
    'A3',
    'A4',
    'A5',
    'Letter',
    'Legal'
]);
const PrintOrientation = strEnum(['landscape', 'portrait']);
const PrintResolution = strEnum(['72', '96', '150', '300']);
const PrintSaveImageFormat = strEnum([
    'Bmp',
    'Gif',
    'Jpeg',
    'Png',
    'Tiff'
]);
const PrintLegendPosition = strEnum([
    'none',
    'topright',
    'topleft',
    'bottomleft',
    'bottomright',
    'newpage'
]);

function PrintFormComponent_mat_option_28_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 19);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const legendPosition_r6 = ctx.$implicit;
    i0.ɵɵproperty("value", legendPosition_r6.key);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.printForm.legendPositions." + legendPosition_r6.value), " ");
} }
function PrintFormComponent_mat_option_34_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 19);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const outputFormat_r7 = ctx.$implicit;
    i0.ɵɵproperty("value", outputFormat_r7.key);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", outputFormat_r7.value, " ");
} }
function PrintFormComponent_mat_option_40_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 19);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const paperFormat_r8 = ctx.$implicit;
    i0.ɵɵproperty("value", paperFormat_r8.key);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.printForm.paperFormats." + paperFormat_r8.value), " ");
} }
function PrintFormComponent_mat_option_46_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 19);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const imageFormat_r9 = ctx.$implicit;
    i0.ɵɵproperty("value", imageFormat_r9.key);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", imageFormat_r9.value, " ");
} }
function PrintFormComponent_mat_option_52_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 19);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const resolution_r10 = ctx.$implicit;
    i0.ɵɵproperty("value", resolution_r10.key);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", resolution_r10.value + " PPI", " ");
} }
function PrintFormComponent_mat_option_58_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 19);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const orientation_r11 = ctx.$implicit;
    i0.ɵɵproperty("value", orientation_r11.key);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, "igo.geo.printForm." + orientation_r11.value), " ");
} }
class PrintFormComponent {
    constructor(formBuilder) {
        this.formBuilder = formBuilder;
        this.outputFormats = PrintOutputFormat;
        this.paperFormats = PrintPaperFormat;
        this.orientations = PrintOrientation;
        this.resolutions = PrintResolution;
        this.imageFormats = PrintSaveImageFormat;
        this.legendPositions = PrintLegendPosition;
        this.isPrintService = true;
        this.submit = new EventEmitter();
        this.form = this.formBuilder.group({
            title: ['', []],
            subtitle: ['', []],
            comment: ['', []],
            outputFormat: ['', [Validators.required]],
            paperFormat: ['', [Validators.required]],
            imageFormat: ['', [Validators.required]],
            resolution: ['', [Validators.required]],
            orientation: ['', [Validators.required]],
            legendPosition: ['', [Validators.required]],
            showProjection: false,
            showScale: false,
            showLegend: false,
            doZipFile: [{ hidden: this.isPrintService }]
        });
    }
    get imageFormat() {
        return this.imageFormatField.value;
    }
    set imageFormat(value) {
        this.imageFormatField.setValue(value || PrintSaveImageFormat.Jpeg, {
            onlySelf: true
        });
    }
    get outputFormat() {
        return this.outputFormatField.value;
    }
    set outputFormat(value) {
        this.outputFormatField.setValue(value || PrintOutputFormat.Pdf, {
            onlySelf: true
        });
    }
    get paperFormat() {
        return this.paperFormatField.value;
    }
    set paperFormat(value) {
        this.paperFormatField.setValue(value || PrintPaperFormat.Letter, {
            onlySelf: true
        });
    }
    get orientation() {
        return this.orientationField.value;
    }
    set orientation(value) {
        this.orientationField.setValue(value || PrintOrientation.landscape, {
            onlySelf: true
        });
    }
    get resolution() {
        return this.resolutionField.value;
    }
    set resolution(value) {
        this.resolutionField.setValue(value || PrintResolution['96'], {
            onlySelf: true
        });
    }
    get legendPosition() {
        return this.legendPositionField.value;
    }
    set legendPosition(value) {
        this.legendPositionField.setValue(value || PrintLegendPosition.none, {
            onlySelf: true
        });
    }
    get title() {
        return this.titleField.value;
    }
    set title(value) {
        this.titleField.setValue(value, { onlySelf: true });
    }
    get subtitle() {
        return this.subtitleField.value;
    }
    set subtitle(value) {
        this.subtitleField.setValue(value, { onlySelf: true });
    }
    get comment() {
        return this.commentField.value;
    }
    set comment(value) {
        this.commentField.setValue(value, { onlySelf: true });
    }
    get showProjection() {
        return this.showProjectionField.value;
    }
    set showProjection(value) {
        this.showProjectionField.setValue(value, { onlySelf: true });
    }
    get showScale() {
        return this.showScaleField.value;
    }
    set showScale(value) {
        this.showScaleField.setValue(value, { onlySelf: true });
    }
    get showLegend() {
        return this.showLegendField.value;
    }
    set showLegend(value) {
        this.showLegendField.setValue(value, { onlySelf: true });
    }
    get doZipFile() {
        return this.doZipFileField.value;
    }
    set doZipFile(value) {
        this.doZipFileField.setValue(value, { onlySelf: true });
    }
    get outputFormatField() {
        return this.form.controls.outputFormat;
    }
    get paperFormatField() {
        return this.form.controls.paperFormat;
    }
    get imageFormatField() {
        return this.form.controls.imageFormat;
    }
    get orientationField() {
        return this.form.controls.orientation;
    }
    get resolutionField() {
        return this.form.controls.resolution;
    }
    get commentField() {
        return this.form.controls.comment;
    }
    get showProjectionField() {
        return this.form.controls.showProjection;
    }
    get showScaleField() {
        return this.form.controls.showScale;
    }
    get showLegendField() {
        return this.form.controls.showLegend;
    }
    get doZipFileField() {
        return this.form.controls.doZipFile;
    }
    get titleField() {
        return this.form.controls.title;
    }
    get subtitleField() {
        return this.form.controls.subtitle;
    }
    get legendPositionField() {
        return this.form.controls.legendPosition;
    }
    ngOnInit() {
        this.doZipFileField.setValue(false);
    }
    handleFormSubmit(data, isValid) {
        data.isPrintService = this.isPrintService;
        if (isValid) {
            this.submit.emit(data);
        }
    }
    toggleImageSaveProp() {
        if (this.outputFormatField.value === 'Image') {
            this.isPrintService = false;
        }
        else {
            this.isPrintService = true;
        }
    }
}
PrintFormComponent.ɵfac = function PrintFormComponent_Factory(t) { return new (t || PrintFormComponent)(i0.ɵɵdirectiveInject(i16.FormBuilder)); };
PrintFormComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: PrintFormComponent, selectors: [["igo-print-form"]], inputs: { disabled$: "disabled$", imageFormat: "imageFormat", outputFormat: "outputFormat", paperFormat: "paperFormat", orientation: "orientation", resolution: "resolution", legendPosition: "legendPosition", title: "title", subtitle: "subtitle", comment: "comment", showProjection: "showProjection", showScale: "showScale", showLegend: "showLegend", doZipFile: "doZipFile" }, outputs: { submit: "submit" }, decls: 65, vars: 72, consts: [[1, "igo-form", 3, "formGroup"], [1, "igo-input-container"], ["matInput", "", "formControlName", "title", 3, "placeholder"], ["matInput", "", "formControlName", "subtitle", 3, "placeholder"], ["matInput", "", "formControlName", "comment", 3, "placeholder"], [1, "print-slide-toggle-container", "mat-typography"], ["formControlName", "showProjection", 1, "print-option", 3, "labelPosition"], ["formControlName", "showScale", 1, "print-option", 3, "labelPosition"], ["formControlName", "doZipFile", 1, "print-option", 3, "labelPosition"], ["formControlName", "legendPosition", 3, "placeholder"], [3, "value", 4, "ngFor", "ngForOf"], ["formControlName", "outputFormat", 3, "placeholder", "selectionChange"], ["formControlName", "paperFormat", 3, "placeholder"], ["formControlName", "imageFormat", 3, "placeholder"], [1, "igo-input-container", 2, "display", "none"], ["formControlName", "resolution", 3, "placeholder"], ["formControlName", "orientation", 3, "placeholder"], [1, "igo-form-button-group", "print-button-top-padding"], ["mat-raised-button", "", "type", "button", 3, "disabled", "click"], [3, "value"]], template: function PrintFormComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "form", 0);
        i0.ɵɵelementStart(1, "div", 1);
        i0.ɵɵelementStart(2, "mat-form-field");
        i0.ɵɵelement(3, "input", 2);
        i0.ɵɵpipe(4, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(5, "div", 1);
        i0.ɵɵelementStart(6, "mat-form-field");
        i0.ɵɵelement(7, "input", 3);
        i0.ɵɵpipe(8, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(9, "div", 1);
        i0.ɵɵelementStart(10, "mat-form-field");
        i0.ɵɵelement(11, "input", 4);
        i0.ɵɵpipe(12, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(13, "div", 1);
        i0.ɵɵelementStart(14, "div", 5);
        i0.ɵɵelementStart(15, "mat-slide-toggle", 6);
        i0.ɵɵtext(16);
        i0.ɵɵpipe(17, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(18, "mat-slide-toggle", 7);
        i0.ɵɵtext(19);
        i0.ɵɵpipe(20, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(21, "mat-slide-toggle", 8);
        i0.ɵɵtext(22);
        i0.ɵɵpipe(23, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(24, "div", 1);
        i0.ɵɵelementStart(25, "mat-form-field");
        i0.ɵɵelementStart(26, "mat-select", 9);
        i0.ɵɵpipe(27, "translate");
        i0.ɵɵtemplate(28, PrintFormComponent_mat_option_28_Template, 3, 4, "mat-option", 10);
        i0.ɵɵpipe(29, "keyvalue");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(30, "div", 1);
        i0.ɵɵelementStart(31, "mat-form-field");
        i0.ɵɵelementStart(32, "mat-select", 11);
        i0.ɵɵlistener("selectionChange", function PrintFormComponent_Template_mat_select_selectionChange_32_listener() { return ctx.toggleImageSaveProp(); });
        i0.ɵɵpipe(33, "translate");
        i0.ɵɵtemplate(34, PrintFormComponent_mat_option_34_Template, 2, 2, "mat-option", 10);
        i0.ɵɵpipe(35, "keyvalue");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(36, "div", 1);
        i0.ɵɵelementStart(37, "mat-form-field");
        i0.ɵɵelementStart(38, "mat-select", 12);
        i0.ɵɵpipe(39, "translate");
        i0.ɵɵtemplate(40, PrintFormComponent_mat_option_40_Template, 3, 4, "mat-option", 10);
        i0.ɵɵpipe(41, "keyvalue");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(42, "div", 1);
        i0.ɵɵelementStart(43, "mat-form-field");
        i0.ɵɵelementStart(44, "mat-select", 13);
        i0.ɵɵpipe(45, "translate");
        i0.ɵɵtemplate(46, PrintFormComponent_mat_option_46_Template, 2, 2, "mat-option", 10);
        i0.ɵɵpipe(47, "keyvalue");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(48, "div", 14);
        i0.ɵɵelementStart(49, "mat-form-field");
        i0.ɵɵelementStart(50, "mat-select", 15);
        i0.ɵɵpipe(51, "translate");
        i0.ɵɵtemplate(52, PrintFormComponent_mat_option_52_Template, 2, 2, "mat-option", 10);
        i0.ɵɵpipe(53, "keyvalue");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(54, "div", 1);
        i0.ɵɵelementStart(55, "mat-form-field");
        i0.ɵɵelementStart(56, "mat-select", 16);
        i0.ɵɵpipe(57, "translate");
        i0.ɵɵtemplate(58, PrintFormComponent_mat_option_58_Template, 3, 4, "mat-option", 10);
        i0.ɵɵpipe(59, "keyvalue");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(60, "div", 17);
        i0.ɵɵelementStart(61, "button", 18);
        i0.ɵɵlistener("click", function PrintFormComponent_Template_button_click_61_listener() { return ctx.handleFormSubmit(ctx.form.value, ctx.form.valid); });
        i0.ɵɵpipe(62, "async");
        i0.ɵɵtext(63);
        i0.ɵɵpipe(64, "translate");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("formGroup", ctx.form);
        i0.ɵɵadvance(3);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(4, 32, "igo.geo.printForm.title"));
        i0.ɵɵadvance(4);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(8, 34, "igo.geo.printForm.subtitle"));
        i0.ɵɵadvance(4);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(12, 36, "igo.geo.printForm.comment"));
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("labelPosition", "before");
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(17, 38, "igo.geo.printForm.showProjection"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("labelPosition", "before");
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(20, 40, "igo.geo.printForm.showScale"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("display", ctx.isPrintService ? "none" : "");
        i0.ɵɵproperty("labelPosition", "before");
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(23, 42, "igo.geo.printForm.doZipFile"), " ");
        i0.ɵɵadvance(4);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(27, 44, "igo.geo.printForm.legendPosition"));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(29, 46, ctx.legendPositions));
        i0.ɵɵadvance(4);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(33, 48, "igo.geo.printForm.outputFormat"));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(35, 50, ctx.outputFormats));
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("display", ctx.isPrintService ? "block" : "none");
        i0.ɵɵadvance(2);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(39, 52, "igo.geo.printForm.paperFormat"));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(41, 54, ctx.paperFormats));
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("display", ctx.isPrintService ? "none" : "block");
        i0.ɵɵadvance(2);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(45, 56, "igo.geo.printForm.imageFormat"));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(47, 58, ctx.imageFormats));
        i0.ɵɵadvance(4);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(51, 60, "igo.geo.printForm.resolution"));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(53, 62, ctx.resolutions));
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("display", ctx.isPrintService ? "block" : "none");
        i0.ɵɵadvance(2);
        i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(57, 64, "igo.geo.printForm.orientation"));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(59, 66, ctx.orientations));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("disabled", !ctx.form.valid || i0.ɵɵpipeBind1(62, 68, ctx.disabled$));
        i0.ɵɵadvance(2);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(64, 70, "igo.geo.printForm.saveBtn"), " ");
    } }, directives: [i16.ɵNgNoValidate, i16.NgControlStatusGroup, i16.FormGroupDirective, i12.MatFormField, i5$1.MatInput, i16.DefaultValueAccessor, i16.NgControlStatus, i16.FormControlName, i22.MatSlideToggle, i13.MatSelect, i1$1.NgForOf, i2.MatButton, i9.MatOption], pipes: [i7.TranslatePipe, i6.KeyValuePipe, i1$1.AsyncPipe], styles: ["mat-form-field[_ngcontent-%COMP%]{width:100%}.print-slide-toggle-container[_ngcontent-%COMP%]{overflow-x:hidden}.print-slide-toggle-container[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]{width:100%;margin:10px}.print-slide-toggle-container[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-content{width:calc(100% - 60px)}.print-option[_ngcontent-%COMP%]{display:block;margin-right:10px;margin-bottom:15px}.print-button-top-padding[_ngcontent-%COMP%]{padding-top:25px}.igo-form[_ngcontent-%COMP%]{padding:10px 5px 5px}.igo-form-button-group[_ngcontent-%COMP%]{text-align:center}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PrintFormComponent, [{
        type: Component,
        args: [{
                selector: 'igo-print-form',
                templateUrl: './print-form.component.html',
                styleUrls: ['./print-form.component.scss']
            }]
    }], function () { return [{ type: i16.FormBuilder }]; }, { disabled$: [{
            type: Input
        }], imageFormat: [{
            type: Input
        }], outputFormat: [{
            type: Input
        }], paperFormat: [{
            type: Input
        }], orientation: [{
            type: Input
        }], resolution: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], title: [{
            type: Input
        }], subtitle: [{
            type: Input
        }], comment: [{
            type: Input
        }], showProjection: [{
            type: Input
        }], showScale: [{
            type: Input
        }], showLegend: [{
            type: Input
        }], doZipFile: [{
            type: Input
        }], submit: [{
            type: Output
        }] }); })();

class PrintComponent {
    constructor(printService) {
        this.printService = printService;
        this.disabled$ = new BehaviorSubject(false);
    }
    get map() {
        return this._map;
    }
    set map(value) {
        this._map = value;
    }
    get outputFormat() {
        return this._outputFormat;
    }
    set outputFormat(value) {
        this._outputFormat = value;
    }
    get paperFormat() {
        return this._paperFormat;
    }
    set paperFormat(value) {
        this._paperFormat = value;
    }
    get orientation() {
        return this._orientation;
    }
    set orientation(value) {
        this._orientation = value;
    }
    get imageFormat() {
        return this._imageFormat;
    }
    set imageFormat(value) {
        this._imageFormat = value;
    }
    get legendPosition() {
        return this._legendPosition;
    }
    set legendPosition(value) {
        this._legendPosition = value;
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(value) {
        this._resolution = value;
    }
    handleFormSubmit(data) {
        this.disabled$.next(true);
        if (data.isPrintService === true) {
            this.printService
                .print(this.map, data)
                .pipe(take(1))
                .subscribe(() => {
                this.disabled$.next(false);
            });
        }
        else {
            let nbFileToProcess = 1;
            if (data.showLegend) {
                nbFileToProcess++;
            }
            if (data.imageFormat.toLowerCase() === 'tiff') {
                nbFileToProcess++;
            }
            this.printService.defineNbFileToProcess(nbFileToProcess);
            const resolution = +data.resolution;
            let nbRequests = data.showLegend ? 2 : 1;
            this.printService
                .downloadMapImage(this.map, resolution, data.imageFormat, data.showProjection, data.showScale, data.showLegend, data.title, data.subtitle, data.comment, data.doZipFile)
                .pipe(take(1))
                .subscribe(() => {
                nbRequests--;
                if (!nbRequests) {
                    this.disabled$.next(false);
                }
            });
            if (data.showLegend) {
                this.printService
                    .getLayersLegendImage(this.map, data.imageFormat, data.doZipFile, +resolution)
                    .then(() => {
                    nbRequests--;
                    if (!nbRequests) {
                        this.disabled$.next(false);
                    }
                });
            }
        }
    }
}
PrintComponent.ɵfac = function PrintComponent_Factory(t) { return new (t || PrintComponent)(i0.ɵɵdirectiveInject(PrintService)); };
PrintComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: PrintComponent, selectors: [["igo-print"]], inputs: { map: "map", outputFormat: "outputFormat", paperFormat: "paperFormat", orientation: "orientation", imageFormat: "imageFormat", legendPosition: "legendPosition", resolution: "resolution" }, decls: 1, vars: 7, consts: [[3, "outputFormat", "paperFormat", "orientation", "imageFormat", "resolution", "legendPosition", "disabled$", "submit"]], template: function PrintComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "igo-print-form", 0);
        i0.ɵɵlistener("submit", function PrintComponent_Template_igo_print_form_submit_0_listener($event) { return ctx.handleFormSubmit($event); });
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("outputFormat", ctx.outputFormat)("paperFormat", ctx.paperFormat)("orientation", ctx.orientation)("imageFormat", ctx.imageFormat)("resolution", ctx.resolution)("legendPosition", ctx.legendPosition)("disabled$", ctx.disabled$);
    } }, directives: [PrintFormComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PrintComponent, [{
        type: Component,
        args: [{
                selector: 'igo-print',
                templateUrl: './print.component.html'
            }]
    }], function () { return [{ type: PrintService }]; }, { map: [{
            type: Input
        }], outputFormat: [{
            type: Input
        }], paperFormat: [{
            type: Input
        }], orientation: [{
            type: Input
        }], imageFormat: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], resolution: [{
            type: Input
        }] }); })();

class IgoPrintModule {
}
IgoPrintModule.ɵfac = function IgoPrintModule_Factory(t) { return new (t || IgoPrintModule)(); };
IgoPrintModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoPrintModule });
IgoPrintModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            ReactiveFormsModule,
            MatIconModule,
            MatButtonModule,
            MatSelectModule,
            MatOptionModule,
            MatInputModule,
            MatFormFieldModule,
            MatSlideToggleModule,
            IgoLanguageModule,
            IgoKeyValueModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoPrintModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MatIconModule,
                    MatButtonModule,
                    MatSelectModule,
                    MatOptionModule,
                    MatInputModule,
                    MatFormFieldModule,
                    MatSlideToggleModule,
                    IgoLanguageModule,
                    IgoKeyValueModule
                ],
                exports: [PrintComponent, PrintFormComponent],
                declarations: [PrintComponent, PrintFormComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoPrintModule, { declarations: [PrintComponent, PrintFormComponent], imports: [CommonModule,
        FormsModule,
        ReactiveFormsModule,
        MatIconModule,
        MatButtonModule,
        MatSelectModule,
        MatOptionModule,
        MatInputModule,
        MatFormFieldModule,
        MatSlideToggleModule,
        IgoLanguageModule,
        IgoKeyValueModule], exports: [PrintComponent, PrintFormComponent] }); })();

/**
 * Map search source factory
 * @ignore
 */
function querySearchSourceFactory(config) {
    return new QuerySearchSource(config.getConfig(`searchSources.${QuerySearchSource.id}`) || {});
}
/**
 * Function that returns a provider for the map search source
 */
function provideQuerySearchSource() {
    return {
        provide: SearchSource,
        useFactory: querySearchSourceFactory,
        multi: true,
        deps: [ConfigService]
    };
}

class IgoQueryModule {
    static forRoot() {
        return {
            ngModule: IgoQueryModule,
            providers: [provideQuerySearchSource()]
        };
    }
}
IgoQueryModule.ɵfac = function IgoQueryModule_Factory(t) { return new (t || IgoQueryModule)(); };
IgoQueryModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoQueryModule });
IgoQueryModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [QueryService], imports: [[CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoQueryModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                exports: [QueryDirective],
                declarations: [QueryDirective],
                providers: [QueryService]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoQueryModule, { declarations: [QueryDirective], imports: [CommonModule], exports: [QueryDirective] }); })();

class DirectionsSource {
}

class DirectionsSourceService {
    constructor(sources) {
        this.sources = sources;
    }
}
function directionsSourceServiceFactory(sources) {
    return new DirectionsSourceService(sources);
}
function provideDirectionsSourceService() {
    return {
        provide: DirectionsSourceService,
        useFactory: directionsSourceServiceFactory,
        deps: [DirectionsSource]
    };
}

var DirectionsFormat;
(function (DirectionsFormat) {
    DirectionsFormat[DirectionsFormat["GeoJSON"] = 0] = "GeoJSON";
    DirectionsFormat[DirectionsFormat["JSON"] = 1] = "JSON";
})(DirectionsFormat || (DirectionsFormat = {}));
var SourceDirectionsType;
(function (SourceDirectionsType) {
    SourceDirectionsType["Route"] = "route";
    SourceDirectionsType["Trip"] = "trip";
})(SourceDirectionsType || (SourceDirectionsType = {}));
var ProposalType;
(function (ProposalType) {
    ProposalType["Coord"] = "coord";
    ProposalType["Text"] = "text";
})(ProposalType || (ProposalType = {}));
var DirectionType;
(function (DirectionType) {
    DirectionType["Stop"] = "stop";
    DirectionType["Route"] = "route";
    DirectionType["Vertex"] = "vertex";
})(DirectionType || (DirectionType = {}));
var DirectionRelativePositionType;
(function (DirectionRelativePositionType) {
    DirectionRelativePositionType["Start"] = "start";
    DirectionRelativePositionType["Intermediate"] = "intermediate";
    DirectionRelativePositionType["End"] = "end";
})(DirectionRelativePositionType || (DirectionRelativePositionType = {}));

/**
 * Function that updat the sort of the list base on the provided field.
 * @param source stop store
 * @param direction asc / desc sort order
 * @param field the field to use to sort the view
 */
function updateStoreSorting(stopsStore, direction = 'asc', field = 'position') {
    stopsStore.view.sort({
        direction,
        valueAccessor: (entity) => entity[field]
    });
}
function computeRelativePosition(index, totalLength) {
    let relativePosition = DirectionRelativePositionType.Intermediate;
    if (index === 0) {
        relativePosition = DirectionRelativePositionType.Start;
    }
    else if (index === totalLength - 1) {
        relativePosition = DirectionRelativePositionType.End;
    }
    return relativePosition;
}
function computeStopsPosition(stopsStore) {
    const stopsToComputePosition = [...stopsStore.all()];
    stopsToComputePosition.sort((a, b) => a.position - b.position);
    stopsToComputePosition.map((stop, i) => {
        stop.position = i;
        stop.relativePosition = computeRelativePosition(stop.position, stopsToComputePosition.length);
    });
    if (stopsToComputePosition) {
        stopsStore.updateMany(stopsToComputePosition);
    }
}
/**
 * Function that add a stop to the stop store. Stop are always added before the last stop.
 * @param stopsStore stop store as an EntityStore
 */
function addStopToStore(stopsStore) {
    const id = uuid();
    const stops = stopsStore.all();
    let positions;
    if (stopsStore.count === 0) {
        positions = [0];
    }
    else {
        positions = stops.map(stop => stop.position);
    }
    const maxPosition = Math.max(...positions);
    const insertPosition = maxPosition;
    const lastPosition = maxPosition + 1;
    const stopToUpdate = stopsStore.all().find(stop => stop.position === maxPosition);
    if (stopToUpdate) {
        stopToUpdate.position = lastPosition;
        stopToUpdate.relativePosition = computeRelativePosition(lastPosition, stopsStore.count + 1);
    }
    stopsStore.insert({ id, position: insertPosition, relativePosition: computeRelativePosition(insertPosition, stopsStore.count + 1) });
    updateStoreSorting(stopsStore);
    return stopsStore.get(id);
}
function removeStopFromStore(stopsStore, stop) {
    stopsStore.delete(stop);
    computeStopsPosition(stopsStore);
}
/**
 * Create a style for the directions stops and routes
 * @param feature OlFeature
 * @returns OL style function
 */
function directionsStyle(feature, resolution) {
    const vertexStyle = [
        new olstyle.Style({
            geometry: feature.getGeometry(),
            image: new olstyle.Circle({
                radius: 7,
                stroke: new olstyle.Stroke({ color: '#FF0000', width: 3 })
            })
        })
    ];
    const stopStyle = createOverlayMarkerStyle({
        text: feature.get('stopText'),
        opacity: feature.get('stopOpacity'),
        markerColor: feature.get('stopColor'),
        markerOutlineColor: [255, 255, 255]
    });
    const routeStyle = [
        new olstyle.Style({
            stroke: new olstyle.Stroke({ color: `rgba(106, 121, 130, ${feature.get('active') ? 0.75 : 0})`, width: 10 })
        }),
        new olstyle.Style({
            stroke: new olstyle.Stroke({ color: `rgba(79, 169, 221, ${feature.get('active') ? 0.75 : 0})`, width: 6 })
        })
    ];
    if (feature.get('type') === DirectionType.Stop) {
        return stopStyle;
    }
    if (feature.get('type') === 'vertex') {
        return vertexStyle;
    }
    if (feature.get('type') === DirectionType.Route) {
        return routeStyle;
    }
}
function initStopsFeatureStore(stopsFeatureStore, languageService) {
    const loadingStrategy = new FeatureStoreLoadingStrategy({
        motion: FeatureMotion.None
    });
    const stopsLayer = new VectorLayer({
        isIgoInternalLayer: true,
        id: 'igo-direction-stops-layer',
        title: languageService.translate.instant('igo.geo.directionsForm.stopLayer'),
        zIndex: 911,
        source: new FeatureDataSource(),
        showInLayerList: true,
        workspace: {
            enabled: false,
        },
        linkedLayers: {
            linkId: 'igo-direction-stops-layer',
            links: [
                {
                    bidirectionnal: false,
                    syncedDelete: true,
                    linkedIds: ['igo-direction-route-layer'],
                    properties: []
                }
            ]
        },
        exportable: true,
        browsable: false,
        style: directionsStyle
    });
    tryBindStoreLayer(stopsFeatureStore, stopsLayer);
    stopsFeatureStore.layer.visible = true;
    tryAddLoadingStrategy(stopsFeatureStore, loadingStrategy);
}
function initRoutesFeatureStore(routesFeatureStore, languageService) {
    const loadingStrategy = new FeatureStoreLoadingStrategy({
        motion: FeatureMotion.None
    });
    const routeLayer = new VectorLayer({
        isIgoInternalLayer: true,
        id: 'igo-direction-route-layer',
        title: languageService.translate.instant('igo.geo.directionsForm.routeLayer'),
        zIndex: 910,
        source: new FeatureDataSource(),
        showInLayerList: true,
        workspace: {
            enabled: false,
        },
        linkedLayers: {
            linkId: 'igo-direction-route-layer'
        },
        exportable: true,
        browsable: false,
        style: directionsStyle
    });
    tryBindStoreLayer(routesFeatureStore, routeLayer);
    routesFeatureStore.layer.visible = true;
    tryAddLoadingStrategy(routesFeatureStore, loadingStrategy);
}
function initStepFeatureStore(stepFeatureStore) {
    const loadingStrategy = new FeatureStoreLoadingStrategy({
        motion: FeatureMotion.None
    });
    const stepLayer = new VectorLayer({
        isIgoInternalLayer: true,
        id: 'igo-direction-step-layer',
        title: '',
        zIndex: 910,
        source: new FeatureDataSource(),
        showInLayerList: false,
        workspace: {
            enabled: false,
        },
        linkedLayers: {
            linkId: 'igo-direction-route-layer'
        },
        exportable: false,
        browsable: false,
        style: directionsStyle
    });
    tryBindStoreLayer(stepFeatureStore, stepLayer);
    stepFeatureStore.layer.visible = true;
    tryAddLoadingStrategy(stepFeatureStore, loadingStrategy);
}
function addStopToStopsFeatureStore(stop, stopsStore, stopsFeatureStore, projection, languageService) {
    let stopColor;
    let stopText;
    switch (stop.relativePosition) {
        case DirectionRelativePositionType.Start:
            stopColor = '#008000';
            stopText = languageService.translate.instant('igo.geo.directionsForm.start');
            break;
        case DirectionRelativePositionType.End:
            stopColor = '#f64139';
            stopText = languageService.translate.instant('igo.geo.directionsForm.end');
            break;
        default:
            stopColor = '#ffd700';
            stopText = languageService.translate.instant('igo.geo.directionsForm.intermediate') + ' #' + stop.position;
            break;
    }
    const geometry = new olgeom.Point(olproj.transform(stop.coordinates, projection, stopsFeatureStore.map.projection));
    const geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
        featureProjection: stopsFeatureStore.map.projection,
        dataProjection: stopsFeatureStore.map.projection
    });
    const previousStop = stopsFeatureStore.get(stop.id);
    const previousStopRevision = previousStop ? previousStop.meta.revision : 0;
    const stopFeatureStore = {
        type: FEATURE,
        geometry: geojsonGeom,
        projection: stopsFeatureStore.map.projection,
        properties: {
            id: stop.id,
            type: DirectionType.Stop,
            stopText,
            stopColor,
            stopOpacity: 1,
            stop
        },
        meta: {
            id: stop.id,
            revision: previousStopRevision + 1
        },
        ol: new OlFeature({ geometry })
    };
    stopsFeatureStore.update(stopFeatureStore);
}
function addDirectionToRoutesFeatureStore(routesFeatureStore, direction, projection, active = false, moveToExtent = false) {
    const geom = direction.geometry.coordinates;
    const geometry4326 = new olgeom.LineString(geom);
    const geometry = geometry4326.transform(projection, routesFeatureStore.map.projection);
    const geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
        featureProjection: routesFeatureStore.map.projection,
        dataProjection: routesFeatureStore.map.projection
    });
    const previousRoute = routesFeatureStore.get(direction.id);
    const previousRouteRevision = previousRoute
        ? previousRoute.meta.revision
        : 0;
    const routeFeatureStore = {
        type: FEATURE,
        geometry: geojsonGeom,
        projection: routesFeatureStore.map.projection,
        properties: {
            id: direction.id,
            type: DirectionType.Route,
            active,
            direction
        },
        meta: {
            id: direction.id,
            revision: previousRouteRevision + 1
        },
        ol: new OlFeature({ geometry })
    };
    routesFeatureStore.update(routeFeatureStore);
}
function formatDistance(distance) {
    if (distance === 0) {
        return;
    }
    if (distance >= 100000) {
        return NumberUtils.roundToNDecimal(Math.round(distance) / 1000, 1) + ' km';
    }
    if (distance >= 10000) {
        return NumberUtils.roundToNDecimal(Math.round(distance) / 100 / 10, 1) + ' km';
    }
    if (distance >= 1000) {
        return NumberUtils.roundToNDecimal(Math.round(distance) / 100 / 10, 1) + ' km';
    }
    return NumberUtils.roundToNDecimal(distance, 0) + ' m';
}
function formatDuration(duration) {
    if (duration >= 3600) {
        const hour = Math.floor(duration / 3600);
        const minute = Math.round((duration / 3600 - hour) * 60);
        if (minute === 60) {
            return hour + 1 + ' h';
        }
        return hour + ' h ' + minute + ' min';
    }
    if (duration >= 60) {
        return Math.round(duration / 60) + ' min';
    }
    return duration + ' s';
}
function formatInstruction(type, modifier, route, direction, stepPosition, exit, languageService, lastStep = false) {
    const translate = languageService.translate;
    let directive;
    let image = 'forward';
    let cssClass = 'rotate-270';
    const translatedDirection = translateBearing(direction, languageService);
    const translatedModifier = translateModifier(modifier, languageService);
    const prefix = modifier === 'straight' ? '' : translate.instant('igo.geo.directions.modifier.prefix');
    let aggregatedDirection = prefix + translatedModifier;
    if ((modifier === null || modifier === void 0 ? void 0 : modifier.search('slight')) >= 0) {
        aggregatedDirection = translatedModifier;
    }
    if (modifier === 'uturn') {
        image = 'forward';
        cssClass = 'rotate-90';
    }
    else if (modifier === 'sharp right') {
        image = 'subdirectory-arrow-right';
        cssClass = 'icon-flipped';
    }
    else if (modifier === 'right') {
        image = 'subdirectory-arrow-right';
        cssClass = 'icon-flipped';
    }
    else if (modifier === 'slight right') {
        image = 'forward';
        cssClass = 'rotate-290';
    }
    else if (modifier === 'straight') {
        image = 'forward';
    }
    else if (modifier === 'slight left') {
        image = 'forward';
        cssClass = 'rotate-250';
    }
    else if (modifier === 'left') {
        image = 'subdirectory-arrow-left';
        cssClass = 'icon-flipped';
    }
    else if (modifier === 'sharp left') {
        image = 'subdirectory-arrow-left';
        cssClass = 'icon-flipped';
    }
    if (type === 'turn') {
        if (modifier === 'straight') {
            directive = translate.instant('igo.geo.directions.turn.straight', { route });
        }
        else if (modifier === 'uturn') {
            directive = translate.instant('igo.geo.directions.turn.uturn', { route });
        }
        else {
            directive = translate.instant('igo.geo.directions.turn.else', { route, aggregatedDirection, translatedModifier });
        }
    }
    else if (type === 'new name') {
        directive = translate.instant('igo.geo.directions.new name', { route, translatedDirection });
        image = 'compass';
        cssClass = '';
    }
    else if (type === 'depart') {
        directive = translate.instant('igo.geo.directions.depart', { route, translatedDirection });
        image = 'compass';
        cssClass = '';
    }
    else if (type === 'arrive') {
        if (lastStep) {
            const coma = !translatedModifier ? '' : ', ';
            aggregatedDirection = !translatedModifier ? '' : aggregatedDirection;
            directive = translate.instant('igo.geo.directions.arrive.lastStep', { coma, aggregatedDirection });
        }
        else {
            directive = translate.instant('igo.geo.directions.arrive.intermediate', { route });
            image = 'map-marker';
            cssClass = '';
        }
    }
    else if (type === 'merge') {
        directive = translate.instant('igo.geo.directions.merge', { route });
        image = 'forward';
        cssClass = 'rotate-270';
    }
    else if (type === 'on ramp') {
        directive = translate.instant('igo.geo.directions.on ramp', { aggregatedDirection });
    }
    else if (type === 'off ramp') {
        directive = translate.instant('igo.geo.directions.off ramp', { aggregatedDirection });
    }
    else if (type === 'fork') {
        if (modifier.search('left') >= 0) {
            directive = translate.instant('igo.geo.directions.fork.left', { route });
        }
        else if (modifier.search('right') >= 0) {
            directive = translate.instant('igo.geo.directions.fork.right', { route });
        }
        else {
            directive = translate.instant('igo.geo.directions.fork.else', { route });
        }
    }
    else if (type === 'end of road') {
        directive = translate.instant('igo.geo.directions.end of road', { translatedModifier, route });
    }
    else if (type === 'use lane') {
        directive = translate.instant('igo.geo.directions.use lane');
    }
    else if (type === 'continue' && modifier !== 'uturn') {
        directive = translate.instant('igo.geo.directions.continue.notUturn', { route });
        image = 'forward';
        cssClass = 'rotate-270';
    }
    else if (type === 'roundabout') {
        const cntSuffix = exit === 1 ?
            translate.instant('igo.geo.directions.cntSuffix.first') :
            translate.instant('igo.geo.directions.cntSuffix.secondAndMore');
        directive = translate.instant('igo.geo.directions.roundabout', { exit, cntSuffix, route });
        image = 'chart-donut';
        cssClass = '';
    }
    else if (type === 'rotary') {
        directive = translate.instant('igo.geo.directions.rotary');
        image = 'chart-donut';
        cssClass = '';
    }
    else if (type === 'roundabout turn') {
        directive = translate.instant('igo.geo.directions.roundabout turn');
        image = 'chart-donut';
        cssClass = '';
    }
    else if (type === 'exit roundabout') {
        directive = translate.instant('igo.geo.directions.exit roundabout', { route });
        image = 'forward';
        cssClass = 'rotate-270';
    }
    else if (type === 'notification') {
        directive = translate.instant('igo.geo.directions.notification');
    }
    else if (modifier === 'uturn') {
        directive = translate.instant('igo.geo.directions.uturnText', { translatedDirection, route });
    }
    else {
        directive = translate.instant('igo.geo.directions.unknown');
    }
    image = lastStep ? 'flag-variant' : image;
    cssClass = lastStep ? '' : cssClass;
    image = stepPosition === 0 ? 'compass' : image;
    cssClass = stepPosition === 0 ? '' : cssClass;
    return { instruction: directive, image, cssClass };
}
function translateModifier(modifier, languageService) {
    const translate = languageService.translate;
    if (modifier === 'uturn') {
        return translate.instant('igo.geo.directions.uturn');
    }
    else if (modifier === 'sharp right') {
        return translate.instant('igo.geo.directions.sharp right');
    }
    else if (modifier === 'right') {
        return translate.instant('igo.geo.directions.right');
    }
    else if (modifier === 'slight right') {
        return translate.instant('igo.geo.directions.slight right');
    }
    else if (modifier === 'sharp left') {
        return languageService.translate.instant('igo.geo.directions.sharp left');
    }
    else if (modifier === 'left') {
        return languageService.translate.instant('igo.geo.directions.left');
    }
    else if (modifier === 'slight left') {
        return languageService.translate.instant('igo.geo.directions.slight left');
    }
    else if (modifier === 'straight') {
        return languageService.translate.instant('igo.geo.directions.straight');
    }
    else {
        return modifier;
    }
}
function translateBearing(bearing, languageService) {
    const translate = languageService.translate;
    if (bearing >= 337 || bearing < 23) {
        return translate.instant('igo.geo.cardinalPoints.n');
    }
    else if (bearing < 67) {
        return translate.instant('igo.geo.cardinalPoints.ne');
    }
    else if (bearing < 113) {
        return translate.instant('igo.geo.cardinalPoints.e');
    }
    else if (bearing < 157) {
        return translate.instant('igo.geo.cardinalPoints.se');
    }
    else if (bearing < 203) {
        return translate.instant('igo.geo.cardinalPoints.s');
    }
    else if (bearing < 247) {
        return translate.instant('igo.geo.cardinalPoints.sw');
    }
    else if (bearing < 293) {
        return translate.instant('igo.geo.cardinalPoints.w');
    }
    else if (bearing < 337) {
        return translate.instant('igo.geo.cardinalPoints.nw');
    }
    else {
        return;
    }
}

function DirectionsInputsComponent_div_1_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 10);
    i0.ɵɵlistener("click", function DirectionsInputsComponent_div_1_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r9); const stop_r1 = i0.ɵɵnextContext().$implicit; const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.clearStop(stop_r1); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 11);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.directionsForm.clearStop"));
} }
function DirectionsInputsComponent_div_1_mat_optgroup_7_mat_option_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 14);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const result_r12 = ctx.$implicit;
    i0.ɵɵproperty("value", result_r12)("matTooltip", result_r12.meta ? result_r12.meta.title : "");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", result_r12.meta ? result_r12.meta.title : "", " ");
} }
function DirectionsInputsComponent_div_1_mat_optgroup_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-optgroup", 12);
    i0.ɵɵtemplate(1, DirectionsInputsComponent_div_1_mat_optgroup_7_mat_option_1_Template, 2, 3, "mat-option", 13);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const source_r10 = ctx.$implicit;
    i0.ɵɵproperty("label", source_r10.source.title)("disabled", source_r10.source.enabled === false);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", source_r10.results);
} }
function DirectionsInputsComponent_div_1_div_8_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 20);
    i0.ɵɵlistener("click", function DirectionsInputsComponent_div_1_div_8_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r17); const stop_r1 = i0.ɵɵnextContext(2).$implicit; const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.removeStop(stop_r1); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 21);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.directionsForm.removeStop"));
} }
function DirectionsInputsComponent_div_1_div_8_button_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 22);
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 23);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.directionsForm.removeStop"));
} }
function DirectionsInputsComponent_div_1_div_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵelementStart(1, "button", 16);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelement(3, "mat-icon", 17);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(4, DirectionsInputsComponent_div_1_div_8_button_4_Template, 3, 3, "button", 18);
    i0.ɵɵpipe(5, "async");
    i0.ɵɵtemplate(6, DirectionsInputsComponent_div_1_div_8_button_6_Template, 3, 3, "button", 19);
    i0.ɵɵpipe(7, "async");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(2, 3, "igo.geo.directionsForm.moveStop"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(5, 5, ctx_r6.stopsStore.count$) > 2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(7, 7, ctx_r6.stopsStore.count$) <= 2);
} }
function DirectionsInputsComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r19 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 2);
    i0.ɵɵlistener("touchenter", function DirectionsInputsComponent_div_1_Template_div_touchenter_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r19); const stop_r1 = restoredCtx.$implicit; const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18.onStopEnter(stop_r1); })("touchleave", function DirectionsInputsComponent_div_1_Template_div_touchleave_0_listener() { i0.ɵɵrestoreView(_r19); const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.onStopLeave(); })("mouseover", function DirectionsInputsComponent_div_1_Template_div_mouseover_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r19); const stop_r1 = restoredCtx.$implicit; const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.onStopEnter(stop_r1); })("mouseleave", function DirectionsInputsComponent_div_1_Template_div_mouseleave_0_listener() { i0.ɵɵrestoreView(_r19); const ctx_r22 = i0.ɵɵnextContext(); return ctx_r22.onStopLeave(); })("cdkDragStarted", function DirectionsInputsComponent_div_1_Template_div_cdkDragStarted_0_listener() { i0.ɵɵrestoreView(_r19); const ctx_r23 = i0.ɵɵnextContext(); return ctx_r23.stopIsDragged = true; })("cdkDragEnded", function DirectionsInputsComponent_div_1_Template_div_cdkDragEnded_0_listener() { i0.ɵɵrestoreView(_r19); const ctx_r24 = i0.ɵɵnextContext(); return ctx_r24.stopIsDragged = false; });
    i0.ɵɵelementStart(1, "div", 3);
    i0.ɵɵelementStart(2, "mat-form-field");
    i0.ɵɵelementStart(3, "input", 4);
    i0.ɵɵlistener("focus", function DirectionsInputsComponent_div_1_Template_input_focus_3_listener() { const restoredCtx = i0.ɵɵrestoreView(_r19); const stop_r1 = restoredCtx.$implicit; const ctx_r25 = i0.ɵɵnextContext(); return ctx_r25.onInputFocus(stop_r1); })("ngModelChange", function DirectionsInputsComponent_div_1_Template_input_ngModelChange_3_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r19); const stop_r1 = restoredCtx.$implicit; return stop_r1.text = $event; })("keyup", function DirectionsInputsComponent_div_1_Template_input_keyup_3_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r19); const stop_r1 = restoredCtx.$implicit; const ctx_r27 = i0.ɵɵnextContext(); return ctx_r27.setStopText($event, stop_r1); })("keydown.enter", function DirectionsInputsComponent_div_1_Template_input_keydown_enter_3_listener($event) { return $event.preventDefault(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(4, DirectionsInputsComponent_div_1_button_4_Template, 3, 3, "button", 5);
    i0.ɵɵelementStart(5, "mat-autocomplete", 6, 7);
    i0.ɵɵlistener("optionSelected", function DirectionsInputsComponent_div_1_Template_mat_autocomplete_optionSelected_5_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r19); const stop_r1 = restoredCtx.$implicit; const ctx_r29 = i0.ɵɵnextContext(); return ctx_r29.chooseProposal($event, stop_r1); });
    i0.ɵɵtemplate(7, DirectionsInputsComponent_div_1_mat_optgroup_7_Template, 2, 3, "mat-optgroup", 8);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(8, DirectionsInputsComponent_div_1_div_8_Template, 8, 9, "div", 9);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const stop_r1 = ctx.$implicit;
    const _r4 = i0.ɵɵreference(6);
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", ctx_r0.getNgClass(stop_r1));
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("id", stop_r1.id);
    i0.ɵɵproperty("placeholder", ctx_r0.getPlaceholder(stop_r1))("matTooltip", stop_r1.text)("ngModel", stop_r1.text)("matAutocomplete", _r4);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", (stop_r1.text || stop_r1.coordinates) && ctx_r0.stopWithHover && stop_r1.id === ctx_r0.stopWithHover.id);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("displayWith", ctx_r0.getOptionText);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", stop_r1.searchProposals);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !ctx_r0.stopIsDragged && ctx_r0.stopWithHover && stop_r1.id === ctx_r0.stopWithHover.id);
} }
class DirectionsInputsComponent {
    constructor(languageService) {
        this.languageService = languageService;
        this.invalidKeys = ['Control', 'Shift', 'Alt'];
        this.onMapClickEventKeys = [];
        this.stopIsDragged = false;
        this.coordRoundedDecimals = 6;
        this.debounce = 200;
        this.length = 2;
        this.stopInputHasFocus = new EventEmitter(false);
    }
    ngOnDestroy() {
        this.unlistenMapSingleClick();
    }
    onStopEnter(stop) {
        this.stopWithHover = stop;
    }
    onStopLeave() {
        this.stopWithHover = undefined;
    }
    getOptionText(option) {
        if (option instanceof Object) {
            return (option === null || option === void 0 ? void 0 : option.meta) ? option.meta.title : '';
        }
        return option;
    }
    chooseProposal(event, stop) {
        const result = event.option.value;
        if (result) {
            let geomCoord;
            const geom = result.geometry;
            if (geom.type === 'Point') {
                geomCoord = geom.coordinates;
            }
            else {
                const point = pointOnFeature(result.geometry);
                geomCoord = [
                    point.geometry.coordinates[0],
                    point.geometry.coordinates[1]
                ];
            }
            if (geomCoord) {
                stop.coordinates = geomCoord;
                stop.text = result.meta.title;
                this.stopsStore.update(stop);
            }
        }
    }
    setStopText(event, stop) {
        this.unlistenMapSingleClick();
        const term = event.target.value;
        if (term.length === 0) {
            this.clearStop(stop);
        }
        else if (this.validateTerm(term)) {
            stop.text = term;
            this.stopsStore.update(stop);
        }
    }
    validateTerm(term) {
        if (this.keyIsValid(term) &&
            (term.length >= this.length || term.length === 0)) {
            return true;
        }
        return false;
    }
    keyIsValid(key) {
        return this.invalidKeys.find(value => value === key) === undefined;
    }
    getNgClass(stop) {
        if (!this.stopWithHover) {
            return 'igo-input-container';
        }
        else if (stop.id === this.stopWithHover.id) {
            return 'igo-input-container reduce';
        }
        else {
            return 'igo-input-container';
        }
    }
    getPlaceholder(stop) {
        let extra = '';
        if (stop.relativePosition) {
            if (stop.relativePosition === DirectionRelativePositionType.Intermediate) {
                extra = ' #' + stop.position;
            }
            return this.languageService.translate.instant('igo.geo.directionsForm.' + stop.relativePosition) + extra;
        }
        else {
            return '';
        }
    }
    removeStop(stop) {
        removeStopFromStore(this.stopsStore, stop);
    }
    clearStop(stop) {
        this.stopsStore.update({ id: stop.id, relativePosition: stop.relativePosition, position: stop.position });
    }
    drop(event) {
        this.moveStops(event.previousIndex, event.currentIndex);
    }
    moveStops(fromIndex, toIndex) {
        if (fromIndex !== toIndex) {
            const stops = [...this.stopsStore.view.all()];
            moveItemInArray(stops, fromIndex, toIndex);
            stops.map((stop, i) => {
                stop.relativePosition = computeRelativePosition(i, stops.length);
                stop.position = i;
            });
            this.stopsStore.updateMany(stops);
            updateStoreSorting(this.stopsStore);
        }
    }
    onInputFocus(stop) {
        var _a;
        if (!stop.text || ((_a = stop.text) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            this.unlistenMapSingleClick();
            this.stopInputHasFocus.emit(true);
            this.listenMapSingleClick(stop);
        }
    }
    listenMapSingleClick(stop) {
        const key = this.stopsFeatureStore.layer.map.ol.once('singleclick', event => {
            const clickCoordinates = olproj.transform(event.coordinate, this.stopsFeatureStore.layer.map.projection, this.projection);
            const roundedCoord = roundCoordTo(clickCoordinates, this.coordRoundedDecimals);
            stop.text = roundedCoord.join(',');
            stop.coordinates = roundedCoord;
            this.stopsStore.update(stop);
            setTimeout(() => {
                this.stopInputHasFocus.emit(false);
            }, 500);
        });
        this.onMapClickEventKeys.push(key);
    }
    unlistenMapSingleClick() {
        this.onMapClickEventKeys.map(key => {
            olObservable.unByKey(key);
        });
        this.onMapClickEventKeys = [];
    }
}
DirectionsInputsComponent.ɵfac = function DirectionsInputsComponent_Factory(t) { return new (t || DirectionsInputsComponent)(i0.ɵɵdirectiveInject(i2$1.LanguageService)); };
DirectionsInputsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: DirectionsInputsComponent, selectors: [["igo-directions-inputs"]], inputs: { stopsStore: "stopsStore", stopsFeatureStore: "stopsFeatureStore", projection: "projection", coordRoundedDecimals: "coordRoundedDecimals", debounce: "debounce", length: "length" }, outputs: { stopInputHasFocus: "stopInputHasFocus" }, decls: 3, vars: 3, consts: [["cdkDropList", "", 1, "stops-list", 3, "cdkDropListDropped"], ["touchleave", "", "cdkDragLockAxis", "y", "class", "stop-box mat-typography", "cdkDrag", "", 3, "touchenter", "touchleave", "mouseover", "mouseleave", "cdkDragStarted", "cdkDragEnded", 4, "ngFor", "ngForOf"], ["touchleave", "", "cdkDragLockAxis", "y", "cdkDrag", "", 1, "stop-box", "mat-typography", 3, "touchenter", "touchleave", "mouseover", "mouseleave", "cdkDragStarted", "cdkDragEnded"], [3, "ngClass"], ["type", "text", "matTooltipShowDelay", "500", "aria-label", "Number", "matInput", "", 3, "id", "placeholder", "matTooltip", "ngModel", "matAutocomplete", "focus", "ngModelChange", "keyup", "keydown.enter"], ["mat-button", "", "matTooltipShowDelay", "500", "matSuffix", "", "mat-icon-button", "", "color", "warn", "aria-label", "Clear", 3, "matTooltip", "click", 4, "ngIf"], [3, "displayWith", "optionSelected"], ["auto", "matAutocomplete"], [3, "label", "disabled", 4, "ngFor", "ngForOf"], ["class", "igo-form-button-group", 4, "ngIf"], ["mat-button", "", "matTooltipShowDelay", "500", "matSuffix", "", "mat-icon-button", "", "color", "warn", "aria-label", "Clear", 3, "matTooltip", "click"], ["svgIcon", "close"], [3, "label", "disabled"], ["matTooltipShowDelay", "500", 3, "value", "matTooltip", 4, "ngFor", "ngForOf"], ["matTooltipShowDelay", "500", 3, "value", "matTooltip"], [1, "igo-form-button-group"], ["cdkDragHandle", "", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "primary", 1, "swipe-vertical", 3, "matTooltip"], ["svgIcon", "gesture-swipe-vertical"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "warn", 3, "matTooltip", "click", 4, "ngIf"], ["disabled", "true", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "warn", 3, "matTooltip", 4, "ngIf"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "warn", 3, "matTooltip", "click"], ["svgIcon", "delete"], ["disabled", "true", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "warn", 3, "matTooltip"], ["svgIcon", "blank"]], template: function DirectionsInputsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵlistener("cdkDropListDropped", function DirectionsInputsComponent_Template_div_cdkDropListDropped_0_listener($event) { return ctx.drop($event); });
        i0.ɵɵtemplate(1, DirectionsInputsComponent_div_1_Template, 9, 10, "div", 1);
        i0.ɵɵpipe(2, "async");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(2, 1, ctx.stopsStore.view.all$()));
    } }, directives: [i2$2.CdkDropList, i1$1.NgForOf, i2$2.CdkDrag, i1$1.NgClass, i12.MatFormField, i5$1.MatInput, i16.DefaultValueAccessor, i6$1.MatAutocompleteTrigger, i3.MatTooltip, i16.NgControlStatus, i16.NgModel, i1$1.NgIf, i6$1.MatAutocomplete, i2.MatButton, i12.MatSuffix, i4.MatIcon, i9.MatOptgroup, i9.MatOption, i2$2.CdkDragHandle], pipes: [i1$1.AsyncPipe, i7.TranslatePipe], styles: [".igo-input-container[_ngcontent-%COMP%]{width:100%}.igo-input-container[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%]{width:100%}.igo-input-container.reduce[_ngcontent-%COMP%]{width:70%}.igo-input-container.reduce[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%]{width:100%}.stops-list[_ngcontent-%COMP%]{max-width:100%;min-height:60px;display:block;background:white;border-radius:4px;overflow:hidden;padding:20px 10px}.swipe-vertical[_ngcontent-%COMP%]{cursor:move}.stop-box[_ngcontent-%COMP%]{height:60px;padding:20px 10px;color:#000000de;display:flex;flex-direction:row;align-items:center;justify-content:space-between;box-sizing:border-box;background:white}.cdk-drag-preview[_ngcontent-%COMP%]{box-sizing:border-box;border-radius:4px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.cdk-drag-placeholder[_ngcontent-%COMP%]{opacity:0}.cdk-drag-animating[_ngcontent-%COMP%]{transition:transform .25s cubic-bezier(0,0,.2,1)}.stops-list.cdk-drop-list-dragging[_ngcontent-%COMP%]   .stop-box[_ngcontent-%COMP%]:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DirectionsInputsComponent, [{
        type: Component,
        args: [{
                selector: 'igo-directions-inputs',
                templateUrl: './directions-inputs.component.html',
                styleUrls: ['./directions-inputs.component.scss']
            }]
    }], function () { return [{ type: i2$1.LanguageService }]; }, { stopsStore: [{
            type: Input
        }], stopsFeatureStore: [{
            type: Input
        }], projection: [{
            type: Input
        }], coordRoundedDecimals: [{
            type: Input
        }], debounce: [{
            type: Input
        }], length: [{
            type: Input
        }], stopInputHasFocus: [{
            type: Output
        }] }); })();

class DirectionsService {
    constructor(directionsSourceService) {
        this.directionsSourceService = directionsSourceService;
    }
    route(coordinates, directionsOptions = {}) {
        if (coordinates.length === 0) {
            return;
        }
        return this.directionsSourceService.sources
            .filter((source) => source.enabled)
            .map((source) => this.routeSource(source, coordinates, directionsOptions));
    }
    routeSource(source, coordinates, directionsOptions = {}) {
        const request = source.route(coordinates, directionsOptions);
        return request;
    }
}
DirectionsService.ɵfac = function DirectionsService_Factory(t) { return new (t || DirectionsService)(i0.ɵɵinject(DirectionsSourceService)); };
DirectionsService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DirectionsService, factory: DirectionsService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DirectionsService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: DirectionsSourceService }]; }, null); })();

/**
 * Function that checks whether a search source implements TextSearch
 * @param source Search source
 * @returns True if the search source implements TextSearch
 */
function sourceCanSearch(source) {
    return source.search !== undefined;
}
/**
 * Function that checks whether a search source implements ReverseSearch
 * @param source Search source
 * @returns True if the search source implements ReverseSearch
 */
function sourceCanReverseSearch(source) {
    return source.reverseSearch !== undefined;
}
/**
 * Function that checks whether a search source implements ReverseSearch AND is shown in the pointer summary
 * @param source Search source
 * @returns True if the search source implements ReverseSearch AND is shown in the pointer summary
 */
function sourceCanReverseSearchAsSummary(source) {
    return source.reverseSearch !== undefined && source.showInPointerSummary === true;
}
/**
 * Return a search result out of an Feature. This is used to adapt
 * the IGO query module to the new Feature/SearchResult interfaces
 * @param feature feature
 * @param source Search source
 * @returns SearchResult
 */
function featureToSearchResult(feature, source) {
    feature.sourceId = source.getId();
    return {
        source,
        data: feature,
        meta: {
            dataType: FEATURE,
            id: feature.meta.id,
            title: feature.meta.title,
            icon: feature.meta.icon || 'map-marker'
        }
    };
}
function findDiff(str1, str2) {
    let diff = '';
    str2.split('').forEach((val, i) => {
        if (val !== str1.charAt(i)) {
            diff += val;
        }
    });
    return diff;
}
/**
 * Return a score calculation based on "from" term with the "to" term,
 * where the perfect match is 100 and a total difference is 0 or under.
 * @param from string
 * @param to string
 * @param caseSensitive boolean
 * @returns number
 */
function computeTermSimilarity(from, to, caseSensitive = false) {
    if (!from || !to) {
        return 0;
    }
    const termFrom = caseSensitive ? from : from.toLowerCase();
    const termTo = caseSensitive ? to : to.toLowerCase();
    const fromToDiff = findDiff(termFrom, termTo);
    const toFromDiff = findDiff(termTo, termFrom);
    const totalDiff = fromToDiff + toFromDiff;
    let delta = 0;
    if (totalDiff.length) {
        delta = totalDiff.length / termFrom.length * 100;
    }
    return 100 - Math.floor(delta);
}

/**
 * Service where all available search sources are registered.
 */
class SearchSourceService {
    constructor(sources) {
        this.sources = sources;
    }
    /**
     * Return available search sources
     * @returns Search sources
     */
    getSources() {
        return this.sources;
    }
    /**
     * Return enabled search sources
     * @returns Search sources
     */
    getEnabledSources() {
        return this.getSources().filter((source) => source.enabled === true);
    }
    /**
     * Enable search sources of given type
     * @param type Search type
     * @todo It would be better to track the enabled search sources
     *  without updating their 'enabled' property.
     */
    enableSourcesByType(type) {
        this.getSources().forEach((source) => {
            if (source.constructor.type === type) {
                source.enabled = true;
            }
            else {
                source.enabled = false;
            }
        });
    }
    /**
     * Set Param from the selected settings
     * @param source search-source
     * @param setting settings
     */
    setParamFromSetting(source, setting) {
        source.setParamFromSetting(setting);
    }
}

/**
 * This service perform researches in all the search sources enabled.
 * It returns Research objects who's 'request' property needs to be
 * subscribed to in order to trigger the research. This services has
 * keeps internal state of the researches it performed
 * and the results they yielded.
 */
class SearchService {
    constructor(searchSourceService, mapService) {
        this.searchSourceService = searchSourceService;
        this.mapService = mapService;
    }
    /**
     * Perform a research by text
     * @param term Any text
     * @returns Researches
     */
    search(term, options = {}) {
        var _a, _b;
        if (!this.termIsValid(term)) {
            return [];
        }
        const proj = ((_a = this.mapService.getMap()) === null || _a === void 0 ? void 0 : _a.projection) || 'EPSG:3857';
        const response = stringToLonLat(term, proj, {
            forceNA: options.forceNA
        });
        if (response.lonLat) {
            return this.reverseSearch(response.lonLat, { distance: response.radius, conf: response.conf });
        }
        else if (response.message) {
            console.log(response.message);
        }
        options.extent = (_b = this.mapService
            .getMap()) === null || _b === void 0 ? void 0 : _b.viewController.getExtent('EPSG:4326');
        let sources;
        if (options.getEnabledOnly || options.getEnabledOnly === undefined) {
            sources = this.searchSourceService.getEnabledSources();
        }
        else {
            sources = this.searchSourceService.getSources();
        }
        if (options.sourceId) {
            sources = sources.filter((source) => source.getId() === options.sourceId);
        }
        else if (options.searchType) {
            sources = sources.filter((source) => source.getType() === options.searchType);
        }
        sources = sources.filter(sourceCanSearch);
        return this.searchSources(sources, term, options);
    }
    /**
     * Perform a research by lon/lat
     * @param lonLat Any lon/lat coordinates
     * @returns Researches
     */
    reverseSearch(lonLat, options, asPointerSummary = false) {
        const reverseSourceFonction = asPointerSummary
            ? sourceCanReverseSearchAsSummary
            : sourceCanReverseSearch;
        const sources = this.searchSourceService
            .getEnabledSources()
            .filter(reverseSourceFonction);
        return this.reverseSearchSources(sources, lonLat, options || {});
    }
    /**
     * Create a text research out of all given search sources
     * @param sources Search sources that implement TextSearch
     * @param term Search term
     * @returns Observable of Researches
     */
    searchSources(sources, term, options) {
        return sources.map((source) => {
            return {
                request: source.search(term, options),
                reverse: false,
                source
            };
        });
    }
    /**
     * Create a reverse research out of all given search sources
     * @param sources Search sources that implement ReverseSearch
     * @param lonLat Any lon/lat coordinates
     * @returns Observable of Researches
     */
    reverseSearchSources(sources, lonLat, options) {
        return sources.map((source) => {
            return {
                request: source.reverseSearch(lonLat, options),
                reverse: true,
                source
            };
        });
    }
    /**
     * Validate that a search term is valid
     * @param term Search term
     * @returns True if the search term is valid
     */
    termIsValid(term) {
        return typeof term === 'string' && term !== '';
    }
}
SearchService.ɵfac = function SearchService_Factory(t) { return new (t || SearchService)(i0.ɵɵinject(SearchSourceService), i0.ɵɵinject(MapService)); };
SearchService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: SearchService, factory: SearchService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SearchService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: SearchSourceService }, { type: MapService }]; }, null); })();

function DirectionsButtonsComponent_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 5);
    i0.ɵɵlistener("click", function DirectionsButtonsComponent_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.resetStops(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 6);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.directionsForm.resetDirectionsBtn"));
} }
function DirectionsButtonsComponent_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 1);
    i0.ɵɵlistener("click", function DirectionsButtonsComponent_button_7_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.zoomRoute(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 7);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.directionsForm.zoomRoute"));
} }
function DirectionsButtonsComponent_button_9_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 1);
    i0.ɵɵlistener("click", function DirectionsButtonsComponent_button_9_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(); return ctx_r8.copyDirectionsToClipboard(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 8);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.directionsForm.copy"));
} }
function DirectionsButtonsComponent_button_11_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 1);
    i0.ɵɵlistener("click", function DirectionsButtonsComponent_button_11_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.copyLinkToClipboard(); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵelement(2, "mat-icon", 9);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 1, "igo.geo.directionsForm.link"));
} }
class DirectionsButtonsComponent {
    constructor(languageService, messageService, route) {
        this.languageService = languageService;
        this.messageService = messageService;
        this.route = route;
        this.zoomToActiveRoute$ = new Subject();
    }
    get activeRoute() {
        return this.routesFeatureStore.all().find(route => route.properties.active);
    }
    resetStops() {
        this.stopsStore.clearStops();
    }
    // stop are always added before the last stop.
    addStop() {
        addStopToStore(this.stopsStore);
    }
    copyLinkToClipboard() {
        const successful = Clipboard.copy(this.getUrl());
        if (successful) {
            const translate = this.languageService.translate;
            const title = translate.instant('igo.geo.directionsForm.dialog.copyTitle');
            const msg = translate.instant('igo.geo.directionsForm.dialog.copyMsgLink');
            this.messageService.success(msg, title);
        }
    }
    zoomRoute() {
        this.zoomToActiveRoute$.next();
    }
    copyDirectionsToClipboard() {
        const directionsBody = this.directionsToText();
        const successful = Clipboard.copy(directionsBody);
        if (successful) {
            const translate = this.languageService.translate;
            const title = translate.instant('igo.geo.directionsForm.dialog.copyTitle');
            const msg = translate.instant('igo.geo.directionsForm.dialog.copyMsg');
            this.messageService.success(msg, title);
        }
    }
    directionsToText() {
        const indent = '\t';
        let activeRouteDirective = this.languageService.translate.instant('igo.geo.directionsForm.instructions') + ':\n';
        let wayPointList = '';
        const summary = this.languageService.translate.instant('igo.geo.directionsForm.summary') +
            ': \n' +
            indent +
            this.activeRoute.properties.direction.title +
            '\n' +
            indent +
            formatDistance(this.activeRoute.properties.direction.distance) +
            '\n' +
            indent +
            formatDuration(this.activeRoute.properties.direction.duration) +
            '\n\n' +
            this.languageService.translate.instant('igo.geo.directionsForm.stopsList') +
            ':\n';
        const url = this.languageService.translate.instant('igo.geo.directionsForm.link') +
            ':\n' +
            indent +
            this.getUrl();
        let wayPointsCnt = 1;
        this.stopsStore.view.all().forEach(stop => {
            let coord = '';
            let stopText = '';
            if (stop.text !== roundCoordTo(stop.coordinates).join(',')) {
                stopText = stop.text;
                coord = ` ( ${roundCoordTo(stop.coordinates).join(',')} )`;
            }
            else {
                stopText = roundCoordTo(stop.coordinates).join(',');
            }
            wayPointList =
                wayPointList +
                    indent +
                    wayPointsCnt.toLocaleString() +
                    '. ' +
                    stopText +
                    coord +
                    '\n';
            wayPointsCnt++;
        });
        let localCnt = 0;
        this.activeRoute.properties.direction.steps.forEach(step => {
            const instruction = this.formatStep(step, localCnt).instruction;
            const distance = formatDistance(step.distance) === undefined
                ? ''
                : ' (' + formatDistance(step.distance) + ')';
            activeRouteDirective =
                activeRouteDirective +
                    indent +
                    (localCnt + 1).toLocaleString() +
                    '. ' +
                    instruction +
                    distance +
                    '\n';
            localCnt++;
        });
        const directionsBody = summary + wayPointList + '\n' + url + '\n\n' + activeRouteDirective;
        return directionsBody;
    }
    formatStep(step, cnt) {
        return formatInstruction(step.maneuver.type, step.maneuver.modifier, step.name, step.maneuver.bearing_after, cnt, step.maneuver.exit, this.languageService, cnt === this.activeRoute.properties.direction.steps.length - 1);
    }
    getUrl() {
        if (!this.route) {
            return;
        }
        let context = '';
        if (this.contextUri) {
            context = `context=${this.contextUri}&`;
        }
        const pos = this.routesFeatureStore.all()
            .map((direction) => direction.properties.id).indexOf(this.activeRoute.properties.id);
        let routingOptions = '';
        if (pos !== 0) {
            const routingOptionsKey = this.route.options.directionsOptionsKey;
            routingOptions = `&${routingOptionsKey}=result:${pos}`;
        }
        const directionsKey = this.route.options.directionsCoordKey;
        const stopsCoordinates = this.stopsStore.view.all().map(stop => roundCoordTo(stop.coordinates, 6));
        let directionsUrl = '';
        if (stopsCoordinates.length >= 2) {
            directionsUrl = `${directionsKey}=${stopsCoordinates.join(';')}`;
            return `${location.origin}${location.pathname}?${context}tool=directions&sidenav=1&${directionsUrl}${routingOptions}`;
        }
        return;
    }
}
DirectionsButtonsComponent.ɵfac = function DirectionsButtonsComponent_Factory(t) { return new (t || DirectionsButtonsComponent)(i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(i2$1.MessageService), i0.ɵɵdirectiveInject(i2$1.RouteService, 8)); };
DirectionsButtonsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: DirectionsButtonsComponent, selectors: [["igo-directions-buttons"]], inputs: { contextUri: "contextUri", zoomToActiveRoute$: "zoomToActiveRoute$", stopsStore: "stopsStore", routesFeatureStore: "routesFeatureStore" }, decls: 13, vars: 17, consts: [[1, "igo-form-button-group"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "primary", 3, "matTooltip", "click"], ["svgIcon", "map-marker-plus"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "warn", 3, "matTooltip", "click", 4, "ngIf"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "primary", 3, "matTooltip", "click", 4, "ngIf"], ["mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", "color", "warn", 3, "matTooltip", "click"], ["svgIcon", "file-restore"], ["svgIcon", "magnify-plus-outline"], ["svgIcon", "content-copy"], ["svgIcon", "link"]], template: function DirectionsButtonsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelementStart(1, "button", 1);
        i0.ɵɵlistener("click", function DirectionsButtonsComponent_Template_button_click_1_listener() { return ctx.addStop(); });
        i0.ɵɵpipe(2, "translate");
        i0.ɵɵelement(3, "mat-icon", 2);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(4, DirectionsButtonsComponent_button_4_Template, 3, 3, "button", 3);
        i0.ɵɵpipe(5, "async");
        i0.ɵɵpipe(6, "async");
        i0.ɵɵtemplate(7, DirectionsButtonsComponent_button_7_Template, 3, 3, "button", 4);
        i0.ɵɵpipe(8, "async");
        i0.ɵɵtemplate(9, DirectionsButtonsComponent_button_9_Template, 3, 3, "button", 4);
        i0.ɵɵpipe(10, "async");
        i0.ɵɵtemplate(11, DirectionsButtonsComponent_button_11_Template, 3, 3, "button", 4);
        i0.ɵɵpipe(12, "async");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(2, 5, "igo.geo.directionsForm.addStop"));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(5, 7, ctx.routesFeatureStore.count$) >= 1 || i0.ɵɵpipeBind1(6, 9, ctx.stopsStore.count$) >= 1);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(8, 11, ctx.routesFeatureStore.count$) >= 1);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(10, 13, ctx.routesFeatureStore.count$) >= 1);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(12, 15, ctx.routesFeatureStore.count$) >= 1);
    } }, directives: [i2.MatButton, i3.MatTooltip, i4.MatIcon, i1$1.NgIf], pipes: [i7.TranslatePipe, i1$1.AsyncPipe], styles: [""] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DirectionsButtonsComponent, [{
        type: Component,
        args: [{
                selector: 'igo-directions-buttons',
                templateUrl: './directions-buttons.component.html',
                styleUrls: ['./directions-buttons.component.scss']
            }]
    }], function () { return [{ type: i2$1.LanguageService }, { type: i2$1.MessageService }, { type: i2$1.RouteService, decorators: [{
                type: Optional
            }] }]; }, { contextUri: [{
            type: Input
        }], zoomToActiveRoute$: [{
            type: Input
        }], stopsStore: [{
            type: Input
        }], routesFeatureStore: [{
            type: Input
        }] }); })();

function DirectionsResultsComponent_div_0_mat_form_field_1_mat_option_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-option", 9);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const direction_r5 = ctx.$implicit;
    const cnt_r6 = ctx.index;
    const ctx_r4 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("value", direction_r5);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate3(" Option ", cnt_r6 + 1, " : ", ctx_r4.formatDistance(direction_r5.distance), " (", ctx_r4.formatDuration(direction_r5.duration), ") ");
} }
function DirectionsResultsComponent_div_0_mat_form_field_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-form-field");
    i0.ɵɵelementStart(1, "mat-select", 7);
    i0.ɵɵlistener("selectionChange", function DirectionsResultsComponent_div_0_mat_form_field_1_Template_mat_select_selectionChange_1_listener() { i0.ɵɵrestoreView(_r8); const ctx_r7 = i0.ɵɵnextContext(2); return ctx_r7.changeRoute(); })("ngModelChange", function DirectionsResultsComponent_div_0_mat_form_field_1_Template_mat_select_ngModelChange_1_listener($event) { i0.ɵɵrestoreView(_r8); const ctx_r9 = i0.ɵɵnextContext(2); return ctx_r9.activeDirection = $event; });
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵtemplate(3, DirectionsResultsComponent_div_0_mat_form_field_1_mat_option_3_Template, 2, 4, "mat-option", 8);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("placeholder", i0.ɵɵpipeBind1(2, 3, "igo.geo.directionsForm.drivingOptions"));
    i0.ɵɵproperty("ngModel", ctx_r1.activeDirection);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r1.directions);
} }
function DirectionsResultsComponent_div_0_mat_divider_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-divider");
} }
function DirectionsResultsComponent_div_0_mat_list_item_8_Template(rf, ctx) { if (rf & 1) {
    const _r13 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-list-item", 10);
    i0.ɵɵlistener("mouseenter", function DirectionsResultsComponent_div_0_mat_list_item_8_Template_mat_list_item_mouseenter_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r13); const step_r10 = restoredCtx.$implicit; const ctx_r12 = i0.ɵɵnextContext(2); return ctx_r12.showSegment(step_r10); })("click", function DirectionsResultsComponent_div_0_mat_list_item_8_Template_mat_list_item_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r13); const step_r10 = restoredCtx.$implicit; const ctx_r14 = i0.ɵɵnextContext(2); return ctx_r14.showSegment(step_r10, true); });
    i0.ɵɵelement(1, "mat-icon", 11);
    i0.ɵɵelementStart(2, "h4", 12);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "h4", 13);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r10 = ctx.$implicit;
    const cnt_r11 = ctx.index;
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("svgIcon", ctx_r3.formatStep(step_r10, cnt_r11).image);
    i0.ɵɵproperty("ngClass", ctx_r3.formatStep(step_r10, cnt_r11).cssClass);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate2("", cnt_r11 + 1, ". ", ctx_r3.formatStep(step_r10, cnt_r11).instruction, "");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r3.formatDistance(step_r10.distance));
} }
function DirectionsResultsComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 1);
    i0.ɵɵtemplate(1, DirectionsResultsComponent_div_0_mat_form_field_1_Template, 4, 5, "mat-form-field", 2);
    i0.ɵɵtemplate(2, DirectionsResultsComponent_div_0_mat_divider_2_Template, 1, 0, "mat-divider", 2);
    i0.ɵɵelementStart(3, "mat-list", 3);
    i0.ɵɵlistener("mouseleave", function DirectionsResultsComponent_div_0_Template_mat_list_mouseleave_3_listener() { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.onStepsListBlur(); });
    i0.ɵɵelementStart(4, "h2", 4);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(6, "h2", 5);
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(8, DirectionsResultsComponent_div_0_mat_list_item_8_Template, 6, 5, "mat-list-item", 6);
    i0.ɵɵelement(9, "mat-divider");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.directions && ctx_r0.directions.length > 1);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.directions && ctx_r0.directions.length === 0);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r0.activeDirection.title);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate2("", ctx_r0.formatDistance(ctx_r0.activeDirection.distance), ", ", ctx_r0.formatDuration(ctx_r0.activeDirection.duration), "");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r0.activeDirection.steps);
} }
class DirectionsResultsComponent {
    constructor(languageService, cdRef) {
        this.languageService = languageService;
        this.cdRef = cdRef;
    }
    ngOnInit() {
        this.entities$$ = this.routesFeatureStore.entities$
            .pipe(debounceTime(200))
            .subscribe(entities => {
            const activeFeatureWithDirection = entities.find(entity => entity.properties.active);
            this.directions = entities.map(entity => entity.properties.direction);
            if (activeFeatureWithDirection) {
                this.activeDirection = activeFeatureWithDirection.properties.direction;
            }
            else {
                this.activeDirection = undefined;
            }
            this.cdRef.detectChanges();
        });
    }
    ngOnDestroy() {
        this.entities$$.unsubscribe();
    }
    changeRoute() {
        this.routesFeatureStore.entities$.value.map(entity => entity.properties.active = !entity.properties.active);
        this.routesFeatureStore.layer.ol.getSource().getFeatures().map(feature => feature.set('active', !feature.get('active')));
    }
    formatDistance(distance) {
        return formatDistance(distance);
    }
    formatDuration(duration) {
        return formatDuration(duration);
    }
    formatStep(step, cnt) {
        return formatInstruction(step.maneuver.type, step.maneuver.modifier, step.name, step.maneuver.bearing_after, cnt, step.maneuver.exit, this.languageService, cnt === this.activeDirection.steps.length - 1);
    }
    onStepsListBlur() {
        this.stepFeatureStore.clear();
    }
    showSegment(step, zoomToExtent = false) {
        this.showRouteSegmentGeometry(step, zoomToExtent);
    }
    showRouteSegmentGeometry(step, zoomToExtent = false) {
        const coordinates = step.geometry.coordinates;
        const vertexId = 'vertex';
        const geometry4326 = new olgeom.LineString(coordinates);
        const geometryMapProjection = geometry4326.transform('EPSG:4326', this.stepFeatureStore.layer.map.projection);
        const routeSegmentCoordinates = geometryMapProjection.getCoordinates();
        const lastPoint = routeSegmentCoordinates[0];
        const geometry = new olgeom.Point(lastPoint);
        const feature = new OlFeature({ geometry });
        const geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
            featureProjection: this.stepFeatureStore.layer.map.projection,
            dataProjection: this.stepFeatureStore.layer.map.projection
        });
        const previousVertex = this.stepFeatureStore.get(vertexId);
        const previousVertexRevision = previousVertex
            ? previousVertex.meta.revision
            : 0;
        const stepFeature = {
            type: FEATURE,
            geometry: geojsonGeom,
            projection: this.stepFeatureStore.layer.map.projection,
            properties: {
                id: vertexId,
                step,
                type: DirectionType.Vertex
            },
            meta: {
                id: vertexId,
                revision: previousVertexRevision + 1
            },
            ol: feature
        };
        this.stepFeatureStore.update(stepFeature);
        if (zoomToExtent) {
            this.stepFeatureStore.layer.map.viewController.zoomToExtent(feature.getGeometry().getExtent());
        }
    }
}
DirectionsResultsComponent.ɵfac = function DirectionsResultsComponent_Factory(t) { return new (t || DirectionsResultsComponent)(i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
DirectionsResultsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: DirectionsResultsComponent, selectors: [["igo-directions-results"]], inputs: { routesFeatureStore: "routesFeatureStore", stepFeatureStore: "stepFeatureStore" }, decls: 1, vars: 1, consts: [["class", "igo-input-container", 4, "ngIf"], [1, "igo-input-container"], [4, "ngIf"], [3, "mouseleave"], ["mat-header", "", 1, "igo-route-title", "mat-typography"], ["mat-subheader", ""], ["class", "igo-steps", "igoListItem", "", 3, "mouseenter", "click", 4, "ngFor", "ngForOf"], [3, "placeholder", "ngModel", "selectionChange", "ngModelChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], ["igoListItem", "", 1, "igo-steps", 3, "mouseenter", "click"], ["mat-list-icon", "", 3, "ngClass", "svgIcon"], ["mat-line", ""], ["mat-line", "", 1, "right"]], template: function DirectionsResultsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, DirectionsResultsComponent_div_0_Template, 10, 6, "div", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.directions && ctx.activeDirection);
    } }, directives: [i1$1.NgIf, i1$3.MatList, i1$3.MatListSubheaderCssMatStyler, i1$1.NgForOf, i10.MatDivider, i12.MatFormField, i13.MatSelect, i16.NgControlStatus, i16.NgModel, i9.MatOption, i1$3.MatListItem, i4.MatIcon, i1$3.MatListIconCssMatStyler, i1$1.NgClass, i9.MatLine], pipes: [i7.TranslatePipe], styles: [".igo-input-container[_ngcontent-%COMP%]{width:100%;padding:20px 10px}.igo-input-container[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%]{width:70%}.igo-route-title[_ngcontent-%COMP%]{font-weight:bold}.igo-steps[_ngcontent-%COMP%]{cursor:pointer}.mat-line[_ngcontent-%COMP%]{word-wrap:break-word!important;white-space:pre-wrap!important}.mat-line.right[_ngcontent-%COMP%]{text-align:right}.rotate-90[_ngcontent-%COMP%]{transform:rotate(90deg)}.rotate-45[_ngcontent-%COMP%]{transform:rotate(45deg)}.rotate-270[_ngcontent-%COMP%]{transform:rotate(270deg)}.rotate-250[_ngcontent-%COMP%]{transform:rotate(250deg)}.rotate-290[_ngcontent-%COMP%]{transform:rotate(290deg)}.icon-flipped[_ngcontent-%COMP%]{transform:scaleY(-1)}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DirectionsResultsComponent, [{
        type: Component,
        args: [{
                selector: 'igo-directions-results',
                templateUrl: './directions-results.component.html',
                styleUrls: ['./directions-results.component.scss']
            }]
    }], function () { return [{ type: i2$1.LanguageService }, { type: i0.ChangeDetectorRef }]; }, { routesFeatureStore: [{
            type: Input
        }], stepFeatureStore: [{
            type: Input
        }] }); })();

class DirectionsComponent {
    constructor(cdRef, languageService, directionsService, searchService, queryService) {
        this.cdRef = cdRef;
        this.languageService = languageService;
        this.directionsService = directionsService;
        this.searchService = searchService;
        this.queryService = queryService;
        this.projection = 'EPSG:4326';
        this.routesQueries$$ = [];
        this.focusOnStop = false;
        this.isTranslating = false;
        this.previousStops = [];
        this.searchs$$ = [];
        this.debounce = 200;
        this.length = 2;
        this.coordRoundedDecimals = 6;
        this.zoomToActiveRoute$ = new Subject();
    }
    ngOnInit() {
        this.queryService.queryEnabled = false;
        this.initEntityStores();
        setTimeout(() => {
            initStopsFeatureStore(this.stopsFeatureStore, this.languageService);
            initRoutesFeatureStore(this.routesFeatureStore, this.languageService);
            initStepFeatureStore(this.stepFeatureStore);
            this.initOlInteraction();
        }, 1);
    }
    ngOnDestroy() {
        this.queryService.queryEnabled = true;
        this.storeEmpty$$.unsubscribe();
        this.storeChange$$.unsubscribe();
        this.routesQueries$$.map((u) => u.unsubscribe());
        this.zoomRoute$$.unsubscribe();
        this.freezeStores();
    }
    freezeStores() {
        this.stopsFeatureStore.layer.map.ol.removeInteraction(this.selectStopInteraction);
        this.stopsFeatureStore.layer.map.ol.removeInteraction(this.translateStop);
        this.routesFeatureStore.layer.map.ol.removeInteraction(this.selectedRoute);
        this.stopsFeatureStore.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
        this.routesFeatureStore.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
        this.stepFeatureStore.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
    }
    initEntityStores() {
        this.watcher = new EntityStoreWatcher(this.stopsStore, this.cdRef);
        this.monitorEmptyEntityStore();
        this.monitorEntityStoreChange();
        this.monitorActiveRouteZoom();
    }
    monitorActiveRouteZoom() {
        this.zoomRoute$$ = this.zoomToActiveRoute$.subscribe(() => {
            if (this.routesFeatureStore.count >= 1) {
                const activeRoute = this.routesFeatureStore.all().find(route => route.properties.active);
                if (activeRoute) {
                    activeRoute.ol.getGeometry();
                    const routeExtent = activeRoute.ol.getGeometry().getExtent();
                    this.routesFeatureStore.layer.map.viewController.zoomToExtent(routeExtent);
                }
            }
        });
    }
    initOlInteraction() {
        this.selectStopInteraction = new olInteraction.Select({
            layers: [this.stopsFeatureStore.layer.ol],
            hitTolerance: 7,
            condition: (event) => {
                return event.type === 'pointermove' && !event.dragging;
            }
        });
        this.translateStop = new olInteraction.Translate({
            features: this.selectStopInteraction.getFeatures()
        });
        this.translateStop.on('translating', (evt) => {
            this.isTranslating = true;
            this.executeStopTranslation(evt.features);
        });
        this.translateStop.on('translateend', (evt) => {
            this.isTranslating = false;
            this.executeStopTranslation(evt.features);
        });
        this.selectedRoute = new olInteraction.Select({
            layers: [this.routesFeatureStore.layer.ol],
            condition: olCondition.click,
            hitTolerance: 7,
            filter: feature => {
                return feature.get('type') === DirectionType.Route &&
                    feature.get('active') &&
                    !this.isTranslating;
            }
        });
        this.selectedRoute.on('select', (evt) => {
            if (this.focusOnStop === false) {
                const selectCoordinates = roundCoordTo(olproj.transform(evt.mapBrowserEvent.coordinate, this.routesFeatureStore.layer.map.projection, this.projection), this.coordRoundedDecimals);
                const addedStop = addStopToStore(this.stopsStore);
                addedStop.text = selectCoordinates.join(',');
                addedStop.coordinates = [selectCoordinates[0], selectCoordinates[1]];
            }
        });
        this.stopsFeatureStore.layer.map.ol.addInteraction(this.selectStopInteraction);
        this.stopsFeatureStore.layer.map.ol.addInteraction(this.translateStop);
        this.routesFeatureStore.layer.map.ol.addInteraction(this.selectedRoute);
    }
    onStopInputHasFocusChange(stopInputHasFocus) {
        stopInputHasFocus ?
            this.routesFeatureStore.layer.map.ol.removeInteraction(this.selectedRoute) :
            this.routesFeatureStore.layer.map.ol.addInteraction(this.selectedRoute);
    }
    executeStopTranslation(features) {
        if (features.getLength() === 0) {
            return;
        }
        const firstFeature = features.getArray()[0];
        const translatedStopId = firstFeature.getId();
        const translationCoordinates = olproj.transform(firstFeature.getGeometry().getCoordinates(), this.stopsFeatureStore.layer.map.projection, this.projection);
        const translatedStop = this.stopsStore.get(translatedStopId);
        const roundedCoord = roundCoordTo(translationCoordinates, this.coordRoundedDecimals);
        translatedStop.coordinates = roundedCoord;
        translatedStop.text = roundedCoord.join(',');
        this.stopsStore.update(translatedStop);
    }
    monitorEmptyEntityStore() {
        // Watch if the store is empty to reset it
        this.storeEmpty$$ = this.stopsStore.count$
            .pipe(distinctUntilChanged()).subscribe((count) => {
            if (count < 2) {
                addStopToStore(this.stopsStore);
                if (this.stopsStore.count === 2) {
                    this.stopsStore.storeInitialized$.next(true);
                    return;
                }
                this.stopsStore.storeInitialized$.next(false);
            }
            this.routesQueries$$.map((u) => u.unsubscribe());
        });
    }
    monitorEntityStoreChange() {
        this.storeChange$$ = this.stopsStore.entities$
            .pipe(debounceTime(this.debounce))
            .subscribe((stops) => {
            this.handleStopDiff(stops);
            updateStoreSorting(this.stopsStore);
            this.handleStopsFeature();
            this.getRoutes(this.isTranslating);
        });
    }
    cancelSearch() {
        this.searchs$$.map(s => s.unsubscribe());
    }
    handleStopDiff(stops) {
        const simplifiedStops = stops.map((stop) => {
            return ObjectUtils.removeUndefined(Object.assign({ id: stop.id, text: stop.text, coordinates: stop.coordinates }));
        });
        const diff = ChangeUtils.findChanges(this.previousStops, simplifiedStops, ['coordinates']);
        const stopIdToProcess = diff.added.concat(diff.modified);
        if (stopIdToProcess) {
            stopIdToProcess.map((change) => {
                const changedStop = change.newValue;
                if (changedStop) {
                    const stop = this.stopsStore.get(changedStop.id);
                    const term = stop.text;
                    if (!term || term.length === 0) {
                        return;
                    }
                    const response = stringToLonLat(term, this.stopsFeatureStore.layer.map.projection);
                    let researches;
                    let isCoord = false;
                    if (response.lonLat) {
                        isCoord = true;
                    }
                    researches = this.searchService.search(term, { searchType: 'Feature' });
                    this.cancelSearch();
                    const requests$ = researches.map(res => res.request
                        .pipe(map((results) => results.filter(r => isCoord ? r.data.geometry.type === 'Point' && r.data.geometry : r.data.geometry))));
                    this.searchs$$ = requests$.map((request) => {
                        return request.pipe(map((results) => results.filter(r => isCoord ? r.data.geometry.type === 'Point' && r.data.geometry : r.data.geometry)))
                            .subscribe((res) => {
                            if (res.length > 0) {
                                const source = res[0].source;
                                const meta = res[0].meta;
                                const results = res.map(r => r.data);
                                if (!stop.searchProposals) {
                                    stop.searchProposals = [];
                                }
                                stop.searchProposals = stop.searchProposals.filter(sp => sp.type === (isCoord ? ProposalType.Coord : ProposalType.Text));
                                let storedSource = stop.searchProposals.find(sp => sp.source === source);
                                if (storedSource) {
                                    storedSource.results = results;
                                }
                                else {
                                    stop.searchProposals.push({
                                        type: isCoord ? ProposalType.Coord : ProposalType.Text,
                                        source,
                                        meta,
                                        results
                                    });
                                }
                            }
                            this.cdRef.detectChanges();
                        });
                    });
                }
            });
        }
        this.previousStops = simplifiedStops;
    }
    handleStopsFeature() {
        const stops = this.stopsStore.all();
        const stopsWithCoordinates = stops.filter(stop => stop.coordinates);
        stopsWithCoordinates.map(stop => this.addStopOverlay(stop));
        this.stopsFeatureStore.all().map((stopFeature) => {
            if (!this.stopsStore.get(stopFeature.properties.id)) {
                this.stopsFeatureStore.delete(stopFeature);
            }
        });
        const stopsWithoutCoordinates = stops.filter(stop => !stop.coordinates);
        stopsWithoutCoordinates.map(stop => {
            const stopFeature = this.stopsFeatureStore.get(stop.id);
            if (stopFeature) {
                this.stopsFeatureStore.delete(stopFeature);
            }
        });
    }
    getRoutes(isOverview = false) {
        const stopsWithCoordinates = this.stopsStore.view
            .all()
            .filter(stop => stop.coordinates);
        if (stopsWithCoordinates.length < 2) {
            this.routesFeatureStore.deleteMany(this.routesFeatureStore.all());
            return;
        }
        const roundedCoordinates = stopsWithCoordinates.map((stop) => {
            const roundedCoord = roundCoordTo(stop.coordinates, this.coordRoundedDecimals);
            return roundedCoord;
        });
        const overviewDirectionsOptions = {
            overview: true,
            steps: false,
            alternatives: false,
            continue_straight: false
        };
        this.routesQueries$$.map((u) => u.unsubscribe());
        const routeResponse = this.directionsService.route(roundedCoordinates, isOverview ? overviewDirectionsOptions : undefined);
        if (routeResponse) {
            routeResponse.map(res => this.routesQueries$$.push(res.subscribe(directions => {
                this.routesFeatureStore.deleteMany(this.routesFeatureStore.all());
                directions.map(direction => addDirectionToRoutesFeatureStore(this.routesFeatureStore, direction, this.projection, direction === directions[0] ? true : false));
            })));
        }
    }
    addStopOverlay(stop) {
        addStopToStopsFeatureStore(stop, this.stopsStore, this.stopsFeatureStore, this.projection, this.languageService);
    }
}
DirectionsComponent.ɵfac = function DirectionsComponent_Factory(t) { return new (t || DirectionsComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(DirectionsService), i0.ɵɵdirectiveInject(SearchService), i0.ɵɵdirectiveInject(QueryService)); };
DirectionsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: DirectionsComponent, selectors: [["igo-directions"]], inputs: { contextUri: "contextUri", stopsStore: "stopsStore", stopsFeatureStore: "stopsFeatureStore", routesFeatureStore: "routesFeatureStore", stepFeatureStore: "stepFeatureStore", debounce: "debounce", length: "length", coordRoundedDecimals: "coordRoundedDecimals", zoomToActiveRoute$: "zoomToActiveRoute$" }, decls: 4, vars: 12, consts: [[3, "contextUri", "zoomToActiveRoute$", "routesFeatureStore", "stopsStore"], [3, "coordRoundedDecimals", "projection", "stopsFeatureStore", "stopsStore", "debounce", "length", "stopInputHasFocus"], [3, "stepFeatureStore", "routesFeatureStore"]], template: function DirectionsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelement(0, "igo-directions-buttons", 0);
        i0.ɵɵelementStart(1, "igo-directions-inputs", 1);
        i0.ɵɵlistener("stopInputHasFocus", function DirectionsComponent_Template_igo_directions_inputs_stopInputHasFocus_1_listener($event) { return ctx.onStopInputHasFocusChange($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵelement(2, "br");
        i0.ɵɵelement(3, "igo-directions-results", 2);
    } if (rf & 2) {
        i0.ɵɵproperty("contextUri", ctx.contextUri)("zoomToActiveRoute$", ctx.zoomToActiveRoute$)("routesFeatureStore", ctx.routesFeatureStore)("stopsStore", ctx.stopsStore);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("coordRoundedDecimals", ctx.coordRoundedDecimals)("projection", ctx.projection)("stopsFeatureStore", ctx.stopsFeatureStore)("stopsStore", ctx.stopsStore)("debounce", ctx.debounce)("length", ctx.length);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("stepFeatureStore", ctx.stepFeatureStore)("routesFeatureStore", ctx.routesFeatureStore);
    } }, directives: [DirectionsButtonsComponent, DirectionsInputsComponent, DirectionsResultsComponent], styles: [""] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(DirectionsComponent, [{
        type: Component,
        args: [{
                selector: 'igo-directions',
                templateUrl: './directions.component.html',
                styleUrls: ['./directions.component.scss']
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i2$1.LanguageService }, { type: DirectionsService }, { type: SearchService }, { type: QueryService }]; }, { contextUri: [{
            type: Input
        }], stopsStore: [{
            type: Input
        }], stopsFeatureStore: [{
            type: Input
        }], routesFeatureStore: [{
            type: Input
        }], stepFeatureStore: [{
            type: Input
        }], debounce: [{
            type: Input
        }], length: [{
            type: Input
        }], coordRoundedDecimals: [{
            type: Input
        }], zoomToActiveRoute$: [{
            type: Input
        }] }); })();

class IgoDirectionsModule {
    static forRoot() {
        return {
            ngModule: IgoDirectionsModule
        };
    }
}
IgoDirectionsModule.ɵfac = function IgoDirectionsModule_Factory(t) { return new (t || IgoDirectionsModule)(); };
IgoDirectionsModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoDirectionsModule });
IgoDirectionsModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [provideDirectionsSourceService()], imports: [[
            CommonModule,
            DragDropModule,
            FormsModule,
            ReactiveFormsModule,
            MatIconModule,
            MatButtonModule,
            MatListModule,
            MatDividerModule,
            MatFormFieldModule,
            MatInputModule,
            MatOptionModule,
            MatSelectModule,
            MatTooltipModule,
            MatAutocompleteModule,
            IgoLanguageModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoDirectionsModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    DragDropModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MatIconModule,
                    MatButtonModule,
                    MatListModule,
                    MatDividerModule,
                    MatFormFieldModule,
                    MatInputModule,
                    MatOptionModule,
                    MatSelectModule,
                    MatTooltipModule,
                    MatAutocompleteModule,
                    IgoLanguageModule
                ],
                exports: [
                    DirectionsComponent,
                    DirectionsInputsComponent,
                    DirectionsButtonsComponent,
                    DirectionsResultsComponent
                ],
                declarations: [
                    DirectionsComponent,
                    DirectionsInputsComponent,
                    DirectionsButtonsComponent,
                    DirectionsResultsComponent
                ],
                providers: [provideDirectionsSourceService()]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoDirectionsModule, { declarations: [DirectionsComponent,
        DirectionsInputsComponent,
        DirectionsButtonsComponent,
        DirectionsResultsComponent], imports: [CommonModule,
        DragDropModule,
        FormsModule,
        ReactiveFormsModule,
        MatIconModule,
        MatButtonModule,
        MatListModule,
        MatDividerModule,
        MatFormFieldModule,
        MatInputModule,
        MatOptionModule,
        MatSelectModule,
        MatTooltipModule,
        MatAutocompleteModule,
        IgoLanguageModule], exports: [DirectionsComponent,
        DirectionsInputsComponent,
        DirectionsButtonsComponent,
        DirectionsResultsComponent] }); })();

/**
 * Search source factory
 * @ignore
 */
function searchSourceServiceFactory(sources) {
    return new SearchSourceService(sources);
}
/**
 * Function that returns a provider for the SearchSource service
 */
function provideSearchSourceService() {
    return {
        provide: SearchSourceService,
        useFactory: searchSourceServiceFactory,
        deps: [SearchSource]
    };
}

class IChercheSearchResultFormatter {
    constructor(languageService) {
        this.languageService = languageService;
    }
    formatResult(result) {
        return result;
    }
}
IChercheSearchResultFormatter.ɵfac = function IChercheSearchResultFormatter_Factory(t) { return new (t || IChercheSearchResultFormatter)(i0.ɵɵinject(i2$1.LanguageService)); };
IChercheSearchResultFormatter.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: IChercheSearchResultFormatter, factory: IChercheSearchResultFormatter.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IChercheSearchResultFormatter, [{
        type: Injectable
    }], function () { return [{ type: i2$1.LanguageService }]; }, null); })();
// Fix the "+" is replaced with space " " in a query string
// https://github.com/angular/angular/issues/11058
class IgoHttpParameterCodec {
    encodeKey(key) {
        return encodeURIComponent(key);
    }
    encodeValue(value) {
        return encodeURIComponent(value);
    }
    decodeKey(key) {
        return decodeURIComponent(key);
    }
    decodeValue(value) {
        return decodeURIComponent(value);
    }
}
/**
 * ICherche search source
 */
class IChercheSearchSource extends SearchSource {
    constructor(http, languageService, storageService, options, formatter, injector) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
        this.formatter = formatter;
        this.title$ = new BehaviorSubject('');
        this.hashtagsLieuxToKeep = [];
        this.languageService.translate
            .get(this.options.title)
            .subscribe((title) => this.title$.next(title));
        const authService = injector.get(AuthService);
        if (this.settings.length) {
            if (!authService) {
                this.getAllowedTypes();
            }
            else {
                authService.authenticate$.subscribe(() => {
                    this.getAllowedTypes();
                });
            }
        }
    }
    get title() {
        return this.title$.getValue();
    }
    getId() {
        return IChercheSearchSource.id;
    }
    getType() {
        return IChercheSearchSource.type;
    }
    getDefaultOptions() {
        var _a;
        const limit = this.options.params && this.options.params.limit
            ? Number(this.options.params.limit)
            : undefined;
        const ecmax = this.options.params && this.options.params.ecmax
            ? Number(this.options.params.ecmax)
            : undefined;
        const types = ((_a = this.options.params) === null || _a === void 0 ? void 0 : _a.type)
            ? this.options.params.type.replace(/\s/g, '').toLowerCase().split(',')
            : [
                'adresses',
                'codes-postaux',
                'routes',
                'intersections',
                'municipalites',
                'mrc',
                'regadmin',
                'lieux'
            ];
        return {
            title: 'igo.geo.search.icherche.name',
            searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/icherche',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'type',
                    values: [
                        {
                            title: 'igo.geo.search.icherche.type.address',
                            value: 'adresses',
                            enabled: types.indexOf('adresses') !== -1,
                            hashtags: ['adresse']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.oldAddress',
                            value: 'anciennes-adresses',
                            enabled: types.indexOf('anciennes-adresses') !== -1,
                            hashtags: ['anciennes-adresses']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.postalCode',
                            value: 'codes-postaux',
                            enabled: types.indexOf('codes-postaux') !== -1,
                            hashtags: ['code-postal']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.road',
                            value: 'routes',
                            enabled: types.indexOf('routes') !== -1,
                            hashtags: ['route']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.intersection',
                            value: 'intersections',
                            enabled: types.indexOf('intersections') !== -1,
                            hashtags: ['intersection', '+']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.city',
                            value: 'municipalites',
                            enabled: types.indexOf('municipalites') !== -1,
                            hashtags: ['municipalité', 'mun']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.oldCity',
                            value: 'anciennes-municipalites',
                            enabled: types.indexOf('anciennes-municipalites') !== -1,
                            hashtags: ['anciennes-municipalites']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.mrc',
                            value: 'mrc',
                            enabled: types.indexOf('mrc') !== -1,
                            hashtags: ['mrc']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.regadmin',
                            value: 'regadmin',
                            enabled: types.indexOf('regadmin') !== -1,
                            hashtags: ['région-administrative', 'regadmin']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.entreprise',
                            value: 'entreprises',
                            enabled: types.indexOf('entreprises') !== -1,
                            available: false,
                            hashtags: ['entreprise']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.place',
                            value: 'lieux',
                            enabled: types.indexOf('lieux') !== -1,
                            hashtags: ['lieu']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.exit',
                            value: 'sorties-autoroute',
                            enabled: types.indexOf('sorties-autoroute') !== -1,
                            hashtags: ['sortie', 'sorties', 'exit']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.km',
                            value: 'bornes-km',
                            enabled: types.indexOf('bornes-km') !== -1,
                            hashtags: ['borne', 'bornes', 'repère', 'km']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.gcc',
                            value: 'bornes-gcc',
                            enabled: types.indexOf('bornes-gcc') !== -1,
                            hashtags: ['borne', 'bornes', 'repère', 'gcc', 'ccg']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.cn',
                            value: 'bornes-cn',
                            enabled: types.indexOf('bornes-cn') !== -1,
                            hashtags: ['borne', 'bornes', 'cn']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.sumi',
                            value: 'bornes-sumi',
                            enabled: types.indexOf('bornes-sumi') !== -1,
                            hashtags: ['borne', 'bornes', 'sumi']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.hq',
                            value: 'hq',
                            enabled: types.indexOf('hq') !== -1,
                            hashtags: ['hq']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.cadastre',
                            value: 'cadastre',
                            enabled: types.indexOf('cadastre') !== -1,
                            hashtags: ['cadastre']
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'results limit',
                    name: 'limit',
                    values: [
                        {
                            title: '1',
                            value: 1,
                            enabled: limit === 1
                        },
                        {
                            title: '5',
                            value: 5,
                            enabled: limit === 5 || !limit
                        },
                        {
                            title: '10',
                            value: 10,
                            enabled: limit === 10
                        },
                        {
                            title: '25',
                            value: 25,
                            enabled: limit === 25
                        },
                        {
                            title: '50',
                            value: 50,
                            enabled: limit === 50
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'ecmax',
                    name: 'ecmax',
                    values: [
                        {
                            title: '10 %',
                            value: 10,
                            enabled: ecmax === 10
                        },
                        {
                            title: '30 %',
                            value: 30,
                            enabled: ecmax === 30 || !ecmax
                        },
                        {
                            title: '50 %',
                            value: 50,
                            enabled: ecmax === 50
                        },
                        {
                            title: '75 %',
                            value: 75,
                            enabled: ecmax === 75
                        },
                        {
                            title: '100 %',
                            value: 100,
                            enabled: ecmax === 100
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'restrictExtent',
                    name: 'loc',
                    values: [
                        {
                            title: 'igo.geo.search.icherche.restrictExtent.map',
                            value: 'true',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.icherche.restrictExtent.quebec',
                            value: 'false',
                            enabled: true
                        }
                    ]
                }
            ]
        };
    }
    /**
     * Search a location by name or keyword
     * @param term Location name or keyword
     * @returns Observable of <SearchResult<Feature>[]
     */
    search(term, options) {
        const params = this.computeRequestParams(term, options || {});
        if (!params.get('type').length) {
            return of([]);
        }
        this.options.params.page = params.get('page') || '1';
        return this.http.get(`${this.searchUrl}/geocode`, { params }).pipe(map((response) => this.extractResults(response, term)), catchError((err) => {
            err.error.toDisplay = true;
            err.error.title = this.languageService.translate.instant(this.getDefaultOptions().title);
            throw err;
        }));
    }
    getAllowedTypes() {
        return this.http
            .get(`${this.searchUrl}/types`)
            .subscribe((types) => {
            const typeSetting = this.settings.find((s) => s.name === 'type');
            typeSetting.values.forEach((v) => {
                const regex = new RegExp(`^${v.value}(\\.|$)`);
                const typesMatched = types.filter((value) => regex.test(value));
                v.available = typesMatched.length > 0;
                if (v.value === 'lieux') {
                    this.hashtagsLieuxToKeep = [
                        ...new Set(typesMatched
                            .map((t) => t.split('.'))
                            .reduce((a, b) => a.concat(b))
                            .filter((t) => t !== 'lieux'))
                    ];
                }
            });
            this.setParamFromSetting(typeSetting, false);
        });
    }
    computeRequestParams(term, options) {
        const queryParams = Object.assign({
            geometry: true,
            bbox: true,
            icon: true,
            type: 'adresses,codes-postaux,municipalites,mrc,regadmin,lieux,entreprises,bornes-sumi'
        }, this.params, this.computeOptionsParam(term, options || {}).params, {
            q: this.computeTerm(term),
            page: options.page
        });
        if (queryParams.loc === 'true') {
            const [xMin, yMin, xMax, yMax] = options.extent;
            queryParams.loc = `${xMin},${yMin};${xMax},${yMin};${xMax},${yMax};${xMin},${yMax};${xMin},${yMin}`;
        }
        else if (queryParams.loc === 'false') {
            delete queryParams.loc;
        }
        if (/#[A-Za-z]+/.test(queryParams.q)) {
            queryParams.type = 'lieux';
        }
        return new HttpParams({
            fromObject: ObjectUtils.removeUndefined(queryParams),
            encoder: new IgoHttpParameterCodec()
        });
    }
    extractResults(response, term) {
        return response.features.map((data) => {
            return this.formatter.formatResult(this.dataToResult(data, term, response));
        });
    }
    dataToResult(data, term, response) {
        const properties = this.computeProperties(data);
        const id = [this.getId(), properties.type, properties.code].join('.');
        const titleHtml = data.highlight.title || data.properties.nom;
        const subtitleHtml = data.highlight.title2
            ? ' <small> ' + data.highlight.title2 + '</small>'
            : '';
        const subtitleHtml2 = data.highlight.title3
            ? '<br><small> ' + data.highlight.title3 + '</small>'
            : '';
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                extent: data.bbox,
                properties,
                meta: {
                    id,
                    title: data.properties.nom
                }
            },
            meta: {
                dataType: FEATURE,
                id,
                title: data.properties.nom,
                titleHtml: titleHtml + subtitleHtml + subtitleHtml2,
                icon: data.icon || 'map-marker',
                score: data.score || computeTermSimilarity(term.trim(), data.properties.nom),
                nextPage: response.features.length % +this.options.params.limit === 0 &&
                    +this.options.params.page < 10
            }
        };
    }
    computeProperties(data) {
        const properties = ObjectUtils.removeKeys(data.properties, IChercheSearchSource.propertiesBlacklist);
        if (!data.geometry) {
            return Object.assign({ type: data.index }, properties);
        }
        const googleLinksProperties = {
            GoogleMaps: ''
        };
        let googleMaps;
        if (data.geometry.type === 'Point') {
            googleMaps = GoogleLinks.getGoogleMapsCoordLink(data.geometry.coordinates[0], data.geometry.coordinates[1]);
        }
        else {
            const point = pointOnFeature(data.geometry);
            googleMaps = GoogleLinks.getGoogleMapsCoordLink(point.geometry.coordinates[0], point.geometry.coordinates[1]);
        }
        let googleMapsNom;
        if (data.index === 'routes') {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom + ', ' + data.properties.municipalite);
        }
        else if (data.index === 'municipalites') {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom + ', ' + 'ville');
        }
        else if (data.index === 'mrc') {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink('mrc+' + data.properties.nom);
        }
        else if (data.index === 'regadmin') {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom + ',+QC');
        }
        else {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom || data.highlight.title);
        }
        googleLinksProperties.GoogleMaps =
            '<a href=' +
                googleMaps +
                ' target="_blank">' +
                this.languageService.translate.instant('igo.geo.searchByCoord') +
                '</a> <br /> <a href=' +
                googleMapsNom +
                ' target="_blank">' +
                this.languageService.translate.instant('igo.geo.searchByName') +
                '</a>';
        if (data.geometry.type === 'Point') {
            googleLinksProperties.GoogleStreetView = GoogleLinks.getGoogleStreetViewLink(data.geometry.coordinates[0], data.geometry.coordinates[1]);
        }
        const routing = {
            Route: '<span class="routing"> <u>' +
                this.languageService.translate.instant('igo.geo.seeRouting') +
                '</u> </span>'
        };
        return Object.assign({ type: data.index }, properties, googleLinksProperties, routing);
    }
    /**
     * Remove hashtag from query
     * @param term Query with hashtag
     */
    computeTerm(term) {
        // Keep hashtags for "lieux"
        const hashtags = term.match(/(#[A-Za-z]+)/g) || [];
        let keep = false;
        keep = hashtags.some((hashtag) => {
            const hashtagKey = hashtag.substring(1);
            return this.hashtagsLieuxToKeep.some((h) => h
                .toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') ===
                hashtagKey
                    .toLowerCase()
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, ''));
        });
        if (!keep) {
            term = term.replace(/(#[A-Za-z]+)/g, '');
        }
        return term.replace(/[^\wÀ-ÿ !\-\+\(\)\.\/½¼¾,'#]+/g, '');
    }
    /**
     * Add hashtag to param if valid
     * @param term Query with hashtag
     * @param options TextSearchOptions
     */
    computeOptionsParam(term, options) {
        const hashtags = super.getHashtagsValid(term, 'type');
        if (hashtags) {
            options.params = Object.assign(options.params || {}, {
                type: hashtags.join(',')
            });
        }
        return options;
    }
}
IChercheSearchSource.id = 'icherche';
IChercheSearchSource.type = FEATURE;
IChercheSearchSource.propertiesBlacklist = [];
IChercheSearchSource.ɵfac = function IChercheSearchSource_Factory(t) { return new (t || IChercheSearchSource)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i2$1.StorageService), i0.ɵɵinject('options'), i0.ɵɵinject(IChercheSearchResultFormatter), i0.ɵɵinject(i0.Injector)); };
IChercheSearchSource.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: IChercheSearchSource, factory: IChercheSearchSource.ɵfac });
__decorate([
    Cacheable({
        maxCacheCount: 20
    })
], IChercheSearchSource.prototype, "search", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IChercheSearchSource, [{
        type: Injectable
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.LanguageService }, { type: i2$1.StorageService }, { type: undefined, decorators: [{
                type: Inject,
                args: ['options']
            }] }, { type: IChercheSearchResultFormatter, decorators: [{
                type: Inject,
                args: [IChercheSearchResultFormatter]
            }] }, { type: i0.Injector }]; }, { search: [] }); })();
/**
 * IChercheReverse search source
 */
class IChercheReverseSearchSource extends SearchSource {
    constructor(http, languageService, storageService, options, injector) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
        this.title$ = new BehaviorSubject('');
        this.languageService.translate
            .get(this.options.title)
            .subscribe((title) => this.title$.next(title));
        const authService = injector.get(AuthService);
        if (this.settings.length) {
            if (!authService) {
                this.getAllowedTypes();
            }
            else {
                authService.authenticate$.subscribe(() => {
                    this.getAllowedTypes();
                });
            }
        }
    }
    get title() {
        return this.title$.getValue();
    }
    getId() {
        return IChercheReverseSearchSource.id;
    }
    getType() {
        return IChercheReverseSearchSource.type;
    }
    getDefaultOptions() {
        const types = this.options.params && this.options.params.type
            ? this.options.params.type.replace(/\s/g, '').toLowerCase().split(',')
            : ['adresses', 'municipalites', 'mrc', 'regadmin'];
        return {
            title: 'igo.geo.search.ichercheReverse.name',
            searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/terrapi',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'type',
                    values: [
                        {
                            title: 'igo.geo.search.icherche.type.address',
                            value: 'adresses',
                            enabled: types.indexOf('adresses') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.road',
                            value: 'routes',
                            enabled: types.indexOf('routes') !== -1,
                            available: false
                        },
                        {
                            title: 'igo.geo.search.icherche.type.district',
                            value: 'arrondissements',
                            enabled: types.indexOf('arrondissements') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.city',
                            value: 'municipalites',
                            enabled: types.indexOf('municipalites') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.mrc',
                            value: 'mrc',
                            enabled: types.indexOf('mrc') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.regadmin',
                            value: 'regadmin',
                            enabled: types.indexOf('regadmin') !== -1
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'radius',
                    name: 'bufferInput',
                    values: [
                        {
                            title: '100 m',
                            value: 100,
                            enabled: !this.options.distance || this.options.distance === 100
                        },
                        {
                            title: '500 m',
                            value: 500,
                            enabled: this.options.distance === 500
                        },
                        {
                            title: '1 km',
                            value: 1000,
                            enabled: this.options.distance === 1000
                        },
                        {
                            title: '2 km',
                            value: 2000,
                            enabled: this.options.distance === 2000
                        },
                        {
                            title: '5 km',
                            value: 5000,
                            enabled: this.options.distance === 5000
                        }
                    ]
                }
            ]
        };
    }
    /**
     * Search a location by coordinates
     * @param lonLat Location coordinates
     * @param distance Search raidus around lonLat
     * @returns Observable of <SearchResult<Feature>[]
     */
    reverseSearch(lonLat, options) {
        const params = this.computeRequestParams(lonLat, options || {});
        if (!params.get('type').length) {
            return of([]);
        }
        return this.http.get(`${this.searchUrl}/locate`, { params }).pipe(map((response) => {
            return this.extractResults(response);
        }));
    }
    getAllowedTypes() {
        return this.http
            .get(`${this.searchUrl}/types`)
            .subscribe((types) => {
            const typeSetting = this.settings.find((s) => s.name === 'type');
            typeSetting.values.forEach((v) => {
                v.available = types.indexOf(v.value) > -1;
            });
            this.setParamFromSetting(typeSetting, false);
        });
    }
    computeRequestParams(lonLat, options) {
        if (options.distance || this.options.distance) {
            options.params = Object.assign(options.params || {}, {
                bufferInput: options.distance || this.options.distance
            });
        }
        return new HttpParams({
            fromObject: Object.assign({
                loc: lonLat.join(','),
                sort: 'distance',
                geometry: true,
                icon: true
            }, options.params || {}, this.params)
        });
    }
    extractResults(response) {
        return response.features.map((data) => {
            return this.dataToResult(data);
        });
    }
    getSubtitle(data) {
        if (!this.settings.length) {
            return '';
        }
        let subtitle = '';
        switch (data.properties.type) {
            case 'arrondissements':
                subtitle = data.properties.municipalite + ' (Arrondissement)';
                break;
            default:
                const typeSetting = this.settings.find((s) => s.name === 'type');
                const type = typeSetting.values.find((t) => t.value === data.properties.type);
                if (type) {
                    subtitle = this.languageService.translate.instant(type.title);
                }
        }
        return subtitle;
    }
    dataToResult(data) {
        const properties = this.computeProperties(data);
        const extent = this.computeExtent(data);
        const id = [this.getId(), properties.type, properties.code].join('.');
        const titleHtml = data.properties.nom;
        const subtitleHtml = ' <small> ' + this.getSubtitle(data) + '</small>';
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                extent,
                properties,
                meta: {
                    id,
                    title: data.properties.nom
                }
            },
            meta: {
                dataType: FEATURE,
                id,
                title: data.properties.nom,
                titleHtml: titleHtml + subtitleHtml,
                icon: data.icon || 'map-marker',
                pointerSummaryTitle: this.getSubtitle(data) + ': ' + data.properties.nom
            }
        };
    }
    computeProperties(data) {
        const properties = ObjectUtils.removeKeys(data.properties, IChercheReverseSearchSource.propertiesBlacklist);
        const routing = {
            Route: '<span class="routing"> <u>' +
                this.languageService.translate.instant('igo.geo.seeRouting') +
                '</u> </span>'
        };
        return Object.assign(properties, routing);
    }
    computeExtent(data) {
        return data.bbox
            ? [data.bbox[0], data.bbox[2], data.bbox[1], data.bbox[3]]
            : undefined;
    }
}
IChercheReverseSearchSource.id = 'icherchereverse';
IChercheReverseSearchSource.type = FEATURE;
IChercheReverseSearchSource.propertiesBlacklist = [];
IChercheReverseSearchSource.ɵfac = function IChercheReverseSearchSource_Factory(t) { return new (t || IChercheReverseSearchSource)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i2$1.StorageService), i0.ɵɵinject('options'), i0.ɵɵinject(i0.Injector)); };
IChercheReverseSearchSource.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: IChercheReverseSearchSource, factory: IChercheReverseSearchSource.ɵfac });
__decorate([
    Cacheable({
        maxCacheCount: 20
    })
], IChercheReverseSearchSource.prototype, "reverseSearch", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IChercheReverseSearchSource, [{
        type: Injectable
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.LanguageService }, { type: i2$1.StorageService }, { type: undefined, decorators: [{
                type: Inject,
                args: ['options']
            }] }, { type: i0.Injector }]; }, { reverseSearch: [] }); })();

/**
 * ICherche search result formatter factory
 * @ignore
 */
function defaultIChercheSearchResultFormatterFactory(languageService) {
    return new IChercheSearchResultFormatter(languageService);
}
/**
 * Function that returns a provider for the ICherche search result formatter
 */
function provideDefaultIChercheSearchResultFormatter() {
    return {
        provide: IChercheSearchResultFormatter,
        useFactory: defaultIChercheSearchResultFormatterFactory,
        deps: [LanguageService]
    };
}
/**
 * ICherche search source factory
 * @ignore
 */
function ichercheSearchSourceFactory(http, languageService, storageService, config, formatter, injector) {
    return new IChercheSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${IChercheSearchSource.id}`), formatter, injector);
}
/**
 * Function that returns a provider for the ICherche search source
 */
function provideIChercheSearchSource() {
    return {
        provide: SearchSource,
        useFactory: ichercheSearchSourceFactory,
        multi: true,
        deps: [
            HttpClient,
            LanguageService,
            StorageService,
            ConfigService,
            IChercheSearchResultFormatter,
            Injector
        ]
    };
}
/**
 * IChercheReverse search source factory
 * @ignore
 */
function ichercheReverseSearchSourceFactory(http, languageService, storageService, config, injector) {
    return new IChercheReverseSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${IChercheReverseSearchSource.id}`), injector);
}
/**
 * Function that returns a provider for the IChercheReverse search source
 */
function provideIChercheReverseSearchSource() {
    return {
        provide: SearchSource,
        useFactory: ichercheReverseSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, StorageService, ConfigService, Injector]
    };
}

class CoordinatesSearchResultFormatter {
    constructor(languageService) {
        this.languageService = languageService;
    }
    formatResult(result) {
        return result;
    }
}
CoordinatesSearchResultFormatter.ɵfac = function CoordinatesSearchResultFormatter_Factory(t) { return new (t || CoordinatesSearchResultFormatter)(i0.ɵɵinject(i2$1.LanguageService)); };
CoordinatesSearchResultFormatter.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CoordinatesSearchResultFormatter, factory: CoordinatesSearchResultFormatter.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CoordinatesSearchResultFormatter, [{
        type: Injectable
    }], function () { return [{ type: i2$1.LanguageService }]; }, null); })();
/**
 * CoordinatesReverse search source
 */
class CoordinatesReverseSearchSource extends SearchSource {
    constructor(options, languageService, storageService, projections) {
        super(options, storageService);
        this.languageService = languageService;
        this.title$ = new BehaviorSubject('');
        this.projections = projections;
        this.languageService.translate
            .get(this.options.title)
            .subscribe(title => this.title$.next(title));
    }
    get title() {
        return this.title$.getValue();
    }
    getId() {
        return CoordinatesReverseSearchSource.id;
    }
    getType() {
        return CoordinatesReverseSearchSource.type;
    }
    getDefaultOptions() {
        return {
            title: 'igo.geo.search.coordinates.name',
            order: 1,
            showInSettings: false
        };
    }
    /**
     * Search a location by coordinates
     * @param lonLat Location coordinates
     * @param options options of ReverseSearchOptions (distance, conf, zoom, params)
     * @returns Observable of <SearchResult<Feature>[]
     */
    reverseSearch(lonLat, options) {
        return of([this.dataToResult(lonLat, options)]);
    }
    dataToResult(data, options) {
        const dataDMS = convertDDToDMS(data);
        const convertedCoord = lonLatConversion(data, this.projections);
        const coords = convertedCoord.reduce((obj, item) => (obj[item.alias] = item.igo2CoordFormat, obj), {});
        const roundedCoordString = roundCoordTo(data, 6).join(', ');
        const roundedCoordStringDMS = dataDMS.join(', ');
        let geometry = {
            type: 'Point',
            coordinates: [data[0], data[1]]
        };
        const properties = {};
        let subtitleHtml = '';
        if (options.distance) {
            const radiusKey = this.languageService.translate.instant('igo.geo.search.coordinates.radius');
            properties[radiusKey] = options.distance;
            subtitleHtml = '<br><small>Rayon: ' + options.distance + ' m</small>';
            // Create polygon
            const center = olproj.transform([data[0], data[1]], 'EPSG:4326', 'EPSG:3857');
            const circleGeometry = new OlCircle(center, options.distance);
            const polygonGeometry = fromCircle(circleGeometry);
            const writer = new olformat.GeoJSON();
            geometry = JSON.parse(writer.writeGeometry(polygonGeometry.transform('EPSG:3857', 'EPSG:4326')));
        }
        if (options.conf) {
            const confKey = this.languageService.translate.instant('igo.geo.search.coordinates.conf');
            properties[confKey] = options.conf;
            subtitleHtml += subtitleHtml === '' ? '<br>' : '<small> - </small>';
            subtitleHtml += '<small>Confiance: ' + options.conf + '%</small>';
        }
        const coordKey = this.languageService.translate.instant('igo.geo.search.coordinates.coord');
        properties[coordKey] = roundedCoordString;
        const coordKeyDMS = this.languageService.translate.instant('igo.geo.search.coordinates.coordDMS');
        properties[coordKeyDMS] = roundedCoordStringDMS;
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry,
                extent: undefined,
                properties: Object.assign(properties, coords, {
                    GoogleMaps: GoogleLinks.getGoogleMapsCoordLink(data[0], data[1]),
                    GoogleStreetView: GoogleLinks.getGoogleStreetViewLink(data[0], data[1]),
                    OpenStreetMap: OsmLinks.getOpenStreetMapLink(data[0], data[1], 14),
                    Route: '<span class="routing"> <u>' + this.languageService.translate.instant('igo.geo.seeRouting') + '</u> </span>'
                }),
                meta: {
                    id: data[0].toString() + ',' + data[1].toString(),
                    title: roundedCoordString
                }
            },
            meta: {
                dataType: FEATURE,
                id: data[0].toString() + ',' + data[1].toString(),
                title: roundedCoordString,
                titleHtml: roundedCoordString + subtitleHtml,
                icon: 'map-marker',
                score: 100, // every coord exists
            }
        };
    }
}
CoordinatesReverseSearchSource.id = 'coordinatesreverse';
CoordinatesReverseSearchSource.type = FEATURE;
CoordinatesReverseSearchSource.ɵfac = function CoordinatesReverseSearchSource_Factory(t) { return new (t || CoordinatesReverseSearchSource)(i0.ɵɵinject('options'), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i2$1.StorageService), i0.ɵɵinject('projections')); };
CoordinatesReverseSearchSource.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CoordinatesReverseSearchSource, factory: CoordinatesReverseSearchSource.ɵfac });
__decorate([
    Cacheable({
        maxCacheCount: 20
    })
], CoordinatesReverseSearchSource.prototype, "reverseSearch", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CoordinatesReverseSearchSource, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: ['options']
            }] }, { type: i2$1.LanguageService }, { type: i2$1.StorageService }, { type: undefined, decorators: [{
                type: Inject,
                args: ['projections']
            }] }]; }, { reverseSearch: [] }); })();

/**
 * ICherche search result formatter factory
 * @ignore
 */
function defaultCoordinatesSearchResultFormatterFactory(languageService) {
    return new CoordinatesSearchResultFormatter(languageService);
}
/**
 * Function that returns a provider for the ICherche search result formatter
 */
function provideDefaultCoordinatesSearchResultFormatter() {
    return {
        provide: CoordinatesSearchResultFormatter,
        useFactory: defaultCoordinatesSearchResultFormatterFactory,
        deps: [LanguageService]
    };
}
/**
 * CoordinatesReverse search source factory
 * @ignore
 */
function CoordinatesReverseSearchSourceFactory(config, languageService, storageService, _projectionService) {
    return new CoordinatesReverseSearchSource(config.getConfig(`searchSources.${CoordinatesReverseSearchSource.id}`), languageService, storageService, config.getConfig('projections') || []);
}
/**
 * Function that returns a provider for the IChercheReverse search source
 */
function provideCoordinatesReverseSearchSource() {
    return {
        provide: SearchSource,
        useFactory: CoordinatesReverseSearchSourceFactory,
        multi: true,
        deps: [ConfigService, LanguageService, StorageService, ProjectionService]
    };
}

class ILayerSearchResultFormatter {
    constructor(languageService) {
        this.languageService = languageService;
    }
    formatResult(data) {
        const allowedKey = [
            'title',
            'abstract',
            'groupTitle',
            'metadataUrl',
            'downloadUrl',
            'urlInfo',
            'name'
        ];
        const property = Object.entries(data.properties)
            .filter(([key]) => allowedKey.indexOf(key) !== -1)
            .reduce((out, entries) => {
            const [key, value] = entries;
            let newKey;
            try {
                newKey = this.languageService.translate.instant('igo.geo.search.ilayer.properties.' + key);
            }
            catch (e) {
                newKey = key;
            }
            out[newKey] = value ? value : '';
            return out;
        }, {});
        const dataR = Object.assign({}, data);
        dataR.properties = property;
        return dataR;
    }
}
ILayerSearchResultFormatter.ɵfac = function ILayerSearchResultFormatter_Factory(t) { return new (t || ILayerSearchResultFormatter)(i0.ɵɵinject(i2$1.LanguageService)); };
ILayerSearchResultFormatter.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ILayerSearchResultFormatter, factory: ILayerSearchResultFormatter.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ILayerSearchResultFormatter, [{
        type: Injectable
    }], function () { return [{ type: i2$1.LanguageService }]; }, null); })();
/**
 * ILayer search source
 */
class ILayerSearchSource extends SearchSource {
    constructor(http, languageService, storageService, options, formatter) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
        this.formatter = formatter;
        this.title$ = new BehaviorSubject('');
        this.languageService.translate
            .get(this.options.title)
            .subscribe(title => this.title$.next(title));
    }
    get title() {
        return this.title$.getValue();
    }
    getId() {
        return ILayerSearchSource.id;
    }
    getType() {
        return ILayerSearchSource.type;
    }
    getDefaultOptions() {
        const limit = this.options.params && this.options.params.limit
            ? Number(this.options.params.limit)
            : undefined;
        const ecmax = this.options.params && this.options.params.ecmax
            ? Number(this.options.params.ecmax)
            : undefined;
        return {
            title: 'igo.geo.search.ilayer.name',
            searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/layers/search',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'type',
                    values: [
                        {
                            title: 'igo.geo.search.ilayer.type.layer',
                            value: 'layer',
                            enabled: true,
                            hashtags: ['layer', 'layers', 'couche', 'couches']
                        },
                        {
                            title: 'igo.geo.search.ilayer.type.groupLayer',
                            value: 'group',
                            enabled: false,
                            hashtags: ['gr-layer', 'gr-layers', 'gr-couche', 'gr-couches']
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'results limit',
                    name: 'limit',
                    values: [
                        {
                            title: '1',
                            value: 1,
                            enabled: limit === 1
                        },
                        {
                            title: '5',
                            value: 5,
                            enabled: limit === 5 || !limit
                        },
                        {
                            title: '10',
                            value: 10,
                            enabled: limit === 10
                        },
                        {
                            title: '25',
                            value: 25,
                            enabled: limit === 25
                        },
                        {
                            title: '50',
                            value: 50,
                            enabled: limit === 50
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'ecmax',
                    name: 'ecmax',
                    values: [
                        {
                            title: '10 %',
                            value: 10,
                            enabled: ecmax === 10
                        },
                        {
                            title: '30 %',
                            value: 30,
                            enabled: ecmax === 30
                        },
                        {
                            title: '50 %',
                            value: 50,
                            enabled: ecmax === 50 || !ecmax
                        },
                        {
                            title: '75 %',
                            value: 75,
                            enabled: ecmax === 75
                        },
                        {
                            title: '100 %',
                            value: 100,
                            enabled: ecmax === 100
                        }
                    ]
                }
            ]
        };
    }
    /**
     * Search a layer by name or keyword
     * @param term Layer name or keyword
     * @returns Observable of <SearchResult<LayerOptions>[]
     */
    search(term, options) {
        const params = this.computeSearchRequestParams(term, options || {});
        if (!params.get('q') || !params.get('type')) {
            return of([]);
        }
        this.options.params.page = params.get('page') || '1';
        return this.http
            .get(this.searchUrl, { params })
            .pipe(map((response) => this.extractResults(response, term)));
    }
    computeSearchRequestParams(term, options) {
        return new HttpParams({
            fromObject: ObjectUtils.removeUndefined(Object.assign({
                q: this.computeTerm(term)
            }, this.params, this.computeOptionsParam(term, options || {}).params, {
                page: options.page
            }))
        });
    }
    /**
     * Remove hashtag from query
     * @param term Query with hashtag
     */
    computeTerm(term) {
        return term.replace(/(#[^\s]*)/g, '').replace(/[^\wÀ-ÿ !\-\(\),'#]+/g, '');
    }
    /**
     * Add hashtag to param if valid
     * @param term Query with hashtag
     * @param options TextSearchOptions
     */
    computeOptionsParam(term, options) {
        const hashtags = super.getHashtagsValid(term, 'type');
        if (hashtags) {
            options.params = Object.assign(options.params || {}, {
                type: hashtags.join(',')
            });
        }
        return options;
    }
    extractResults(response, term) {
        return response.items.map((data) => this.dataToResult(data, term, response));
    }
    dataToResult(data, term, response) {
        const layerOptions = this.computeLayerOptions(data);
        const titleHtml = data.highlight.title || data.properties.title;
        const groupTitle = data.highlight.groupTitle || data.properties.groupTitle;
        const subtitleHtml = groupTitle
            ? ' <small style="color: #6f6969"> ' + groupTitle + '</small>'
            : '';
        return {
            source: this,
            meta: {
                dataType: LAYER,
                id: [this.getId(), data.properties.id].join('.'),
                title: data.properties.title,
                titleHtml: titleHtml + subtitleHtml,
                icon: data.properties.type === 'Layer' ? 'layers' : 'map',
                score: data.score || computeTermSimilarity(term.trim(), data.properties.name),
                nextPage: response.items.length % +this.options.params.limit === 0 &&
                    +this.options.params.page < 10
            },
            data: layerOptions
        };
    }
    computeLayerOptions(data) {
        const url = data.properties.url;
        const queryParams = this.extractQueryParamsFromSourceUrl(url);
        return ObjectUtils.removeUndefined({
            sourceOptions: {
                id: data.properties.id,
                type: data.properties.format,
                url,
                queryFormat: queryParams.queryFormat,
                queryHtmlTarget: queryParams.queryHtmlTarget,
                params: data.properties.format === 'wms' ? { LAYERS: data.properties.name } : undefined,
                layer: data.properties.format === 'wms' ? undefined : data.properties.name,
                optionsFromCapabilities: true,
                crossOrigin: 'anonymous'
            },
            title: data.properties.title,
            maxResolution: getResolutionFromScale(Number(data.properties.maxScaleDenom)),
            minResolution: getResolutionFromScale(Number(data.properties.minScaleDenom)),
            metadata: {
                url: data.properties.metadataUrl,
                extern: data.properties.metadataUrl ? true : undefined,
                abstract: data.properties.abstract || undefined
            },
            properties: this.formatter.formatResult(data).properties
        });
    }
    extractQueryParamsFromSourceUrl(url) {
        let queryFormat;
        let queryHtmlTarget;
        const formatOpt = this.options.queryFormat;
        if (formatOpt) {
            for (const key of Object.keys(formatOpt)) {
                const value = formatOpt[key];
                if (value === '*') {
                    queryFormat = QueryFormat[key.toUpperCase()];
                    break;
                }
                const urls = value.urls;
                if (Array.isArray(urls)) {
                    urls.forEach(urlOpt => {
                        if (url.indexOf(urlOpt) !== -1) {
                            queryFormat = QueryFormat[key.toUpperCase()];
                        }
                    });
                    break;
                }
            }
            if (queryFormat === QueryFormat.HTML ||
                queryFormat === QueryFormat.HTMLGML2) {
                queryHtmlTarget = 'iframe';
            }
        }
        return {
            queryFormat,
            queryHtmlTarget
        };
    }
}
ILayerSearchSource.id = 'ilayer';
ILayerSearchSource.type = LAYER;
ILayerSearchSource.ɵfac = function ILayerSearchSource_Factory(t) { return new (t || ILayerSearchSource)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i2$1.StorageService), i0.ɵɵinject('options'), i0.ɵɵinject(ILayerSearchResultFormatter)); };
ILayerSearchSource.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ILayerSearchSource, factory: ILayerSearchSource.ɵfac });
__decorate([
    Cacheable({
        maxCacheCount: 20
    })
], ILayerSearchSource.prototype, "search", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ILayerSearchSource, [{
        type: Injectable
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.LanguageService }, { type: i2$1.StorageService }, { type: undefined, decorators: [{
                type: Inject,
                args: ['options']
            }] }, { type: ILayerSearchResultFormatter, decorators: [{
                type: Inject,
                args: [ILayerSearchResultFormatter]
            }] }]; }, { search: [] }); })();

/**
 * ILayer search result formatter factory
 * @ignore
 */
function ilayerSearchResultFormatterFactory(languageService) {
    return new ILayerSearchResultFormatter(languageService);
}
/**
 * Function that returns a provider for the ILayer search result formatter
 */
function provideILayerSearchResultFormatter() {
    return {
        provide: ILayerSearchResultFormatter,
        useFactory: ilayerSearchResultFormatterFactory,
        deps: [LanguageService]
    };
}
/**
 * ILayer search source factory
 * @ignore
 */
function ilayerSearchSourceFactory(http, languageService, storageService, config, formatter) {
    return new ILayerSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${ILayerSearchSource.id}`), formatter);
}
/**
 * Function that returns a provider for the ILayer search source
 */
function provideILayerSearchSource() {
    return {
        provide: SearchSource,
        useFactory: ilayerSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, StorageService, ConfigService, ILayerSearchResultFormatter]
    };
}

const SEARCH_TYPES = [FEATURE, LAYER];

function SearchSelectorComponent_mat_radio_button_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-radio-button", 7);
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const searchType_r2 = ctx.$implicit;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("value", searchType_r2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 2, ctx_r1.getSearchTypeTitle(searchType_r2)), " ");
} }
/**
 * This component allows a user to select a search type yo enable. In it's
 * current version, only one search type can be selected at once (radio). If
 * this component were to support more than one search source enabled (checkbox),
 * the searchbar component would require a small change to it's
 * placeholder getter. The search source service already supports having
 * more than one search source enabled.
 */
class SearchSelectorComponent {
    constructor(searchSourceService) {
        this.searchSourceService = searchSourceService;
        this.searchType$ = new BehaviorSubject(undefined);
        /**
         * List of available search types
         */
        this.searchTypes = SEARCH_TYPES;
        /**
         * Event emitted when the enabled search type changes
         */
        this.searchTypeChange = new EventEmitter();
    }
    /**
     * The search type enabled
     */
    set searchType(value) { this.setSearchType(value); }
    get searchType() { return this.searchType$.value; }
    ngOnInit() {
        this.searchType$$ = this.searchType$
            .pipe(distinctUntilChanged())
            .subscribe((searchType) => this.onSetSearchType(searchType));
    }
    ngOnDestroy() {
        this.searchType$$.unsubscribe();
    }
    /**
     * Enable the selected search type
     * @param searchType Search type
     * @internal
     */
    onSearchTypeChange(searchType) {
        this.setSearchType(searchType);
    }
    /**
     * Get a search type's title. The title
     * for all availables search typers needs to be defined in the locale
     * files or an error will be thrown.
     * @param searchType Search type
     * @internal
     */
    getSearchTypeTitle(searchType) {
        return `igo.geo.search.${searchType.toLowerCase()}.title`;
    }
    /**
     * Emit an event and enable the search sources of the given type.
     * @param searchType Search type
     */
    setSearchType(searchType) {
        this.searchType$.next(searchType);
    }
    onSetSearchType(searchType) {
        if (searchType === undefined || searchType === null) {
            return;
        }
        this.searchSourceService.enableSourcesByType(searchType);
        this.searchTypeChange.emit(searchType);
    }
}
SearchSelectorComponent.ɵfac = function SearchSelectorComponent_Factory(t) { return new (t || SearchSelectorComponent)(i0.ɵɵdirectiveInject(SearchSourceService)); };
SearchSelectorComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SearchSelectorComponent, selectors: [["igo-search-selector"]], inputs: { searchTypes: "searchTypes", searchType: "searchType" }, outputs: { searchTypeChange: "searchTypeChange" }, decls: 9, vars: 8, consts: [[1, "igo-search-selector"], ["mat-icon-button", "", "color", "primary", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "igo-search-selector-button", 3, "matTooltip", "matMenuTriggerFor"], ["svgIcon", "menu-down"], ["xPosition", "before", "yPosition", "above", 1, "no-border-radius"], ["searchSelectorMenu", "matMenu"], [1, "igo-search-selector-radio-group", 3, "value", "change"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"]], template: function SearchSelectorComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelementStart(1, "button", 1);
        i0.ɵɵpipe(2, "translate");
        i0.ɵɵelement(3, "mat-icon", 2);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(4, "mat-menu", 3, 4);
        i0.ɵɵelementStart(6, "mat-radio-group", 5);
        i0.ɵɵlistener("change", function SearchSelectorComponent_Template_mat_radio_group_change_6_listener($event) { return ctx.onSearchTypeChange($event.value); });
        i0.ɵɵpipe(7, "async");
        i0.ɵɵtemplate(8, SearchSelectorComponent_mat_radio_button_8_Template, 3, 4, "mat-radio-button", 6);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = i0.ɵɵreference(5);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(2, 4, "igo.geo.search.menu.tooltip"))("matMenuTriggerFor", _r0);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("value", i0.ɵɵpipeBind1(7, 6, ctx.searchType$));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", ctx.searchTypes);
    } }, directives: [i2.MatButton, i3.MatTooltip, i5$2.MatMenuTrigger, i4.MatIcon, i5$2.MatMenu, i19.MatRadioGroup, i1$1.NgForOf, i19.MatRadioButton], pipes: [i7.TranslatePipe, i1$1.AsyncPipe], styles: [".igo-search-selector-button[_ngcontent-%COMP%]     div.mat-button-ripple-round{border-radius:0}.igo-search-selector-radio-group[_ngcontent-%COMP%]{display:inline-flex;flex-direction:column}.igo-search-selector-radio-group[_ngcontent-%COMP%]   mat-radio-button[_ngcontent-%COMP%]{margin:5px}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SearchSelectorComponent, [{
        type: Component,
        args: [{
                selector: 'igo-search-selector',
                templateUrl: './search-selector.component.html',
                styleUrls: ['./search-selector.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: SearchSourceService }]; }, { searchTypes: [{
            type: Input
        }], searchType: [{
            type: Input
        }], searchTypeChange: [{
            type: Output
        }] }); })();

/**
 * @ignore
 */
class IgoSearchSelectorModule {
}
IgoSearchSelectorModule.ɵfac = function IgoSearchSelectorModule_Factory(t) { return new (t || IgoSearchSelectorModule)(); };
IgoSearchSelectorModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoSearchSelectorModule });
IgoSearchSelectorModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatTooltipModule,
            MatIconModule,
            MatButtonModule,
            MatMenuModule,
            MatRadioModule,
            MatTabsModule,
            MatCheckboxModule,
            IgoLanguageModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoSearchSelectorModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatTooltipModule,
                    MatIconModule,
                    MatButtonModule,
                    MatMenuModule,
                    MatRadioModule,
                    MatTabsModule,
                    MatCheckboxModule,
                    IgoLanguageModule
                ],
                exports: [SearchSelectorComponent],
                declarations: [SearchSelectorComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoSearchSelectorModule, { declarations: [SearchSelectorComponent], imports: [CommonModule,
        MatTooltipModule,
        MatIconModule,
        MatButtonModule,
        MatMenuModule,
        MatRadioModule,
        MatTabsModule,
        MatCheckboxModule,
        IgoLanguageModule], exports: [SearchSelectorComponent] }); })();

function SearchSettingsComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 8);
    i0.ɵɵelementStart(1, "button", 9);
    i0.ɵɵlistener("click", function SearchSettingsComponent_div_6_Template_button_click_1_listener($event) { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.checkUncheckAllSources($event); });
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(!ctx_r1.searchSourcesAllEnabled ? i0.ɵɵpipeBind1(3, 1, "igo.geo.search.searchSources.unselectAll") : i0.ɵɵpipeBind1(4, 3, "igo.geo.search.searchSources.selectAll"));
} }
function SearchSettingsComponent_ng_container_7_button_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 15);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const source_r6 = i0.ɵɵnextContext().$implicit;
    const _r9 = i0.ɵɵreference(6);
    i0.ɵɵproperty("matMenuTriggerFor", _r9);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", source_r6.title, " ");
} }
function SearchSettingsComponent_ng_container_7_button_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 16);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const source_r6 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", source_r6.title, " ");
} }
function SearchSettingsComponent_ng_container_7_ng_container_7_span_6_mat_radio_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r22 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-radio-button", 22);
    i0.ɵɵlistener("click", function SearchSettingsComponent_ng_container_7_ng_container_7_span_6_mat_radio_button_2_Template_mat_radio_button_click_0_listener($event) { return $event.stopPropagation(); })("change", function SearchSettingsComponent_ng_container_7_ng_container_7_span_6_mat_radio_button_2_Template_mat_radio_button_change_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r22); const settingValue_r18 = restoredCtx.$implicit; const setting_r13 = i0.ɵɵnextContext(2).$implicit; const source_r6 = i0.ɵɵnextContext().$implicit; const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.settingsValueCheckedRadioButton($event, source_r6, setting_r13, settingValue_r18); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const settingValue_r18 = ctx.$implicit;
    const ctx_r17 = i0.ɵɵnextContext(4);
    i0.ɵɵproperty("value", settingValue_r18)("matTooltip", ctx_r17.getAvailableHashtagsValues(settingValue_r18))("checked", settingValue_r18.enabled);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 4, settingValue_r18.title), " ");
} }
function SearchSettingsComponent_ng_container_7_ng_container_7_span_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵelementStart(1, "mat-radio-group", 20);
    i0.ɵɵtemplate(2, SearchSettingsComponent_ng_container_7_ng_container_7_span_6_mat_radio_button_2_Template, 3, 6, "mat-radio-button", 21);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const setting_r13 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("value", setting_r13);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", setting_r13.values);
} }
function SearchSettingsComponent_ng_container_7_ng_container_7_span_7_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r29 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 8);
    i0.ɵɵelementStart(1, "button", 9);
    i0.ɵɵlistener("click", function SearchSettingsComponent_ng_container_7_ng_container_7_span_7_div_1_Template_button_click_1_listener($event) { i0.ɵɵrestoreView(_r29); const setting_r13 = i0.ɵɵnextContext(2).$implicit; const source_r6 = i0.ɵɵnextContext().$implicit; const ctx_r27 = i0.ɵɵnextContext(); return ctx_r27.checkUncheckAll($event, source_r6, setting_r13); });
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const setting_r13 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(setting_r13.allEnabled || setting_r13.allEnabled === undefined ? i0.ɵɵpipeBind1(3, 1, "igo.geo.search.searchSources.settings.unselectAll") : i0.ɵɵpipeBind1(4, 3, "igo.geo.search.searchSources.settings.selectAll"));
} }
function SearchSettingsComponent_ng_container_7_ng_container_7_span_7_mat_checkbox_2_Template(rf, ctx) { if (rf & 1) {
    const _r36 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "mat-checkbox", 24);
    i0.ɵɵlistener("click", function SearchSettingsComponent_ng_container_7_ng_container_7_span_7_mat_checkbox_2_Template_mat_checkbox_click_0_listener($event) { return $event.stopPropagation(); })("change", function SearchSettingsComponent_ng_container_7_ng_container_7_span_7_mat_checkbox_2_Template_mat_checkbox_change_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r36); const settingValue_r32 = restoredCtx.$implicit; const setting_r13 = i0.ɵɵnextContext(2).$implicit; const source_r6 = i0.ɵɵnextContext().$implicit; const ctx_r34 = i0.ɵɵnextContext(); return ctx_r34.settingsValueCheckedCheckbox($event, source_r6, setting_r13, settingValue_r32); });
    i0.ɵɵtext(1);
    i0.ɵɵpipe(2, "translate");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const settingValue_r32 = ctx.$implicit;
    const setting_r13 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r26 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("display", ctx_r26.displayBlock);
    i0.ɵɵproperty("checked", settingValue_r32.enabled)("value", setting_r13)("matTooltip", ctx_r26.getAvailableHashtagsValues(settingValue_r32));
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(2, 6, settingValue_r32.title), " ");
} }
function SearchSettingsComponent_ng_container_7_ng_container_7_span_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtemplate(1, SearchSettingsComponent_ng_container_7_ng_container_7_span_7_div_1_Template, 5, 5, "div", 5);
    i0.ɵɵtemplate(2, SearchSettingsComponent_ng_container_7_ng_container_7_span_7_mat_checkbox_2_Template, 3, 8, "mat-checkbox", 23);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const setting_r13 = i0.ɵɵnextContext().$implicit;
    const ctx_r16 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", setting_r13.values.length > 3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r16.getAvailableValues(setting_r13));
} }
function SearchSettingsComponent_ng_container_7_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "button", 15);
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "mat-menu", 17, 18);
    i0.ɵɵtemplate(6, SearchSettingsComponent_ng_container_7_ng_container_7_span_6_Template, 3, 2, "span", 19);
    i0.ɵɵtemplate(7, SearchSettingsComponent_ng_container_7_ng_container_7_span_7_Template, 3, 2, "span", 19);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const setting_r13 = ctx.$implicit;
    const _r14 = i0.ɵɵreference(5);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("matMenuTriggerFor", _r14);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(3, 5, "igo.geo.search.searchSources.settings." + setting_r13.title), " ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitch", setting_r13.type);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitchCase", "radiobutton");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngSwitchCase", "checkbox");
} }
function SearchSettingsComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    const _r42 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "span", 10);
    i0.ɵɵelementStart(2, "mat-checkbox", 11);
    i0.ɵɵlistener("click", function SearchSettingsComponent_ng_container_7_Template_mat_checkbox_click_2_listener($event) { return $event.stopPropagation(); })("change", function SearchSettingsComponent_ng_container_7_Template_mat_checkbox_change_2_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r42); const source_r6 = restoredCtx.$implicit; const ctx_r41 = i0.ɵɵnextContext(); return ctx_r41.onCheckSearchSource($event, source_r6); });
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(3, SearchSettingsComponent_ng_container_7_button_3_Template, 2, 2, "button", 12);
    i0.ɵɵtemplate(4, SearchSettingsComponent_ng_container_7_button_4_Template, 2, 1, "button", 13);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(5, "mat-menu", null, 14);
    i0.ɵɵtemplate(7, SearchSettingsComponent_ng_container_7_ng_container_7_Template, 8, 7, "ng-container", 6);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const source_r6 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("checked", source_r6.enabled)("value", source_r6);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", source_r6.settings.length > 0);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", source_r6.settings.length === 0);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngForOf", source_r6.settings);
} }
function SearchSettingsComponent_span_8_Template(rf, ctx) { if (rf & 1) {
    const _r44 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵelement(1, "mat-divider");
    i0.ɵɵelementStart(2, "span", 25);
    i0.ɵɵelementStart(3, "mat-slide-toggle", 26);
    i0.ɵɵlistener("change", function SearchSettingsComponent_span_8_Template_mat_slide_toggle_change_3_listener($event) { i0.ɵɵrestoreView(_r44); const ctx_r43 = i0.ɵɵnextContext(); return ctx_r43.changePointerReverseSearch($event); })("click", function SearchSettingsComponent_span_8_Template_mat_slide_toggle_click_3_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵpipe(4, "translate");
    i0.ɵɵtext(5);
    i0.ɵɵpipe(6, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(7, "mat-slide-toggle", 26);
    i0.ɵɵlistener("change", function SearchSettingsComponent_span_8_Template_mat_slide_toggle_change_7_listener($event) { i0.ɵɵrestoreView(_r44); const ctx_r46 = i0.ɵɵnextContext(); return ctx_r46.changeSearchResultsGeometry($event); })("click", function SearchSettingsComponent_span_8_Template_mat_slide_toggle_click_7_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵpipe(8, "translate");
    i0.ɵɵtext(9);
    i0.ɵɵpipe(10, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(4, 8, "igo.geo.search.pointerSearchSummary.tooltip"))("checked", ctx_r3.pointerSummaryEnabled)("labelPosition", "after");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(6, 10, "igo.geo.search.pointerSearchSummary.title"), " ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(8, 12, "igo.geo.search.searchResultsGeometry.tooltip"))("checked", ctx_r3.searchResultsGeometryEnabled)("labelPosition", "after");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind1(10, 14, "igo.geo.search.searchResultsGeometry.title"), " ");
} }
/**
 * This component allows a user to select a search type yo enable. In it's
 * current version, only one search type can be selected at once (radio). If
 * this component were to support more than one search source enabled (checkbox),
 * the searchbar component would require a small change to it's
 * placeholder getter. The search source service already supports having
 * more than one search source enabled.
 */
class SearchSettingsComponent {
    constructor(searchSourceService, mediaService, storageService) {
        this.searchSourceService = searchSourceService;
        this.mediaService = mediaService;
        this.storageService = storageService;
        this.hasPointerReverseSearchSource = false;
        this.searchSourcesAllEnabled = false;
        this.buffer = [];
        this.lastKeyTime = Date.now();
        this.displayBlock = 'block';
        this.pointerSummaryEnabled = false;
        this.searchResultsGeometryEnabled = false;
        /**
         * Event emitted when the enabled search source changes
         */
        this.searchSourceChange = new EventEmitter();
        /**
         * Event emitted when the pointer summary is activated
         */
        this.pointerSummaryStatus = new EventEmitter();
        /**
         * Event emitted when the show geometry summary is changed
         */
        this.searchResultsGeometryStatus = new EventEmitter();
    }
    get isTouchScreen() {
        return this.mediaService.isTouchScreen();
    }
    handleKeyboardEvent(event) {
        if (event.key === 'F2') {
            this.pointerSummaryEnabled = !this.pointerSummaryEnabled;
            this.pointerSummaryStatus.emit(this.pointerSummaryEnabled);
        }
    }
    ngOnInit() {
        this.hasPointerReverseSearchSource = this.hasReverseSearchSourcesForPointerSummary();
    }
    /**
     * Get all search sources
     * @internal
     */
    getSearchSources() {
        const textSearchSources = this.searchSourceService
            .getSources()
            .filter(sourceCanSearch)
            .filter((s) => s.available && s.getId() !== 'map' && s.showInSettings);
        const reverseSearchSources = this.searchSourceService
            .getSources()
            .filter(sourceCanReverseSearch)
            .filter((s) => s.available && s.getId() !== 'map' && s.showInSettings);
        const sources = textSearchSources.concat(reverseSearchSources);
        this.computeSourcesCheckAllBehavior(sources);
        return sources;
    }
    /**
     * Get all search sources usable for pointer summary
     * @internal
     */
    hasReverseSearchSourcesForPointerSummary() {
        if (this.searchSourceService
            .getEnabledSources()
            .filter(sourceCanReverseSearchAsSummary).length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Triggered when a setting is checked (checkbox style)
     * @internal
     */
    settingsValueCheckedCheckbox(event, source, setting, settingValue) {
        settingValue.enabled = event.checked;
        source.setParamFromSetting(setting);
        this.searchSourceChange.emit(source);
    }
    /**
     * Defining the action to do for check/uncheck checkboxes (settings)
     * return true if all checkbox must be checked
     * return false if all checkbox must be unchecked
     * @internal
     */
    computeSettingCheckAllBehavior(setting) {
        if (setting.allEnabled === undefined) {
            if (setting.values.find((settingValue) => settingValue.enabled)) {
                setting.allEnabled = false;
            }
            else {
                setting.allEnabled = true;
            }
        }
        else {
            setting.allEnabled = !setting.allEnabled;
        }
    }
    /**
     * Defining the action to do for check/uncheck checkboxes (sources)
     * return true if all checkbox must be checked
     * return false if all checkbox must be unchecked
     * @internal
     */
    computeSourcesCheckAllBehavior(sources) {
        const enabledSourcesCnt = sources.filter((source) => source.enabled).length;
        const disabledSourcesCnt = sources.filter((source) => !source.enabled)
            .length;
        this.searchSourcesAllEnabled =
            enabledSourcesCnt >= disabledSourcesCnt ? false : true;
    }
    /**
     * Triggered when the check all / uncheck all type is clicked,
     * @internal
     */
    checkUncheckAll(event, source, setting) {
        event.stopPropagation();
        this.computeSettingCheckAllBehavior(setting);
        setting.values.forEach((settingValue) => {
            settingValue.enabled = setting.allEnabled;
        });
        source.setParamFromSetting(setting);
        this.searchSourceChange.emit(source);
    }
    /**
     * Triggered when the check all / uncheck all type is clicked,
     * @internal
     */
    checkUncheckAllSources(event) {
        event.stopPropagation();
        this.getSearchSources().map((source) => {
            source.enabled = this.searchSourcesAllEnabled;
            this.searchSourceChange.emit(source);
        });
    }
    /**
     * Triggered when a setting is checked (radiobutton style)
     * @internal
     */
    settingsValueCheckedRadioButton(event, source, setting, settingValue) {
        setting.values.forEach((conf) => {
            if (conf.value !== settingValue.value) {
                conf.enabled = !event.source.checked;
            }
            else {
                conf.enabled = event.source.checked;
            }
        });
        source.setParamFromSetting(setting);
        this.searchSourceChange.emit(source);
    }
    onCheckSearchSource(event, source) {
        source.enabled = event.checked;
        const storage = (this.storageService.get(source.getId() + '.options') || {});
        storage.enabled = source.enabled;
        this.storageService.set(source.getId() + '.options', storage);
        this.searchSourceChange.emit(source);
    }
    getAvailableValues(setting) {
        return setting.values.filter((s) => s.available !== false);
    }
    getAvailableHashtagsValues(setting) {
        if (setting.hashtags) {
            return setting.hashtags.map((h) => '#' + h).join(', ');
        }
        return;
    }
    stopPropagation(event) {
        event.stopPropagation();
    }
    changePointerReverseSearch(event) {
        this.pointerSummaryEnabled = event.checked;
        this.pointerSummaryStatus.emit(this.pointerSummaryEnabled);
    }
    changeSearchResultsGeometry(event) {
        this.searchResultsGeometryEnabled = event.checked;
        this.searchResultsGeometryStatus.emit(this.searchResultsGeometryEnabled);
    }
}
SearchSettingsComponent.ɵfac = function SearchSettingsComponent_Factory(t) { return new (t || SearchSettingsComponent)(i0.ɵɵdirectiveInject(SearchSourceService), i0.ɵɵdirectiveInject(i2$1.MediaService), i0.ɵɵdirectiveInject(i2$1.StorageService)); };
SearchSettingsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SearchSettingsComponent, selectors: [["igo-search-settings"]], hostBindings: function SearchSettingsComponent_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("keydown", function SearchSettingsComponent_keydown_HostBindingHandler($event) { return ctx.handleKeyboardEvent($event); }, false, i0.ɵɵresolveDocument);
    } }, inputs: { pointerSummaryEnabled: "pointerSummaryEnabled", searchResultsGeometryEnabled: "searchResultsGeometryEnabled" }, outputs: { searchSourceChange: "searchSourceChange", pointerSummaryStatus: "pointerSummaryStatus", searchResultsGeometryStatus: "searchResultsGeometryStatus" }, decls: 9, vars: 7, consts: [[1, "igo-search-settings"], ["mat-icon-button", "", "color", "primary", "tooltip-position", "below", "matTooltipShowDelay", "500", 1, "igo-search-settings-button", 3, "matTooltip", "matMenuTriggerFor"], ["svgIcon", "chevron-down"], [1, "no-border-radius"], ["searchSettingsMenu", "matMenu"], ["class", "checkAllButton", 4, "ngIf"], [4, "ngFor", "ngForOf"], [4, "ngIf"], [1, "checkAllButton"], ["mat-raised-button", "", 3, "click"], [1, "igo-search-settings-search-source"], [1, "igo-search-settings-checkbox", 3, "checked", "value", "click", "change"], ["mat-menu-item", "", 3, "matMenuTriggerFor", 4, "ngIf"], ["mat-menu-item", "", 4, "ngIf"], ["sub_menu", "matMenu"], ["mat-menu-item", "", 3, "matMenuTriggerFor"], ["mat-menu-item", ""], ["yPosition", "above", 3, "ngSwitch"], ["test_sub_menu", "matMenu"], [4, "ngSwitchCase"], [1, "igo-search-settings-radio-group", 3, "value"], ["class", "mat-typography", 3, "value", "matTooltip", "checked", "click", "change", 4, "ngFor", "ngForOf"], [1, "mat-typography", 3, "value", "matTooltip", "checked", "click", "change"], ["class", "mat-menu-item", 3, "display", "checked", "value", "matTooltip", "click", "change", 4, "ngFor", "ngForOf"], [1, "mat-menu-item", 3, "checked", "value", "matTooltip", "click", "change"], [1, "pointer-summary-slide-toggle-container", "mat-typography"], ["tooltip-position", "below", "matTooltipShowDelay", "500", 1, "pointer-summary-option", 3, "matTooltip", "checked", "labelPosition", "change", "click"]], template: function SearchSettingsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelementStart(1, "button", 1);
        i0.ɵɵpipe(2, "translate");
        i0.ɵɵelement(3, "mat-icon", 2);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(4, "mat-menu", 3, 4);
        i0.ɵɵtemplate(6, SearchSettingsComponent_div_6_Template, 5, 5, "div", 5);
        i0.ɵɵtemplate(7, SearchSettingsComponent_ng_container_7_Template, 8, 5, "ng-container", 6);
        i0.ɵɵtemplate(8, SearchSettingsComponent_span_8_Template, 11, 16, "span", 7);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = i0.ɵɵreference(5);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(2, 5, "igo.geo.search.menu.tooltip"))("matMenuTriggerFor", _r0);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", ctx.getSearchSources().length > 4);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.getSearchSources());
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.hasPointerReverseSearchSource && !ctx.isTouchScreen);
    } }, directives: [i2.MatButton, i3.MatTooltip, i5$2.MatMenuTrigger, i4.MatIcon, i5$2.MatMenu, i1$1.NgIf, i1$1.NgForOf, i11.MatCheckbox, i5$2.MatMenuItem, i1$1.NgSwitch, i1$1.NgSwitchCase, i19.MatRadioGroup, i19.MatRadioButton, i10.MatDivider, i22.MatSlideToggle], pipes: [i7.TranslatePipe], styles: [".checkAllButton[_ngcontent-%COMP%]{text-align:center;padding:0 5px}.igo-search-settings-button[_ngcontent-%COMP%]     div.mat-button-ripple-round{border-radius:0}.igo-search-settings-radio-group[_ngcontent-%COMP%]{display:flex;flex-direction:column}.igo-search-settings-radio-group[_ngcontent-%COMP%]   mat-radio-button[_ngcontent-%COMP%]{margin:5px}.igo-search-settings-checkbox[_ngcontent-%COMP%]   mat-radio-button[_ngcontent-%COMP%]{display:flex}.igo-search-settings-search-source[_ngcontent-%COMP%]{display:flex;width:100%}.igo-search-settings-search-source[_ngcontent-%COMP%]   mat-checkbox[_ngcontent-%COMP%]{display:flex;margin-left:5px;margin-right:5px}.pointer-summary-option[_ngcontent-%COMP%]{display:block;margin-right:10px;margin-bottom:15px}.pointer-summary-slide-toggle-container[_ngcontent-%COMP%]{overflow-x:hidden}.pointer-summary-slide-toggle-container[_ngcontent-%COMP%]   mat-slide-toggle[_ngcontent-%COMP%]{margin:10px}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SearchSettingsComponent, [{
        type: Component,
        args: [{
                selector: 'igo-search-settings',
                templateUrl: './search-settings.component.html',
                styleUrls: ['./search-settings.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: SearchSourceService }, { type: i2$1.MediaService }, { type: i2$1.StorageService }]; }, { pointerSummaryEnabled: [{
            type: Input
        }], searchResultsGeometryEnabled: [{
            type: Input
        }], searchSourceChange: [{
            type: Output
        }], pointerSummaryStatus: [{
            type: Output
        }], searchResultsGeometryStatus: [{
            type: Output
        }], handleKeyboardEvent: [{
            type: HostListener,
            args: ['document:keydown', ['$event']]
        }] }); })();

/**
 * @ignore
 */
class IgoSearchSettingsModule {
}
IgoSearchSettingsModule.ɵfac = function IgoSearchSettingsModule_Factory(t) { return new (t || IgoSearchSettingsModule)(); };
IgoSearchSettingsModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoSearchSettingsModule });
IgoSearchSettingsModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatTooltipModule,
            MatIconModule,
            MatButtonModule,
            MatMenuModule,
            MatRadioModule,
            MatCheckboxModule,
            MatDividerModule,
            MatSlideToggleModule,
            IgoLanguageModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoSearchSettingsModule, [{
        type: NgModule,
        args: [{
                declarations: [SearchSettingsComponent],
                imports: [
                    CommonModule,
                    MatTooltipModule,
                    MatIconModule,
                    MatButtonModule,
                    MatMenuModule,
                    MatRadioModule,
                    MatCheckboxModule,
                    MatDividerModule,
                    MatSlideToggleModule,
                    IgoLanguageModule
                ],
                exports: [SearchSettingsComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoSearchSettingsModule, { declarations: [SearchSettingsComponent], imports: [CommonModule,
        MatTooltipModule,
        MatIconModule,
        MatButtonModule,
        MatMenuModule,
        MatRadioModule,
        MatCheckboxModule,
        MatDividerModule,
        MatSlideToggleModule,
        IgoLanguageModule], exports: [SearchSettingsComponent] }); })();

const _c0$3 = ["input"];
function SearchBarComponent_mat_label_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "mat-label");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r0.label);
} }
function SearchBarComponent_button_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 10);
    i0.ɵɵelement(1, "mat-icon", 11);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("color", ctx_r2.color);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate("svgIcon", ctx_r2.searchIcon);
} }
function SearchBarComponent_button_12_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 12);
    i0.ɵɵlistener("click", function SearchBarComponent_button_12_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.onClearButtonClick(); });
    i0.ɵɵelement(1, "mat-icon", 13);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("color", ctx_r3.color);
} }
function SearchBarComponent_igo_search_selector_14_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-search-selector", 14);
    i0.ɵɵlistener("searchTypeChange", function SearchBarComponent_igo_search_selector_14_Template_igo_search_selector_searchTypeChange_0_listener($event) { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(); return ctx_r8.onSearchTypeChange($event); });
    i0.ɵɵpipe(1, "async");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("searchTypes", ctx_r4.searchTypes)("searchType", i0.ɵɵpipeBind1(1, 2, ctx_r4.searchType$));
} }
function SearchBarComponent_igo_search_settings_15_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-search-settings", 15);
    i0.ɵɵlistener("pointerSummaryStatus", function SearchBarComponent_igo_search_settings_15_Template_igo_search_settings_pointerSummaryStatus_0_listener($event) { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.pointerSummaryStatus.emit($event); })("searchResultsGeometryStatus", function SearchBarComponent_igo_search_settings_15_Template_igo_search_settings_searchResultsGeometryStatus_0_listener($event) { i0.ɵɵrestoreView(_r11); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.searchResultsGeometryStatus.emit($event); })("searchSourceChange", function SearchBarComponent_igo_search_settings_15_Template_igo_search_settings_searchSourceChange_0_listener() { i0.ɵɵrestoreView(_r11); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.onSearchSettingsChange(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("pointerSummaryEnabled", ctx_r5.pointerSummaryEnabled)("searchResultsGeometryEnabled", ctx_r5.searchResultsGeometryEnabled);
} }
const _c1$2 = function (a0) { return { empty: a0 }; };
const _c2$1 = function (a0) { return { "hasSearchIcon": a0 }; };
/**
 * Searchbar that triggers a research in all search sources enabled.
 * If the store input is defined, the search results will be loaded
 * into that store. An event is always emitted when a research is completed.
 */
class SearchBarComponent {
    constructor(languageService, searchService, searchSourceService) {
        this.languageService = languageService;
        this.searchService = searchService;
        this.searchSourceService = searchSourceService;
        this.placeholder$ = new BehaviorSubject('igo.geo.search.placeholder');
        this.empty$ = new BehaviorSubject(true);
        /**
         * Search term stream
         */
        this.stream$ = new BehaviorSubject('');
        /**
         * List of available search types
         */
        this.searchTypes = SEARCH_TYPES;
        this.searchType$ = new BehaviorSubject(undefined);
        /**
         * Event emitted when the pointer summary is activated by the searchbar setting
         */
        this.pointerSummaryStatus = new EventEmitter();
        /**
         * Event emitted when the show geometry setting is changed
         */
        this.searchResultsGeometryStatus = new EventEmitter();
        this.term$ = new BehaviorSubject('');
        this.disabled$ = new BehaviorSubject(false);
        this.pointerSummaryEnabled = false;
        this.searchResultsGeometryEnabled = false;
        /**
         * Whether a float label should be displayed
         */
        this.floatLabel = 'never';
        this.appearance = 'legacy';
        /**
         * Icons color (search and clear)
         */
        this.color = 'primary';
        this.termSplitter = '|';
        /**
         * Debounce time between each keystroke
         */
        this.debounce = 200;
        /**
         * Minimum term length required to trigger a research
         */
        this.minLength = 2;
        /**
         * Search Selector
         */
        this.searchSelector = false;
        /**
         * Search Settings
         */
        this.searchSettings = false;
        /**
         * Force coordinates in north america
         */
        this.forceNA = false;
        /**
         * Event emitted when the search term changes
         */
        this.searchTermChange = new EventEmitter();
        /**
         * Event emitted when a research is completed
         */
        this.search = new EventEmitter();
        /**
         * Event emitted when the search type changes
         */
        this.searchTypeChange = new EventEmitter();
        /**
         * Event emitted when the search type changes
         */
        this.clearFeature = new EventEmitter();
        /**
         * Event emitted when the search settings changes
         */
        this.searchSettingsChange = new EventEmitter();
    }
    /**
     * Search term
     */
    set searchType(value) {
        this.setSearchType(value);
    }
    get searchType() {
        return this.searchType$.value;
    }
    /**
     * Search term
     */
    set term(value) {
        this.setTerm(value);
    }
    get term() {
        return this.term$.value;
    }
    /**
     * Whether this component is disabled
     */
    set disabled(value) {
        this.disabled$.next(value);
    }
    get disabled() {
        return this.disabled$.value;
    }
    /**
     * Whether the search bar is empty
     * @internal
     */
    get empty() {
        return this.term.length === 0;
    }
    /**
     * Subscribe to the search term stream and trigger researches
     * @internal
     */
    ngOnInit() {
        this.term$$ = this.term$.subscribe((term) => {
            this.empty$.next(term === undefined || term.length === 0);
        });
        this.stream$$ = this.stream$
            .pipe(debounce((term) => (term === '' ? EMPTY : timer(this.debounce))))
            .subscribe((term) => this.onSetTerm(term));
        this.handlePlaceholder();
        this.searchType$$ = this.searchType$
            .pipe(distinctUntilChanged())
            .subscribe((searchType) => this.onSetSearchType(searchType));
    }
    /**
     * Unsubscribe to the search term stream
     * @internal
     */
    ngOnDestroy() {
        this.term$$.unsubscribe();
        this.stream$$.unsubscribe();
        this.searchType$$.unsubscribe();
    }
    /**
     * When a user types, validates the key and send it into the
     * stream if it's valid
     * @param event Keyboard event
     * @internal
     */
    onKeyup(event) {
        const key = event.key;
        if (!this.keyIsValid(key)) {
            return;
        }
        const term = event.target.value;
        this.setTerm(term);
    }
    /**
     * Clear the stream and the input
     * @internal
     */
    onClearButtonClick() {
        this.clear();
        this.clearFeature.emit();
    }
    /**
     * Update search type
     * @param searchType Enabled search type
     * @internal
     */
    onSearchTypeChange(searchType) {
        this.setSearchType(searchType);
    }
    /**
     * Update the placeholder with the enabled search type. The placeholder
     * for all availables search typers needs to be defined in the locale
     * files or an error will be thrown.
     * @param searchType Enabled search type
     * @internal
     */
    setSearchType(searchType) {
        this.searchType$.next(searchType);
    }
    onSearchSettingsChange() {
        this.doSearch(this.term);
        this.searchSettingsChange.emit();
        this.handlePlaceholder();
    }
    /**
     * Send the term into the stream only if this component is not disabled
     * @param term Search term
     */
    setTerm(term) {
        if (this.disabled) {
            return;
        }
        term = term || '';
        if (term !== this.term) {
            this.term$.next(term);
        }
        const slug = term.replace(/(#[^\s]*)/g, '').trim();
        if (slug.length >= this.minLength || slug.length === 0) {
            this.stream$.next(term);
        }
    }
    /**
     * Clear the stream and the input
     */
    clear() {
        this.term$.next('');
        this.stream$.next('');
        this.input.nativeElement.focus();
    }
    /**
     * Validate if a given key stroke is a valid input
     */
    keyIsValid(key) {
        return SearchBarComponent.invalidKeys.indexOf(key) === -1;
    }
    /**
     * When the search term changes, emit an event and trigger a
     * research in every enabled search sources.
     * @param term Search term
     */
    onSetTerm(term) {
        this.searchTermChange.emit(term);
        this.doSearch(term);
    }
    handlePlaceholder() {
        const searchTypes = [
            ...new Set(this.searchSourceService
                .getEnabledSources()
                .filter((ss) => !['map', 'coordinatesreverse'].includes(ss.getId()))
                .map((ss) => ss.getType()))
        ];
        let placeholder = `igo.geo.search.placeholder`;
        if (searchTypes.length === 1) {
            placeholder = `igo.geo.search.${searchTypes[0].toLowerCase()}.placeholder`;
        }
        else if (searchTypes.length === 0) {
            placeholder = `igo.geo.search.emptyType.placeholder`;
        }
        this.placeholder$.next(placeholder);
    }
    onSetSearchType(searchType) {
        if (searchType === undefined || searchType === null) {
            return;
        }
        this.searchTypeChange.emit(searchType);
        const placeholder = `igo.geo.search.${searchType.toLowerCase()}.placeholder`;
        this.placeholder$.next(placeholder);
        this.setTerm(this.term);
    }
    /**
     * Execute the search
     * @param term Search term
     */
    doSearch(rawTerm) {
        if (this.researches$$) {
            this.researches$$.map((research) => research.unsubscribe());
            this.researches$$ = undefined;
        }
        let terms;
        if (this.termSplitter && rawTerm.match(new RegExp(this.termSplitter, 'g'))) {
            terms = rawTerm.split(this.termSplitter).filter((t) => t.length >= this.minLength);
            if (this.store) {
                this.store.clear();
            }
        }
        else {
            terms = [rawTerm];
        }
        let researches = [];
        terms.map((term) => {
            const slug = term ? term.replace(/(#[^\s]*)/g, '').trim() : '';
            if (slug === '') {
                if (this.store !== undefined) {
                    this.store.clear();
                }
                return;
            }
            researches = researches.concat(this.searchService.search(term, {
                forceNA: this.forceNA
            }));
        });
        this.researches$$ = researches.map((research) => {
            return research.request.subscribe((results) => {
                this.onResearchCompleted(research, results);
            });
        });
    }
    /**
     * When a research  is completed, emit an event and update
     * the store's items.
     * @param research Research
     * @param results Research results
     */
    onResearchCompleted(research, results) {
        this.search.emit({ research, results });
        if (this.store !== undefined) {
            const newResults = this.store
                .all()
                .filter((result) => result.source !== research.source)
                .concat(results);
            this.store.updateMany(newResults);
        }
    }
}
/**
 * Invalid keys
 */
SearchBarComponent.invalidKeys = [
    'Control',
    'Shift',
    'Alt',
    'ArrowDown',
    'ArrowUp',
    'ArrowRight',
    'ArrowLeft'
];
SearchBarComponent.ɵfac = function SearchBarComponent_Factory(t) { return new (t || SearchBarComponent)(i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(SearchService), i0.ɵɵdirectiveInject(SearchSourceService)); };
SearchBarComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SearchBarComponent, selectors: [["igo-search-bar"]], viewQuery: function SearchBarComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$3, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, inputs: { searchTypes: "searchTypes", searchType: "searchType", term: "term", disabled: "disabled", pointerSummaryEnabled: "pointerSummaryEnabled", searchResultsGeometryEnabled: "searchResultsGeometryEnabled", floatLabel: "floatLabel", appearance: "appearance", placeholder: "placeholder", label: "label", color: "color", termSplitter: "termSplitter", debounce: "debounce", minLength: "minLength", searchIcon: "searchIcon", searchSelector: "searchSelector", searchSettings: "searchSettings", forceNA: "forceNA", store: "store" }, outputs: { pointerSummaryStatus: "pointerSummaryStatus", searchResultsGeometryStatus: "searchResultsGeometryStatus", searchTermChange: "searchTermChange", search: "search", searchTypeChange: "searchTypeChange", clearFeature: "clearFeature", searchSettingsChange: "searchSettingsChange" }, decls: 16, vars: 28, consts: [[1, "igo-search-bar-container", 3, "ngClass"], [3, "floatLabel", "appearance"], [4, "ngIf"], ["matInput", "", "autocomplete", "off", 3, "ngClass", "disabled", "placeholder", "value", "keyup", "touchend"], ["input", ""], [1, "search-bar-buttons"], ["mat-icon-button", "", 3, "color", 4, "ngIf"], ["mat-icon-button", "", 3, "color", "click", 4, "ngIf"], [3, "searchTypes", "searchType", "searchTypeChange", 4, "ngIf"], [3, "pointerSummaryEnabled", "searchResultsGeometryEnabled", "pointerSummaryStatus", "searchResultsGeometryStatus", "searchSourceChange", 4, "ngIf"], ["mat-icon-button", "", 3, "color"], [3, "svgIcon"], ["mat-icon-button", "", 3, "color", "click"], ["svgIcon", "close"], [3, "searchTypes", "searchType", "searchTypeChange"], [3, "pointerSummaryEnabled", "searchResultsGeometryEnabled", "pointerSummaryStatus", "searchResultsGeometryStatus", "searchSourceChange"]], template: function SearchBarComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵpipe(1, "async");
        i0.ɵɵelementStart(2, "mat-form-field", 1);
        i0.ɵɵtemplate(3, SearchBarComponent_mat_label_3_Template, 2, 1, "mat-label", 2);
        i0.ɵɵelementStart(4, "input", 3, 4);
        i0.ɵɵlistener("keyup", function SearchBarComponent_Template_input_keyup_4_listener($event) { return ctx.onKeyup($event); })("touchend", function SearchBarComponent_Template_input_touchend_4_listener($event) { return ctx.onKeyup($event); });
        i0.ɵɵpipe(6, "async");
        i0.ɵɵpipe(7, "async");
        i0.ɵɵpipe(8, "translate");
        i0.ɵɵpipe(9, "async");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(10, "div", 5);
        i0.ɵɵtemplate(11, SearchBarComponent_button_11_Template, 2, 2, "button", 6);
        i0.ɵɵtemplate(12, SearchBarComponent_button_12_Template, 2, 1, "button", 7);
        i0.ɵɵpipe(13, "async");
        i0.ɵɵtemplate(14, SearchBarComponent_igo_search_selector_14_Template, 2, 4, "igo-search-selector", 8);
        i0.ɵɵtemplate(15, SearchBarComponent_igo_search_settings_15_Template, 1, 2, "igo-search-settings", 9);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(24, _c1$2, i0.ɵɵpipeBind1(1, 12, ctx.empty$)));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("floatLabel", ctx.floatLabel)("appearance", ctx.appearance);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.label);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(26, _c2$1, ctx.searchIcon))("disabled", i0.ɵɵpipeBind1(6, 14, ctx.disabled$))("placeholder", ctx.placeholder ? ctx.placeholder : i0.ɵɵpipeBind1(7, 16, ctx.placeholder$) ? i0.ɵɵpipeBind1(8, 18, ctx.placeholder$.value) : undefined)("value", i0.ɵɵpipeBind1(9, 20, ctx.term$));
        i0.ɵɵadvance(7);
        i0.ɵɵproperty("ngIf", ctx.searchIcon !== undefined);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(13, 22, ctx.empty$) === false);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.searchSelector);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.searchSettings);
    } }, directives: [i1$1.NgClass, i12.MatFormField, i1$1.NgIf, i5$1.MatInput, i12.MatLabel, i2.MatButton, i4.MatIcon, SearchSelectorComponent, SearchSettingsComponent], pipes: [i1$1.AsyncPipe, i7.TranslatePipe], styles: ["[_nghost-%COMP%]     .mat-form-field{padding:0 5px}[_nghost-%COMP%]     .mat-form-field-wrapper{margin-bottom:-1.5em}[_nghost-%COMP%]     span.mat-form-field-label-wrapper{top:-20px}[_nghost-%COMP%]     div.mat-form-field-infix{left:5px;right:5px;padding:0 0 12px!important}[_nghost-%COMP%]     div.mat-form-field-underline{display:none}.igo-search-bar-container[_ngcontent-%COMP%]{position:relative;width:100%;display:inline-flex;overflow:hidden}.igo-search-bar-container[_ngcontent-%COMP%] > mat-form-field[_ngcontent-%COMP%]{width:calc(100% - (2 * 40px))}.igo-search-bar-container.empty[_ngcontent-%COMP%] > mat-form-field[_ngcontent-%COMP%]{width:calc(100% - 40px)}.search-bar-buttons[_ngcontent-%COMP%]{position:relative;right:0px;display:inline-flex;top:0}.search-bar-buttons[_ngcontent-%COMP%] > button[_ngcontent-%COMP%]:nth-child(2):before{content:\"\";left:0px;top:5px;border-right:1px solid #ddd;height:28px}igo-search-selector[_ngcontent-%COMP%]{background-color:#fff;top:0;border-radius:0}igo-search-settings[_ngcontent-%COMP%]{background-color:#fff;top:0;border-radius:0}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SearchBarComponent, [{
        type: Component,
        args: [{
                selector: 'igo-search-bar',
                templateUrl: './search-bar.component.html',
                styleUrls: ['./search-bar.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i2$1.LanguageService }, { type: SearchService }, { type: SearchSourceService }]; }, { searchTypes: [{
            type: Input
        }], searchType: [{
            type: Input
        }], pointerSummaryStatus: [{
            type: Output
        }], searchResultsGeometryStatus: [{
            type: Output
        }], term: [{
            type: Input
        }], disabled: [{
            type: Input
        }], pointerSummaryEnabled: [{
            type: Input
        }], searchResultsGeometryEnabled: [{
            type: Input
        }], floatLabel: [{
            type: Input
        }], appearance: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], label: [{
            type: Input
        }], color: [{
            type: Input
        }], termSplitter: [{
            type: Input
        }], debounce: [{
            type: Input
        }], minLength: [{
            type: Input
        }], searchIcon: [{
            type: Input
        }], searchSelector: [{
            type: Input
        }], searchSettings: [{
            type: Input
        }], forceNA: [{
            type: Input
        }], store: [{
            type: Input
        }], searchTermChange: [{
            type: Output
        }], search: [{
            type: Output
        }], searchTypeChange: [{
            type: Output
        }], clearFeature: [{
            type: Output
        }], searchSettingsChange: [{
            type: Output
        }], input: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }] }); })();

class SearchUrlParamDirective {
    constructor(component, ref, route) {
        this.component = component;
        this.ref = ref;
        this.route = route;
    }
    ngOnInit() {
        if (this.route && this.route.options.searchKey) {
            this.route.queryParams.subscribe(params => {
                const searchParams = params[this.route.options.searchKey];
                if (searchParams) {
                    this.component.setTerm(searchParams);
                    this.ref.detectChanges();
                }
            });
        }
    }
}
SearchUrlParamDirective.ɵfac = function SearchUrlParamDirective_Factory(t) { return new (t || SearchUrlParamDirective)(i0.ɵɵdirectiveInject(SearchBarComponent, 2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2$1.RouteService, 8)); };
SearchUrlParamDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: SearchUrlParamDirective, selectors: [["", "igoSearchUrlParam", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SearchUrlParamDirective, [{
        type: Directive,
        args: [{
                selector: '[igoSearchUrlParam]'
            }]
    }], function () { return [{ type: SearchBarComponent, decorators: [{
                type: Self
            }] }, { type: i0.ChangeDetectorRef }, { type: i2$1.RouteService, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @ignore
 */
class IgoSearchBarModule {
}
IgoSearchBarModule.ɵfac = function IgoSearchBarModule_Factory(t) { return new (t || IgoSearchBarModule)(); };
IgoSearchBarModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoSearchBarModule });
IgoSearchBarModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            MatTooltipModule,
            MatIconModule,
            MatButtonModule,
            MatMenuModule,
            MatRadioModule,
            MatFormFieldModule,
            MatInputModule,
            IgoLanguageModule,
            IgoSearchSelectorModule,
            IgoSearchSettingsModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoSearchBarModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    MatTooltipModule,
                    MatIconModule,
                    MatButtonModule,
                    MatMenuModule,
                    MatRadioModule,
                    MatFormFieldModule,
                    MatInputModule,
                    IgoLanguageModule,
                    IgoSearchSelectorModule,
                    IgoSearchSettingsModule
                ],
                exports: [
                    SearchBarComponent,
                ],
                declarations: [
                    SearchBarComponent,
                    SearchUrlParamDirective
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoSearchBarModule, { declarations: [SearchBarComponent,
        SearchUrlParamDirective], imports: [CommonModule,
        FormsModule,
        MatTooltipModule,
        MatIconModule,
        MatButtonModule,
        MatMenuModule,
        MatRadioModule,
        MatFormFieldModule,
        MatInputModule,
        IgoLanguageModule,
        IgoSearchSelectorModule,
        IgoSearchSettingsModule], exports: [SearchBarComponent] }); })();

function SearchResultsItemComponent_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "mat-icon", 4);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵpropertyInterpolate("svgIcon", ctx_r0.showIcons ? ctx_r0.icon : "blank");
} }
function SearchResultsItemComponent_h4_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "h4", 5);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("innerHtml", ctx_r1.titleHtml, i0.ɵɵsanitizeHtml)("matTooltip", ctx_r1.tooltipHtml);
} }
function SearchResultsItemComponent_h4_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "h4", 6);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", ctx_r2.title);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r2.title);
} }
function SearchResultsItemComponent_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 7);
    i0.ɵɵlistener("click", function SearchResultsItemComponent_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.onZoomHandler(); });
    i0.ɵɵelement(1, "mat-icon", 8);
    i0.ɵɵelementEnd();
} }
const _c0$2 = [[["", "igoSearchItemToolbar", ""]]];
const _c1$1 = ["[igoSearchItemToolbar]"];
/**
 * Search results list item
 */
class SearchResultsItemComponent {
    constructor() {
        /**
         * Whether there should be a zoom button
         */
        this.withZoomButton = false;
        this.zoomEvent = new EventEmitter();
        this.format = new OlGeoJSON();
    }
    get title() {
        return getEntityTitle(this.result);
    }
    /**
     * Search result HTML title
     * @internal
     */
    get titleHtml() {
        return getEntityTitleHtml(this.result);
    }
    /**
     * Search result tooltip
     * @internal
     */
    get tooltipHtml() {
        return this.titleHtml
            .replace(/<small?[^>]+(>|$)/g, '\n')
            .replace(/<\/?[^>]+(>|$)/g, '');
    }
    /**
     * Search result icon
     * @internal
     */
    get icon() {
        return getEntityIcon(this.result);
    }
    onZoomHandler() {
        const olFeature = this.format.readFeature(this.result.data, {
            dataProjection: this.result.data.projection,
            featureProjection: this.map.projection
        });
        moveToOlFeatures(this.map, [olFeature], FeatureMotion.Default);
    }
}
SearchResultsItemComponent.ɵfac = function SearchResultsItemComponent_Factory(t) { return new (t || SearchResultsItemComponent)(); };
SearchResultsItemComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SearchResultsItemComponent, selectors: [["igo-search-results-item"]], inputs: { result: "result", map: "map", showIcons: "showIcons", withZoomButton: "withZoomButton" }, outputs: { zoomEvent: "zoomEvent" }, ngContentSelectors: _c1$1, decls: 6, vars: 4, consts: [["mat-list-avatar", "", 3, "svgIcon", 4, "ngIf"], ["matLine", "", "matTooltipShowDelay", "500", "matTooltipClass", "search-result-tooltip", 3, "innerHtml", "matTooltip", 4, "ngIf"], ["matLine", "", "matTooltipShowDelay", "500", 3, "matTooltip", 4, "ngIf"], ["igoStopPropagation", "", "mat-icon-button", "", 3, "click", 4, "ngIf"], ["mat-list-avatar", "", 3, "svgIcon"], ["matLine", "", "matTooltipShowDelay", "500", "matTooltipClass", "search-result-tooltip", 3, "innerHtml", "matTooltip"], ["matLine", "", "matTooltipShowDelay", "500", 3, "matTooltip"], ["igoStopPropagation", "", "mat-icon-button", "", 3, "click"], ["svgIcon", "magnify"]], template: function SearchResultsItemComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c0$2);
        i0.ɵɵelementStart(0, "mat-list-item");
        i0.ɵɵtemplate(1, SearchResultsItemComponent_mat_icon_1_Template, 1, 1, "mat-icon", 0);
        i0.ɵɵtemplate(2, SearchResultsItemComponent_h4_2_Template, 1, 2, "h4", 1);
        i0.ɵɵtemplate(3, SearchResultsItemComponent_h4_3_Template, 2, 2, "h4", 2);
        i0.ɵɵtemplate(4, SearchResultsItemComponent_button_4_Template, 2, 0, "button", 3);
        i0.ɵɵprojection(5);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.icon);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.titleHtml);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx.titleHtml);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.withZoomButton);
    } }, directives: [i1$3.MatListItem, i1$1.NgIf, i4.MatIcon, i1$3.MatListAvatarCssMatStyler, i9.MatLine, i3.MatTooltip, i2.MatButton, i6.StopPropagationDirective], styles: ["[_nghost-%COMP%]     small{color:#8c8c8c}  .search-result-tooltip{white-space:pre-line}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SearchResultsItemComponent, [{
        type: Component,
        args: [{
                selector: 'igo-search-results-item',
                templateUrl: './search-results-item.component.html',
                styleUrls: ['./search-results-item.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { result: [{
            type: Input
        }], map: [{
            type: Input
        }], showIcons: [{
            type: Input
        }], withZoomButton: [{
            type: Input
        }], zoomEvent: [{
            type: Output
        }] }); })();

const _c0$1 = ["igoSearchItemToolbar"];
function SearchResultsComponent_ng_template_1_igo_collapsible_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
const _c1 = function (a0) { return { results: a0 }; };
function SearchResultsComponent_ng_template_1_igo_collapsible_0_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-collapsible", 6);
    i0.ɵɵlistener("toggle", function SearchResultsComponent_ng_template_1_igo_collapsible_0_Template_igo_collapsible_toggle_0_listener($event) { i0.ɵɵrestoreView(_r10); const group_r2 = i0.ɵɵnextContext().$implicit; const ctx_r9 = i0.ɵɵnextContext(); return (ctx_r9.collapsed[group_r2.source.title] = $event); });
    i0.ɵɵtemplate(1, SearchResultsComponent_ng_template_1_igo_collapsible_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const group_r2 = i0.ɵɵnextContext().$implicit;
    const _r6 = i0.ɵɵreference(4);
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(group_r2.source.getId());
    i0.ɵɵproperty("title", ctx_r3.computeGroupTitle(group_r2))("collapsed", ctx_r3.collapsed[group_r2.source.title]);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", _r6)("ngTemplateOutletContext", i0.ɵɵpureFunction1(6, _c1, group_r2.results));
} }
function SearchResultsComponent_ng_template_1_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function SearchResultsComponent_ng_template_1_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, SearchResultsComponent_ng_template_1_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 7);
} if (rf & 2) {
    const group_r2 = i0.ɵɵnextContext().$implicit;
    const _r6 = i0.ɵɵreference(4);
    i0.ɵɵproperty("ngTemplateOutlet", _r6)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c1, group_r2.results));
} }
const _c2 = function (a0) { return { result: a0 }; };
function SearchResultsComponent_ng_template_1_ng_template_3_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    const _r20 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "igo-search-results-item", 9);
    i0.ɵɵlistener("focus", function SearchResultsComponent_ng_template_1_ng_template_3_ng_template_0_Template_igo_search_results_item_focus_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r20); const result_r18 = restoredCtx.$implicit; const ctx_r19 = i0.ɵɵnextContext(3); return ctx_r19.resultFocus.emit(result_r18); })("unfocus", function SearchResultsComponent_ng_template_1_ng_template_3_ng_template_0_Template_igo_search_results_item_unfocus_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r20); const result_r18 = restoredCtx.$implicit; const ctx_r21 = i0.ɵɵnextContext(3); return ctx_r21.resultUnfocus.emit(result_r18); })("select", function SearchResultsComponent_ng_template_1_ng_template_3_ng_template_0_Template_igo_search_results_item_select_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r20); const result_r18 = restoredCtx.$implicit; const ctx_r22 = i0.ɵɵnextContext(3); return ctx_r22.onResultSelect(result_r18); })("mouseenter", function SearchResultsComponent_ng_template_1_ng_template_3_ng_template_0_Template_igo_search_results_item_mouseenter_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r20); const result_r18 = restoredCtx.$implicit; const ctx_r23 = i0.ɵɵnextContext(3); return ctx_r23.resultFocus.emit(result_r18); })("mouseleave", function SearchResultsComponent_ng_template_1_ng_template_3_ng_template_0_Template_igo_search_results_item_mouseleave_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r20); const result_r18 = restoredCtx.$implicit; const ctx_r24 = i0.ɵɵnextContext(3); return ctx_r24.resultUnfocus.emit(result_r18); });
    i0.ɵɵelementContainer(1, 10);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const result_r18 = ctx.$implicit;
    const ctx_r16 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("map", ctx_r16.map)("result", result_r18)("showIcons", ctx_r16.showIcons)("withZoomButton", ctx_r16.withZoomButton)("focused", ctx_r16.store.state.get(result_r18).focused)("selected", ctx_r16.store.state.get(result_r18).selected);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r16.templateSearchToolbar)("ngTemplateOutletContext", i0.ɵɵpureFunction1(8, _c2, result_r18));
} }
function SearchResultsComponent_ng_template_1_ng_template_3_span_1_Template(rf, ctx) { if (rf & 1) {
    const _r27 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "span", 11);
    i0.ɵɵlistener("click", function SearchResultsComponent_ng_template_1_ng_template_3_span_1_Template_span_click_0_listener() { i0.ɵɵrestoreView(_r27); const group_r2 = i0.ɵɵnextContext(2).$implicit; const ctx_r25 = i0.ɵɵnextContext(); return ctx_r25.displayMoreResults(group_r2); });
    i0.ɵɵelementStart(1, "u");
    i0.ɵɵtext(2);
    i0.ɵɵpipe(3, "translate");
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 1, "igo.geo.search.displayMoreResults"));
} }
function SearchResultsComponent_ng_template_1_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, SearchResultsComponent_ng_template_1_ng_template_3_ng_template_0_Template, 2, 10, "ng-template", 1);
    i0.ɵɵtemplate(1, SearchResultsComponent_ng_template_1_ng_template_3_span_1_Template, 4, 3, "span", 8);
} if (rf & 2) {
    const results_r15 = ctx.results;
    const group_r2 = i0.ɵɵnextContext().$implicit;
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngForOf", results_r15);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r7.isMoreResults(group_r2));
} }
function SearchResultsComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, SearchResultsComponent_ng_template_1_igo_collapsible_0_Template, 2, 8, "igo-collapsible", 3);
    i0.ɵɵtemplate(1, SearchResultsComponent_ng_template_1_ng_template_1_Template, 1, 4, "ng-template", null, 4, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtemplate(3, SearchResultsComponent_ng_template_1_ng_template_3_Template, 2, 2, "ng-template", null, 5, i0.ɵɵtemplateRefExtractor);
} if (rf & 2) {
    const _r4 = i0.ɵɵreference(2);
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngIf", ctx_r1.mode === ctx_r1.searchResultMode.Grouped)("ngIfElse", _r4);
} }
var SearchResultMode;
(function (SearchResultMode) {
    SearchResultMode["Grouped"] = "grouped";
    SearchResultMode["Flat"] = "flat";
})(SearchResultMode || (SearchResultMode = {}));
/**
 * List of search results with focus and selection capabilities.
 * This component is dumb and only emits events.
 */
class SearchResultsComponent {
    constructor(cdRef, searchService) {
        this.cdRef = cdRef;
        this.searchService = searchService;
        /**
         * Reference to the SearchResultMode enum
         * @internal
         */
        this.searchResultMode = SearchResultMode;
        this.pageIterator = [];
        this.collapsed = [];
        /**
         * Search results display mode
         */
        this.mode = SearchResultMode.Grouped;
        /**
         * Whether there should be a zoom button
         */
        this.withZoomButton = false;
        this.settingsChange$ = new BehaviorSubject(undefined);
        this.termSplitter = '|';
        /**
         * Event emitted when a result is focused
         */
        this.resultFocus = new EventEmitter();
        /**
         * Event emitted when a result is unfocused
         */
        this.resultUnfocus = new EventEmitter();
        /**
         * Event emitted when a result is selected
         */
        this.resultSelect = new EventEmitter();
        /**
         * Event emitted when a research is completed after displaying more results is clicked
         */
        this.moreResults = new EventEmitter();
        /**
         * Events emitted when a result is focus or unfocus by mouse event
         */
        this.resultMouseenter = new EventEmitter();
        this.resultMouseleave = new EventEmitter();
    }
    /**
     * Search term
     */
    get term() {
        return this._term;
    }
    set term(value) {
        this._term = value;
        this.pageIterator = [];
    }
    get results$() {
        if (this._results$ === undefined) {
            this._results$ = this.liftResults();
        }
        return this._results$;
    }
    /**
     * Bind the search results store to the watcher
     * @internal
     */
    ngOnInit() {
        this.watcher = new EntityStoreWatcher(this.store, this.cdRef);
        this.settingsChange$$ = this.settingsChange$.subscribe(() => {
            this.pageIterator = [];
        });
    }
    /**
     * Unbind the search results store from the watcher
     * @internal
     */
    ngOnDestroy() {
        this.watcher.destroy();
        this.settingsChange$$.unsubscribe();
    }
    /**
     * Compute a group title
     * @param group Search results group
     * @returns Group title
     * @internal
     */
    computeGroupTitle(group) {
        const parts = [group.source.title];
        const count = group.results.length;
        if (count > 1) {
            parts.push(`(${count})`);
        }
        return parts.join(' ');
    }
    /**
     * When a result is selected, update it's state in the store and emit
     * an event. A selected result is also considered focused
     * @param result Search result
     * @internal
     */
    onResultSelect(result) {
        if (this.store.state.get(result)) {
            if (this.store.state.get(result).selected === true) {
                return;
            }
        }
        this.store.state.update(result, { focused: true, selected: true }, true);
        this.resultSelect.emit(result);
    }
    /**
     * Return an observable of the search results, grouped by search source
     * @returns Observable of grouped search results
     * @internal
     */
    liftResults() {
        return this.store.stateView.all$().pipe(debounce((results) => {
            return results.length === 0 ? EMPTY : timer(200);
        }), map((results) => {
            return this.groupResults(results.map(r => r.entity).sort(this.sortByOrder));
        }));
    }
    /**
     * Sort the results by display order.
     * @param r1 First result
     * @param r2 Second result
     */
    sortByOrder(r1, r2) {
        return r1.source.displayOrder - r2.source.displayOrder;
    }
    /**
     * Group results by search source
     * @param results Search results from all sources
     * @returns Search results grouped by source
     */
    groupResults(results) {
        const grouped = new Map();
        results.forEach((result) => {
            const source = result.source;
            let sourceResults = grouped.get(source);
            if (sourceResults === undefined) {
                sourceResults = [];
                grouped.set(source, sourceResults);
            }
            sourceResults.push(result);
        });
        return Array.from(grouped.keys()).map((source) => {
            if (this.pageIterator[source.getId()] === undefined) {
                this.pageIterator[source.getId()] = 1;
            }
            return { source, results: grouped.get(source) };
        });
    }
    isMoreResults(group) {
        // getStrategyOfType is to avoid display more result based on a filtered state
        const stategy = this.store.getStrategyOfType(EntityStoreFilterCustomFuncStrategy);
        const active = (stategy === null || stategy === void 0 ? void 0 : stategy.active) || false;
        return !active && group.results &&
            group.results[group.results.length - 1].meta.nextPage === true;
    }
    displayMoreResults(group) {
        const options = {
            sourceId: group.source.getId(),
            page: ++this.pageIterator[group.source.getId()]
        };
        let terms;
        if (this.termSplitter && this.term.match(new RegExp(this.termSplitter, 'g'))) {
            terms = this.term.split(this.termSplitter);
        }
        else {
            terms = [this.term];
        }
        let researches = [];
        terms.map((term) => {
            researches = researches.concat(this.searchService.search(term, options));
        });
        researches.map(research => {
            research.request.subscribe((results) => {
                const newResults = group.results.concat(results);
                if (!results.length) {
                    newResults[newResults.length - 1].meta.nextPage = false;
                }
                this.moreResults.emit({ research, results: newResults });
            });
        });
        return;
    }
}
SearchResultsComponent.ɵfac = function SearchResultsComponent_Factory(t) { return new (t || SearchResultsComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(SearchService)); };
SearchResultsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SearchResultsComponent, selectors: [["igo-search-results"]], contentQueries: function SearchResultsComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, _c0$1, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateSearchToolbar = _t.first);
    } }, inputs: { map: "map", store: "store", showIcons: "showIcons", mode: "mode", withZoomButton: "withZoomButton", term: "term", settingsChange$: "settingsChange$", termSplitter: "termSplitter" }, outputs: { resultFocus: "resultFocus", resultUnfocus: "resultUnfocus", resultSelect: "resultSelect", moreResults: "moreResults", resultMouseenter: "resultMouseenter", resultMouseleave: "resultMouseleave" }, decls: 4, vars: 4, consts: [[3, "navigation"], ["ngFor", "", 3, "ngForOf"], ["groupTemplate", ""], [3, "class", "title", "collapsed", "toggle", 4, "ngIf", "ngIfElse"], ["flatTemplate", ""], ["storeItemTemplate", ""], [3, "title", "collapsed", "toggle"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "moreResults mat-typography", 3, "click", 4, "ngIf"], ["igoListItem", "", "color", "accent", 3, "map", "result", "showIcons", "withZoomButton", "focused", "selected", "focus", "unfocus", "select", "mouseenter", "mouseleave"], ["igoSearchItemToolbar", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "moreResults", "mat-typography", 3, "click"]], template: function SearchResultsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "igo-list", 0);
        i0.ɵɵtemplate(1, SearchResultsComponent_ng_template_1_Template, 5, 2, "ng-template", 1, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵpipe(3, "async");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("navigation", true);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(3, 2, ctx.results$));
    } }, directives: [i6.ListComponent, i1$1.NgForOf, i1$1.NgIf, i6.CollapsibleComponent, i1$1.NgTemplateOutlet, SearchResultsItemComponent, i6.ListItemDirective], pipes: [i1$1.AsyncPipe, i7.TranslatePipe], styles: [".moreResults[_ngcontent-%COMP%]{cursor:pointer;color:#00f;float:right;margin-right:10px;margin-top:5px}igo-list[_ngcontent-%COMP%]     mat-list{height:100%}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SearchResultsComponent, [{
        type: Component,
        args: [{
                selector: 'igo-search-results',
                templateUrl: './search-results.component.html',
                styleUrls: ['./search-results.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: SearchService }]; }, { map: [{
            type: Input
        }], store: [{
            type: Input
        }], showIcons: [{
            type: Input
        }], mode: [{
            type: Input
        }], withZoomButton: [{
            type: Input
        }], term: [{
            type: Input
        }], settingsChange$: [{
            type: Input
        }], termSplitter: [{
            type: Input
        }], resultFocus: [{
            type: Output
        }], resultUnfocus: [{
            type: Output
        }], resultSelect: [{
            type: Output
        }], moreResults: [{
            type: Output
        }], resultMouseenter: [{
            type: Output
        }], resultMouseleave: [{
            type: Output
        }], templateSearchToolbar: [{
            type: ContentChild,
            args: ['igoSearchItemToolbar', /* TODO: add static flag */ {}]
        }] }); })();

function SearchResultAddButtonComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 1);
    i0.ɵɵlistener("mouseenter", function SearchResultAddButtonComponent_button_0_Template_button_mouseenter_0_listener($event) { i0.ɵɵrestoreView(_r2); const ctx_r1 = i0.ɵɵnextContext(); return ctx_r1.onMouseEvent($event); })("mouseleave", function SearchResultAddButtonComponent_button_0_Template_button_mouseleave_0_listener($event) { i0.ɵɵrestoreView(_r2); const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.onMouseEvent($event); })("click", function SearchResultAddButtonComponent_button_0_Template_button_click_0_listener($event) { i0.ɵɵrestoreView(_r2); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.onToggleClick($event); });
    i0.ɵɵpipe(1, "translate");
    i0.ɵɵpipe(2, "async");
    i0.ɵɵpipe(3, "async");
    i0.ɵɵelement(4, "mat-icon", 2);
    i0.ɵɵpipe(5, "async");
    i0.ɵɵpipe(6, "async");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("matTooltip", i0.ɵɵpipeBind1(1, 4, i0.ɵɵpipeBind1(2, 6, ctx_r0.tooltip$)))("color", i0.ɵɵpipeBind1(3, 8, ctx_r0.isPreview$) ? "" : ctx_r0.added ? "warn" : "");
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("matBadgeHidden", i0.ɵɵpipeBind1(5, 10, ctx_r0.inRange$))("svgIcon", i0.ɵɵpipeBind1(6, 12, ctx_r0.isPreview$) ? "plus" : ctx_r0.added ? "delete" : "plus");
} }
class SearchResultAddButtonComponent {
    constructor(layerService) {
        this.layerService = layerService;
        this.tooltip$ = new BehaviorSubject('igo.geo.catalog.layer.addToMap');
        this.inRange$ = new BehaviorSubject(true);
        this.isPreview$ = new BehaviorSubject(false);
        this.layersSubcriptions = [];
        this.mouseInsideAdd = false;
        this._color = 'primary';
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    /**
     * @internal
     */
    ngOnInit() {
        if (this.layer.meta.dataType === 'Layer') {
            this.added =
                this.map.layers.findIndex(lay => lay.id === this.layer.data.sourceOptions.id) !== -1;
        }
        this.resolution$$ = this.map.viewController.resolution$.subscribe(value => {
            this.isInResolutionsRange(value);
            this.tooltip$.next(this.computeTooltip());
        });
    }
    ngOnDestroy() {
        this.resolution$$.unsubscribe();
    }
    /**
     * On mouse event, mouseenter /mouseleave
     * @internal
     */
    onMouseEvent(event) {
        this.onToggleClick(event);
    }
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    onToggleClick(event) {
        if (typeof this.lastTimeoutRequest !== 'undefined') {
            clearTimeout(this.lastTimeoutRequest);
        }
        if (event.type === 'mouseenter' && this.mouseInsideAdd) {
            return;
        }
        switch (event.type) {
            case 'click':
                if (!this.isPreview$.value) {
                    if (this.added) {
                        this.remove();
                    }
                    else {
                        this.add();
                    }
                }
                this.isPreview$.next(false);
                break;
            case 'mouseenter':
                if (!this.isPreview$.value && !this.added) {
                    this.lastTimeoutRequest = setTimeout(() => {
                        this.add();
                        this.isPreview$.next(true);
                    }, 500);
                }
                this.mouseInsideAdd = true;
                break;
            case 'mouseleave':
                if (this.isPreview$.value) {
                    this.remove();
                    this.isPreview$.next(false);
                }
                this.mouseInsideAdd = false;
                break;
            default:
                break;
        }
    }
    add() {
        if (!this.added) {
            this.added = true;
            this.addLayerToMap();
        }
    }
    remove() {
        if (this.added) {
            this.added = false;
            this.removeLayerFromMap();
            this.layersSubcriptions.map(s => s.unsubscribe());
            this.layersSubcriptions = [];
        }
    }
    /**
     * Emit added change event with added = true
     */
    addLayerToMap() {
        if (this.map === undefined) {
            return;
        }
        if (this.layer.meta.dataType !== LAYER) {
            return undefined;
        }
        const layerOptions = this.layer.data;
        if (layerOptions.sourceOptions.optionsFromApi === undefined) {
            layerOptions.sourceOptions.optionsFromApi = true;
        }
        this.layersSubcriptions.push(this.layerService
            .createAsyncLayer(layerOptions)
            .subscribe(layer => this.map.addLayer(layer)));
    }
    /**
     * Emit added change event with added = false
     */
    removeLayerFromMap() {
        if (this.map === undefined) {
            return;
        }
        if (this.layer.meta.dataType !== LAYER) {
            return undefined;
        }
        const oLayer = this.map.getLayerById(this.layer.data.sourceOptions.id);
        this.map.removeLayer(oLayer);
    }
    isInResolutionsRange(resolution) {
        const minResolution = this.layer.data.minResolution || 0;
        const maxResolution = this.layer.data.maxResolution || Infinity;
        this.inRange$.next(resolution >= minResolution && resolution <= maxResolution);
    }
    computeTooltip() {
        if (this.added) {
            return this.inRange$.value
                ? 'igo.geo.catalog.layer.removeFromMap'
                : 'igo.geo.catalog.layer.removeFromMapOutRange';
        }
        else {
            return this.inRange$.value
                ? 'igo.geo.catalog.layer.addToMap'
                : 'igo.geo.catalog.layer.addToMapOutRange';
        }
    }
}
SearchResultAddButtonComponent.ɵfac = function SearchResultAddButtonComponent_Factory(t) { return new (t || SearchResultAddButtonComponent)(i0.ɵɵdirectiveInject(LayerService)); };
SearchResultAddButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SearchResultAddButtonComponent, selectors: [["igo-search-add-button"]], inputs: { layer: "layer", added: "added", map: "map", color: "color" }, decls: 1, vars: 1, consts: [["igoStopPropagation", "", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", "mouseenter", "mouseleave", "click", 4, "ngIf"], ["igoStopPropagation", "", "mat-icon-button", "", "tooltip-position", "below", "matTooltipShowDelay", "500", 3, "matTooltip", "color", "mouseenter", "mouseleave", "click"], ["matBadge", "icon", "igoMatBadgeIcon", "eye-off", "igoMatBadgeInverseColor", "true", "matBadgeDisabled", "true", "matBadgeSize", "small", "matBadgePosition", "after", 3, "matBadgeHidden", "svgIcon"]], template: function SearchResultAddButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, SearchResultAddButtonComponent_button_0_Template, 7, 14, "button", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.layer.meta.dataType === "Layer");
    } }, directives: [i1$1.NgIf, i2.MatButton, i6.StopPropagationDirective, i3.MatTooltip, i4.MatIcon, i9$1.MatBadge, i6.IgoBadgeIconDirective], pipes: [i7.TranslatePipe, i1$1.AsyncPipe], styles: [""], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SearchResultAddButtonComponent, [{
        type: Component,
        args: [{
                selector: 'igo-search-add-button',
                templateUrl: './search-results-add-button.component.html',
                styleUrls: ['./search-results-add-button.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: LayerService }]; }, { layer: [{
            type: Input
        }], added: [{
            type: Input
        }], map: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

/**
 * @ignore
 */
class IgoSearchResultsModule {
}
IgoSearchResultsModule.ɵfac = function IgoSearchResultsModule_Factory(t) { return new (t || IgoSearchResultsModule)(); };
IgoSearchResultsModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoSearchResultsModule });
IgoSearchResultsModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatBadgeModule,
            MatTooltipModule,
            MatIconModule,
            MatListModule,
            MatButtonModule,
            IgoCollapsibleModule,
            IgoListModule,
            IgoStopPropagationModule,
            IgoLanguageModule,
            IgoMatBadgeIconModule,
            IgoMetadataModule,
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoSearchResultsModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatBadgeModule,
                    MatTooltipModule,
                    MatIconModule,
                    MatListModule,
                    MatButtonModule,
                    IgoCollapsibleModule,
                    IgoListModule,
                    IgoStopPropagationModule,
                    IgoLanguageModule,
                    IgoMatBadgeIconModule,
                    IgoMetadataModule,
                ],
                exports: [
                    SearchResultsComponent,
                    SearchResultAddButtonComponent
                ],
                declarations: [
                    SearchResultsComponent,
                    SearchResultsItemComponent,
                    SearchResultAddButtonComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoSearchResultsModule, { declarations: [SearchResultsComponent,
        SearchResultsItemComponent,
        SearchResultAddButtonComponent], imports: [CommonModule,
        MatBadgeModule,
        MatTooltipModule,
        MatIconModule,
        MatListModule,
        MatButtonModule,
        IgoCollapsibleModule,
        IgoListModule,
        IgoStopPropagationModule,
        IgoLanguageModule,
        IgoMatBadgeIconModule,
        IgoMetadataModule], exports: [SearchResultsComponent,
        SearchResultAddButtonComponent] }); })();

/**
 * This directive makes the mouse coordinate trigger a reverse search on available search sources.
 * The search results are placed into a label, on a cross icon, representing the mouse coordinate.
 * By default, no search sources. Config in config file must be defined.
 * the layer level.
 */
class SearchPointerSummaryDirective {
    constructor(component, searchService, searchSourceService, mediaService) {
        this.component = component;
        this.searchService = searchService;
        this.searchSourceService = searchSourceService;
        this.mediaService = mediaService;
        this.pointerSearchStore = new EntityStore([]);
        this.reverseSearch$$ = [];
        this.hasPointerReverseSearchSource = false;
        this.searchPointerSummaryFeatureId = 'searchPointerSummaryFeatureId';
        /**
         * The delay where the mouse must be motionless before trigger the reverse search
         */
        this.igoSearchPointerSummaryDelay = 1000;
        /**
         * If the user has enabled or not the directive
         */
        this.igoSearchPointerSummaryEnabled = false;
    }
    /**
     * IGO map
     * @internal
     */
    get map() {
        return this.component.map;
    }
    get mapProjection() {
        return this.component.map.projection;
    }
    /**
     * Start listening to pointermove and reverse search results.
     * @internal
     */
    ngOnInit() {
        this.listenToMapPointerMove();
        this.subscribeToPointerStore();
        this.map.status$.pipe(take(1)).subscribe(() => {
            this.store = new FeatureStore([], { map: this.map });
            this.initStore();
        });
        // To handle context change without using the contextService.
        this.layers$$ = this.map.layers$.subscribe((layers) => {
            if (this.store && !layers.find(l => l.id === 'searchPointerSummaryId')) {
                this.initStore();
            }
        });
    }
    /**
     * Initialize the pointer position store
     * @internal
     */
    initStore() {
        const store = this.store;
        const layer = new VectorLayer({
            isIgoInternalLayer: true,
            id: 'searchPointerSummaryId',
            title: 'searchPointerSummary',
            zIndex: 900,
            source: new FeatureDataSource(),
            showInLayerList: false,
            exportable: false,
            browsable: false,
            style: pointerPositionSummaryMarker
        });
        tryBindStoreLayer(store, layer);
    }
    ngAfterContentChecked() {
        if (!this.searchSourceService.getEnabledSources().filter(sourceCanReverseSearchAsSummary).length) {
            this.hasPointerReverseSearchSource = false;
        }
        else {
            this.hasPointerReverseSearchSource = true;
        }
    }
    /**
     * Stop listening to pointermove and reverse search results.
     * @internal
     */
    ngOnDestroy() {
        this.unlistenToMapPointerMove();
        this.unsubscribeToPointerStore();
        this.unsubscribeReverseSearch();
        this.layers$$.unsubscribe();
    }
    /**
     * Subscribe to pointermove result store
     * @internal
     */
    subscribeToPointerStore() {
        this.store$$ = this.pointerSearchStore.entities$.subscribe(resultsUnderPointerPosition => {
            this.entitiesToPointerOverlay(resultsUnderPointerPosition);
        });
    }
    /**
     * Build an object based on the closest feature by type (base on type and distance properties )
     * @param results SearchResult[]
     * @returns OL style function
     */
    computeSummaryClosestFeature(results) {
        const closestResultByType = {};
        results.map(result => {
            if (result.data.properties.type && result.data.properties.distance >= 0) {
                if (closestResultByType.hasOwnProperty(result.data.properties.type)) {
                    const prevDistance = closestResultByType[result.data.properties.type].distance;
                    if (result.data.properties.distance < prevDistance) {
                        const title = result.meta.pointerSummaryTitle || result.meta.title;
                        closestResultByType[result.data.properties.type] = { distance: result.data.properties.distance, title };
                    }
                }
                else {
                    const title = result.meta.pointerSummaryTitle || result.meta.title;
                    closestResultByType[result.data.properties.type] = { distance: result.data.properties.distance, title };
                }
            }
        });
        return closestResultByType;
    }
    /**
     * convert store entities to a pointer position overlay with label summary on.
     * @param event OL map browser pointer event
     */
    entitiesToPointerOverlay(resultsUnderPointerPosition) {
        const closestResultByType = this.computeSummaryClosestFeature(resultsUnderPointerPosition);
        const summarizedClosestType = Object.keys(closestResultByType);
        const processedSummarizedClosestType = [];
        const summary = [];
        resultsUnderPointerPosition.map(result => {
            const typeIndex = summarizedClosestType.indexOf(result.data.properties.type);
            if (typeIndex !== -1) {
                summary.push(closestResultByType[result.data.properties.type].title);
                summarizedClosestType.splice(typeIndex, 1);
                processedSummarizedClosestType.push(result.data.properties.type);
            }
            else {
                if (processedSummarizedClosestType.indexOf(result.data.properties.type) === -1) {
                    summary.push(result.meta.pointerSummaryTitle || result.meta.title);
                }
            }
        });
        if (summary.length) {
            this.addPointerOverlay(summary.join('\n'));
        }
    }
    /**
     * On map pointermove
     */
    listenToMapPointerMove() {
        this.pointerMoveListener = this.map.ol.on('pointermove', (event) => this.onMapEvent(event));
    }
    /**
     * Unsubscribe to pointer store.
     * @internal
     */
    unsubscribeToPointerStore() {
        this.store$$.unsubscribe();
    }
    /**
     * Unsubscribe to reverse seatch store.
     * @internal
     */
    unsubscribeReverseSearch() {
        this.reverseSearch$$.map(s => s.unsubscribe());
        this.reverseSearch$$ = [];
    }
    /**
     * Stop listening for map pointermove
     * @internal
     */
    unlistenToMapPointerMove() {
        unByKey(this.pointerMoveListener);
        this.pointerMoveListener = undefined;
    }
    /**
     * Trigger reverse search when the mouse is motionless during the defined delay (pointerMoveDelay).
     * @param event OL map browser pointer event
     */
    onMapEvent(event) {
        if (event.dragging || !this.igoSearchPointerSummaryEnabled ||
            !this.hasPointerReverseSearchSource || this.mediaService.isTouchScreen()) {
            this.clearLayer();
            return;
        }
        if (typeof this.lastTimeoutRequest !== 'undefined') { // cancel timeout when the mouse moves
            clearTimeout(this.lastTimeoutRequest);
            this.clearLayer();
            this.unsubscribeReverseSearch();
        }
        this.lonLat = transform(event.coordinate, this.mapProjection, 'EPSG:4326');
        this.lastTimeoutRequest = setTimeout(() => {
            this.onSearchCoordinate();
        }, this.igoSearchPointerSummaryDelay);
    }
    /**
   * Sort the results by display order.
   * @param r1 First result
   * @param r2 Second result
   */
    sortByOrder(r1, r2) {
        return r1.source.displayOrder - r2.source.displayOrder;
    }
    onSearchCoordinate() {
        this.pointerSearchStore.clear();
        const results = this.searchService.reverseSearch(this.lonLat, { params: { geometry: 'false', icon: 'false' } }, true);
        for (const i in results) {
            if (results.length > 0) {
                this.reverseSearch$$.push(results[i].request.subscribe((_results) => {
                    this.onSearch({ research: results[i], results: _results });
                }));
            }
        }
    }
    onSearch(event) {
        const results = event.results;
        const newResults = this.pointerSearchStore.all()
            .filter((result) => result.source !== event.research.source)
            .concat(results);
        this.pointerSearchStore.load(newResults.sort(this.sortByOrder));
    }
    /**
     * Add a feature to the pointer store
     * @param text string
     */
    addPointerOverlay(text) {
        this.clearLayer();
        const geometry = new olgeom.Point(transform(this.lonLat, 'EPSG:4326', this.mapProjection));
        const feature = new OlFeature({ geometry });
        const geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
            featureProjection: this.mapProjection,
            dataProjection: this.mapProjection
        });
        const f = {
            type: FEATURE,
            geometry: geojsonGeom,
            projection: this.mapProjection,
            properties: {
                id: this.searchPointerSummaryFeatureId,
                pointerSummary: text
            },
            meta: {
                id: this.searchPointerSummaryFeatureId
            },
            ol: feature
        };
        this.store.setLayerFeatures([f], FeatureMotion.None);
    }
    /**
     * Clear the pointer store features
     */
    clearLayer() {
        if (this.store) {
            this.store.clearLayer();
        }
    }
}
SearchPointerSummaryDirective.ɵfac = function SearchPointerSummaryDirective_Factory(t) { return new (t || SearchPointerSummaryDirective)(i0.ɵɵdirectiveInject(MapBrowserComponent, 2), i0.ɵɵdirectiveInject(SearchService), i0.ɵɵdirectiveInject(SearchSourceService), i0.ɵɵdirectiveInject(i2$1.MediaService)); };
SearchPointerSummaryDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: SearchPointerSummaryDirective, selectors: [["", "igoSearchPointerSummary", ""]], inputs: { igoSearchPointerSummaryDelay: "igoSearchPointerSummaryDelay", igoSearchPointerSummaryEnabled: "igoSearchPointerSummaryEnabled" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SearchPointerSummaryDirective, [{
        type: Directive,
        args: [{
                selector: '[igoSearchPointerSummary]'
            }]
    }], function () { return [{ type: MapBrowserComponent, decorators: [{
                type: Self
            }] }, { type: SearchService }, { type: SearchSourceService }, { type: i2$1.MediaService }]; }, { igoSearchPointerSummaryDelay: [{
            type: Input
        }], igoSearchPointerSummaryEnabled: [{
            type: Input
        }] }); })();
/**
 * Create a default style for the pointer position and it's label summary.
 * @param feature OlFeature
 * @returns OL style function
 */
function pointerPositionSummaryMarker(feature, resolution) {
    return new olstyle.Style({
        image: new olstyle.Icon({
            src: './assets/igo2/geo/icons/cross_black_18px.svg',
            imgSize: [18, 18], // for ie
        }),
        text: new olstyle.Text({
            text: feature.get('pointerSummary'),
            textAlign: 'left',
            textBaseline: 'bottom',
            font: '12px Calibri,sans-serif',
            fill: new olstyle.Fill({ color: '#000' }),
            backgroundFill: new olstyle.Fill({ color: 'rgba(255, 255, 255, 0.5)' }),
            backgroundStroke: new olstyle.Stroke({ color: 'rgba(200, 200, 200, 0.75)', width: 2 }),
            stroke: new olstyle.Stroke({ color: '#fff', width: 3 }),
            overflow: true,
            offsetX: 10,
            offsetY: -10,
            padding: [2.5, 2.5, 2.5, 2.5]
        })
    });
}

class IgoSearchModule {
    static forRoot() {
        return {
            ngModule: IgoSearchModule,
            providers: [
                SearchService,
                provideSearchSourceService(),
                provideDefaultIChercheSearchResultFormatter(),
                provideDefaultCoordinatesSearchResultFormatter(),
                provideILayerSearchResultFormatter()
            ]
        };
    }
}
IgoSearchModule.ɵfac = function IgoSearchModule_Factory(t) { return new (t || IgoSearchModule)(); };
IgoSearchModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoSearchModule });
IgoSearchModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            IgoSearchBarModule,
            IgoSearchSelectorModule,
            IgoSearchResultsModule,
            IgoSearchSettingsModule
        ], IgoSearchBarModule,
        IgoSearchSelectorModule,
        IgoSearchResultsModule,
        IgoSearchSettingsModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoSearchModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    IgoSearchBarModule,
                    IgoSearchSelectorModule,
                    IgoSearchResultsModule,
                    IgoSearchSettingsModule
                ],
                exports: [
                    IgoSearchBarModule,
                    IgoSearchSelectorModule,
                    IgoSearchResultsModule,
                    IgoSearchSettingsModule,
                    SearchPointerSummaryDirective
                ],
                declarations: [SearchPointerSummaryDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoSearchModule, { declarations: [SearchPointerSummaryDirective], imports: [CommonModule,
        IgoSearchBarModule,
        IgoSearchSelectorModule,
        IgoSearchResultsModule,
        IgoSearchSettingsModule], exports: [IgoSearchBarModule,
        IgoSearchSelectorModule,
        IgoSearchResultsModule,
        IgoSearchSettingsModule,
        SearchPointerSummaryDirective] }); })();

function ToastComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r3 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 7);
    i0.ɵɵlistener("click", function ToastComponent_button_5_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r3); const ctx_r2 = i0.ɵɵnextContext(); return ctx_r2.zoomToFeatureExtent(); });
    i0.ɵɵelement(1, "mat-icon", 8);
    i0.ɵɵelementEnd();
} }
const _c0 = function () { return ["collapsed", "initial"]; };
class ToastComponent {
    constructor() {
        this.format = new OlGeoJSON();
        this.opened = new EventEmitter();
    }
    get expanded() {
        return this._expanded;
    }
    set expanded(value) {
        this.state = value ? 'expanded' : 'collapsed';
        this._expanded = value;
    }
    get map() {
        return this._map;
    }
    set map(value) {
        this._map = value;
    }
    get feature() {
        return this._feature;
    }
    set feature(value) {
        this._feature = value;
    }
    /**
     * @internal
     */
    get title() { return getEntityTitle(this.feature); }
    toggle() {
        this.expanded = !this.expanded;
        this.opened.emit(this.expanded);
    }
    zoomToFeatureExtent() {
        if (this.feature.geometry) {
            const olFeature = this.format.readFeature(this.feature, {
                dataProjection: this.feature.projection,
                featureProjection: this.map.projection
            });
            moveToOlFeatures(this.map, [olFeature], FeatureMotion.Zoom);
        }
    }
    swipe(action) {
        if (action === ToastComponent.SWIPE_ACTION.UP) {
            if (!this.expanded) {
                this.toggle();
            }
        }
        else if (action === ToastComponent.SWIPE_ACTION.DOWN) {
            if (this.expanded) {
                this.toggle();
            }
        }
    }
}
ToastComponent.SWIPE_ACTION = {
    UP: 'swipeup',
    DOWN: 'swipedown'
};
ToastComponent.ɵfac = function ToastComponent_Factory(t) { return new (t || ToastComponent)(); };
ToastComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ToastComponent, selectors: [["igo-toast"]], inputs: { expanded: "expanded", map: "map", feature: "feature" }, outputs: { opened: "opened" }, decls: 7, vars: 6, consts: [["collapsedMobile", "51px", "expandedMobile", "300px", 3, "state", "swipeup", "swipedown"], ["flex", ""], [3, "title"], ["mat-icon-button", "", "panelLeftButton", "", 3, "click"], [3, "svgIcon"], ["mat-icon-button", "", "panelRightButton", "", "class", "igo-icon-button", 3, "click", 4, "ngIf"], [3, "feature"], ["mat-icon-button", "", "panelRightButton", "", 1, "igo-icon-button", 3, "click"], ["svgIcon", "zoom-in"]], template: function ToastComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "igo-flexible", 0, 1);
        i0.ɵɵlistener("swipeup", function ToastComponent_Template_igo_flexible_swipeup_0_listener($event) { return ctx.swipe($event.type); })("swipedown", function ToastComponent_Template_igo_flexible_swipedown_0_listener($event) { return ctx.swipe($event.type); });
        i0.ɵɵelementStart(2, "igo-panel", 2);
        i0.ɵɵelementStart(3, "button", 3);
        i0.ɵɵlistener("click", function ToastComponent_Template_button_click_3_listener() { return ctx.toggle(); });
        i0.ɵɵelement(4, "mat-icon", 4);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(5, ToastComponent_button_5_Template, 2, 0, "button", 5);
        i0.ɵɵelement(6, "igo-feature-details", 6);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = i0.ɵɵreference(1);
        i0.ɵɵproperty("state", ctx.state);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("title", ctx.title);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("svgIcon", i0.ɵɵpureFunction0(5, _c0).indexOf(_r0.state) >= 0 ? "arrow_upward" : "arrow_downward");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.feature.geometry);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("feature", ctx.feature);
    } }, directives: [i6.FlexibleComponent, i6.PanelComponent, i2.MatButton, i4.MatIcon, i1$1.NgIf, FeatureDetailsComponent], styles: ["[_nghost-%COMP%]{position:absolute;bottom:0px;width:100%;max-height:calc(100% - 50px);background-color:#fff}igo-feature-details[_ngcontent-%COMP%]     table{width:100%}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ToastComponent, [{
        type: Component,
        args: [{
                selector: 'igo-toast',
                templateUrl: './toast.component.html',
                styleUrls: ['./toast.component.scss']
            }]
    }], function () { return []; }, { expanded: [{
            type: Input
        }], map: [{
            type: Input
        }], feature: [{
            type: Input
        }], opened: [{
            type: Output
        }] }); })();

class IgoToastModule {
    static forRoot() {
        return {
            ngModule: IgoToastModule
        };
    }
}
IgoToastModule.ɵfac = function IgoToastModule_Factory(t) { return new (t || IgoToastModule)(); };
IgoToastModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoToastModule });
IgoToastModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatIconModule,
            MatButtonModule,
            IgoPanelModule,
            IgoFlexibleModule,
            IgoFeatureModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoToastModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatIconModule,
                    MatButtonModule,
                    IgoPanelModule,
                    IgoFlexibleModule,
                    IgoFeatureModule
                ],
                exports: [ToastComponent],
                declarations: [ToastComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoToastModule, { declarations: [ToastComponent], imports: [CommonModule,
        MatIconModule,
        MatButtonModule,
        IgoPanelModule,
        IgoFlexibleModule,
        IgoFeatureModule], exports: [ToastComponent] }); })();

class OgcFilterComponent {
    constructor(cdRef) {
        this.cdRef = cdRef;
        /**
         * Event emitted on complete
         */
        this.complete = new EventEmitter();
        /**
         * Event emitted on cancel
         */
        this.cancel = new EventEmitter();
    }
    /**
     * Implemented as part of OnUpdateInputs
     */
    onUpdateInputs() {
        this.cdRef.detectChanges();
    }
    /**
     * On close, emit the cancel event
     */
    onClose() {
        this.cancel.emit();
    }
}
OgcFilterComponent.ɵfac = function OgcFilterComponent_Factory(t) { return new (t || OgcFilterComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
OgcFilterComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OgcFilterComponent, selectors: [["igo-ogc-filter"]], inputs: { layer: "layer", map: "map" }, outputs: { complete: "complete", cancel: "cancel" }, decls: 1, vars: 3, consts: [["igoListItem", "", 3, "layer", "header", "map"]], template: function OgcFilterComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelement(0, "igo-ogc-filterable-item", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("layer", ctx.layer)("header", false)("map", ctx.map);
    } }, directives: [OgcFilterableItemComponent], styles: [""], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OgcFilterComponent, [{
        type: Component,
        args: [{
                selector: 'igo-ogc-filter',
                templateUrl: './ogc-filter.component.html',
                styleUrls: ['./ogc-filter.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }]; }, { layer: [{
            type: Input
        }], map: [{
            type: Input
        }], complete: [{
            type: Output
        }], cancel: [{
            type: Output
        }] }); })();

const OgcFilterWidget = new InjectionToken('OgcFilterWidget');
function ogcFilterWidgetFactory(widgetService) {
    return widgetService.create(OgcFilterComponent);
}
function provideOgcFilterWidget() {
    return {
        provide: OgcFilterWidget,
        useFactory: ogcFilterWidgetFactory,
        deps: [WidgetService]
    };
}

/**
 * @ignore
 */
class IgoOgcFilterModule {
}
IgoOgcFilterModule.ɵfac = function IgoOgcFilterModule_Factory(t) { return new (t || IgoOgcFilterModule)(); };
IgoOgcFilterModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoOgcFilterModule });
IgoOgcFilterModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatButtonModule,
            IgoLanguageModule,
            IgoFilterModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoOgcFilterModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatButtonModule,
                    IgoLanguageModule,
                    IgoFilterModule
                ],
                exports: [OgcFilterComponent],
                declarations: [OgcFilterComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoOgcFilterModule, { declarations: [OgcFilterComponent], imports: [CommonModule,
        MatButtonModule,
        IgoLanguageModule,
        IgoFilterModule], exports: [OgcFilterComponent] }); })();

class WfsWorkspace extends Workspace {
    constructor(options) {
        super(options);
        this.options = options;
        this.inResolutionRange$ = new BehaviorSubject(true);
        this.map.viewController.resolution$.subscribe((mapResolution) => {
            if (mapResolution > this.layer.minResolution && mapResolution < this.layer.maxResolution) {
                this.inResolutionRange$.next(true);
            }
            else {
                this.inResolutionRange$.next(false);
            }
        });
    }
    get layer() { return this.options.layer; }
    get map() { return this.options.map; }
    getLayerWksOptionTabQuery() {
        var _a;
        if (((_a = this.layer.options.workspace.queryOptions) === null || _a === void 0 ? void 0 : _a.tabQuery) !== undefined) {
            return this.layer.options.workspace.queryOptions.tabQuery;
        }
        return true;
    }
    getLayerWksOptionMapQuery() {
        var _a;
        if (((_a = this.layer.options.workspace.queryOptions) === null || _a === void 0 ? void 0 : _a.mapQueryOnOpenTab) !== undefined) {
            return this.layer.options.workspace.queryOptions.mapQueryOnOpenTab;
        }
        return true;
    }
    getInResolutionRange() {
        return this.inResolutionRange$.value;
    }
}

class WfsWorkspaceService {
    constructor(storageService) {
        this.storageService = storageService;
        this.ws$ = new BehaviorSubject(undefined);
    }
    get zoomAuto() {
        return this.storageService.get('zoomAuto');
    }
    createWorkspace(layer, map) {
        var _a;
        if (((_a = layer.options.workspace) === null || _a === void 0 ? void 0 : _a.enabled) === false || layer.dataSource.options.edition) {
            return;
        }
        layer.options.workspace = Object.assign({}, layer.options.workspace, {
            srcId: layer.id,
            workspaceId: layer.id,
            enabled: true
        });
        const wks = new WfsWorkspace({
            id: layer.id,
            title: layer.title,
            layer,
            map,
            entityStore: this.createFeatureStore(layer, map),
            actionStore: new ActionStore([]),
            meta: {
                tableTemplate: undefined
            }
        });
        this.createTableTemplate(wks, layer);
        return wks;
    }
    createFeatureStore(layer, map) {
        const store = new FeatureStore([], { map });
        store.bindLayer(layer);
        const loadingStrategy = new FeatureStoreLoadingLayerStrategy({});
        const inMapExtentStrategy = new FeatureStoreInMapExtentStrategy({});
        const inMapResolutionStrategy = new FeatureStoreInMapResolutionStrategy({});
        const selectedRecordStrategy = new EntityStoreFilterSelectionStrategy({});
        const selectionStrategy = new FeatureStoreSelectionStrategy({
            layer: new VectorLayer({
                zIndex: 300,
                source: new FeatureDataSource(),
                style: undefined,
                showInLayerList: false,
                exportable: false,
                browsable: false
            }),
            map,
            hitTolerance: 15,
            motion: this.zoomAuto ? FeatureMotion.Default : FeatureMotion.None,
            many: true,
            dragBox: true
        });
        store.addStrategy(loadingStrategy, true);
        store.addStrategy(inMapExtentStrategy, true);
        store.addStrategy(inMapResolutionStrategy, true);
        store.addStrategy(selectionStrategy, true);
        store.addStrategy(selectedRecordStrategy, false);
        store.addStrategy(this.createFilterInMapExtentOrResolutionStrategy(), true);
        return store;
    }
    createTableTemplate(workspace, layer) {
        const fields = layer.dataSource.options.sourceFields || [];
        const relations = layer.dataSource.options.relations || [];
        if (fields.length === 0) {
            workspace.entityStore.entities$.pipe(skipWhile(val => val.length === 0), take(1)).subscribe(entities => {
                const ol = entities[0].ol;
                const columnsFromFeatures = ol.getKeys()
                    .filter(col => !col.startsWith('_') &&
                    col !== 'geometry' &&
                    col !== ol.getGeometryName() &&
                    !col.match(/boundedby/gi))
                    .map(key => {
                    return {
                        name: `properties.${key}`,
                        title: key,
                        renderer: EntityTableColumnRenderer.UnsanitizedHTML
                    };
                });
                workspace.meta.tableTemplate = {
                    selection: true,
                    sort: true,
                    columns: columnsFromFeatures
                };
            });
            return;
        }
        const columns = fields.map((field) => {
            return {
                name: `properties.${field.name}`,
                title: field.alias ? field.alias : field.name,
                renderer: EntityTableColumnRenderer.UnsanitizedHTML,
                tooltip: field.tooltip
            };
        });
        const relationsColumn = relations.map((relation) => {
            return {
                name: `properties.${relation.name}`,
                title: relation.alias ? relation.alias : relation.name,
                renderer: EntityTableColumnRenderer.Icon,
                icon: relation.icon,
                parent: relation.parent,
                type: 'relation',
                tooltip: relation.tooltip,
                onClick: () => {
                    this.ws$.next(relation.title);
                },
                cellClassFunc: () => {
                    return { 'class_icon': true };
                }
            };
        });
        columns.push(...relationsColumn);
        workspace.meta.tableTemplate = {
            selection: true,
            sort: true,
            columns
        };
    }
    createFilterInMapExtentOrResolutionStrategy() {
        const filterClauseFunc = (record) => {
            return record.state.inMapExtent === true && record.state.inMapResolution === true;
        };
        return new EntityStoreFilterCustomFuncStrategy({ filterClauseFunc });
    }
}
WfsWorkspaceService.ɵfac = function WfsWorkspaceService_Factory(t) { return new (t || WfsWorkspaceService)(i0.ɵɵinject(i2$1.StorageService)); };
WfsWorkspaceService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: WfsWorkspaceService, factory: WfsWorkspaceService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(WfsWorkspaceService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i2$1.StorageService }]; }, null); })();

class WmsWorkspaceService {
    constructor(layerService, storageService) {
        this.layerService = layerService;
        this.storageService = storageService;
        this.ws$ = new BehaviorSubject(undefined);
    }
    get zoomAuto() {
        return this.storageService.get('zoomAuto');
    }
    createWorkspace(layer, map) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (!layer.options.workspace ||
            map.layers.find(lay => lay.id === layer.id + '.WfsWorkspaceTableDest') ||
            layer.dataSource.options.edition) {
            return;
        }
        const dataSource = layer.dataSource;
        const wmsLinkId = layer.id + '.WmsWorkspaceTableSrc';
        const wfsLinkId = layer.id + '.WfsWorkspaceTableDest';
        if (!layer.options.linkedLayers) {
            layer.options.linkedLayers = { linkId: wmsLinkId, links: [] };
        }
        const linkProperties = {
            bidirectionnal: true,
            syncedDelete: true,
            linkedIds: [wfsLinkId],
            properties: [
                LinkedProperties.ZINDEX,
                LinkedProperties.VISIBLE
            ]
        };
        if (!((_a = layer.options.workspace) === null || _a === void 0 ? void 0 : _a.minResolution)) {
            linkProperties.properties.push(LinkedProperties.MINRESOLUTION);
        }
        let hasOgcFilters = false;
        if ((_b = dataSource.options.ogcFilters) === null || _b === void 0 ? void 0 : _b.enabled) {
            linkProperties.properties.push(LinkedProperties.OGCFILTERS);
            hasOgcFilters = true;
        }
        if (!((_c = layer.options.workspace) === null || _c === void 0 ? void 0 : _c.maxResolution)) {
            linkProperties.properties.push(LinkedProperties.MAXRESOLUTION);
        }
        let clonedLinks = [];
        if (layer.options.linkedLayers.links) {
            clonedLinks = JSON.parse(JSON.stringify(layer.options.linkedLayers.links));
        }
        clonedLinks.push(linkProperties);
        layer.options.linkedLayers.linkId = layer.options.linkedLayers.linkId ? layer.options.linkedLayers.linkId : wmsLinkId,
            layer.options.linkedLayers.links = clonedLinks;
        let wks;
        let wksLayerOption = {
            srcId: layer.id,
            workspaceId: undefined,
            enabled: false,
            queryOptions: {
                mapQueryOnOpenTab: (_e = (_d = layer.options.workspace) === null || _d === void 0 ? void 0 : _d.queryOptions) === null || _e === void 0 ? void 0 : _e.mapQueryOnOpenTab,
                tabQuery: (_g = (_f = layer.options.workspace) === null || _f === void 0 ? void 0 : _f.queryOptions) === null || _g === void 0 ? void 0 : _g.tabQuery
            },
            pageSize: (_h = layer.options.workspace) === null || _h === void 0 ? void 0 : _h.pageSize,
            pageSizeOptions: (_j = layer.options.workspace) === null || _j === void 0 ? void 0 : _j.pageSizeOptions
        };
        this.layerService
            .createAsyncLayer({
            isIgoInternalLayer: true,
            id: wfsLinkId,
            linkedLayers: {
                linkId: wfsLinkId
            },
            workspace: wksLayerOption,
            showInLayerList: false,
            opacity: 0,
            title: layer.title,
            minResolution: ((_k = layer.options.workspace) === null || _k === void 0 ? void 0 : _k.minResolution) || layer.minResolution || 0,
            maxResolution: ((_l = layer.options.workspace) === null || _l === void 0 ? void 0 : _l.maxResolution) || layer.maxResolution || Infinity,
            sourceOptions: {
                download: dataSource.options.download,
                type: 'wfs',
                url: dataSource.options.urlWfs || dataSource.options.url,
                queryable: true,
                relations: dataSource.options.relations,
                queryTitle: dataSource.options.queryTitle,
                queryFormatAsWms: dataSource.options.queryFormatAsWms,
                params: dataSource.options.paramsWFS,
                ogcFilters: Object.assign({}, dataSource.ogcFilters$.value, { enabled: hasOgcFilters }),
                sourceFields: dataSource.options.sourceFields || undefined
            }
        })
            .subscribe((workspaceLayer) => {
            var _a, _b, _c, _d, _e, _f, _g;
            map.addLayer(workspaceLayer);
            layer.ol.setProperties({ linkedLayers: { linkId: layer.options.linkedLayers.linkId, links: clonedLinks } }, false);
            workspaceLayer.dataSource.ol.refresh();
            if (!((_a = layer.options.workspace) === null || _a === void 0 ? void 0 : _a.enabled)) {
                return;
            }
            wks = new WfsWorkspace({
                id: layer.id,
                title: layer.title,
                layer: workspaceLayer,
                map,
                entityStore: this.createFeatureStore(workspaceLayer, map),
                actionStore: new ActionStore([]),
                meta: {
                    tableTemplate: undefined
                }
            });
            this.createTableTemplate(wks, workspaceLayer);
            workspaceLayer.options.workspace.workspaceId = workspaceLayer.id;
            layer.options.workspace = Object.assign({}, layer.options.workspace, {
                enabled: true,
                srcId: layer.id,
                workspaceId: workspaceLayer.id,
                queryOptions: {
                    mapQueryOnOpenTab: (_c = (_b = layer.options.workspace) === null || _b === void 0 ? void 0 : _b.queryOptions) === null || _c === void 0 ? void 0 : _c.mapQueryOnOpenTab,
                    tabQuery: (_e = (_d = layer.options.workspace) === null || _d === void 0 ? void 0 : _d.queryOptions) === null || _e === void 0 ? void 0 : _e.tabQuery
                },
                pageSize: (_f = layer.options.workspace) === null || _f === void 0 ? void 0 : _f.pageSize,
                pageSizeOptions: (_g = layer.options.workspace) === null || _g === void 0 ? void 0 : _g.pageSizeOptions
            });
            delete dataSource.options.download;
            return wks;
        });
        return wks;
    }
    createFeatureStore(layer, map) {
        const store = new FeatureStore([], { map });
        store.bindLayer(layer);
        const loadingStrategy = new FeatureStoreLoadingLayerStrategy({});
        const inMapExtentStrategy = new FeatureStoreInMapExtentStrategy({});
        const inMapResolutionStrategy = new FeatureStoreInMapResolutionStrategy({});
        const selectedRecordStrategy = new EntityStoreFilterSelectionStrategy({});
        const selectionStrategy = new FeatureStoreSelectionStrategy({
            layer: new VectorLayer({
                zIndex: 300,
                source: new FeatureDataSource(),
                style: undefined,
                showInLayerList: false,
                exportable: false,
                browsable: false
            }),
            map,
            hitTolerance: 15,
            motion: this.zoomAuto ? FeatureMotion.Default : FeatureMotion.None,
            many: true,
            dragBox: true
        });
        store.addStrategy(loadingStrategy, true);
        store.addStrategy(inMapExtentStrategy, true);
        store.addStrategy(inMapResolutionStrategy, true);
        store.addStrategy(selectionStrategy, true);
        store.addStrategy(selectedRecordStrategy, false);
        store.addStrategy(this.createFilterInMapExtentOrResolutionStrategy(), true);
        return store;
    }
    createTableTemplate(workspace, layer) {
        const fields = layer.dataSource.options.sourceFields || [];
        const relations = layer.dataSource.options.relations || [];
        if (fields.length === 0) {
            workspace.entityStore.entities$.pipe(skipWhile(val => val.length === 0), take(1)).subscribe(entities => {
                const ol = entities[0].ol;
                const columnsFromFeatures = ol.getKeys()
                    .filter(col => !col.startsWith('_') &&
                    col !== 'geometry' &&
                    col !== ol.getGeometryName() &&
                    !col.match(/boundedby/gi))
                    .map(key => {
                    return {
                        name: `properties.${key}`,
                        title: key,
                        renderer: EntityTableColumnRenderer.UnsanitizedHTML
                    };
                });
                workspace.meta.tableTemplate = {
                    selection: true,
                    sort: true,
                    columns: columnsFromFeatures
                };
            });
            return;
        }
        const columns = fields.map((field) => {
            return {
                name: `properties.${field.name}`,
                title: field.alias ? field.alias : field.name,
                renderer: EntityTableColumnRenderer.UnsanitizedHTML,
                tooltip: field.tooltip
            };
        });
        const relationsColumn = relations.map((relation) => {
            return {
                name: `properties.${relation.name}`,
                title: relation.alias ? relation.alias : relation.name,
                renderer: EntityTableColumnRenderer.Icon,
                icon: relation.icon,
                parent: relation.parent,
                type: 'relation',
                tooltip: relation.tooltip,
                onClick: () => {
                    this.ws$.next(relation.title);
                },
                cellClassFunc: () => {
                    return { 'class_icon': true };
                }
            };
        });
        columns.push(...relationsColumn);
        workspace.meta.tableTemplate = {
            selection: true,
            sort: true,
            columns
        };
    }
    createFilterInMapExtentOrResolutionStrategy() {
        const filterClauseFunc = (record) => {
            return record.state.inMapExtent === true && record.state.inMapResolution === true;
        };
        return new EntityStoreFilterCustomFuncStrategy({ filterClauseFunc });
    }
}
WmsWorkspaceService.ɵfac = function WmsWorkspaceService_Factory(t) { return new (t || WmsWorkspaceService)(i0.ɵɵinject(LayerService), i0.ɵɵinject(i2$1.StorageService)); };
WmsWorkspaceService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: WmsWorkspaceService, factory: WmsWorkspaceService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(WmsWorkspaceService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: LayerService }, { type: i2$1.StorageService }]; }, null); })();

class ConfirmationPopupComponent {
    constructor(dialogRef, languageService, data) {
        this.dialogRef = dialogRef;
        this.languageService = languageService;
        this.data = data;
    }
    cancelAction() {
        this.data.cancel = true;
        this.dialogRef.close(this.data.cancel);
    }
    confirmedAction() {
        this.data.cancel = false;
        this.dialogRef.close(this.data.cancel);
    }
}
ConfirmationPopupComponent.ɵfac = function ConfirmationPopupComponent_Factory(t) { return new (t || ConfirmationPopupComponent)(i0.ɵɵdirectiveInject(i1.MatDialogRef), i0.ɵɵdirectiveInject(i2$1.LanguageService), i0.ɵɵdirectiveInject(MAT_DIALOG_DATA)); };
ConfirmationPopupComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ConfirmationPopupComponent, selectors: [["igo-confirmation-popup-component"]], decls: 8, vars: 2, consts: [["mat-dialog-content", ""], [1, "mat-typography"], ["mat-dialog-actions", ""], ["mat-raised-button", "", "color", "primary", 3, "click"], ["mat-raised-button", "", 3, "click"]], template: function ConfirmationPopupComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelementStart(1, "p", 1);
        i0.ɵɵtext(2);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(3, "div", 2);
        i0.ɵɵelementStart(4, "button", 3);
        i0.ɵɵlistener("click", function ConfirmationPopupComponent_Template_button_click_4_listener() { return ctx.confirmedAction(); });
        i0.ɵɵtext(5, "Ok ");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(6, "button", 4);
        i0.ɵɵlistener("click", function ConfirmationPopupComponent_Template_button_click_6_listener() { return ctx.cancelAction(); });
        i0.ɵɵtext(7);
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵtextInterpolate(ctx.data.type === "add" ? ctx.languageService.translate.instant("igo.geo.workspace.addConfirmation") : ctx.languageService.translate.instant("igo.geo.workspace.deleteConfirmation"));
        i0.ɵɵadvance(5);
        i0.ɵɵtextInterpolate1("", ctx.languageService.translate.instant("igo.geo.workspace.cancel"), " ");
    } }, directives: [i1.MatDialogContent, i1.MatDialogActions, i2.MatButton], styles: ["div.mat-dialog-actions[_ngcontent-%COMP%]{justify-content:center}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ConfirmationPopupComponent, [{
        type: Component,
        args: [{
                selector: 'igo-confirmation-popup-component',
                templateUrl: './confirmation-popup.component.html',
                styleUrls: ['./confirmation-popup.component.scss']
            }]
    }], function () { return [{ type: i1.MatDialogRef }, { type: i2$1.LanguageService }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_DIALOG_DATA]
            }] }]; }, null); })();

class EditionWorkspace extends Workspace {
    constructor(options, editionWorkspaceService, dialog, configService) {
        super(options);
        this.options = options;
        this.editionWorkspaceService = editionWorkspaceService;
        this.dialog = dialog;
        this.configService = configService;
        this.inResolutionRange$ = new BehaviorSubject(true);
        this.olDrawingLayerSource = new OlVectorSource();
        this.geometryType = GeometryType; // Reference to the GeometryType enum
        this.modifyStyle = new olstyle.Style({
            stroke: new olstyle.Stroke({
                color: 'rgba(255,255,255,1)',
                width: 1
            }),
            fill: new olstyle.Fill({
                color: 'rgba(0,161,222,1)'
            }),
            image: new olstyle.Circle({
                radius: 7,
                stroke: new olstyle.Stroke({
                    color: 'rgba(255,255,255,1)',
                    width: 1
                }),
                fill: new olstyle.Fill({
                    color: 'rgba(0,161,222,1)'
                })
            })
        });
        this.filterClauseFunc = (record) => {
            return record.state.newFeature === true;
        };
        this.map.viewController.resolution$.subscribe((mapResolution) => {
            if (mapResolution > this.layer.minResolution && mapResolution < this.layer.maxResolution) {
                this.inResolutionRange$.next(true);
            }
            else {
                this.inResolutionRange$.next(false);
            }
        });
        this.drawControl = this.createDrawControl();
        this.drawControl.setGeometryType(this.geometryType.Point);
        this.map.removeLayer(this.olDrawingLayer);
        this.olDrawingLayer = new VectorLayer({
            id: 'igo-draw-layer',
            title: 'edition',
            zIndex: 300,
            source: new FeatureDataSource(),
            showInLayerList: false,
            exportable: false,
            browsable: false,
            workspace: {
                enabled: false
            },
        });
    }
    get layer() { return this.options.layer; }
    get map() { return this.options.map; }
    getInResolutionRange() {
        return this.inResolutionRange$.value;
    }
    deleteFeature(feature, workspace) {
        setTimeout(() => {
            const dialogRef = this.dialog.open(ConfirmationPopupComponent, {
                disableClose: false,
                data: { type: 'delete' }
            });
            dialogRef.afterClosed().subscribe(result => {
                if (result === false) {
                    const baseUrl = workspace.layer.dataSource.options.edition.baseUrl;
                    const deleteUrl = workspace.layer.dataSource.options.edition.deleteUrl;
                    let id;
                    let url;
                    if (baseUrl) {
                        url = this.configService.getConfig('edition.url') + baseUrl + '?' + deleteUrl;
                    }
                    else {
                        url = this.configService.getConfig('edition.url') + deleteUrl;
                    }
                    for (const column of workspace.meta.tableTemplate.columns) {
                        for (const property in feature.properties) {
                            let columnName = column.name;
                            if (columnName.includes('properties.')) {
                                columnName = columnName.split('.')[1];
                            }
                            if (columnName === property && column.primary === true) {
                                id = feature.properties[property];
                            }
                        }
                    }
                    if (url) {
                        url += id;
                        this.editionWorkspaceService.deleteFeature(workspace, url);
                    }
                }
            });
        }, 250);
    }
    editFeature(feature, workspace) {
        feature.edition = true;
        let id;
        let find = false;
        const editionOpt = workspace.layer.dataSource.options.edition;
        for (const column of workspace.meta.tableTemplate.columns) {
            // Update domain list
            if (column.type === 'list' || column.type === 'autocomplete') {
                this.editionWorkspaceService.getDomainValues(column.relation.table).subscribe(result => {
                    column.domainValues = result;
                });
            }
            if (find === false) {
                for (const property in feature.properties) {
                    let columnName = column.name;
                    if (columnName.includes('properties.')) {
                        columnName = columnName.split('.')[1];
                    }
                    if (columnName === property && column.primary === true) {
                        id = feature.properties[property];
                        find = true;
                        break;
                    }
                }
            }
        }
        if (id) {
            feature.original_properties = JSON.parse(JSON.stringify(feature.properties));
            feature.original_geometry = feature.geometry;
            feature.idkey = id;
            this.addFeatureToStore(feature, workspace);
        }
        else {
            // Only for edition with it's own geometry
            if (!feature.newFeature && editionOpt.geomType) {
                feature.newFeature = true;
                this.editionWorkspaceService.adding$.next(true);
                workspace.entityStore.state.updateAll({ newFeature: false });
                workspace.entityStore.stateView.filter(this.filterClauseFunc);
                if (editionOpt.addWithDraw) {
                    const geometryType = editionOpt.geomType;
                    this.onGeometryTypeChange(geometryType, feature, workspace);
                }
                else {
                    workspace.entityStore.insert(feature);
                    workspace.entityStore.state.update(feature, { newFeature: true }, true);
                }
            }
        }
    }
    /**
     * Create a Draw Control
     * @param fillColor the fill color
     * @param strokeColor the stroke color
     * @param strokeWidth the stroke width
     * @returns a Draw Control
     */
    createDrawControl(fillColor, strokeColor, strokeWidth) {
        const drawControl = new DrawControl({
            geometryType: undefined,
            drawingLayerSource: this.olDrawingLayerSource,
            drawingLayerStyle: new olstyle.Style({}),
            interactionStyle: createInteractionStyle(fillColor, strokeColor, strokeWidth),
        });
        return drawControl;
    }
    /**
     * Called when the user selects a new geometry type
     * @param geometryType the geometry type selected by the user
     */
    onGeometryTypeChange(geometryType, feature, workspace) {
        this.drawControl.setGeometryType(geometryType);
        this.toggleDrawControl(feature, workspace);
    }
    /**
     * Activate the correct control
     */
    toggleDrawControl(feature, workspace) {
        this.deactivateDrawControl();
        this.activateDrawControl(feature, workspace);
    }
    /**
     * Deactivate the active draw control
     */
    deactivateDrawControl() {
        if (!this.drawControl) {
            return;
        }
        if (this.drawEnd$$) {
            this.drawEnd$$.unsubscribe();
        }
        this.drawControl.setOlMap(undefined);
    }
    /**
     * Activate a given control
     */
    activateDrawControl(feature, workspace) {
        this.drawEnd$$ = this.drawControl.end$.subscribe((olGeometry) => {
            this.addFeatureToStore(feature, workspace, olGeometry);
        });
        this.drawControl.setOlMap(this.map.ol, true);
    }
    /**
     * Add a feature to layer. The loading strategy of the layer
     * will trigger and add the feature to the workspace store.
     * @internal
     */
    addFeatureToStore(feature, workspace, olGeometry) {
        const projection = this.map.ol.getView().getProjection();
        let geometry = feature.geometry;
        // If an olGeometry is passed, it means that it is a new feature
        if (olGeometry) {
            workspace.entityStore.insert(feature);
            workspace.entityStore.state.update(feature, { newFeature: true }, true);
            geometry = new OlGeoJSON().writeGeometryObject(olGeometry, {
                featureProjection: projection,
                dataProjection: 'EPSG:4326'
            });
            feature.geometry = geometry;
        }
        feature.projection = 'EPSG:4326';
        const featureOl = featureToOl(feature, projection.getCode());
        this.olDrawingLayer.dataSource.ol.clear();
        this.olDrawingLayer.dataSource.ol.addFeature(featureOl);
        this.map.addLayer(this.olDrawingLayer);
        this.deactivateDrawControl();
        this.createModifyInteraction(featureOl, feature, workspace);
    }
    /**
     * Delete drawings layer and source from the map AND feature from the entity store.
     * Layer refresh will automatically add the new feature into the store.
     */
    deleteDrawings() {
        this.map.removeLayer(this.olDrawingLayer);
        this.olDrawingLayerSource.clear();
        this.map.ol.removeInteraction(this.modify);
    }
    /**
     * Create a modify interaction to allow a geometry change one feature at the time (drag and drop)
     */
    createModifyInteraction(olFeature, feature, workspace) {
        this.map.ol.removeInteraction(this.modify);
        const olCollection = new Collection([olFeature], { unique: true });
        this.modify = new OlModify({
            features: olCollection
        });
        this.map.ol.addInteraction(this.modify);
        olCollection.forEach(feature => {
            feature.setStyle(this.modifyStyle);
        });
        this.modify.on('modifyend', (event) => {
            var _a;
            const olGeometry = (_a = event.features.getArray()[0]) === null || _a === void 0 ? void 0 : _a.getGeometry();
            if (olGeometry) {
                this.addFeatureToStore(feature, workspace, olGeometry);
            }
        });
    }
}

class EditionWorkspaceService {
    constructor(layerService, storageService, configService, messageService, languageService, http, dialog, authInterceptor) {
        this.layerService = layerService;
        this.storageService = storageService;
        this.configService = configService;
        this.messageService = messageService;
        this.languageService = languageService;
        this.http = http;
        this.dialog = dialog;
        this.authInterceptor = authInterceptor;
        this.ws$ = new BehaviorSubject(undefined);
        this.adding$ = new BehaviorSubject(false);
        this.relationLayers$ = new BehaviorSubject(undefined);
        this.rowsInMapExtentCheckCondition$ = new BehaviorSubject(true);
        this.loading = false;
    }
    get zoomAuto() {
        return this.storageService.get('zoomAuto');
    }
    createWorkspace(layer, map) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        if (((_a = layer.options.workspace) === null || _a === void 0 ? void 0 : _a.enabled) !== true || layer.dataSource.options.edition.enabled !== true) {
            return;
        }
        let wksConfig;
        if (layer.options.workspace) {
            wksConfig = layer.options.workspace;
        }
        else {
            wksConfig = {};
        }
        wksConfig.srcId = layer.id;
        wksConfig.workspaceId = layer.id;
        wksConfig.enabled = true;
        wksConfig.pageSize = (_b = layer.options.workspace) === null || _b === void 0 ? void 0 : _b.pageSize;
        wksConfig.pageSizeOptions = (_c = layer.options.workspace) === null || _c === void 0 ? void 0 : _c.pageSizeOptions;
        const dataSource = layer.dataSource;
        const wmsLinkId = layer.id + '.WmsWorkspaceTableSrc';
        const wfsLinkId = layer.id + '.WfsWorkspaceTableDest';
        if (!layer.options.linkedLayers) {
            layer.options.linkedLayers = { linkId: wmsLinkId, links: [] };
        }
        const linkProperties = {
            bidirectionnal: true,
            syncedDelete: true,
            linkedIds: [wfsLinkId],
            properties: [
                LinkedProperties.ZINDEX,
                LinkedProperties.VISIBLE
            ]
        };
        if (!((_d = layer.options.workspace) === null || _d === void 0 ? void 0 : _d.minResolution)) {
            linkProperties.properties.push(LinkedProperties.MINRESOLUTION);
        }
        let hasOgcFilters = false;
        if ((_e = dataSource.options.ogcFilters) === null || _e === void 0 ? void 0 : _e.enabled) {
            linkProperties.properties.push(LinkedProperties.OGCFILTERS);
            hasOgcFilters = true;
        }
        if (!((_f = layer.options.workspace) === null || _f === void 0 ? void 0 : _f.maxResolution)) {
            linkProperties.properties.push(LinkedProperties.MAXRESOLUTION);
        }
        let clonedLinks = [];
        if (layer.options.linkedLayers.links) {
            clonedLinks = JSON.parse(JSON.stringify(layer.options.linkedLayers.links));
        }
        clonedLinks.push(linkProperties);
        layer.options.linkedLayers.linkId = layer.options.linkedLayers.linkId ? layer.options.linkedLayers.linkId : wmsLinkId,
            layer.options.linkedLayers.links = clonedLinks;
        let wks;
        this.layerService
            .createAsyncLayer({
            id: wfsLinkId,
            linkedLayers: {
                linkId: wfsLinkId
            },
            workspace: {
                srcId: layer.id,
                workspaceId: undefined,
                enabled: false,
                queryOptions: {
                    mapQueryOnOpenTab: (_h = (_g = layer.options.workspace) === null || _g === void 0 ? void 0 : _g.queryOptions) === null || _h === void 0 ? void 0 : _h.mapQueryOnOpenTab,
                    tabQuery: false
                },
                pageSize: (_j = layer.options.workspace) === null || _j === void 0 ? void 0 : _j.pageSize,
                pageSizeOptions: (_k = layer.options.workspace) === null || _k === void 0 ? void 0 : _k.pageSizeOptions
            },
            showInLayerList: false,
            opacity: 0,
            title: layer.title,
            minResolution: ((_l = layer.options.workspace) === null || _l === void 0 ? void 0 : _l.minResolution) || layer.minResolution || 0,
            maxResolution: ((_m = layer.options.workspace) === null || _m === void 0 ? void 0 : _m.maxResolution) || layer.maxResolution || Infinity,
            sourceOptions: {
                download: dataSource.options.download,
                type: 'wfs',
                url: dataSource.options.urlWfs || dataSource.options.url,
                queryable: true,
                relations: dataSource.options.relations,
                queryTitle: dataSource.options.queryTitle,
                params: dataSource.options.paramsWFS,
                ogcFilters: Object.assign({}, dataSource.ogcFilters$.value, { enabled: hasOgcFilters }),
                sourceFields: dataSource.options.sourceFields || undefined,
                edition: dataSource.options.edition
            }
        })
            .subscribe((workspaceLayer) => {
            map.addLayer(workspaceLayer);
            layer.ol.setProperties({ linkedLayers: { linkId: layer.options.linkedLayers.linkId, links: clonedLinks } }, false);
            workspaceLayer.dataSource.ol.refresh();
            wks = new EditionWorkspace({
                id: layer.id,
                title: layer.title,
                layer: workspaceLayer,
                map,
                entityStore: this.createFeatureStore(workspaceLayer, map),
                actionStore: new ActionStore([]),
                meta: {
                    tableTemplate: undefined
                }
            }, this, this.dialog, this.configService);
            this.createTableTemplate(wks, workspaceLayer);
            workspaceLayer.options.workspace.workspaceId = workspaceLayer.id;
            layer.options.workspace = Object.assign({}, layer.options.workspace, {
                wksConfig
            });
            delete dataSource.options.download;
            return wks;
        });
        return wks;
    }
    createFeatureStore(layer, map) {
        const store = new FeatureStore([], { map });
        store.bindLayer(layer);
        const loadingStrategy = new FeatureStoreLoadingLayerStrategy({});
        const inMapExtentStrategy = new FeatureStoreInMapExtentStrategy({});
        const inMapResolutionStrategy = new FeatureStoreInMapResolutionStrategy({});
        const selectedRecordStrategy = new EntityStoreFilterSelectionStrategy({});
        const selectionStrategy = new FeatureStoreSelectionStrategy({
            layer: new VectorLayer({
                zIndex: 300,
                source: new FeatureDataSource(),
                style: undefined,
                showInLayerList: false,
                exportable: false,
                browsable: false
            }),
            map,
            hitTolerance: 15,
            motion: this.zoomAuto ? FeatureMotion.Default : FeatureMotion.None,
            many: true,
            dragBox: true
        });
        store.addStrategy(loadingStrategy, true);
        store.addStrategy(inMapExtentStrategy, true);
        store.addStrategy(inMapResolutionStrategy, true);
        store.addStrategy(selectionStrategy, true);
        store.addStrategy(selectedRecordStrategy, false);
        store.addStrategy(this.createFilterInMapExtentOrResolutionStrategy(), true);
        return store;
    }
    createTableTemplate(workspace, layer) {
        const fields = layer.dataSource.options.sourceFields || [];
        const relations = layer.dataSource.options.relations || [];
        let rendererType = EntityTableColumnRenderer.UnsanitizedHTML;
        let buttons = [];
        let columns = [];
        let relationsColumn = [];
        buttons = [{
                name: 'edition',
                title: undefined,
                renderer: EntityTableColumnRenderer.ButtonGroup,
                primary: false,
                valueAccessor: () => {
                    return [{
                            editMode: false,
                            icon: 'pencil',
                            color: 'primary',
                            click: (feature) => { workspace.editFeature(feature, workspace); }
                        },
                        {
                            editMode: false,
                            icon: 'delete',
                            color: 'warn',
                            click: (feature) => { workspace.deleteFeature(feature, workspace); }
                        },
                        {
                            editMode: true,
                            icon: 'check',
                            color: 'primary',
                            disabled: this.loading,
                            click: (feature) => { this.saveFeature(feature, workspace); }
                        },
                        {
                            editMode: true,
                            icon: 'alpha-x',
                            color: 'primary',
                            disabled: this.loading,
                            click: (feature) => { this.cancelEdit(workspace, feature); }
                        }];
                }
            }];
        if (fields.length === 0) {
            workspace.entityStore.entities$.pipe(skipWhile(val => val.length === 0), take(1)).subscribe(entities => {
                const ol = entities[0].ol;
                const columnsFromFeatures = ol.getKeys()
                    .filter(col => !col.startsWith('_') &&
                    col !== 'geometry' &&
                    col !== ol.getGeometryName() &&
                    !col.match(/boundedby/gi))
                    .map(key => {
                    return {
                        name: `properties.${key}`,
                        title: key,
                        renderer: rendererType,
                    };
                });
                workspace.meta.tableTemplate = {
                    selection: false,
                    sort: true,
                    columns: columnsFromFeatures
                };
            });
            return;
        }
        columns = fields.map((field) => {
            let column = {
                name: `properties.${field.name}`,
                title: field.alias ? field.alias : field.name,
                renderer: rendererType,
                valueAccessor: undefined,
                cellClassFunc: () => {
                    const cellClass = {};
                    if (field.type) {
                        cellClass[`class_${field.type}`] = true;
                        return cellClass;
                    }
                },
                primary: field.primary === true ? true : false,
                visible: field.visible,
                validation: field.validation,
                type: field.type,
                domainValues: undefined,
                relation: undefined,
                multiple: field.multiple,
                step: field.step,
                tooltip: field.tooltip
            };
            if (field.type === 'list' || field.type === 'autocomplete') {
                this.getDomainValues(field.relation.table).subscribe(result => {
                    column.domainValues = result;
                    column.relation = field.relation;
                });
            }
            return column;
        });
        relationsColumn = relations.map((relation) => {
            return {
                name: `properties.${relation.name}`,
                title: relation.alias ? relation.alias : relation.name,
                renderer: EntityTableColumnRenderer.Icon,
                icon: relation.icon,
                parent: relation.parent,
                type: 'relation',
                tooltip: relation.tooltip,
                onClick: () => {
                    if (this.adding$.getValue() === false) {
                        this.ws$.next(relation.title);
                    }
                },
                cellClassFunc: () => {
                    return { 'class_icon': true };
                }
            };
        });
        columns.push(...relationsColumn);
        columns.push(...buttons);
        workspace.meta.tableTemplate = {
            selection: false,
            sort: true,
            columns
        };
    }
    createFilterInMapExtentOrResolutionStrategy() {
        const filterClauseFunc = (record) => {
            return record.state.inMapExtent === true && record.state.inMapResolution === true;
        };
        return new EntityStoreFilterCustomFuncStrategy({ filterClauseFunc });
    }
    saveFeature(feature, workspace) {
        if (!this.validateFeature(feature, workspace)) {
            return false;
        }
        this.sanitizeParameter(feature, workspace);
        let url = this.configService.getConfig('edition.url');
        if (workspace.layer.dataSource.options.edition.baseUrl) {
            url += workspace.layer.dataSource.options.edition.baseUrl;
        }
        if (feature.newFeature) {
            url += workspace.layer.dataSource.options.edition.addUrl;
            const addHeaders = workspace.layer.dataSource.options.edition.addHeaders;
            const headers = new HttpHeaders(addHeaders);
            this.addFeature(feature, workspace, url, headers);
        }
        else {
            if (workspace.layer.dataSource.options.edition.modifyProtocol !== "post") {
                url += '?' + workspace.layer.dataSource.options.edition.modifyUrl + feature.idkey;
            }
            else {
                url += workspace.layer.dataSource.options.edition.modifyUrl;
            }
            const protocole = workspace.layer.dataSource.options.edition.modifyProtocol;
            const modifyHeaders = workspace.layer.dataSource.options.edition.modifyHeaders;
            const headers = new HttpHeaders(modifyHeaders);
            this.modifyFeature(feature, workspace, url, headers, protocole);
        }
    }
    addFeature(feature, workspace, url, headers) {
        var _a;
        // TODO: adapt to any kind of geometry
        if (workspace.layer.dataSource.options.edition.hasGeometry) {
            //feature.properties[geom] = feature.geometry;
            feature.properties["longitude"] = feature.geometry.coordinates[0];
            feature.properties["latitude"] = feature.geometry.coordinates[1];
        }
        for (const property in feature.properties) {
            for (const sf of workspace.layer.dataSource.options.sourceFields) {
                if (sf.name === property && ((_a = sf.validation) === null || _a === void 0 ? void 0 : _a.readonly)) {
                    delete feature.properties[property];
                }
            }
        }
        this.loading = true;
        this.http.post(`${url}`, feature.properties, { headers: headers }).subscribe(() => {
            this.loading = false;
            workspace.entityStore.stateView.clear();
            workspace.deleteDrawings();
            workspace.entityStore.delete(feature);
            const message = this.languageService.translate.instant('igo.geo.workspace.addSuccess');
            this.messageService.success(message);
            this.refreshMap(workspace.layer, workspace.layer.map);
            this.adding$.next(false);
            this.rowsInMapExtentCheckCondition$.next(true);
        }, error => {
            this.loading = false;
            error.error.caught = true;
            const genericErrorMessage = this.languageService.translate.instant('igo.geo.workspace.addError');
            const messages = workspace.layer.dataSource.options.edition.messages;
            if (messages) {
                let text;
                messages.forEach(message => {
                    const key = Object.keys(message)[0];
                    if (error.error.message.includes(key)) {
                        text = message[key];
                        this.messageService.error(text);
                    }
                });
                if (!text) {
                    this.messageService.error(genericErrorMessage);
                }
            }
            else {
                this.messageService.error(genericErrorMessage);
            }
        });
    }
    deleteFeature(workspace, url) {
        this.loading = true;
        this.http.delete(`${url}`, {}).subscribe(() => {
            this.loading = false;
            const message = this.languageService.translate.instant('igo.geo.workspace.deleteSuccess');
            this.messageService.success(message);
            this.refreshMap(workspace.layer, workspace.layer.map);
            for (const relation of workspace.layer.options.sourceOptions.relations) {
                workspace.map.layers.forEach((layer) => {
                    if (layer.title === relation.title) {
                        layer.dataSource.ol.refresh();
                    }
                });
            }
        }, error => {
            this.loading = false;
            error.error.caught = true;
            const genericErrorMessage = this.languageService.translate.instant('igo.geo.workspace.addError');
            const messages = workspace.layer.dataSource.options.edition.messages;
            if (messages) {
                let text;
                messages.forEach(message => {
                    const key = Object.keys(message)[0];
                    if (error.error.message.includes(key)) {
                        text = message[key];
                        this.messageService.error(text);
                    }
                });
                if (!text) {
                    this.messageService.error(genericErrorMessage);
                }
            }
            else {
                this.messageService.error(genericErrorMessage);
            }
        });
    }
    modifyFeature(feature, workspace, url, headers, protocole = 'patch') {
        var _a;
        //TODO: adapt to any kind of geometry
        if (workspace.layer.dataSource.options.edition.hasGeometry) {
            //feature.properties[geom] = feature.geometry;
            feature.properties["longitude"] = feature.geometry.coordinates[0];
            feature.properties["latitude"] = feature.geometry.coordinates[1];
        }
        for (const property in feature.properties) {
            for (const sf of workspace.layer.dataSource.options.sourceFields) {
                if ((sf.name === property && ((_a = sf.validation) === null || _a === void 0 ? void 0 : _a.readonly)) || property === 'boundedBy') {
                    delete feature.properties[property];
                }
            }
        }
        this.loading = true;
        this.http[protocole](`${url}`, feature.properties, { headers: headers }).subscribe(() => {
            this.loading = false;
            this.cancelEdit(workspace, feature, true);
            const message = this.languageService.translate.instant('igo.geo.workspace.modifySuccess');
            this.messageService.success(message);
            this.refreshMap(workspace.layer, workspace.layer.map);
            let relationLayers = [];
            for (const relation of workspace.layer.options.sourceOptions.relations) {
                workspace.map.layers.forEach((layer) => {
                    if (layer.title === relation.title) {
                        relationLayers.push(layer);
                        layer.dataSource.ol.refresh();
                    }
                });
            }
            this.relationLayers$.next(relationLayers);
        }, error => {
            this.loading = false;
            error.error.caught = true;
            const genericErrorMessage = this.languageService.translate.instant('igo.geo.workspace.addError');
            const messages = workspace.layer.dataSource.options.edition.messages;
            if (messages) {
                let text;
                messages.forEach(message => {
                    const key = Object.keys(message)[0];
                    if (error.error.message.includes(key)) {
                        text = message[key];
                        this.messageService.error(text);
                    }
                });
                if (!text) {
                    this.messageService.error(genericErrorMessage);
                }
            }
            else {
                this.messageService.error(genericErrorMessage);
            }
        });
    }
    cancelEdit(workspace, feature, fromSave = false) {
        feature.edition = false;
        this.adding$.next(false);
        workspace.deleteDrawings();
        if (feature.newFeature) {
            workspace.entityStore.stateView.clear();
            workspace.entityStore.delete(feature);
            workspace.deactivateDrawControl();
            this.rowsInMapExtentCheckCondition$.next(true);
        }
        else {
            if (!fromSave) {
                feature.properties = feature.original_properties;
                feature.geometry = feature.original_geometry;
            }
            delete feature.original_properties;
            delete feature.original_geometry;
        }
    }
    getDomainValues(table) {
        let url = this.configService.getConfig('edition.url') + table;
        return this.http.get(url).pipe(map(result => {
            return result;
        }), catchError((err) => {
            return throwError(err);
        }));
    }
    /*
     * Refresh both wms and wfs layer
     * A new wfs loader is used to ensure cache is not retrieving old data
     * WMS params are updated to ensure layer is correctly refreshed
     */
    refreshMap(layer, map) {
        var _a, _b;
        const wfsOlLayer = layer.dataSource.ol;
        const loader = (extent, resolution, proj, success, failure) => {
            layer.customWFSLoader(layer.ol.getSource(), layer.options.sourceOptions, this.authInterceptor, extent, resolution, proj, success, failure, true);
        };
        wfsOlLayer.setLoader(loader);
        wfsOlLayer.refresh();
        for (const lay of map.layers) {
            if (lay.id !== layer.id &&
                ((_a = lay.options.linkedLayers) === null || _a === void 0 ? void 0 : _a.linkId.includes(layer.id.substr(0, layer.id.indexOf('.') - 1))) &&
                ((_b = lay.options.linkedLayers) === null || _b === void 0 ? void 0 : _b.linkId.includes('WmsWorkspaceTableSrc'))) {
                const wmsOlLayer = lay.dataSource.ol;
                let params = wmsOlLayer.getParams();
                params._t = new Date().getTime();
                wmsOlLayer.updateParams(params);
            }
        }
    }
    validateFeature(feature, workspace) {
        const translate = this.languageService.translate;
        let message;
        let key;
        let valid = true;
        workspace.meta.tableTemplate.columns.forEach(column => {
            if (column.hasOwnProperty('validation') && column.validation) {
                key = getColumnKeyWithoutPropertiesTag(column.name);
                Object.keys(column.validation).forEach((type) => {
                    switch (type) {
                        case 'mandatory': {
                            if (column.validation[type] && (!feature.properties.hasOwnProperty(key) || !feature.properties[key])) {
                                valid = false;
                                message = translate.instant('igo.geo.formValidation.mandatory', {
                                    column: column.title
                                });
                                this.messageService.error(message);
                            }
                            break;
                        }
                        case 'minValue': {
                            if (feature.properties.hasOwnProperty(key) && feature.properties[key] && feature.properties[key] < column.validation[type]) {
                                valid = false;
                                message = translate.instant('igo.geo.formValidation.minValue', {
                                    column: column.title,
                                    value: column.validation[type]
                                });
                                this.messageService.error(message);
                            }
                            break;
                        }
                        case 'maxValue': {
                            if (feature.properties.hasOwnProperty(key) && feature.properties[key] && feature.properties[key] > column.validation[type]) {
                                valid = false;
                                message = translate.instant('igo.geo.formValidation.maxValue', {
                                    column: column.title,
                                    value: column.validation[type]
                                });
                                this.messageService.error(message);
                            }
                            break;
                        }
                        case 'minLength': {
                            if (feature.properties.hasOwnProperty(key) && feature.properties[key] &&
                                feature.properties[key].length < column.validation[type]) {
                                valid = false;
                                message = translate.instant('igo.geo.formValidation.minLength', {
                                    column: column.title,
                                    value: column.validation[type]
                                });
                                this.messageService.error(message);
                            }
                            break;
                        }
                        case 'maxLength': {
                            if (feature.properties.hasOwnProperty(key) && feature.properties[key] &&
                                feature.properties[key].length > column.validation[type]) {
                                valid = false;
                                message = translate.instant('igo.geo.formValidation.maxLength', {
                                    column: column.title,
                                    value: column.validation[type]
                                });
                                this.messageService.error(message);
                            }
                            break;
                        }
                    }
                });
            }
        });
        return valid;
    }
    sanitizeParameter(feature, workspace) {
        workspace.meta.tableTemplate.columns.forEach(column => {
            if (column.type === 'list' && feature.properties[getColumnKeyWithoutPropertiesTag(column.name)]) {
                feature.properties[getColumnKeyWithoutPropertiesTag(column.name)] =
                    feature.properties[getColumnKeyWithoutPropertiesTag(column.name)].toString();
            }
        });
    }
}
EditionWorkspaceService.ɵfac = function EditionWorkspaceService_Factory(t) { return new (t || EditionWorkspaceService)(i0.ɵɵinject(LayerService), i0.ɵɵinject(i2$1.StorageService), i0.ɵɵinject(i2$1.ConfigService), i0.ɵɵinject(i2$1.MessageService), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i1.MatDialog), i0.ɵɵinject(i5.AuthInterceptor)); };
EditionWorkspaceService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: EditionWorkspaceService, factory: EditionWorkspaceService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(EditionWorkspaceService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: LayerService }, { type: i2$1.StorageService }, { type: i2$1.ConfigService }, { type: i2$1.MessageService }, { type: i2$1.LanguageService }, { type: i1$2.HttpClient }, { type: i1.MatDialog }, { type: i5.AuthInterceptor }]; }, null); })();
function getColumnKeyWithoutPropertiesTag(column) {
    if (column.includes('properties.')) {
        return column.split('.')[1];
    }
    return column;
}

class FeatureWorkspace extends Workspace {
    constructor(options) {
        super(options);
        this.options = options;
        this.inResolutionRange$ = new BehaviorSubject(true);
        this.map.viewController.resolution$.subscribe((mapResolution) => {
            if (mapResolution > this.layer.minResolution && mapResolution < this.layer.maxResolution) {
                this.inResolutionRange$.next(true);
            }
            else {
                this.inResolutionRange$.next(false);
            }
        });
    }
    get layer() { return this.options.layer; }
    get map() { return this.options.map; }
    getLayerWksOptionTabQuery() {
        var _a;
        if (((_a = this.layer.options.workspace.queryOptions) === null || _a === void 0 ? void 0 : _a.tabQuery) !== undefined) {
            return this.layer.options.workspace.queryOptions.tabQuery;
        }
        return true;
    }
    getLayerWksOptionMapQuery() {
        var _a;
        if (((_a = this.layer.options.workspace.queryOptions) === null || _a === void 0 ? void 0 : _a.mapQueryOnOpenTab) !== undefined) {
            return this.layer.options.workspace.queryOptions.mapQueryOnOpenTab;
        }
        return true;
    }
    getInResolutionRange() {
        return this.inResolutionRange$.value;
    }
}

class FeatureWorkspaceService {
    constructor(storageService) {
        this.storageService = storageService;
        this.ws$ = new BehaviorSubject(undefined);
    }
    get zoomAuto() {
        return this.storageService.get('zoomAuto');
    }
    createWorkspace(layer, map) {
        var _a;
        if (((_a = layer.options.workspace) === null || _a === void 0 ? void 0 : _a.enabled) === false || layer.dataSource.options.edition) {
            return;
        }
        layer.options.workspace = Object.assign({}, layer.options.workspace, {
            srcId: layer.id,
            workspaceId: layer.id,
            enabled: true
        });
        const wks = new FeatureWorkspace({
            id: layer.id,
            title: layer.title,
            layer,
            map,
            entityStore: this.createFeatureStore(layer, map),
            actionStore: new ActionStore([]),
            meta: {
                tableTemplate: undefined
            }
        });
        this.createTableTemplate(wks, layer);
        return wks;
    }
    createFeatureStore(layer, map) {
        const store = new FeatureStore([], { map });
        store.bindLayer(layer);
        const loadingStrategy = new FeatureStoreLoadingLayerStrategy({});
        const inMapExtentStrategy = new FeatureStoreInMapExtentStrategy({});
        const inMapResolutionStrategy = new FeatureStoreInMapResolutionStrategy({});
        const selectedRecordStrategy = new EntityStoreFilterSelectionStrategy({});
        const selectionStrategy = new FeatureStoreSelectionStrategy({
            layer: new VectorLayer({
                zIndex: 300,
                source: new FeatureDataSource(),
                style: undefined,
                showInLayerList: false,
                exportable: false,
                browsable: false
            }),
            map,
            hitTolerance: 15,
            motion: this.zoomAuto ? FeatureMotion.Default : FeatureMotion.None,
            many: true,
            dragBox: true
        });
        store.addStrategy(loadingStrategy, true);
        store.addStrategy(inMapExtentStrategy, true);
        store.addStrategy(inMapResolutionStrategy, true);
        store.addStrategy(selectionStrategy, true);
        store.addStrategy(selectedRecordStrategy, false);
        store.addStrategy(this.createFilterInMapExtentOrResolutionStrategy(), true);
        return store;
    }
    createTableTemplate(workspace, layer) {
        const fields = layer.dataSource.options.sourceFields || [];
        const relations = layer.dataSource.options.relations || [];
        if (fields.length === 0) {
            workspace.entityStore.entities$.pipe(skipWhile(val => val.length === 0), take(1)).subscribe(entities => {
                const ol = entities[0].ol;
                const columnsFromFeatures = ol.getKeys()
                    .filter(col => !col.startsWith('_') &&
                    col !== 'geometry' &&
                    col !== ol.getGeometryName() &&
                    !col.match(/boundedby/gi))
                    .map(key => {
                    return {
                        name: `properties.${key}`,
                        title: key,
                        renderer: EntityTableColumnRenderer.UnsanitizedHTML
                    };
                });
                workspace.meta.tableTemplate = {
                    selection: true,
                    sort: true,
                    columns: columnsFromFeatures
                };
            });
            return;
        }
        const columns = fields.map((field) => {
            return {
                name: `properties.${field.name}`,
                title: field.alias ? field.alias : field.name,
                renderer: EntityTableColumnRenderer.UnsanitizedHTML,
                tooltip: field.tooltip
            };
        });
        const relationsColumn = relations.map((relation) => {
            return {
                name: `properties.${relation.name}`,
                title: relation.alias ? relation.alias : relation.name,
                renderer: EntityTableColumnRenderer.Icon,
                icon: relation.icon,
                parent: relation.parent,
                type: 'relation',
                tooltip: relation.tooltip,
                onClick: () => {
                    this.ws$.next(relation.title);
                },
                cellClassFunc: () => {
                    return { 'class_icon': true };
                }
            };
        });
        columns.push(...relationsColumn);
        workspace.meta.tableTemplate = {
            selection: true,
            sort: true,
            columns
        };
    }
    createFilterInMapExtentOrResolutionStrategy() {
        const filterClauseFunc = (record) => {
            return record.state.inMapExtent === true && record.state.inMapResolution === true;
        };
        return new EntityStoreFilterCustomFuncStrategy({ filterClauseFunc });
    }
}
FeatureWorkspaceService.ɵfac = function FeatureWorkspaceService_Factory(t) { return new (t || FeatureWorkspaceService)(i0.ɵɵinject(i2$1.StorageService)); };
FeatureWorkspaceService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: FeatureWorkspaceService, factory: FeatureWorkspaceService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(FeatureWorkspaceService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i2$1.StorageService }]; }, null); })();

class WorkspaceSelectorDirective {
    constructor(component, wfsWorkspaceService, wmsWorkspaceService, editionWorkspaceService, featureWorkspaceService) {
        this.component = component;
        this.wfsWorkspaceService = wfsWorkspaceService;
        this.wmsWorkspaceService = wmsWorkspaceService;
        this.editionWorkspaceService = editionWorkspaceService;
        this.featureWorkspaceService = featureWorkspaceService;
        this.entities$$ = [];
        this.changeWorkspace = new EventEmitter();
        this.disableSwitch = new EventEmitter();
        this.relationLayers = new EventEmitter();
        this.rowsInMapExtentCheckCondition = new EventEmitter();
    }
    get workspaceStore() {
        return this.component.store;
    }
    ngOnInit() {
        this.layers$$ = this.map.layers$
            .pipe(debounceTime(50))
            .subscribe((layers) => this.onLayersChange(layers));
        this.featureWorkspaceService.ws$.subscribe((ws) => { this.changeWorkspace.emit(ws); });
        this.wmsWorkspaceService.ws$.subscribe((ws) => { this.changeWorkspace.emit(ws); });
        this.wfsWorkspaceService.ws$.subscribe((ws) => { this.changeWorkspace.emit(ws); });
        this.editionWorkspaceService.ws$.subscribe((ws) => { this.changeWorkspace.emit(ws); });
        this.editionWorkspaceService.adding$.subscribe((adding) => { this.disableSwitch.emit(adding); });
        this.editionWorkspaceService.relationLayers$.subscribe((layers) => { this.relationLayers.emit(layers); });
        this.editionWorkspaceService.rowsInMapExtentCheckCondition$.subscribe((condition) => {
            this.rowsInMapExtentCheckCondition.emit(condition);
        });
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
        this.entities$$.map(entities => entities.unsubscribe());
    }
    onLayersChange(layers) {
        const editableLayers = layers.filter((layer) => this.layerIsEditable(layer));
        const editableLayersIds = editableLayers.map((layer) => layer.id);
        const workspacesToAdd = editableLayers
            .map((layer) => this.getOrCreateWorkspace(layer))
            .filter((workspace) => workspace !== undefined);
        const workspacesToRemove = this.workspaceStore.all()
            .filter((workspace) => {
            return editableLayersIds.indexOf(workspace.id) < 0;
        });
        if (workspacesToRemove.length > 0) {
            workspacesToRemove.forEach((workspace) => {
                workspace.entityStore.deactivateStrategyOfType(FeatureStoreInMapExtentStrategy);
                workspace.deactivate();
            });
            this.workspaceStore.state.updateMany(workspacesToRemove, { active: false, selected: false });
            this.workspaceStore.deleteMany(workspacesToRemove);
        }
        if (workspacesToAdd.length > 0) {
            this.workspaceStore.insertMany(workspacesToAdd);
        }
    }
    getOrCreateWorkspace(layer) {
        var _a, _b, _c, _d;
        const workspace = this.workspaceStore.get(layer.id);
        if (workspace !== undefined) {
            return;
        }
        if (layer.dataSource instanceof WFSDataSource && ((_a = layer.dataSource.options.edition) === null || _a === void 0 ? void 0 : _a.enabled) !== true) {
            const wfsWks = this.wfsWorkspaceService.createWorkspace(layer, this.map);
            return wfsWks;
        }
        else if (layer.dataSource instanceof WMSDataSource && ((_b = layer.dataSource.options.edition) === null || _b === void 0 ? void 0 : _b.enabled) !== true) {
            if (!layer.dataSource.options.paramsWFS) {
                return;
            }
            const wmsWks = this.wmsWorkspaceService.createWorkspace(layer, this.map);
            wmsWks === null || wmsWks === void 0 ? void 0 : wmsWks.inResolutionRange$.subscribe((inResolutionRange) => {
                layer.dataSource.options.queryable = !inResolutionRange;
                wmsWks.layer.dataSource.options.queryable = inResolutionRange;
            });
            return wmsWks;
        }
        else if (layer.dataSource instanceof FeatureDataSource &&
            layer.exportable === true &&
            ((_c = layer.dataSource.options.edition) === null || _c === void 0 ? void 0 : _c.enabled) !== true) {
            const featureWks = this.featureWorkspaceService.createWorkspace(layer, this.map);
            return featureWks;
        }
        else if (layer.dataSource instanceof WMSDataSource && ((_d = layer.dataSource.options.edition) === null || _d === void 0 ? void 0 : _d.enabled) === true) {
            const editionWks = this.editionWorkspaceService.createWorkspace(layer, this.map);
            return editionWks;
        }
        return;
    }
    layerIsEditable(layer) {
        var _a, _b;
        const dataSource = layer.dataSource;
        if (dataSource instanceof WFSDataSource) {
            return true;
        }
        if (dataSource instanceof FeatureDataSource) {
            return true;
        }
        if (dataSource instanceof WMSDataSource) {
            const dataSourceOptions = (dataSource.options ||
                {});
            return (((_a = dataSourceOptions.ogcFilters) === null || _a === void 0 ? void 0 : _a.enabled) || ((_b = dataSource.options.paramsWFS) === null || _b === void 0 ? void 0 : _b.featureTypes) !== undefined);
        }
        return false;
    }
}
WorkspaceSelectorDirective.ɵfac = function WorkspaceSelectorDirective_Factory(t) { return new (t || WorkspaceSelectorDirective)(i0.ɵɵdirectiveInject(i6.WorkspaceSelectorComponent), i0.ɵɵdirectiveInject(WfsWorkspaceService), i0.ɵɵdirectiveInject(WmsWorkspaceService), i0.ɵɵdirectiveInject(EditionWorkspaceService), i0.ɵɵdirectiveInject(FeatureWorkspaceService)); };
WorkspaceSelectorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: WorkspaceSelectorDirective, selectors: [["", "igoWorkspaceSelector", ""]], inputs: { map: "map" }, outputs: { changeWorkspace: "changeWorkspace", disableSwitch: "disableSwitch", relationLayers: "relationLayers", rowsInMapExtentCheckCondition: "rowsInMapExtentCheckCondition" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(WorkspaceSelectorDirective, [{
        type: Directive,
        args: [{
                selector: '[igoWorkspaceSelector]'
            }]
    }], function () { return [{ type: i6.WorkspaceSelectorComponent }, { type: WfsWorkspaceService }, { type: WmsWorkspaceService }, { type: EditionWorkspaceService }, { type: FeatureWorkspaceService }]; }, { map: [{
            type: Input
        }], changeWorkspace: [{
            type: Output
        }], disableSwitch: [{
            type: Output
        }], relationLayers: [{
            type: Output
        }], rowsInMapExtentCheckCondition: [{
            type: Output
        }] }); })();

/**
 * @ignore
 */
class IgoWorkspaceSelectorModule {
}
IgoWorkspaceSelectorModule.ɵfac = function IgoWorkspaceSelectorModule_Factory(t) { return new (t || IgoWorkspaceSelectorModule)(); };
IgoWorkspaceSelectorModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoWorkspaceSelectorModule });
IgoWorkspaceSelectorModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoWorkspaceSelectorModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    WorkspaceSelectorDirective
                ],
                declarations: [
                    WorkspaceSelectorDirective
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoWorkspaceSelectorModule, { declarations: [WorkspaceSelectorDirective], imports: [CommonModule], exports: [WorkspaceSelectorDirective] }); })();

class WorkspaceUpdatorDirective {
    constructor(wfsWorkspaceService, wmsWorkspaceService, editionWorkspaceService, featureWorkspaceService) {
        this.wfsWorkspaceService = wfsWorkspaceService;
        this.wmsWorkspaceService = wmsWorkspaceService;
        this.editionWorkspaceService = editionWorkspaceService;
        this.featureWorkspaceService = featureWorkspaceService;
        this.entities$$ = [];
    }
    ngOnInit() {
        this.layers$$ = this.map.layers$
            .pipe(debounceTime(50))
            .subscribe((layers) => this.onLayersChange(layers));
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
        this.entities$$.map(entities => entities.unsubscribe());
    }
    onLayersChange(layers) {
        const editableLayers = layers.filter((layer) => this.layerIsEditable(layer));
        const editableLayersIds = editableLayers.map((layer) => layer.id);
        const workspacesToAdd = editableLayers
            .map((layer) => this.getOrCreateWorkspace(layer))
            .filter((workspace) => workspace !== undefined);
        const workspacesToRemove = this.workspaceStore.all()
            .filter((workspace) => {
            return editableLayersIds.indexOf(workspace.id) < 0;
        });
        if (workspacesToRemove.length > 0) {
            workspacesToRemove.forEach((workspace) => {
                workspace.entityStore.deactivateStrategyOfType(FeatureStoreInMapExtentStrategy);
                workspace.deactivate();
            });
            this.workspaceStore.state.updateMany(workspacesToRemove, { active: false, selected: false });
            this.workspaceStore.deleteMany(workspacesToRemove);
        }
        if (workspacesToAdd.length > 0) {
            this.workspaceStore.insertMany(workspacesToAdd);
        }
    }
    getOrCreateWorkspace(layer) {
        var _a, _b, _c, _d;
        const workspace = this.workspaceStore.get(layer.id);
        if (workspace !== undefined) {
            return;
        }
        if (layer.dataSource instanceof WFSDataSource && ((_a = layer.dataSource.options.edition) === null || _a === void 0 ? void 0 : _a.enabled) !== true) {
            const wfsWks = this.wfsWorkspaceService.createWorkspace(layer, this.map);
            return wfsWks;
        }
        else if (layer.dataSource instanceof WMSDataSource && ((_b = layer.dataSource.options.edition) === null || _b === void 0 ? void 0 : _b.enabled) !== true) {
            if (!layer.dataSource.options.paramsWFS) {
                return;
            }
            const wmsWks = this.wmsWorkspaceService.createWorkspace(layer, this.map);
            wmsWks === null || wmsWks === void 0 ? void 0 : wmsWks.inResolutionRange$.subscribe((inResolutionRange) => {
                var _a;
                if ((_a = layer.dataSource.options) === null || _a === void 0 ? void 0 : _a.queryFormatAsWms) {
                    wmsWks.layer.dataSource.options.queryable = true;
                    return wmsWks;
                }
                layer.dataSource.options.queryable = !inResolutionRange;
                wmsWks.layer.dataSource.options.queryable = inResolutionRange;
            });
            return wmsWks;
        }
        else if (layer.dataSource instanceof FeatureDataSource &&
            layer.exportable === true &&
            ((_c = layer.dataSource.options.edition) === null || _c === void 0 ? void 0 : _c.enabled) !== true) {
            const featureWks = this.featureWorkspaceService.createWorkspace(layer, this.map);
            return featureWks;
        }
        else if (layer.dataSource instanceof WMSDataSource && ((_d = layer.dataSource.options.edition) === null || _d === void 0 ? void 0 : _d.enabled) === true) {
            const editionWks = this.editionWorkspaceService.createWorkspace(layer, this.map);
            return editionWks;
        }
        return;
    }
    layerIsEditable(layer) {
        var _a, _b;
        const dataSource = layer.dataSource;
        if (dataSource instanceof WFSDataSource) {
            return true;
        }
        if (dataSource instanceof FeatureDataSource) {
            return true;
        }
        if (dataSource instanceof WMSDataSource) {
            const dataSourceOptions = (dataSource.options ||
                {});
            return (((_a = dataSourceOptions.ogcFilters) === null || _a === void 0 ? void 0 : _a.enabled) || ((_b = dataSource.options.paramsWFS) === null || _b === void 0 ? void 0 : _b.featureTypes) !== undefined);
        }
        return false;
    }
}
WorkspaceUpdatorDirective.ɵfac = function WorkspaceUpdatorDirective_Factory(t) { return new (t || WorkspaceUpdatorDirective)(i0.ɵɵdirectiveInject(WfsWorkspaceService), i0.ɵɵdirectiveInject(WmsWorkspaceService), i0.ɵɵdirectiveInject(EditionWorkspaceService), i0.ɵɵdirectiveInject(FeatureWorkspaceService)); };
WorkspaceUpdatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: WorkspaceUpdatorDirective, selectors: [["", "igoWorkspaceUpdator", ""]], inputs: { map: "map", workspaceStore: "workspaceStore" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(WorkspaceUpdatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igoWorkspaceUpdator]'
            }]
    }], function () { return [{ type: WfsWorkspaceService }, { type: WmsWorkspaceService }, { type: EditionWorkspaceService }, { type: FeatureWorkspaceService }]; }, { map: [{
            type: Input
        }], workspaceStore: [{
            type: Input
        }] }); })();

/**
 * @ignore
 */
class IgoWorkspaceUpdatorModule {
}
IgoWorkspaceUpdatorModule.ɵfac = function IgoWorkspaceUpdatorModule_Factory(t) { return new (t || IgoWorkspaceUpdatorModule)(); };
IgoWorkspaceUpdatorModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoWorkspaceUpdatorModule });
IgoWorkspaceUpdatorModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoWorkspaceUpdatorModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    WorkspaceUpdatorDirective
                ],
                declarations: [
                    WorkspaceUpdatorDirective
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoWorkspaceUpdatorModule, { declarations: [WorkspaceUpdatorDirective], imports: [CommonModule], exports: [WorkspaceUpdatorDirective] }); })();

/**
 * @ignore
 */
class IgoConfirmationPopupModule {
}
IgoConfirmationPopupModule.ɵfac = function IgoConfirmationPopupModule_Factory(t) { return new (t || IgoConfirmationPopupModule)(); };
IgoConfirmationPopupModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoConfirmationPopupModule });
IgoConfirmationPopupModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            MatButtonModule,
            MatDialogModule,
            MatButtonToggleModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoConfirmationPopupModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    MatButtonModule,
                    MatDialogModule,
                    MatButtonToggleModule
                ],
                exports: [ConfirmationPopupComponent],
                declarations: [ConfirmationPopupComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoConfirmationPopupModule, { declarations: [ConfirmationPopupComponent], imports: [CommonModule,
        MatButtonModule,
        MatDialogModule,
        MatButtonToggleModule], exports: [ConfirmationPopupComponent] }); })();

class IgoGeoWorkspaceModule {
}
IgoGeoWorkspaceModule.ɵfac = function IgoGeoWorkspaceModule_Factory(t) { return new (t || IgoGeoWorkspaceModule)(); };
IgoGeoWorkspaceModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoGeoWorkspaceModule });
IgoGeoWorkspaceModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [
        provideOgcFilterWidget()
    ], imports: [[
            CommonModule,
            IgoLanguageModule,
            IgoWidgetModule,
            IgoWorkspaceSelectorModule,
            IgoWorkspaceUpdatorModule,
            IgoOgcFilterModule,
            MatDialogModule
        ], IgoWorkspaceSelectorModule,
        IgoWorkspaceUpdatorModule,
        IgoOgcFilterModule,
        IgoConfirmationPopupModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoGeoWorkspaceModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    IgoLanguageModule,
                    IgoWidgetModule,
                    IgoWorkspaceSelectorModule,
                    IgoWorkspaceUpdatorModule,
                    IgoOgcFilterModule,
                    MatDialogModule
                ],
                exports: [
                    IgoWorkspaceSelectorModule,
                    IgoWorkspaceUpdatorModule,
                    IgoOgcFilterModule,
                    IgoConfirmationPopupModule
                ],
                declarations: [],
                providers: [
                    provideOgcFilterWidget()
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoGeoWorkspaceModule, { imports: [CommonModule,
        IgoLanguageModule,
        IgoWidgetModule,
        IgoWorkspaceSelectorModule,
        IgoWorkspaceUpdatorModule,
        IgoOgcFilterModule,
        MatDialogModule], exports: [IgoWorkspaceSelectorModule,
        IgoWorkspaceUpdatorModule,
        IgoOgcFilterModule,
        IgoConfirmationPopupModule] }); })();

class IgoWktModule {
    static forRoot() {
        return {
            ngModule: IgoWktModule,
            providers: []
        };
    }
}
IgoWktModule.ɵfac = function IgoWktModule_Factory(t) { return new (t || IgoWktModule)(); };
IgoWktModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoWktModule });
IgoWktModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoWktModule, [{
        type: NgModule,
        args: [{
                imports: [],
                exports: [],
                declarations: []
            }]
    }], null, null); })();

class IgoGeoModule {
    static forRoot() {
        return {
            ngModule: IgoGeoModule,
            providers: []
        };
    }
}
IgoGeoModule.ɵfac = function IgoGeoModule_Factory(t) { return new (t || IgoGeoModule)(); };
IgoGeoModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: IgoGeoModule });
IgoGeoModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[], IgoCatalogModule,
        IgoDataSourceModule,
        IgoDownloadModule,
        IgoDrawingToolModule,
        IgoFeatureModule,
        IgoFilterModule,
        IgoGeometryModule,
        IgoImportExportModule,
        IgoLayerModule,
        IgoMapModule,
        IgoMeasureModule,
        IgoMetadataModule,
        IgoOverlayModule,
        IgoPrintModule,
        IgoQueryModule,
        IgoDirectionsModule,
        IgoSearchModule,
        IgoToastModule,
        IgoGeoWorkspaceModule,
        IgoWktModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(IgoGeoModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [],
                exports: [
                    IgoCatalogModule,
                    IgoDataSourceModule,
                    IgoDownloadModule,
                    IgoDrawingToolModule,
                    IgoFeatureModule,
                    IgoFilterModule,
                    IgoGeometryModule,
                    IgoImportExportModule,
                    IgoLayerModule,
                    IgoMapModule,
                    IgoMeasureModule,
                    IgoMetadataModule,
                    IgoOverlayModule,
                    IgoPrintModule,
                    IgoQueryModule,
                    IgoDirectionsModule,
                    IgoSearchModule,
                    IgoToastModule,
                    IgoGeoWorkspaceModule,
                    IgoWktModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(IgoGeoModule, { exports: [IgoCatalogModule,
        IgoDataSourceModule,
        IgoDownloadModule,
        IgoDrawingToolModule,
        IgoFeatureModule,
        IgoFilterModule,
        IgoGeometryModule,
        IgoImportExportModule,
        IgoLayerModule,
        IgoMapModule,
        IgoMeasureModule,
        IgoMetadataModule,
        IgoOverlayModule,
        IgoPrintModule,
        IgoQueryModule,
        IgoDirectionsModule,
        IgoSearchModule,
        IgoToastModule,
        IgoGeoWorkspaceModule,
        IgoWktModule] }); })();

/**
 * The class is a specialized version of an EntityStore that stores
 * stops.
 */
class StopsStore extends EntityStore {
    constructor() {
        super(...arguments);
        this.storeInitialized$ = new BehaviorSubject(false);
    }
    clearStops() {
        this.storeInitialized$.next(false);
        this.clear();
    }
}
class StopsFeatureStore extends FeatureStore {
}
class RoutesFeatureStore extends FeatureStore {
}
class StepFeatureStore extends FeatureStore {
}

class OsrmDirectionsSource extends DirectionsSource {
    constructor(http, config) {
        super();
        this.http = http;
        this.config = config;
        this.directionsUrl = 'https://geoegl.msp.gouv.qc.ca/services/itineraire/route/v1/driving/';
        this.options = this.config.getConfig('directionsSources.osrm') || {};
        this.directionsUrl = this.options.url || this.directionsUrl;
    }
    get enabled() {
        return this.options.enabled !== false;
    }
    set enabled(value) {
        this.options.enabled = value;
    }
    getName() {
        return OsrmDirectionsSource._name;
    }
    route(coordinates, directionsOptions = {}) {
        const directionsParams = this.getRouteParams(directionsOptions);
        return this.http
            .get(this.directionsUrl + coordinates.join(';'), {
            params: directionsParams
        })
            .pipe(map(res => this.extractRoutesData(res)));
    }
    extractRoutesData(response) {
        const routeResponse = [];
        response.routes.forEach(route => {
            routeResponse.push(this.formatRoute(route, response.waypoints));
        });
        return routeResponse;
    }
    getRouteParams(directionsOptions = {}) {
        directionsOptions.alternatives = directionsOptions.alternatives !== undefined ? directionsOptions.alternatives : true;
        directionsOptions.steps = directionsOptions.steps !== undefined ? directionsOptions.steps : true;
        directionsOptions.geometries = directionsOptions.geometries !== undefined ? directionsOptions.geometries : 'geojson';
        directionsOptions.overview = directionsOptions.overview !== undefined ? directionsOptions.overview : false;
        directionsOptions.continue_straight = directionsOptions.continue_straight !== undefined ? directionsOptions.continue_straight : false;
        return new HttpParams({
            fromObject: {
                alternatives: directionsOptions.alternatives ? 'true' : 'false',
                overview: directionsOptions.overview ? 'simplified' : 'full',
                steps: directionsOptions.steps ? 'true' : 'false',
                geometries: directionsOptions.geometries ? directionsOptions.geometries : 'geojson',
                continue_straight: directionsOptions.continue_straight ? 'true' : 'false',
            }
        });
    }
    formatRoute(roadNetworkRoute, waypoints) {
        const stepsUI = [];
        roadNetworkRoute.legs.forEach(leg => {
            leg.steps.forEach(step => {
                stepsUI.push(step);
            });
        });
        return {
            id: uuid(),
            title: roadNetworkRoute.legs[0].summary,
            source: OsrmDirectionsSource._name,
            sourceType: SourceDirectionsType.Route,
            order: 1,
            format: DirectionsFormat.GeoJSON,
            icon: 'directions',
            projection: 'EPSG:4326',
            waypoints,
            distance: roadNetworkRoute.distance,
            duration: roadNetworkRoute.duration,
            geometry: roadNetworkRoute.geometry,
            legs: roadNetworkRoute.legs,
            steps: stepsUI,
            weight: roadNetworkRoute.weight,
            weight_name: roadNetworkRoute.weight_name
        };
    }
}
OsrmDirectionsSource._name = 'OSRM Québec';
OsrmDirectionsSource.ɵfac = function OsrmDirectionsSource_Factory(t) { return new (t || OsrmDirectionsSource)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.ConfigService)); };
OsrmDirectionsSource.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: OsrmDirectionsSource, factory: OsrmDirectionsSource.ɵfac });
__decorate([
    Cacheable({
        maxCacheCount: 20
    })
], OsrmDirectionsSource.prototype, "route", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(OsrmDirectionsSource, [{
        type: Injectable
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.ConfigService }]; }, { route: [] }); })();

function osrmDirectionsSourcesFactory(http, config) {
    return new OsrmDirectionsSource(http, config);
}
function provideOsrmDirectionsSource() {
    return {
        provide: DirectionsSource,
        useFactory: osrmDirectionsSourcesFactory,
        multi: true,
        deps: [HttpClient, ConfigService]
    };
}

/**
 * Cadastre search source
 */
class CadastreSearchSource extends SearchSource {
    constructor(http, languageService, storageService, options) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
    }
    getId() {
        return CadastreSearchSource.id;
    }
    getType() {
        return CadastreSearchSource.type;
    }
    /*
     * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
     */
    getDefaultOptions() {
        return {
            title: 'Cadastre (Québec)',
            searchUrl: 'https://carto.cptaq.gouv.qc.ca/php/find_lot_v1.php?'
        };
    }
    /**
     * Search a place by name
     * @param term Place name
     * @returns Observable of <SearchResult<Feature>[]
     */
    search(term, options) {
        term = term.endsWith(',') ? term.slice(0, -1) : term;
        term = term.startsWith(',') ? term.substr(1) : term;
        term = term.replace(/ /g, '');
        const params = this.computeSearchRequestParams(term, options || {});
        if (!params.get('numero') || !params.get('numero').match(/^[0-9,]+$/g)) {
            return of([]);
        }
        return this.http
            .get(this.searchUrl, { params, responseType: 'text' })
            .pipe(map((response) => this.extractResults(response, term)));
    }
    computeSearchRequestParams(term, options) {
        return new HttpParams({
            fromObject: Object.assign({
                numero: term,
                epsg: '4326'
            }, this.params, options.params || {})
        });
    }
    extractResults(response, term) {
        return response
            .split('<br />')
            .filter((lot) => lot.length > 0)
            .map((lot) => this.dataToResult(lot, term));
    }
    dataToResult(data, term) {
        const lot = data.split(';');
        const numero = lot[0];
        const wkt = lot[7];
        const geometry = this.computeGeometry(wkt);
        const properties = {
            NoLot: numero,
            Route: '<span class="routing"> <u>' + this.languageService.translate.instant('igo.geo.seeRouting') + '</u> </span>'
        };
        const id = [this.getId(), 'cadastre', numero].join('.');
        return {
            source: this,
            meta: {
                dataType: FEATURE,
                id,
                title: numero,
                score: computeTermSimilarity(term.trim(), numero),
                icon: 'map-marker'
            },
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry,
                properties,
                meta: {
                    id,
                    title: numero
                }
            }
        };
    }
    computeGeometry(wkt) {
        const feature = new olWKT().readFeature(wkt, {
            dataProjection: 'EPSG:4326',
            featureProjection: 'EPSG:4326'
        });
        return {
            type: feature.getGeometry().getType(),
            coordinates: feature.getGeometry().getCoordinates()
        };
    }
}
CadastreSearchSource.id = 'cadastre';
CadastreSearchSource.type = FEATURE;
CadastreSearchSource.ɵfac = function CadastreSearchSource_Factory(t) { return new (t || CadastreSearchSource)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i2$1.StorageService), i0.ɵɵinject('options')); };
CadastreSearchSource.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CadastreSearchSource, factory: CadastreSearchSource.ɵfac });
__decorate([
    Cacheable({
        maxCacheCount: 20
    })
], CadastreSearchSource.prototype, "search", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CadastreSearchSource, [{
        type: Injectable
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.LanguageService }, { type: i2$1.StorageService }, { type: undefined, decorators: [{
                type: Inject,
                args: ['options']
            }] }]; }, { search: [] }); })();

/**
 * Cadastre search source factory
 * @ignore
 */
function cadastreSearchSourceFactory(http, languageService, storageService, config) {
    return new CadastreSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${CadastreSearchSource.id}`));
}
/**
 * Function that returns a provider for the Cadastre search source
 */
function provideCadastreSearchSource() {
    return {
        provide: SearchSource,
        useFactory: cadastreSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, StorageService, ConfigService]
    };
}

/**
 * Nominatim search source
 */
class NominatimSearchSource extends SearchSource {
    constructor(http, options, storageService) {
        super(options, storageService);
        this.http = http;
    }
    getId() {
        return NominatimSearchSource.id;
    }
    getType() {
        return NominatimSearchSource.type;
    }
    /*
     * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
     */
    getDefaultOptions() {
        return {
            title: 'Nominatim (OSM)',
            searchUrl: 'https://nominatim.openstreetmap.org/search',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'amenity',
                    values: [
                        {
                            title: 'igo.geo.search.nominatim.type.food',
                            value: 'bar,bbq,biergaten,cafe,drinking_water,fast_food,food_court,ice_cream,pub,restaurant',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.nominatim.type.health',
                            value: 'baby_hatch,clinic,dentist,doctors,hospital,nursing_home,pharmacy,social_facility,veterinary',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.nominatim.type.entertainment',
                            value: 'arts_centre,brothel,casino,cinema,community_center_fountain,gambling,nightclub,planetarium \
                          ,public_bookcase,social_centre,stripclub,studio,swingerclub,theatre,internet_cafe',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.nominatim.type.finance',
                            value: 'atm,bank,bureau_de_change',
                            enabled: false
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'results limit',
                    name: 'limit',
                    values: [
                        {
                            title: '10',
                            value: 10,
                            enabled: true
                        },
                        {
                            title: '20',
                            value: 20,
                            enabled: false
                        },
                        {
                            title: '50',
                            value: 50,
                            enabled: false
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'restrictExtent',
                    name: 'countrycodes',
                    values: [
                        {
                            title: 'igo.geo.search.nominatim.country.canada',
                            value: 'CA',
                            enabled: true
                        },
                        {
                            title: 'igo.geo.search.nominatim.country.all',
                            value: null,
                            enabled: false
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'multiple object',
                    name: 'dedupe',
                    values: [
                        {
                            title: 'igo.geo.search.searchSources.settings.true',
                            value: 0,
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.searchSources.settings.false',
                            value: 1,
                            enabled: true
                        }
                    ]
                }
            ]
        };
    }
    /**
     * Search a place by name
     * @param term Place name
     * @returns Observable of <SearchResult<Feature>[]
     */
    search(term, options) {
        const params = this.computeSearchRequestParams(term, options || {});
        if (!params.get('q')) {
            return of([]);
        }
        return this.http
            .get(this.searchUrl, { params })
            .pipe(map((response) => this.extractResults(response, term)));
    }
    computeSearchRequestParams(term, options) {
        return new HttpParams({
            fromObject: Object.assign({
                q: this.computeTerm(term),
                format: 'json'
            }, this.params, options.params || {})
        });
    }
    extractResults(response, term) {
        return response.map((data) => this.dataToResult(data, term));
    }
    dataToResult(data, term) {
        const properties = this.computeProperties(data);
        const geometry = this.computeGeometry(data);
        const extent = this.computeExtent(data);
        const id = [this.getId(), 'place', data.place_id].join('.');
        return {
            source: this,
            meta: {
                dataType: FEATURE,
                id,
                title: data.display_name,
                icon: 'map-marker',
                score: computeTermSimilarity(term.trim(), data.display_name)
            },
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry,
                extent,
                properties,
                meta: {
                    id,
                    title: data.display_name
                }
            }
        };
    }
    computeProperties(data) {
        return {
            display_name: data.display_name,
            place_id: data.place_id,
            osm_type: data.osm_type,
            class: data.class,
            type: data.type
        };
    }
    computeGeometry(data) {
        return {
            type: 'Point',
            coordinates: [parseFloat(data.lon), parseFloat(data.lat)]
        };
    }
    computeExtent(data) {
        return [
            parseFloat(data.boundingbox[2]),
            parseFloat(data.boundingbox[0]),
            parseFloat(data.boundingbox[3]),
            parseFloat(data.boundingbox[1])
        ];
    }
    computeTerm(term) {
        return this.computeTermTags(term);
    }
    /**
     * Add hashtag from query in Nominatim's format (+[])
     * @param term Query with hashtag
     */
    computeTermTags(term) {
        const hashtags = super.getHashtagsValid(term, 'amenity');
        if (!hashtags) {
            return this.computeTermSettings(term);
        }
        if (!hashtags.length) {
            return null;
        }
        term = term.replace(/(#[^\s]*)/g, '');
        hashtags.forEach(tag => {
            term += '+[' + tag + ']';
        });
        return term;
    }
    /**
     * Add hashtag from settings in Nominatim's format (+[])
     * @param term Query
     */
    computeTermSettings(term) {
        this.options.settings.forEach(settings => {
            if (settings.name === 'amenity') {
                settings.values.forEach(conf => {
                    if (conf.enabled && typeof conf.value === 'string') {
                        const splitted = conf.value.split(',');
                        splitted.forEach(value => {
                            term += '+[' + value + ']';
                        });
                    }
                });
            }
        });
        return term;
    }
}
NominatimSearchSource.id = 'nominatim';
NominatimSearchSource.type = FEATURE;
NominatimSearchSource.ɵfac = function NominatimSearchSource_Factory(t) { return new (t || NominatimSearchSource)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject('options'), i0.ɵɵinject(i2$1.StorageService)); };
NominatimSearchSource.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: NominatimSearchSource, factory: NominatimSearchSource.ɵfac });
__decorate([
    Cacheable({
        maxCacheCount: 20
    })
], NominatimSearchSource.prototype, "search", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NominatimSearchSource, [{
        type: Injectable
    }], function () { return [{ type: i1$2.HttpClient }, { type: undefined, decorators: [{
                type: Inject,
                args: ['options']
            }] }, { type: i2$1.StorageService }]; }, { search: [] }); })();

/**
 * Nominatim search source factory
 * @ignore
 */
function nominatimSearchSourceFactory(http, config, storageService) {
    return new NominatimSearchSource(http, config.getConfig(`searchSources.${NominatimSearchSource.id}`), storageService);
}
/**
 * Function that returns a provider for the Nominatim search source
 */
function provideNominatimSearchSource() {
    return {
        provide: SearchSource,
        useFactory: nominatimSearchSourceFactory,
        multi: true,
        deps: [HttpClient, ConfigService, StorageService]
    };
}

/**
 * StoredQueries search source
 */
class StoredQueriesSearchSource extends SearchSource {
    constructor(http, languageService, storageService, options) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
        this.storedQueriesOptions = options;
        if (this.storedQueriesOptions && !this.storedQueriesOptions.available) {
            return;
        }
        const defaultStoredqueryId = 'rtss';
        const defaultFieldSplitter = [
            { name: 'rtss', defaultValue: '-99' },
            { name: 'chainage', defaultValue: '0', splitPrefix: '\\+' }
        ];
        const defaultOutputformat = 'text/xml; subtype=gml/3.1.1';
        const defaultSrsname = 'EPSG:4326';
        const defaultResultTitle = 'title';
        if (!this.storedQueriesOptions) {
            console.log(' No configuration for this search source (storedqueries). You will use the default values');
            this.storedQueriesOptions = {
                storedquery_id: defaultStoredqueryId,
                fields: defaultFieldSplitter,
                outputformat: defaultOutputformat,
                srsname: defaultSrsname,
                resultTitle: defaultResultTitle
            };
            this.resultTitle = defaultResultTitle;
            console.log('Default values', this.storedQueriesOptions);
        }
        if (!this.storedQueriesOptions.storedquery_id) {
            const err = 'Stored Queries :You have to set "storedquery_id" into StoredQueries options. ex: storedquery_id: "nameofstoredquerie"';
            throw new Error(err);
        }
        if (!this.storedQueriesOptions.fields) {
            throw new Error('Stored Queries :You have to set "fields" into options. ex: fields: {"name": "rtss", "defaultValue": "-99"}');
        }
        this.storedQueriesOptions.outputformat =
            this.storedQueriesOptions.outputformat || 'text/xml; subtype=gml/3.1.1';
        this.storedQueriesOptions.srsname =
            this.storedQueriesOptions.srsname || 'EPSG:4326';
        const storedQueryId = this.storedQueriesOptions.storedquery_id.toLowerCase();
        if (storedQueryId.includes('getfeaturebyid') &&
            this.storedQueriesOptions.outputformat
                .toLowerCase()
                .includes('getfeaturebyid')) {
            let err = 'You must set a geojson format for your stored query. This is due to an openlayers issue)';
            err += ' (wfs 1.1.0 & gml 3.1.1 limitation)';
            throw new Error(err);
        }
        if (!(this.storedQueriesOptions.fields instanceof Array)) {
            this.storedQueriesOptions.fields = [this.storedQueriesOptions.fields];
        }
        this.multipleFieldsQuery =
            this.storedQueriesOptions.fields.length > 1 ? true : false;
        this.storedQueriesOptions.fields.forEach((field, index) => {
            if (this.multipleFieldsQuery && !field.splitPrefix && index !== 0) {
                throw new Error('Stored Queries :You must set a field spliter into your field definition (optional for the first one!)');
            }
            if (!field.defaultValue) {
                throw new Error('Stored Queries :You must set a field default value into your field definition');
            }
        });
        this.storedQueriesOptions.resultTitle =
            this.storedQueriesOptions.resultTitle || this.resultTitle;
    }
    getId() {
        return StoredQueriesSearchSource.id;
    }
    getType() {
        return StoredQueriesSearchSource.type;
    }
    getDefaultOptions() {
        return {
            title: 'Stored Queries',
            searchUrl: 'https://ws.mapserver.transports.gouv.qc.ca/swtq'
        };
    }
    // URL CALL EXAMPLES:
    //  GetFeatureById (mandatory storedquery for wfs server) (outputformat must be in geojson)
    /* eslint-disable max-len */
    //  https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=2.0.0&request=GetFeature&storedquery_id=urn:ogc:def:query:OGC-WFS::GetFeatureById&srsname=epsg:4326&outputformat=geojson&ID=a_num_route.132
    //  Custom StoredQuery
    /* eslint-disable max-len */
    //  https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=rtss&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&rtss=0013801110000c&chainage=12
    /**
     * Search a location by name or keyword
     * @param term Location name or keyword
     * @returns Observable of <SearchResult<Feature>[]
     */
    search(term, options) {
        const storedqueriesParams = this.termSplitter(term, this.storedQueriesOptions.fields);
        const params = this.computeRequestParams(options || {}, storedqueriesParams);
        this.options.params = this.options.params ? this.options.params : {};
        this.options.params.page = options.page ? String(options.page) : '1';
        if (new RegExp('.*?gml.*?', 'i').test(this.storedQueriesOptions.outputformat)) {
            return this.http
                .get(this.searchUrl, { params, responseType: 'text' })
                .pipe(map(response => {
                let resultArray = this.extractResults(this.extractWFSData(response), term);
                resultArray.sort((a, b) => (a.meta.score > b.meta.score) ? 1 :
                    (a.meta.score === b.meta.score) ? ((a.meta.titleHtml < b.meta.titleHtml) ? 1 : -1) : -1);
                resultArray.reverse();
                if (resultArray.length > Number(this.options.params.limit)) {
                    const idxEnd = Number(this.options.params.limit) * Number(this.options.params.page);
                    const resultTotLenght = resultArray.length;
                    resultArray = resultArray.slice(0, idxEnd);
                    if (idxEnd < resultTotLenght) {
                        resultArray[resultArray.length - 1].meta.nextPage = true;
                    }
                    else {
                        resultArray[resultArray.length - 1].meta.nextPage = false;
                    }
                }
                return resultArray;
            }));
        }
        else {
            return this.http.get(this.searchUrl, { params }).pipe(map(response => {
                return this.extractResults(this.extractWFSData(response), term);
            }));
        }
    }
    getFormatFromOptions() {
        let olFormatCls;
        const outputFormat = this.storedQueriesOptions.outputformat;
        const patternGml3 = new RegExp('.*?gml.*?', 'i');
        const patternGeojson = new RegExp('.*?json.*?', 'i');
        if (patternGeojson.test(outputFormat)) {
            olFormatCls = olformat.GeoJSON;
        }
        if (patternGml3.test(outputFormat)) {
            olFormatCls = olformat.WFS;
        }
        return new olFormatCls();
    }
    extractWFSData(res) {
        const olFormat = this.getFormatFromOptions();
        const geojson = olformat.GeoJSON;
        const wfsfeatures = olFormat.readFeatures(res);
        const features = JSON.parse(new geojson().writeFeatures(wfsfeatures));
        return features;
    }
    termSplitter(term, fields) {
        const splittedTerm = {};
        let remainingTerm = term;
        let cnt = 0;
        // Used to build the default values
        fields.forEach(field => {
            splittedTerm[field.name] = field.defaultValue;
            const splitterRegex = new RegExp(field.splitPrefix + '(.+)', 'i');
            if (splitterRegex.test(remainingTerm)) {
                cnt = field.splitPrefix ? (cnt += 1) : cnt;
                remainingTerm = remainingTerm.split(splitterRegex)[1];
            }
        });
        if (cnt === 0) {
            splittedTerm[fields[0].name] = term;
            return splittedTerm;
        }
        remainingTerm = term;
        const localFields = [...fields].reverse();
        localFields.forEach(field => {
            const splitterRegex = new RegExp(field.splitPrefix || '' + '(.+)', 'i');
            if (remainingTerm || remainingTerm !== '') {
                const values = remainingTerm.split(splitterRegex);
                remainingTerm = values[0];
                if (values[1]) {
                    splittedTerm[field.name] = values[1].trim();
                }
            }
        });
        return splittedTerm;
    }
    computeRequestParams(options, queryParams) {
        const wfsversion = this.storedQueriesOptions.storedquery_id
            .toLowerCase()
            .includes('getfeaturebyid')
            ? '2.0.0'
            : '1.1.0';
        return new HttpParams({
            fromObject: Object.assign({
                service: 'wfs',
                version: wfsversion,
                request: 'GetFeature',
                storedquery_id: this.storedQueriesOptions.storedquery_id,
                srsname: this.storedQueriesOptions.srsname,
                outputformat: this.storedQueriesOptions.outputformat
            }, queryParams, this.params, options.params || {})
        });
    }
    extractResults(response, term) {
        return response.features.map((data) => {
            return this.dataToResult(data, term);
        });
    }
    dataToResult(data, term) {
        const properties = this.computeProperties(data);
        const id = [this.getId(), properties.type, data.id].join('.');
        const title = data.properties[this.storedQueriesOptions.resultTitle]
            ? this.storedQueriesOptions.resultTitle
            : this.resultTitle;
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                // extent: data.bbox,
                properties,
                meta: {
                    id,
                    title: data.properties[title]
                }
            },
            meta: {
                dataType: FEATURE,
                id,
                title: data.properties.title,
                titleHtml: data.properties[title],
                icon: 'map-marker',
                score: (data.properties.title) ?
                    computeTermSimilarity(term.trim(), data.properties.title) :
                    computeTermSimilarity(term.trim(), data.properties[title]),
            }
        };
    }
    computeProperties(data) {
        const properties = Object.assign({}, ObjectUtils.removeKeys(data.properties, StoredQueriesSearchSource.propertiesBlacklist), { Route: '<span class="routing"> <u>' + this.languageService.translate.instant('igo.geo.seeRouting') + '</u> </span>' });
        return properties;
    }
}
StoredQueriesSearchSource.id = 'storedqueries';
StoredQueriesSearchSource.type = FEATURE;
StoredQueriesSearchSource.propertiesBlacklist = [
    'boundedBy',
    'id',
    'coord_x',
    'coord_y'
];
StoredQueriesSearchSource.ɵfac = function StoredQueriesSearchSource_Factory(t) { return new (t || StoredQueriesSearchSource)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i2$1.StorageService), i0.ɵɵinject('options')); };
StoredQueriesSearchSource.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: StoredQueriesSearchSource, factory: StoredQueriesSearchSource.ɵfac });
__decorate([
    Cacheable({
        maxCacheCount: 20
    })
], StoredQueriesSearchSource.prototype, "search", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(StoredQueriesSearchSource, [{
        type: Injectable
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.LanguageService }, { type: i2$1.StorageService }, { type: undefined, decorators: [{
                type: Inject,
                args: ['options']
            }] }]; }, { search: [] }); })();
/**
 * StoredQueriesReverse search source
 */
// EXAMPLE CALLS
/* eslint-disable max-len */
// https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=lim_adm&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&long=-71.292469&lat=46.748107
//
class StoredQueriesReverseSearchSource extends SearchSource {
    constructor(http, languageService, storageService, options) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
        this.storedQueriesOptions = options;
        if (!this.storedQueriesOptions || (this.storedQueriesOptions && !this.storedQueriesOptions.available)) {
            return;
        }
        if (!this.storedQueriesOptions.storedquery_id) {
            const err = 'Stored Queries :You have to set "storedquery_id" into StoredQueries options. ex: storedquery_id: "nameofstoredquerie"';
            throw new Error(err);
        }
        if (!this.storedQueriesOptions.longField) {
            throw new Error('Stored Queries :You have to set "longField" to map the longitude coordinate to the query params.');
        }
        if (!this.storedQueriesOptions.latField) {
            throw new Error('Stored Queries :You have to set "latField" to map the latitude coordinate to the query params.');
        }
        this.storedQueriesOptions.outputformat =
            this.storedQueriesOptions.outputformat || 'text/xml; subtype=gml/3.1.1';
        this.storedQueriesOptions.srsname =
            this.storedQueriesOptions.srsname || 'EPSG:4326';
        this.storedQueriesOptions.resultTitle =
            this.storedQueriesOptions.resultTitle || this.resultTitle;
    }
    getId() {
        return StoredQueriesReverseSearchSource.id;
    }
    getType() {
        return StoredQueriesReverseSearchSource.type;
    }
    getDefaultOptions() {
        return {
            title: 'Stored Queries (reverse)',
            searchUrl: 'https://ws.mapserver.transports.gouv.qc.ca/swtq'
        };
    }
    /**
     * Search a location by coordinates
     * @param lonLat Location coordinates
     * @param distance Search raidus around lonLat
     * @returns Observable of <SearchResult<Feature>[]
     */
    reverseSearch(lonLat, options) {
        const params = this.computeRequestParams(lonLat, options || {});
        if (new RegExp('.*?gml.*?', 'i').test(this.storedQueriesOptions.outputformat)) {
            return this.http
                .get(this.searchUrl, { params, responseType: 'text' })
                .pipe(map(response => {
                return this.extractResults(this.extractWFSData(response));
            }));
        }
        else {
            return this.http.get(this.searchUrl, { params }).pipe(map(response => {
                return this.extractResults(this.extractWFSData(response));
            }));
        }
    }
    getFormatFromOptions() {
        let olFormatCls;
        const outputFormat = this.storedQueriesOptions.outputformat;
        const patternGml3 = new RegExp('.*?gml.*?', 'i');
        const patternGeojson = new RegExp('.*?json.*?', 'i');
        if (patternGeojson.test(outputFormat)) {
            olFormatCls = olformat.GeoJSON;
        }
        if (patternGml3.test(outputFormat)) {
            olFormatCls = olformat.WFS;
        }
        return new olFormatCls();
    }
    extractWFSData(res) {
        const olFormat = this.getFormatFromOptions();
        const geojson = olformat.GeoJSON;
        const wfsfeatures = olFormat.readFeatures(res);
        const features = JSON.parse(new geojson().writeFeatures(wfsfeatures));
        return features;
    }
    computeRequestParams(lonLat, options) {
        const longLatParams = {};
        longLatParams[this.storedQueriesOptions.longField] = lonLat[0];
        longLatParams[this.storedQueriesOptions.latField] = lonLat[1];
        return new HttpParams({
            fromObject: Object.assign({
                service: 'WFS',
                version: '1.1.0',
                request: 'GetFeature',
                storedquery_id: this.storedQueriesOptions.storedquery_id,
                srsname: this.storedQueriesOptions.srsname,
                outputformat: this.storedQueriesOptions.outputformat
            }, longLatParams, this.params, options.params || {})
        });
    }
    extractResults(response) {
        return response.features.map((data) => {
            return this.dataToResult(data);
        });
    }
    dataToResult(data) {
        const properties = this.computeProperties(data);
        const id = [this.getId(), properties.type, data.id].join('.');
        const title = data.properties[this.storedQueriesOptions.resultTitle]
            ? this.storedQueriesOptions.resultTitle
            : this.resultTitle;
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                properties,
                meta: {
                    id,
                    title: data.properties[title]
                }
            },
            meta: {
                dataType: FEATURE,
                id,
                title: data.properties[title],
                icon: 'map-marker'
            }
        };
    }
    computeProperties(data) {
        const properties = ObjectUtils.removeKeys(data.properties, StoredQueriesReverseSearchSource.propertiesBlacklist);
        const routing = {
            Route: '<span class="routing"> <u>' + this.languageService.translate.instant('igo.geo.seeRouting') + '</u> </span>'
        };
        return Object.assign(properties, { type: data.properties.doc_type }, routing);
    }
}
StoredQueriesReverseSearchSource.id = 'storedqueriesreverse';
StoredQueriesReverseSearchSource.type = FEATURE;
StoredQueriesReverseSearchSource.propertiesBlacklist = [];
StoredQueriesReverseSearchSource.ɵfac = function StoredQueriesReverseSearchSource_Factory(t) { return new (t || StoredQueriesReverseSearchSource)(i0.ɵɵinject(i1$2.HttpClient), i0.ɵɵinject(i2$1.LanguageService), i0.ɵɵinject(i2$1.StorageService), i0.ɵɵinject('options')); };
StoredQueriesReverseSearchSource.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: StoredQueriesReverseSearchSource, factory: StoredQueriesReverseSearchSource.ɵfac });
__decorate([
    Cacheable({
        maxCacheCount: 20
    })
], StoredQueriesReverseSearchSource.prototype, "reverseSearch", null);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(StoredQueriesReverseSearchSource, [{
        type: Injectable
    }], function () { return [{ type: i1$2.HttpClient }, { type: i2$1.LanguageService }, { type: i2$1.StorageService }, { type: undefined, decorators: [{
                type: Inject,
                args: ['options']
            }] }]; }, { reverseSearch: [] }); })();

/**
 * StoredQueries search source factory
 * @ignore
 */
function storedqueriesSearchSourceFactory(http, languageService, storageService, config) {
    return new StoredQueriesSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${StoredQueriesSearchSource.id}`));
}
/**
 * Function that returns a provider for the StoredQueries search source
 */
function provideStoredQueriesSearchSource() {
    return {
        provide: SearchSource,
        useFactory: storedqueriesSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, StorageService, ConfigService]
    };
}
/**
 * StoredQueriesReverse search source factory
 * @ignore
 */
function storedqueriesReverseSearchSourceFactory(http, languageService, storageService, config) {
    return new StoredQueriesReverseSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${StoredQueriesReverseSearchSource.id}`));
}
/**
 * Function that returns a provider for the StoredQueriesReverse search source
 */
function provideStoredQueriesReverseSearchSource() {
    return {
        provide: SearchSource,
        useFactory: storedqueriesReverseSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, StorageService, ConfigService]
    };
}

function getRowsInMapExtent(layerId, storageService) {
    return storageService.get(`workspace.rowsInMapExtent.${layerId}`) || true;
}
function setRowsInMapExtent(value, layerId, storageService) {
    storageService.set(`workspace.rowsInMapExtent.${layerId}`, value, StorageScope.SESSION);
}
function getSelectedOnly(layerId, storageService) {
    return storageService.get(`workspace.selectedOnly.${layerId}`) || false;
}
function setSelectedOnly(value, layerId, storageService) {
    storageService.set(`workspace.selectedOnly.${layerId}`, value, StorageScope.SESSION);
}
function mapExtentStrategyActiveToolTip(ws) {
    return ws.entityStore.getStrategyOfType(EntityStoreFilterCustomFuncStrategy).active$.pipe(map((active) => active ? 'igo.geo.workspace.inMapExtent.active.tooltip' : 'igo.geo.workspace.inMapExtent.inactive.tooltip'));
}
function noElementSelected(ws) {
    return ws.entityStore.stateView.manyBy$((record) => {
        return record.state.selected === true;
    }).pipe(map((entities) => entities.length >= 1));
}

/*
 * Public API Surface of geo
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AddCatalogDialogComponent, ArcGISRestDataSource, BaseLayersSwitcherComponent, CadastreSearchSource, CapabilitiesService, CartoDataSource, Catalog, CatalogBrowserComponent, CatalogFactory, CatalogItemType, CatalogLibaryComponent, CatalogService, ClusterDataSource, CompositeCatalog, ConfirmationPopupComponent, CoordinatesReverseSearchSource, CoordinatesReverseSearchSourceFactory, CoordinatesSearchResultFormatter, DataService, DataSource, DataSourceService, DirectionRelativePositionType, DirectionType, DirectionsButtonsComponent, DirectionsComponent, DirectionsFormat, DirectionsInputsComponent, DirectionsResultsComponent, DirectionsService, DirectionsSource, DownloadButtonComponent, DownloadService, DrawComponent, DrawControl, DrawIconService, DrawStyleService, DropGeoFileDirective, EditionWorkspace, EditionWorkspaceService, EncodingFormat, EsriStyleGenerator, ExportButtonComponent, ExportError, ExportFormat, ExportInvalidFileError, ExportNothingToExportError, ExportService, FEATURE, FeatureDataSource, FeatureDetailsComponent, FeatureDetailsDirective, FeatureFormComponent, FeatureMotion, FeatureStore, FeatureStoreInMapExtentStrategy, FeatureStoreInMapResolutionStrategy, FeatureStoreLoadingLayerStrategy, FeatureStoreLoadingStrategy, FeatureStoreSelectionStrategy, FeatureWorkspace, FeatureWorkspaceService, FilterableDataSourcePipe, GeolocateButtonComponent, GeometryFormFieldComponent, GeometryFormFieldInputComponent, GeometrySliceError, GeometrySliceLineStringError, GeometrySliceMultiPolygonError, GeometrySliceTooManyIntersectionError, GeometryType, GoogleLinks, HomeExtentButtonComponent, HoverFeatureDirective, IChercheReverseSearchSource, IChercheSearchResultFormatter, IChercheSearchSource, ILayerSearchResultFormatter, ILayerSearchSource, IgoCatalogBrowserModule, IgoCatalogLibraryModule, IgoCatalogModule, IgoConfirmationPopupModule, IgoDataSourceModule, IgoDirectionsModule, IgoDownloadModule, IgoDrawModule, IgoDrawingToolModule, IgoFeatureDetailsModule, IgoFeatureFormModule, IgoFeatureModule, IgoFilterModule, IgoGeoModule, IgoGeoWorkspaceModule, IgoGeometryFormFieldModule, IgoGeometryModule, IgoHttpParameterCodec, IgoImportExportModule, IgoLayerModule, IgoMap, IgoMapModule, IgoMeasureModule, IgoMeasurerModule, IgoMetadataModule, IgoOgcFilterModule, IgoOverlayModule, IgoPrintModule, IgoQueryModule, IgoSearchBarModule, IgoSearchModule, IgoSearchResultsModule, IgoSearchSelectorModule, IgoSearchSettingsModule, IgoStyleListModule, IgoToastModule, IgoWktModule, IgoWorkspaceSelectorModule, IgoWorkspaceUpdatorModule, ImageArcGISRestDataSource, ImageLayer, ImageWatcher, ImportError, ImportExportComponent, ImportInvalidFileError, ImportNothingToImportError, ImportOgreServerError, ImportSRSError, ImportService, ImportSizeError, ImportUnreadableFileError, InfoSectionComponent, LAYER, Layer, LayerItemComponent, LayerLegendComponent, LayerLegendItemComponent, LayerLegendListBindingDirective, LayerLegendListComponent, LayerListBindingDirective, LayerListComponent, LayerListControlsEnum, LayerListDisplacement, LayerListSelectVisibleEnum, LayerListToolComponent, LayerListToolControlsEnum, LayerListToolService, LayerService, LayerSyncWatcher, LinkedProperties, MEASURE_UNIT_AUTO, MVTDataSource, MapBrowserComponent, MapCenterComponent, MapController, MapOfflineDirective, MapService, MapViewAction, MapViewController, MeasureAreaUnit, MeasureAreaUnitAbbreviation, MeasureFormatPipe, MeasureLengthUnit, MeasureLengthUnitAbbreviation, MeasureType, MeasurerComponent, MenuButtonComponent, MetadataAbstractComponent, MetadataButtonComponent, MetadataService, MiniBaseMapComponent, ModifyControl, NominatimSearchSource, OGCFilterService, OSMDataSource, OfflineButtonComponent, OgcFilterButtonComponent, OgcFilterComponent, OgcFilterFormComponent, OgcFilterOperator, OgcFilterOperatorType, OgcFilterSelectionComponent, OgcFilterTimeComponent, OgcFilterTimeSliderComponent, OgcFilterWidget, OgcFilterWriter, OgcFilterableFormComponent, OgcFilterableItemComponent, OgcFilterableListBindingDirective, OgcFilterableListComponent, OlDragSelectInteraction, OptionsApiService, OptionsService, OsmLinks, OsrmDirectionsSource, Overlay, OverlayAction, OverlayDirective, OverlayService, PointerPositionDirective, PrintComponent, PrintFormComponent, PrintLegendPosition, PrintOrientation, PrintOutputFormat, PrintPaperFormat, PrintResolution, PrintSaveImageFormat, PrintService, ProjectionService, ProposalType, QueryDirective, QueryFormat, QueryFormatMimeType, QueryHtmlTarget, QuerySearchSource, QueryService, RotationButtonComponent, RoutesFeatureStore, SEARCH_TYPES, STYLELIST_OPTIONS, SearchBarComponent, SearchPointerSummaryDirective, SearchResultAddButtonComponent, SearchResultMode, SearchResultsComponent, SearchResultsItemComponent, SearchSelectorComponent, SearchService, SearchSettingsComponent, SearchSource, SearchSourceService, SliceControl, SourceDirectionsType, SpatialFilterItemComponent, SpatialFilterItemType, SpatialFilterListComponent, SpatialFilterQueryType, SpatialFilterService, SpatialFilterType, SpatialFilterTypeComponent, StepFeatureStore, StopsFeatureStore, StopsStore, StoredQueriesReverseSearchSource, StoredQueriesSearchSource, StyleListService, StyleService, SwipeControlComponent, TileArcGISRestDataSource, TileDebugDataSource, TileLayer, TileWatcher, TimeFilterButtonComponent, TimeFilterFormComponent, TimeFilterItemComponent, TimeFilterListBindingDirective, TimeFilterListComponent, TimeFilterService, TimeFilterStyle, TimeFilterType, ToastComponent, TooltipType, TrackFeatureButtonComponent, TypeCapabilities, TypeCatalog, VectorLayer, VectorTileLayer, VectorWatcher, WFSDataSource, WFSService, WMSDataSource, WMTSDataSource, WebSocketDataSource, WfsWorkspace, WfsWorkspaceService, WktService, WorkspaceSelectorDirective, WorkspaceUpdatorDirective, XYZDataSource, ZoomButtonComponent, addDirectionToRoutesFeatureStore, addLayerAndFeaturesStyledToMap, addLayerAndFeaturesToMap, addLinearRingToOlPolygon, addStopToStopsFeatureStore, addStopToStore, buildUrl, cadastreSearchSourceFactory, checkWfsParams, clearOlGeometryMidpoints, computeBestAreaUnit, computeBestLengthUnit, computeLayerTitleFromFile, computeMVTOptionsOnHover, computeOlFeatureExtent, computeOlFeaturesDiff, computeOlFeaturesExtent, computeProjectionsConstraints, computeRelativePosition, computeStopsPosition, computeTermSimilarity, convertDDToDMS, createDefaultTileGrid, createDrawHoleInteractionStyle, createDrawInteractionStyle, createInteractionStyle, createMeasureInteractionStyle, createMeasureLayerStyle, createOlTooltipAtPoint, createOlTooltipDrawAtPoint, createOverlayDefaultStyle, createOverlayLayer, createOverlayMarkerStyle, ctrlKeyDown, defaultCoordinatesSearchResultFormatterFactory, defaultEpsg, defaultFieldNameGeometry, defaultIChercheSearchResultFormatterFactory, defaultMaxFeatures, defaultWfsVersion, directionsStyle, entitiesToRowData, exportToCSV, featureFromOl, featureToOl, featureToSearchResult, featuresAreOutOfView, featuresAreTooDeepInView, findDiff, formatDistance, formatDuration, formatInstruction, formatMeasure, formatScale, formatWFSQueryString, generateArcgisRestIdFromSourceOptions, generateFeatureIdFromSourceOptions, generateId, generateIdFromSourceOptions, generateWMSIdFromSourceOptions, generateWMTSIdFromSourceOptions, generateWfsIdFromSourceOptions, generateXYZIdFromSourceOptions, getCommonVectorSelectedStyle, getCommonVectorStyle, getFileExtension, getFormatFromOptions, getLayersLegends, getMousePositionFromOlGeometryEvent, getOlTooltipAtCenter, getOlTooltipsAtMidpoints, getResolutionFromScale, getRowsInMapExtent, getScaleFromResolution, getSelectedOnly, getTooltipsOfOlGeometry, gmlRegex, handleFileExportError, handleFileExportSuccess, handleFileImportError, handleFileImportSuccess, handleInvalidFileImportError, handleNothingToExportError, handleNothingToImportError, handleOgreServerImportError, handleSRSImportError, handleSizeFileImportError, handleUnreadbleFileImportError, hideOlFeature, hoverFeatureMarker, ichercheReverseSearchSourceFactory, ichercheSearchSourceFactory, ilayerSearchResultFormatterFactory, ilayerSearchSourceFactory, initRoutesFeatureStore, initStepFeatureStore, initStopsFeatureStore, jsonRegex, layerFeatureIsQueryable, layerIsQueryable, lonLatConversion, mapExtentStrategyActiveToolTip, measureOlGeometry, measureOlGeometryArea, measureOlGeometryLength, metersToFeet, metersToKilometers, metersToMiles, metersToUnit, moveToOlFeatures, mtmZoneFromLonLat, noElementSelected, nominatimSearchSourceFactory, ogcFilterWidgetFactory, olLayerFeatureIsQueryable, olLayerIsQueryable, optionsApiFactory, osrmDirectionsSourcesFactory, pointerPositionSummaryMarker, provideCadastreSearchSource, provideCoordinatesReverseSearchSource, provideDefaultCoordinatesSearchResultFormatter, provideDefaultIChercheSearchResultFormatter, provideIChercheReverseSearchSource, provideIChercheSearchSource, provideILayerSearchResultFormatter, provideILayerSearchSource, provideNominatimSearchSource, provideOgcFilterWidget, provideOptionsApi, provideOsrmDirectionsSource, provideSearchSourceService, provideStoredQueriesReverseSearchSource, provideStoredQueriesSearchSource, provideStyleListLoader, provideStyleListOptions, removeStopFromStore, renderFeatureFromOl, roundCoordTo, scaleExtent, searchSourceServiceFactory, setRowsInMapExtent, setSelectedOnly, sliceOlGeometry, sliceOlLineString, sliceOlPolygon, sourceCanReverseSearch, sourceCanReverseSearchAsSummary, sourceCanSearch, squareMetersToAcres, squareMetersToHectares, squareMetersToSquareFeet, squareMetersToSquareKilometers, squareMetersToSquareMiles, squareMetersToUnit, standardizeUrl, storedqueriesReverseSearchSourceFactory, storedqueriesSearchSourceFactory, stringToLonLat, styleListFactory, translateBearing, translateModifier, tryAddLoadingStrategy, tryAddSelectionStrategy, tryBindStoreLayer, updateOlGeometryCenter, updateOlGeometryMidpoints, updateOlTooltipAtCenter, updateOlTooltipDrawAtCenter, updateOlTooltipsAtMidpoints, updateOlTooltipsDrawAtMidpoints, updateStoreSorting, utmZoneFromLonLat, viewStatesAreEqual, zoneMtm, zoneUtm };
//# sourceMappingURL=igo2-geo.js.map
