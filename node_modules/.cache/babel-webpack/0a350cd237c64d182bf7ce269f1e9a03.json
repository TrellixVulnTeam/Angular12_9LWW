{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/geom/MultiLineString\n */\n\n\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { douglasPeuckerArray } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { interpolatePoint, lineStringsCoordinateAtM } from './flat/interpolate.js';\nimport { intersectsLineStringArray } from './flat/intersectsextent.js';\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\n\nvar MultiLineString = function (_super) {\n  __extends(MultiLineString, _super);\n  /**\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n   *     combination with `opt_layout` and `opt_ends` are also accepted.)\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.\n   */\n\n\n  function MultiLineString(coordinates, opt_layout, opt_ends) {\n    var _this = _super.call(this) || this;\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n\n    _this.ends_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      _this.setCoordinates(coordinates, opt_layout);\n    } else if (opt_layout !== undefined && opt_ends) {\n      _this.setFlatCoordinates(opt_layout, coordinates);\n\n      _this.ends_ = opt_ends;\n    } else {\n      var layout = _this.getLayout();\n\n      var lineStrings = coordinates;\n      var flatCoordinates = [];\n      var ends = [];\n\n      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n        var lineString = lineStrings[i];\n\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n\n      _this.setFlatCoordinates(layout, flatCoordinates);\n\n      _this.ends_ = ends;\n    }\n\n    return _this;\n  }\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n\n\n  MultiLineString.prototype.appendLineString = function (lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @api\n   */\n\n\n  MultiLineString.prototype.clone = function () {\n    var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n\n\n  MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `opt_interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `opt_interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n   * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n\n\n  MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {\n    if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM || this.flatCoordinates.length === 0) {\n      return null;\n    }\n\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n    return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n  };\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n\n\n  MultiLineString.prototype.getCoordinates = function () {\n    return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n  };\n  /**\n   * @return {Array<number>} Ends.\n   */\n\n\n  MultiLineString.prototype.getEnds = function () {\n    return this.ends_;\n  };\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n\n\n  MultiLineString.prototype.getLineString = function (index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n\n    return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n\n\n  MultiLineString.prototype.getLineStrings = function () {\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var layout = this.layout;\n    /** @type {Array<LineString>} */\n\n    var lineStrings = [];\n    var offset = 0;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n      lineStrings.push(lineString);\n      offset = end;\n    }\n\n    return lineStrings;\n  };\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n\n\n  MultiLineString.prototype.getFlatMidpoints = function () {\n    var midpoints = [];\n    var flatCoordinates = this.flatCoordinates;\n    var offset = 0;\n    var ends = this.ends_;\n    var stride = this.stride;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n\n    return midpoints;\n  };\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiLineString} Simplified MultiLineString.\n   * @protected\n   */\n\n\n  MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   * @api\n   */\n\n\n  MultiLineString.prototype.getType = function () {\n    return GeometryType.MULTI_LINE_STRING;\n  };\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n\n\n  MultiLineString.prototype.intersectsExtent = function (extent) {\n    return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n  };\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {GeometryLayout} [opt_layout] Layout.\n   * @api\n   */\n\n\n  MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return MultiLineString;\n}(SimpleGeometry);\n\nexport default MultiLineString;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/geom/MultiLineString.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","GeometryLayout","GeometryType","LineString","SimpleGeometry","arrayMaxSquaredDelta","assignClosestArrayPoint","closestSquaredDistanceXY","deflateCoordinatesArray","douglasPeuckerArray","extend","inflateCoordinatesArray","interpolatePoint","lineStringsCoordinateAtM","intersectsLineStringArray","MultiLineString","_super","coordinates","opt_layout","opt_ends","_this","ends_","maxDelta_","maxDeltaRevision_","isArray","setCoordinates","undefined","setFlatCoordinates","layout","getLayout","lineStrings","flatCoordinates","ends","i","ii","length","lineString","getFlatCoordinates","push","appendLineString","slice","changed","clone","multiLineString","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","getCoordinateAtM","m","opt_extrapolate","opt_interpolate","XYM","XYZM","extrapolate","interpolate","getCoordinates","getEnds","getLineString","index","getLineStrings","offset","end","getFlatMidpoints","midpoints","midpoint","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEnds","XY","getType","MULTI_LINE_STRING","intersectsExtent","extent","setLayout"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiLineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { douglasPeuckerArray } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { interpolatePoint, lineStringsCoordinateAtM, } from './flat/interpolate.js';\nimport { intersectsLineStringArray } from './flat/intersectsextent.js';\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /** @class */ (function (_super) {\n    __extends(MultiLineString, _super);\n    /**\n     * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n     *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n     *     combination with `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.\n     */\n    function MultiLineString(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (Array.isArray(coordinates[0])) {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        else if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            var layout = _this.getLayout();\n            var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n            var flatCoordinates = [];\n            var ends = [];\n            for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n                var lineString = lineStrings[i];\n                if (i === 0) {\n                    layout = lineString.getLayout();\n                }\n                extend(flatCoordinates, lineString.getFlatCoordinates());\n                ends.push(flatCoordinates.length);\n            }\n            _this.setFlatCoordinates(layout, flatCoordinates);\n            _this.ends_ = ends;\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linestring to the multilinestring.\n     * @param {LineString} lineString LineString.\n     * @api\n     */\n    MultiLineString.prototype.appendLineString = function (lineString) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = lineString.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiLineString} Clone.\n     * @api\n     */\n    MultiLineString.prototype.clone = function () {\n        var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        multiLineString.applyProperties(this);\n        return multiLineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * `opt_interpolate` controls interpolation between consecutive LineStrings\n     * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n     * will be linearly interpolated between the last coordinate of one LineString\n     * and the first coordinate of the next LineString.  If `opt_interpolate` is\n     * `false` then the function will return `null` for Ms falling between\n     * LineStrings.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {\n        if ((this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) ||\n            this.flatCoordinates.length === 0) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n        return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n    };\n    /**\n     * Return the coordinates of the multilinestring.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinates = function () {\n        return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    MultiLineString.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * Return the linestring at the specified index.\n     * @param {number} index Index.\n     * @return {LineString} LineString.\n     * @api\n     */\n    MultiLineString.prototype.getLineString = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linestrings of this multilinestring.\n     * @return {Array<LineString>} LineStrings.\n     * @api\n     */\n    MultiLineString.prototype.getLineStrings = function () {\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var layout = this.layout;\n        /** @type {Array<LineString>} */\n        var lineStrings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n            lineStrings.push(lineString);\n            offset = end;\n        }\n        return lineStrings;\n    };\n    /**\n     * @return {Array<number>} Flat midpoints.\n     */\n    MultiLineString.prototype.getFlatMidpoints = function () {\n        var midpoints = [];\n        var flatCoordinates = this.flatCoordinates;\n        var offset = 0;\n        var ends = this.ends_;\n        var stride = this.stride;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n            extend(midpoints, midpoint);\n            offset = end;\n        }\n        return midpoints;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiLineString} Simplified MultiLineString.\n     * @protected\n     */\n    MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    MultiLineString.prototype.getType = function () {\n        return GeometryType.MULTI_LINE_STRING;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiLineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multilinestring.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {GeometryLayout} [opt_layout] Layout.\n     * @api\n     */\n    MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return MultiLineString;\n}(SimpleGeometry));\nexport default MultiLineString;\n"]},"metadata":{},"sourceType":"module"}