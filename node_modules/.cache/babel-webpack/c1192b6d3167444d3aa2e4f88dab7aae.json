{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/Map\n */\n\n\nimport Disposable from '../Disposable.js';\nimport { TRUE } from '../functions.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, makeInverse } from '../transform.js';\nimport { getWidth } from '../extent.js';\nimport { shared as iconImageCache } from '../style/IconImageCache.js';\nimport { inView } from '../layer/Layer.js';\nimport { wrapX } from '../coordinate.js';\n/**\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n * @template T\n */\n\n/**\n * @abstract\n */\n\nvar MapRenderer = function (_super) {\n  __extends(MapRenderer, _super);\n  /**\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n\n\n  function MapRenderer(map) {\n    var _this = _super.call(this) || this;\n    /**\n     * @private\n     * @type {import(\"../PluggableMap.js\").default}\n     */\n\n\n    _this.map_ = map;\n    return _this;\n  }\n  /**\n   * @abstract\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   */\n\n\n  MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {\n    abstract();\n  };\n  /**\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @protected\n   */\n\n\n  MapRenderer.prototype.calculateMatrices2D = function (frameState) {\n    var viewState = frameState.viewState;\n    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n    composeTransform(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  };\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n\n\n  MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {\n    var result;\n    var viewState = frameState.viewState;\n    /**\n     * @param {boolean} managed Managed layer.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../layer/Layer.js\").default} layer Layer.\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n\n    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n      return callback.call(thisArg, feature, managed ? layer : null, geometry);\n    }\n\n    var projection = viewState.projection;\n    var translatedCoordinate = wrapX(coordinate.slice(), projection);\n    var offsets = [[0, 0]];\n\n    if (projection.canWrapX() && checkWrapped) {\n      var projectionExtent = projection.getExtent();\n      var worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n\n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n    var matches = [];\n    var tmpCoord = [];\n\n    for (var i = 0; i < offsets.length; i++) {\n      for (var j = numLayers - 1; j >= 0; --j) {\n        var layerState = layerStates[j];\n        var layer = layerState.layer;\n\n        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {\n          var layerRenderer = layer.getRenderer();\n          var source = layer.getSource();\n\n          if (layerRenderer && source) {\n            var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;\n            var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);\n            tmpCoord[0] = coordinates[0] + offsets[i][0];\n            tmpCoord[1] = coordinates[1] + offsets[i][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);\n          }\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n\n    if (matches.length === 0) {\n      return undefined;\n    }\n\n    var order = 1 / matches.length;\n    matches.forEach(function (m, i) {\n      return m.distanceSq += i * order;\n    });\n    matches.sort(function (a, b) {\n      return a.distanceSq - b.distanceSq;\n    });\n    matches.some(function (m) {\n      return result = m.callback(m.feature, m.layer, m.geometry);\n    });\n    return result;\n  };\n  /**\n   * @abstract\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n   *     callback.\n   * @param {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {\n    return abstract();\n  };\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n\n\n  MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {\n    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);\n    return hasFeature !== undefined;\n  };\n  /**\n   * @return {import(\"../PluggableMap.js\").default} Map.\n   */\n\n\n  MapRenderer.prototype.getMap = function () {\n    return this.map_;\n  };\n  /**\n   * Render.\n   * @abstract\n   * @param {?import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   */\n\n\n  MapRenderer.prototype.renderFrame = function (frameState) {\n    abstract();\n  };\n  /**\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {\n    if (iconImageCache.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  };\n\n  return MapRenderer;\n}(Disposable);\n/**\n * @param {import(\"../PluggableMap.js\").default} map Map.\n * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n */\n\n\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\n\nexport default MapRenderer;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/renderer/Map.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","Disposable","TRUE","abstract","compose","composeTransform","makeInverse","getWidth","shared","iconImageCache","inView","wrapX","MapRenderer","_super","map","_this","map_","dispatchRenderEvent","type","frameState","calculateMatrices2D","viewState","coordinateToPixelTransform","pixelToCoordinateTransform","size","resolution","rotation","center","forEachFeatureAtCoordinate","coordinate","hitTolerance","checkWrapped","callback","thisArg","layerFilter","thisArg2","result","managed","feature","layer","geometry","projection","translatedCoordinate","slice","offsets","canWrapX","projectionExtent","getExtent","worldWidth","push","layerStates","layerStatesArray","numLayers","length","matches","tmpCoord","i","j","layerState","hasRenderer","layerRenderer","getRenderer","source","getSource","coordinates","getWrapX","callback_1","bind","undefined","order","forEach","m","distanceSq","sort","a","some","forEachLayerAtPixel","pixel","hasFeatureAtCoordinate","hasFeature","getMap","renderFrame","scheduleExpireIconCache","canExpireCache","postRenderFunctions","expireIconCache","expire"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/Map\n */\nimport Disposable from '../Disposable.js';\nimport { TRUE } from '../functions.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, makeInverse } from '../transform.js';\nimport { getWidth } from '../extent.js';\nimport { shared as iconImageCache } from '../style/IconImageCache.js';\nimport { inView } from '../layer/Layer.js';\nimport { wrapX } from '../coordinate.js';\n/**\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n * @template T\n */\n/**\n * @abstract\n */\nvar MapRenderer = /** @class */ (function (_super) {\n    __extends(MapRenderer, _super);\n    /**\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     */\n    function MapRenderer(map) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../PluggableMap.js\").default}\n         */\n        _this.map_ = map;\n        return _this;\n    }\n    /**\n     * @abstract\n     * @param {import(\"../render/EventType.js\").default} type Event type.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     */\n    MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {\n        abstract();\n    };\n    /**\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n     * @protected\n     */\n    MapRenderer.prototype.calculateMatrices2D = function (frameState) {\n        var viewState = frameState.viewState;\n        var coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n        var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n        composeTransform(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n        makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n    };\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {boolean} checkWrapped Check for wrapped geometries.\n     * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {S} thisArg Value to use as `this` when executing `callback`.\n     * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n     *     function, only layers which are visible and for which this function\n     *     returns `true` will be tested for features.  By default, all visible\n     *     layers will be tested.\n     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n     * @return {T|undefined} Callback result.\n     * @template S,T,U\n     */\n    MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {\n        var result;\n        var viewState = frameState.viewState;\n        /**\n         * @param {boolean} managed Managed layer.\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n         * @return {T|undefined} Callback result.\n         */\n        function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n            return callback.call(thisArg, feature, managed ? layer : null, geometry);\n        }\n        var projection = viewState.projection;\n        var translatedCoordinate = wrapX(coordinate.slice(), projection);\n        var offsets = [[0, 0]];\n        if (projection.canWrapX() && checkWrapped) {\n            var projectionExtent = projection.getExtent();\n            var worldWidth = getWidth(projectionExtent);\n            offsets.push([-worldWidth, 0], [worldWidth, 0]);\n        }\n        var layerStates = frameState.layerStatesArray;\n        var numLayers = layerStates.length;\n        var matches = /** @type {Array<HitMatch<T>>} */ ([]);\n        var tmpCoord = [];\n        for (var i = 0; i < offsets.length; i++) {\n            for (var j = numLayers - 1; j >= 0; --j) {\n                var layerState = layerStates[j];\n                var layer = layerState.layer;\n                if (layer.hasRenderer() &&\n                    inView(layerState, viewState) &&\n                    layerFilter.call(thisArg2, layer)) {\n                    var layerRenderer = layer.getRenderer();\n                    var source = layer.getSource();\n                    if (layerRenderer && source) {\n                        var coordinates = source.getWrapX()\n                            ? translatedCoordinate\n                            : coordinate;\n                        var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);\n                        tmpCoord[0] = coordinates[0] + offsets[i][0];\n                        tmpCoord[1] = coordinates[1] + offsets[i][1];\n                        result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);\n                    }\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n        }\n        if (matches.length === 0) {\n            return undefined;\n        }\n        var order = 1 / matches.length;\n        matches.forEach(function (m, i) { return (m.distanceSq += i * order); });\n        matches.sort(function (a, b) { return a.distanceSq - b.distanceSq; });\n        matches.some(function (m) {\n            return (result = m.callback(m.feature, m.layer, m.geometry));\n        });\n        return result;\n    };\n    /**\n     * @abstract\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n     *     callback.\n     * @param {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} layerFilter Layer filter\n     *     function, only layers which are visible and for which this function\n     *     returns `true` will be tested for features.  By default, all visible\n     *     layers will be tested.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {\n        return abstract();\n    };\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {boolean} checkWrapped Check for wrapped geometries.\n     * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n     *     function, only layers which are visible and for which this function\n     *     returns `true` will be tested for features.  By default, all visible\n     *     layers will be tested.\n     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n     * @return {boolean} Is there a feature at the given coordinate?\n     * @template U\n     */\n    MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {\n        var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);\n        return hasFeature !== undefined;\n    };\n    /**\n     * @return {import(\"../PluggableMap.js\").default} Map.\n     */\n    MapRenderer.prototype.getMap = function () {\n        return this.map_;\n    };\n    /**\n     * Render.\n     * @abstract\n     * @param {?import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     */\n    MapRenderer.prototype.renderFrame = function (frameState) {\n        abstract();\n    };\n    /**\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {\n        if (iconImageCache.canExpireCache()) {\n            frameState.postRenderFunctions.push(expireIconCache);\n        }\n    };\n    return MapRenderer;\n}(Disposable));\n/**\n * @param {import(\"../PluggableMap.js\").default} map Map.\n * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n */\nfunction expireIconCache(map, frameState) {\n    iconImageCache.expire();\n}\nexport default MapRenderer;\n"]},"metadata":{},"sourceType":"module"}