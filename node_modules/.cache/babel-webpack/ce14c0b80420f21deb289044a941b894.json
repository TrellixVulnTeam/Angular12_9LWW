{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\n\n\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport ReplayType from '../../render/canvas/BuilderType.js';\nimport TileState from '../../TileState.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport ViewHint from '../../ViewHint.js';\nimport { HIT_DETECT_RESOLUTION, createHitDetectionImageData, hitDetect } from '../../render/canvas/hitdetect.js';\nimport { apply as applyTransform, create as createTransform, multiply, reset as resetTransform, scale, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { boundingExtent, buffer, containsExtent, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\nimport { wrapX } from '../../coordinate.js';\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\n\nvar IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING],\n  'vector': []\n};\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\n\nvar VECTOR_REPLAYS = {\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT]\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\n\nvar CanvasVectorTileLayerRenderer = function (_super) {\n  __extends(CanvasVectorTileLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n\n\n  function CanvasVectorTileLayerRenderer(layer) {\n    var _this = _super.call(this, layer) || this;\n    /** @private */\n\n\n    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.renderedLayerRevision_;\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n\n    _this.renderedPixelToCoordinateTransform_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.renderedRotation_;\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    _this.tmpTransform_ = createTransform();\n    return _this;\n  }\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection) {\n    var render;\n    var state = tile.getState();\n\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n\n      if (this.tileImageNeedsRender_(tile)) {\n        render = true;\n      }\n    }\n\n    return render;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var resolution = viewState.resolution;\n    var projection = viewState.projection;\n    var layer = this.getLayer();\n    var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n\n    var render = this.prepareTile(tile, pixelRatio, projection);\n\n    if (render && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== VectorTileRenderType.VECTOR) {\n      this.renderTileImage_(tile, frameState);\n    }\n\n    return _super.prototype.getTile.call(this, z, x, y, frameState);\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    var layer = this.getLayer();\n    return _super.prototype.isDrawableTile.call(this, tile) && (layer.getRenderMode() === VectorTileRenderType.VECTOR ? getUid(layer) in tile.executorGroups : tile.hasContext(layer));\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage(this.getLayer());\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    var layerRevision = this.getLayer().getRevision();\n\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n\n    this.renderedLayerRevision_ = layerRevision;\n    return _super.prototype.prepareFrame.call(this, frameState);\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {\n    var layer = this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder = layer.getRenderOrder() || null;\n    var resolution = tile.wantedResolution;\n    var builderState = tile.getReplayState(layer);\n\n    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n\n    var source = layer.getSource();\n    var declutter = layer.getDeclutter();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    var layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n\n    if (declutter) {\n      tile.declutterExecutorGroups[layerUid] = [];\n    }\n\n    var _loop_1 = function (t, tt) {\n      var sourceTile = sourceTiles[t];\n\n      if (sourceTile.getState() != TileState.LOADED) {\n        return \"continue\";\n      }\n\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      var builderExtent = buffer(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);\n      var bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : builderExtent;\n      builderState.dirty = false;\n      var builderGroup = new CanvasBuilderGroup(0, builderExtent, resolution, pixelRatio);\n      var declutterBuilderGroup = declutter ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio) : undefined;\n      var squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n\n      var render = function (feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      var features = sourceTile.getFeatures();\n\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        var feature = features[i];\n\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this_1, feature);\n        }\n      }\n\n      var executorGroupInstructions = builderGroup.finish(); // no need to clip when the render tile is covered by a single source tile\n\n      var replayExtent = layer.getRenderMode() !== VectorTileRenderType.VECTOR && declutter && sourceTiles.length === 1 ? null : sharedExtent;\n      var renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n\n      if (declutterBuilderGroup) {\n        var declutterExecutorGroup = new CanvasExecutorGroup(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());\n        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      _loop_1(t, tt);\n    }\n\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer = this.getLayer();\n    var source = layer.getSource();\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n\n    var features = {};\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n\n    var featureCallback = function (feature, geometry, distanceSq) {\n      var key = feature.getId();\n\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n\n      var match = features[key];\n\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n\n        matches.push(features[key] = {\n          feature: feature,\n          layer: layer,\n          geometry: geometry,\n          distanceSq: distanceSq,\n          callback: callback\n        });\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n\n      return undefined;\n    };\n\n    var renderedTiles = this.renderedTiles;\n    var found;\n\n    var _loop_2 = function (i, ii) {\n      var tile = renderedTiles[i];\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n      if (!intersects(tileExtent, hitExtent)) {\n        return \"continue\";\n      }\n\n      var layerUid = getUid(layer);\n      var executorGroups = [tile.executorGroups[layerUid]];\n      var declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n\n      if (declutterExecutorGroups) {\n        executorGroups.push(declutterExecutorGroups);\n      }\n\n      executorGroups.some(function (executorGroups) {\n        var declutteredFeatures = executorGroups === declutterExecutorGroups ? frameState.declutterTree.all().map(function (item) {\n          return item.value;\n        }) : null;\n\n        for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n          var executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);\n\n          if (found) {\n            return true;\n          }\n        }\n      });\n    };\n\n    for (var i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      _loop_2(i, ii);\n    }\n\n    return found;\n  };\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getFeatures = function (pixel) {\n    return new Promise(function (resolve, reject) {\n      var layer = this.getLayer();\n      var layerUid = getUid(layer);\n      var source = layer.getSource();\n      var projection = this.renderedProjection;\n      var projectionExtent = projection.getExtent();\n      var resolution = this.renderedResolution;\n      var tileGrid = source.getTileGridForProjection(projection);\n      var coordinate = applyTransform(this.renderedPixelToCoordinateTransform_, pixel.slice());\n      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n      var tile;\n\n      for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {\n          tile = this.renderedTiles[i];\n\n          if (tile.getState() === TileState.LOADED) {\n            var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);\n\n            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent_1)) {\n              wrapX(coordinate, projection);\n            }\n\n            break;\n          }\n\n          tile = undefined;\n        }\n      }\n\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n\n      var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var corner = getTopLeft(extent);\n      var tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];\n      var features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      var hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n\n      if (!hitDetectionImageData && !this.animatingOrInteracting_) {\n        var tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));\n        var rotation = this.renderedRotation_;\n        var transforms = [this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0)];\n        hitDetectionImageData = createHitDetectionImageData(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    }.bind(this));\n  };\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderDeclutter = function (frameState) {\n    var context = this.context;\n    var alpha = context.globalAlpha;\n    context.globalAlpha = this.getLayer().getOpacity();\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    var tiles = this.renderedTiles;\n\n    for (var i = 0, ii = tiles.length; i < ii; ++i) {\n      var tile = tiles[i];\n      var declutterExecutorGroups = tile.declutterExecutorGroups[getUid(this.getLayer())];\n\n      if (declutterExecutorGroups) {\n        for (var j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n          declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, undefined, frameState.declutterTree);\n        }\n      }\n    }\n\n    context.globalAlpha = alpha;\n  };\n\n  CanvasVectorTileLayerRenderer.prototype.getTileRenderTransform = function (tile, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var center = viewState.center;\n    var resolution = viewState.resolution;\n    var rotation = viewState.rotation;\n    var size = frameState.size;\n    var width = Math.round(size[0] * pixelRatio);\n    var height = Math.round(size[1] * pixelRatio);\n    var source = this.getLayer().getSource();\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var tileCoord = tile.tileCoord;\n    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    var transform = multiply(scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n    return transform;\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n\n    _super.prototype.renderFrame.call(this, frameState, target);\n\n    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    var layer = this.getLayer();\n    var renderMode = layer.getRenderMode();\n    var context = this.context;\n    var alpha = context.globalAlpha;\n    context.globalAlpha = layer.getOpacity();\n    var replayTypes = VECTOR_REPLAYS[renderMode];\n    var viewState = frameState.viewState;\n    var rotation = viewState.rotation;\n    var tiles = this.renderedTiles;\n    var clips = [];\n    var clipZs = [];\n\n    for (var i = tiles.length - 1; i >= 0; --i) {\n      var tile = tiles[i];\n      var transform = this.getTileRenderTransform(tile, frameState);\n      var executorGroups = tile.executorGroups[getUid(layer)];\n      var clipped = false;\n\n      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n        var executorGroup = executorGroups[t];\n\n        if (!executorGroup.hasExecutors(replayTypes)) {\n          // sourceTile has no instructions of the types we want to render\n          continue;\n        }\n\n        var currentZ = tile.tileCoord[0];\n        var currentClip = void 0;\n\n        if (!clipped) {\n          currentClip = executorGroup.getClipCoords(transform);\n\n          if (currentClip) {\n            context.save(); // Create a clip mask for regions in this low resolution tile that are\n            // already filled by a higher resolution tile\n\n            for (var j = 0, jj = clips.length; j < jj; ++j) {\n              var clip = clips[j];\n\n              if (currentZ < clipZs[j]) {\n                context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n                context.moveTo(currentClip[0], currentClip[1]);\n                context.lineTo(currentClip[2], currentClip[3]);\n                context.lineTo(currentClip[4], currentClip[5]);\n                context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile\n\n                context.moveTo(clip[6], clip[7]);\n                context.lineTo(clip[4], clip[5]);\n                context.lineTo(clip[2], clip[3]);\n                context.lineTo(clip[0], clip[1]);\n                context.clip();\n              }\n            }\n          }\n        }\n\n        executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);\n\n        if (!clipped && currentClip) {\n          context.restore();\n          clips.push(currentClip);\n          clipZs.push(currentZ);\n          clipped = true;\n        }\n      }\n    }\n\n    context.globalAlpha = alpha;\n    return this.container;\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder group for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_declutterBuilderGroup) {\n    if (!styles) {\n      return false;\n    }\n\n    var loading = false;\n\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup) || loading;\n      }\n    } else {\n      loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup);\n    }\n\n    return loading;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile) {\n    var layer = this.getLayer();\n\n    if (layer.getRenderMode() === VectorTileRenderType.VECTOR) {\n      return false;\n    }\n\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var resolution = tile.wantedResolution;\n    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {\n    var layer = this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n    var tileCoord = tile.wrappedTileCoord;\n    var z = tileCoord[0];\n    var source = layer.getSource();\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;\n    var resolution = tileGrid.getResolution(z);\n    var context = tile.getContext(layer); // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n\n    pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));\n    var size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    var renderScale = pixelRatio / renderPixelRatio;\n\n    if (renderScale !== 1) {\n      var canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var pixelScale = renderPixelRatio / resolution;\n    var transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n\n    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n      var executorGroup = executorGroups[i];\n      executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n    }\n\n    replayState.renderedTileResolution = tile.wantedResolution;\n  };\n\n  return CanvasVectorTileLayerRenderer;\n}(CanvasTileLayerRenderer);\n\nexport default CanvasVectorTileLayerRenderer;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/renderer/canvas/VectorTileLayer.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","CanvasBuilderGroup","CanvasExecutorGroup","CanvasTileLayerRenderer","ReplayType","TileState","VectorTileRenderType","ViewHint","HIT_DETECT_RESOLUTION","createHitDetectionImageData","hitDetect","apply","applyTransform","createTransform","multiply","reset","resetTransform","scale","scaleTransform","translate","translateTransform","boundingExtent","buffer","containsExtent","equals","getIntersection","getTopLeft","intersects","getSquaredTolerance","getSquaredRenderTolerance","renderFeature","getUid","toSize","wrapX","IMAGE_REPLAYS","POLYGON","CIRCLE","LINE_STRING","IMAGE","TEXT","VECTOR_REPLAYS","DEFAULT","CanvasVectorTileLayerRenderer","_super","layer","_this","boundHandleStyleImageChange_","handleStyleImageChange_","bind","dirty_","renderedLayerRevision_","renderedPixelToCoordinateTransform_","renderedRotation_","tmpTransform_","prepareTile","tile","pixelRatio","projection","render","state","getState","LOADED","ERROR","updateExecutorGroup_","tileImageNeedsRender_","getTile","z","x","y","frameState","viewState","resolution","getLayer","getSource","viewHints","hifi","ANIMATING","INTERACTING","wantedResolution","Date","now","time","getRenderMode","VECTOR","renderTileImage_","isDrawableTile","executorGroups","hasContext","getTileImage","getImage","prepareFrame","layerRevision","getRevision","renderedTiles","length","revision","renderOrder","getRenderOrder","builderState","getReplayState","dirty","renderedResolution","renderedRevision","renderedRenderOrder","source","declutter","getDeclutter","sourceTileGrid","getTileGrid","tileGrid","getTileGridForProjection","tileExtent","getTileCoordExtent","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","declutterExecutorGroups","_loop_1","t","tt","sourceTile","sourceTileCoord","tileCoord","sourceTileExtent","sharedExtent","builderExtent","getRenderBuffer","this_1","tmpExtent","bufferedExtent","builderGroup","declutterBuilderGroup","undefined","squaredTolerance","feature","styles","styleFunction","getStyleFunction","features","getFeatures","sort","i","ii","getGeometry","getExtent","executorGroupInstructions","finish","replayExtent","renderingReplayGroup","getOverlaps","push","declutterExecutorGroup","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","matches","rotation","hitExtent","featureCallback","geometry","distanceSq","key","getId","match","splice","lastIndexOf","found","_loop_2","some","declutteredFeatures","declutterTree","all","map","item","value","executorGroup","pixel","Promise","resolve","reject","renderedProjection","projectionExtent","slice","getTileCoordForCoordAndResolution","toString","extent_1","getWrapX","canWrapX","loadingSourceTiles","extent","corner","tilePixel","reduce","accumulator","concat","animatingOrInteracting_","tileSize","getTileSize","getZForResolution","transforms","getRenderTransform","getTileCoordCenter","handleFontsChanged","getVisible","changed","event","renderIfReadyAndVisible","renderDeclutter","context","alpha","globalAlpha","getOpacity","tiles","j","execute","getTileRenderTransform","center","size","width","Math","round","height","worldOffset","transform","inversePixelTransform","renderFrame","target","pixelToCoordinateTransform","renderMode","replayTypes","clips","clipZs","clipped","hasExecutors","currentZ","currentClip","getClipCoords","save","jj","clip","beginPath","moveTo","lineTo","restore","container","opt_declutterBuilderGroup","loading","isArray","replayState","renderedTileResolution","renderedTileRevision","tileResolution","getResolution","renderPixelRatio","getContext","max","getTilePixelSize","canvas","renderScale","canvasTransform","setTransform","pixelScale"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport ReplayType from '../../render/canvas/BuilderType.js';\nimport TileState from '../../TileState.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport ViewHint from '../../ViewHint.js';\nimport { HIT_DETECT_RESOLUTION, createHitDetectionImageData, hitDetect, } from '../../render/canvas/hitdetect.js';\nimport { apply as applyTransform, create as createTransform, multiply, reset as resetTransform, scale, scale as scaleTransform, translate as translateTransform, } from '../../transform.js';\nimport { boundingExtent, buffer, containsExtent, equals, getIntersection, getTopLeft, intersects, } from '../../extent.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature, } from '../vector.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\nimport { wrapX } from '../../coordinate.js';\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nvar IMAGE_REPLAYS = {\n    'image': [\n        ReplayType.POLYGON,\n        ReplayType.CIRCLE,\n        ReplayType.LINE_STRING,\n        ReplayType.IMAGE,\n        ReplayType.TEXT,\n    ],\n    'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING],\n    'vector': [],\n};\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nvar VECTOR_REPLAYS = {\n    'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n    'vector': [\n        ReplayType.POLYGON,\n        ReplayType.CIRCLE,\n        ReplayType.LINE_STRING,\n        ReplayType.IMAGE,\n        ReplayType.TEXT,\n        ReplayType.DEFAULT,\n    ],\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nvar CanvasVectorTileLayerRenderer = /** @class */ (function (_super) {\n    __extends(CanvasVectorTileLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n     */\n    function CanvasVectorTileLayerRenderer(layer) {\n        var _this = _super.call(this, layer) || this;\n        /** @private */\n        _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.dirty_ = false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.renderedLayerRevision_;\n        /**\n         * @private\n         * @type {import(\"../../transform\").Transform}\n         */\n        _this.renderedPixelToCoordinateTransform_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.renderedRotation_;\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n        _this.tmpTransform_ = createTransform();\n        return _this;\n    }\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../../proj/Projection\").default} projection Projection.\n     * @return {boolean|undefined} Tile needs to be rendered.\n     */\n    CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection) {\n        var render;\n        var state = tile.getState();\n        if (state === TileState.LOADED || state === TileState.ERROR) {\n            this.updateExecutorGroup_(tile, pixelRatio, projection);\n            if (this.tileImageNeedsRender_(tile)) {\n                render = true;\n            }\n        }\n        return render;\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {!import(\"../../Tile.js\").default} Tile.\n     */\n    CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n        var pixelRatio = frameState.pixelRatio;\n        var viewState = frameState.viewState;\n        var resolution = viewState.resolution;\n        var projection = viewState.projection;\n        var layer = this.getLayer();\n        var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n        var viewHints = frameState.viewHints;\n        var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n        if (hifi || !tile.wantedResolution) {\n            tile.wantedResolution = resolution;\n        }\n        var render = this.prepareTile(tile, pixelRatio, projection);\n        if (render &&\n            (hifi || Date.now() - frameState.time < 8) &&\n            layer.getRenderMode() !== VectorTileRenderType.VECTOR) {\n            this.renderTileImage_(tile, frameState);\n        }\n        return _super.prototype.getTile.call(this, z, x, y, frameState);\n    };\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @return {boolean} Tile is drawable.\n     */\n    CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n        var layer = this.getLayer();\n        return (_super.prototype.isDrawableTile.call(this, tile) &&\n            (layer.getRenderMode() === VectorTileRenderType.VECTOR\n                ? getUid(layer) in tile.executorGroups\n                : tile.hasContext(layer)));\n    };\n    /**\n     * @inheritDoc\n     */\n    CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {\n        return tile.getImage(this.getLayer());\n    };\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n        var layerRevision = this.getLayer().getRevision();\n        if (this.renderedLayerRevision_ != layerRevision) {\n            this.renderedTiles.length = 0;\n        }\n        this.renderedLayerRevision_ = layerRevision;\n        return _super.prototype.prepareFrame.call(this, frameState);\n    };\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n     * @private\n     */\n    CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {\n        var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n        var revision = layer.getRevision();\n        var renderOrder = layer.getRenderOrder() || null;\n        var resolution = tile.wantedResolution;\n        var builderState = tile.getReplayState(layer);\n        if (!builderState.dirty &&\n            builderState.renderedResolution === resolution &&\n            builderState.renderedRevision == revision &&\n            builderState.renderedRenderOrder == renderOrder) {\n            return;\n        }\n        var source = layer.getSource();\n        var declutter = layer.getDeclutter();\n        var sourceTileGrid = source.getTileGrid();\n        var tileGrid = source.getTileGridForProjection(projection);\n        var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n        var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n        var layerUid = getUid(layer);\n        delete tile.hitDetectionImageData[layerUid];\n        tile.executorGroups[layerUid] = [];\n        if (declutter) {\n            tile.declutterExecutorGroups[layerUid] = [];\n        }\n        var _loop_1 = function (t, tt) {\n            var sourceTile = sourceTiles[t];\n            if (sourceTile.getState() != TileState.LOADED) {\n                return \"continue\";\n            }\n            var sourceTileCoord = sourceTile.tileCoord;\n            var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n            var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n            var builderExtent = buffer(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);\n            var bufferedExtent = equals(sourceTileExtent, sharedExtent)\n                ? null\n                : builderExtent;\n            builderState.dirty = false;\n            var builderGroup = new CanvasBuilderGroup(0, builderExtent, resolution, pixelRatio);\n            var declutterBuilderGroup = declutter\n                ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio)\n                : undefined;\n            var squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n            /**\n             * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n             * @this {CanvasVectorTileLayerRenderer}\n             */\n            var render = function (feature) {\n                var styles;\n                var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n                if (styleFunction) {\n                    styles = styleFunction(feature, resolution);\n                }\n                if (styles) {\n                    var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);\n                    this.dirty_ = this.dirty_ || dirty;\n                    builderState.dirty = builderState.dirty || dirty;\n                }\n            };\n            var features = sourceTile.getFeatures();\n            if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n                features.sort(renderOrder);\n            }\n            for (var i = 0, ii = features.length; i < ii; ++i) {\n                var feature = features[i];\n                if (!bufferedExtent ||\n                    intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n                    render.call(this_1, feature);\n                }\n            }\n            var executorGroupInstructions = builderGroup.finish();\n            // no need to clip when the render tile is covered by a single source tile\n            var replayExtent = layer.getRenderMode() !== VectorTileRenderType.VECTOR &&\n                declutter &&\n                sourceTiles.length === 1\n                ? null\n                : sharedExtent;\n            var renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n            tile.executorGroups[layerUid].push(renderingReplayGroup);\n            if (declutterBuilderGroup) {\n                var declutterExecutorGroup = new CanvasExecutorGroup(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());\n                tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n            }\n        };\n        var this_1 = this;\n        for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {\n            _loop_1(t, tt);\n        }\n        builderState.renderedRevision = revision;\n        builderState.renderedRenderOrder = renderOrder;\n        builderState.renderedResolution = resolution;\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        var resolution = frameState.viewState.resolution;\n        var rotation = frameState.viewState.rotation;\n        hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n        var layer = this.getLayer();\n        var source = layer.getSource();\n        var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n        var hitExtent = boundingExtent([coordinate]);\n        buffer(hitExtent, resolution * hitTolerance, hitExtent);\n        /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n        var features = {};\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n         * @param {number} distanceSq The squared distance to the click position.\n         * @return {T|undefined} Callback result.\n         */\n        var featureCallback = function (feature, geometry, distanceSq) {\n            var key = feature.getId();\n            if (key === undefined) {\n                key = getUid(feature);\n            }\n            var match = features[key];\n            if (!match) {\n                if (distanceSq === 0) {\n                    features[key] = true;\n                    return callback(feature, layer, geometry);\n                }\n                matches.push((features[key] = {\n                    feature: feature,\n                    layer: layer,\n                    geometry: geometry,\n                    distanceSq: distanceSq,\n                    callback: callback,\n                }));\n            }\n            else if (match !== true && distanceSq < match.distanceSq) {\n                if (distanceSq === 0) {\n                    features[key] = true;\n                    matches.splice(matches.lastIndexOf(match), 1);\n                    return callback(feature, layer, geometry);\n                }\n                match.geometry = geometry;\n                match.distanceSq = distanceSq;\n            }\n            return undefined;\n        };\n        var renderedTiles = \n        /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (this.renderedTiles);\n        var found;\n        var _loop_2 = function (i, ii) {\n            var tile = renderedTiles[i];\n            var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n            if (!intersects(tileExtent, hitExtent)) {\n                return \"continue\";\n            }\n            var layerUid = getUid(layer);\n            var executorGroups = [tile.executorGroups[layerUid]];\n            var declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n            if (declutterExecutorGroups) {\n                executorGroups.push(declutterExecutorGroups);\n            }\n            executorGroups.some(function (executorGroups) {\n                var declutteredFeatures = executorGroups === declutterExecutorGroups\n                    ? frameState.declutterTree.all().map(function (item) { return item.value; })\n                    : null;\n                for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n                    var executorGroup = executorGroups[t];\n                    found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);\n                    if (found) {\n                        return true;\n                    }\n                }\n            });\n        };\n        for (var i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n            _loop_2(i, ii);\n        }\n        return found;\n    };\n    /**\n     * Asynchronous layer level hit detection.\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n     */\n    CanvasVectorTileLayerRenderer.prototype.getFeatures = function (pixel) {\n        return new Promise(function (resolve, reject) {\n            var layer = \n            /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n            var layerUid = getUid(layer);\n            var source = layer.getSource();\n            var projection = this.renderedProjection;\n            var projectionExtent = projection.getExtent();\n            var resolution = this.renderedResolution;\n            var tileGrid = source.getTileGridForProjection(projection);\n            var coordinate = applyTransform(this.renderedPixelToCoordinateTransform_, pixel.slice());\n            var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n            var tile;\n            for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n                if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {\n                    tile = this.renderedTiles[i];\n                    if (tile.getState() === TileState.LOADED) {\n                        var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);\n                        if (source.getWrapX() &&\n                            projection.canWrapX() &&\n                            !containsExtent(projectionExtent, extent_1)) {\n                            wrapX(coordinate, projection);\n                        }\n                        break;\n                    }\n                    tile = undefined;\n                }\n            }\n            if (!tile || tile.loadingSourceTiles > 0) {\n                resolve([]);\n                return;\n            }\n            var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n            var corner = getTopLeft(extent);\n            var tilePixel = [\n                (coordinate[0] - corner[0]) / resolution,\n                (corner[1] - coordinate[1]) / resolution,\n            ];\n            var features = tile\n                .getSourceTiles()\n                .reduce(function (accumulator, sourceTile) {\n                return accumulator.concat(sourceTile.getFeatures());\n            }, []);\n            var hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n            if (!hitDetectionImageData && !this.animatingOrInteracting_) {\n                var tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));\n                var rotation = this.renderedRotation_;\n                var transforms = [\n                    this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0),\n                ];\n                hitDetectionImageData = createHitDetectionImageData(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);\n                tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n            }\n            resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n        }.bind(this));\n    };\n    /**\n     * Perform action necessary to get the layer rendered after new fonts have loaded\n     */\n    CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {\n        var layer = this.getLayer();\n        if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n            layer.changed();\n        }\n    };\n    /**\n     * Handle changes in image style state.\n     * @param {import(\"../../events/Event.js\").default} event Image style change event.\n     * @private\n     */\n    CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {\n        this.renderIfReadyAndVisible();\n    };\n    /**\n     * Render declutter items for this layer\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     */\n    CanvasVectorTileLayerRenderer.prototype.renderDeclutter = function (frameState) {\n        var context = this.context;\n        var alpha = context.globalAlpha;\n        context.globalAlpha = this.getLayer().getOpacity();\n        var viewHints = frameState.viewHints;\n        var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n        var tiles = \n        /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (this.renderedTiles);\n        for (var i = 0, ii = tiles.length; i < ii; ++i) {\n            var tile = tiles[i];\n            var declutterExecutorGroups = tile.declutterExecutorGroups[getUid(this.getLayer())];\n            if (declutterExecutorGroups) {\n                for (var j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n                    declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, undefined, frameState.declutterTree);\n                }\n            }\n        }\n        context.globalAlpha = alpha;\n    };\n    CanvasVectorTileLayerRenderer.prototype.getTileRenderTransform = function (tile, frameState) {\n        var pixelRatio = frameState.pixelRatio;\n        var viewState = frameState.viewState;\n        var center = viewState.center;\n        var resolution = viewState.resolution;\n        var rotation = viewState.rotation;\n        var size = frameState.size;\n        var width = Math.round(size[0] * pixelRatio);\n        var height = Math.round(size[1] * pixelRatio);\n        var source = this.getLayer().getSource();\n        var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n        var tileCoord = tile.tileCoord;\n        var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n        var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n        var transform = multiply(scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n        return transform;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {HTMLElement} target Target that may be used to render content to.\n     * @return {HTMLElement} The rendered element.\n     */\n    CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n        var viewHints = frameState.viewHints;\n        var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n        _super.prototype.renderFrame.call(this, frameState, target);\n        this.renderedPixelToCoordinateTransform_ =\n            frameState.pixelToCoordinateTransform.slice();\n        this.renderedRotation_ = frameState.viewState.rotation;\n        var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n        var renderMode = layer.getRenderMode();\n        var context = this.context;\n        var alpha = context.globalAlpha;\n        context.globalAlpha = layer.getOpacity();\n        var replayTypes = VECTOR_REPLAYS[renderMode];\n        var viewState = frameState.viewState;\n        var rotation = viewState.rotation;\n        var tiles = this.renderedTiles;\n        var clips = [];\n        var clipZs = [];\n        for (var i = tiles.length - 1; i >= 0; --i) {\n            var tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (tiles[i]);\n            var transform = this.getTileRenderTransform(tile, frameState);\n            var executorGroups = tile.executorGroups[getUid(layer)];\n            var clipped = false;\n            for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n                var executorGroup = executorGroups[t];\n                if (!executorGroup.hasExecutors(replayTypes)) {\n                    // sourceTile has no instructions of the types we want to render\n                    continue;\n                }\n                var currentZ = tile.tileCoord[0];\n                var currentClip = void 0;\n                if (!clipped) {\n                    currentClip = executorGroup.getClipCoords(transform);\n                    if (currentClip) {\n                        context.save();\n                        // Create a clip mask for regions in this low resolution tile that are\n                        // already filled by a higher resolution tile\n                        for (var j = 0, jj = clips.length; j < jj; ++j) {\n                            var clip = clips[j];\n                            if (currentZ < clipZs[j]) {\n                                context.beginPath();\n                                // counter-clockwise (outer ring) for current tile\n                                context.moveTo(currentClip[0], currentClip[1]);\n                                context.lineTo(currentClip[2], currentClip[3]);\n                                context.lineTo(currentClip[4], currentClip[5]);\n                                context.lineTo(currentClip[6], currentClip[7]);\n                                // clockwise (inner ring) for higher resolution tile\n                                context.moveTo(clip[6], clip[7]);\n                                context.lineTo(clip[4], clip[5]);\n                                context.lineTo(clip[2], clip[3]);\n                                context.lineTo(clip[0], clip[1]);\n                                context.clip();\n                            }\n                        }\n                    }\n                }\n                executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);\n                if (!clipped && currentClip) {\n                    context.restore();\n                    clips.push(currentClip);\n                    clipZs.push(currentZ);\n                    clipped = true;\n                }\n            }\n        }\n        context.globalAlpha = alpha;\n        return this.container;\n    };\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n     * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n     * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder group for decluttering.\n     * @return {boolean} `true` if an image is loading.\n     */\n    CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_declutterBuilderGroup) {\n        if (!styles) {\n            return false;\n        }\n        var loading = false;\n        if (Array.isArray(styles)) {\n            for (var i = 0, ii = styles.length; i < ii; ++i) {\n                loading =\n                    renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup) || loading;\n            }\n        }\n        else {\n            loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup);\n        }\n        return loading;\n    };\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @return {boolean} A new tile image was rendered.\n     * @private\n     */\n    CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile) {\n        var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n        if (layer.getRenderMode() === VectorTileRenderType.VECTOR) {\n            return false;\n        }\n        var replayState = tile.getReplayState(layer);\n        var revision = layer.getRevision();\n        var resolution = tile.wantedResolution;\n        return (replayState.renderedTileResolution !== resolution ||\n            replayState.renderedTileRevision !== revision);\n    };\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {\n        var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n        var replayState = tile.getReplayState(layer);\n        var revision = layer.getRevision();\n        var executorGroups = tile.executorGroups[getUid(layer)];\n        replayState.renderedTileRevision = revision;\n        var tileCoord = tile.wrappedTileCoord;\n        var z = tileCoord[0];\n        var source = layer.getSource();\n        var pixelRatio = frameState.pixelRatio;\n        var viewState = frameState.viewState;\n        var projection = viewState.projection;\n        var tileGrid = source.getTileGridForProjection(projection);\n        var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n        var renderPixelRatio = (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n        var resolution = tileGrid.getResolution(z);\n        var context = tile.getContext(layer);\n        // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n        pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));\n        var size = source.getTilePixelSize(z, pixelRatio, projection);\n        context.canvas.width = size[0];\n        context.canvas.height = size[1];\n        var renderScale = pixelRatio / renderPixelRatio;\n        if (renderScale !== 1) {\n            var canvasTransform = resetTransform(this.tmpTransform_);\n            scaleTransform(canvasTransform, renderScale, renderScale);\n            context.setTransform.apply(context, canvasTransform);\n        }\n        var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n        var pixelScale = renderPixelRatio / resolution;\n        var transform = resetTransform(this.tmpTransform_);\n        scaleTransform(transform, pixelScale, -pixelScale);\n        translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n        for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n            var executorGroup = executorGroups[i];\n            executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n        }\n        replayState.renderedTileResolution = tile.wantedResolution;\n    };\n    return CanvasVectorTileLayerRenderer;\n}(CanvasTileLayerRenderer));\nexport default CanvasVectorTileLayerRenderer;\n"]},"metadata":{},"sourceType":"module"}