{"ast":null,"code":"/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../../has.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray } from '../../transform.js';\nimport { createEmpty, createOrUpdate, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextBaseline, drawImageOrLabel } from '../canvas.js';\nimport { defaultTextAlign, measureAndCacheTextWidth, measureTextHeight, measureTextWidths } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @typedef {Object} BBox\n * @property {number} minX Minimal x.\n * @property {number} minY Minimal y.\n * @property {number} maxX Maximal x.\n * @property {number} maxY Maximal y\n * @property {*} value Value.\n */\n\n/**\n * @typedef {Object} ImageOrLabelDimensions\n * @property {number} drawImageX DrawImageX.\n * @property {number} drawImageY DrawImageY.\n * @property {number} drawImageW DrawImageW.\n * @property {number} drawImageH DrawImageH.\n * @property {number} originX OriginX.\n * @property {number} originY OriginY.\n * @property {Array<number>} scale Scale.\n * @property {BBox} declutterBox DeclutterBox.\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\n */\n\n/**\n * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\n */\n\n/**\n * @template T\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\n\nvar tmpExtent = createEmpty();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p4 = [];\n/**\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\n * @return {BBox} Declutter bbox.\n */\n\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n  return replayImageOrLabelArgs[3].declutterBox;\n}\n\nvar rtlRegEx = new RegExp(\n/* eslint-disable prettier/prettier */\n'[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']'\n/* eslint-enable prettier/prettier */\n);\n/**\n * @param {string} text Text.\n * @param {string} align Alignment.\n * @return {number} Text alignment.\n */\n\nfunction horizontalTextAlign(text, align) {\n  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {\n    align = align === 'start' ? 'left' : 'right';\n  }\n\n  return TEXT_ALIGN[align];\n}\n\nvar Executor = function () {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions\n   */\n  function Executor(resolution, pixelRatio, overlaps, instructions) {\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.alignFill_;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.instructions = instructions.instructions;\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    this.coordinates = instructions.coordinates;\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n\n    this.coordinateCache_ = {};\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n\n    this.renderedTransform_ = createTransform();\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.pixelCoordinates_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.viewRotation_ = 0;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n\n    this.fillStates = instructions.fillStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n\n    this.strokeStates = instructions.strokeStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n\n    this.textStates = instructions.textStates || {};\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n\n    this.widths_ = {};\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n\n    this.labels_ = {};\n  }\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n\n\n  Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {\n    var key = text + textKey + fillKey + strokeKey;\n\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n\n    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    var fillState = fillKey ? this.fillStates[fillKey] : null;\n    var textState = this.textStates[textKey];\n    var pixelRatio = this.pixelRatio;\n    var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];\n    var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);\n    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var lines = text.split('\\n');\n    var numLines = lines.length;\n    var widths = [];\n    var width = measureTextWidths(textState.font, lines, widths);\n    var lineHeight = measureTextHeight(textState.font);\n    var height = lineHeight * numLines;\n    var renderWidth = width + strokeWidth;\n    var contextInstructions = []; // make canvas 2 pixels wider to account for italic text width measurement errors\n\n    var w = (renderWidth + 2) * scale[0];\n    var h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n\n    var label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions\n    };\n\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n\n    contextInstructions.push('font', textState.font);\n\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit); // eslint-disable-next-line\n\n      var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n\n      if (Context.prototype.setLineDash) {\n        contextInstructions.push('setLineDash', [strokeState.lineDash]);\n        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n      }\n    }\n\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    var leftRight = 0.5 - align;\n    var x = align * renderWidth + leftRight * strokeWidth;\n    var i;\n\n    if (strokeKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('strokeText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);\n      }\n    }\n\n    if (fillKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('fillText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);\n      }\n    }\n\n    this.labels_[key] = label;\n    return label;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n\n\n  Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n\n    if (fillInstruction) {\n      this.alignFill_ = fillInstruction[2];\n      this.fill_(context);\n    }\n\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context, strokeInstruction);\n      context.stroke();\n    }\n  };\n  /**\n   * @private\n   * @param {number} sheetWidth Width of the sprite sheet.\n   * @param {number} sheetHeight Height of the sprite sheet.\n   * @param {number} centerX X.\n   * @param {number} centerY Y.\n   * @param {number} width Width.\n   * @param {number} height Height.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {import(\"../../size.js\").Size} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {Array<number>} padding Padding.\n   * @param {boolean} fillStroke Background fill or stroke.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\n   */\n\n\n  Executor.prototype.calculateImageOrLabelDimensions_ = function (sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    var x = centerX - anchorX;\n    var y = centerY - anchorY;\n    var w = width + originX > sheetWidth ? sheetWidth - originX : width;\n    var h = height + originY > sheetHeight ? sheetHeight - originY : height;\n    var boxW = padding[3] + w * scale[0] + padding[1];\n    var boxH = padding[0] + h * scale[1] + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n\n    var transform;\n\n    if (rotation !== 0) {\n      transform = composeTransform(createTransform(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      applyTransform(transform, p1);\n      applyTransform(transform, p2);\n      applyTransform(transform, p3);\n      applyTransform(transform, p4);\n      createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n    } else {\n      createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);\n    }\n\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    return {\n      drawImageX: x,\n      drawImageY: y,\n      drawImageW: w,\n      drawImageH: h,\n      originX: originX,\n      originY: originY,\n      declutterBox: {\n        minX: tmpExtent[0],\n        minY: tmpExtent[1],\n        maxX: tmpExtent[2],\n        maxY: tmpExtent[3],\n        value: feature\n      },\n      canvasTransform: transform,\n      scale: scale\n    };\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n   * @param {ImageOrLabelDimensions} dimensions Dimensions.\n   * @param {number} opacity Opacity.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @return {boolean} The image or label was rendered.\n   */\n\n\n  Executor.prototype.replayImageOrLabel_ = function (context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {\n    var fillStroke = !!(fillInstruction || strokeInstruction);\n    var box = dimensions.declutterBox;\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;\n    var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;\n\n    if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction);\n      }\n\n      drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n\n\n  Executor.prototype.fill_ = function (context) {\n    if (this.alignFill_) {\n      var origin_1 = applyTransform(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n\n    context.fill();\n\n    if (this.alignFill_) {\n      context.restore();\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n\n\n  Executor.prototype.setStrokeStyle_ = function (context, instruction) {\n    context['strokeStyle'] = instruction[1];\n    context.lineWidth = instruction[2];\n    context.lineCap = instruction[3];\n    context.lineJoin = instruction[4];\n    context.miterLimit = instruction[5];\n\n    if (context.setLineDash) {\n      context.lineDashOffset = instruction[7];\n      context.setLineDash(instruction[6]);\n    }\n  };\n  /**\n   * @private\n   * @param {string} text The text to draw.\n   * @param {string} textKey The key of the text state.\n   * @param {string} strokeKey The key for the stroke state.\n   * @param {string} fillKey The key for the fill state.\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n   */\n\n\n  Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {\n    var textState = this.textStates[textKey];\n    var label = this.createLabel(text, textKey, fillKey, strokeKey);\n    var strokeState = this.strokeStates[strokeKey];\n    var pixelRatio = this.pixelRatio;\n    var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);\n    var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0; // Remove the 2 pixels we added in createLabel() for the anchor\n\n    var width = label.width / pixelRatio - 2 * textState.scale[0];\n    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY\n    };\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n   *     features that intersect this extent.\n   * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {\n    /** @type {Array<number>} */\n    var pixelCoordinates;\n\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n\n      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n\n    var i = 0; // instruction index\n\n    var ii = instructions.length; // end of instructions\n\n    var d = 0; // data index\n\n    var dd; // end of per-instruction data\n\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n    var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n    var state = {\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    }; // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var\n    /** @type {import(\"../../Feature.js\").FeatureLike} */\n    feature;\n    var x, y, currentGeometry;\n\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type = instruction[0];\n\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature = instruction[1];\n          currentGeometry = instruction[3];\n\n          if (!feature.getGeometry()) {\n            i = instruction[2];\n          } else if (opt_hitExtent !== undefined && !intersects(opt_hitExtent, currentGeometry.getExtent())) {\n            i =\n            /** @type {number} */\n            instruction[2] + 1;\n          } else {\n            ++i;\n          }\n\n          break;\n\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.CIRCLE:\n          d = instruction[1];\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n\n        case CanvasInstruction.CUSTOM:\n          d = instruction[1];\n          dd = instruction[2];\n          var geometry = instruction[3];\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n\n          var coords = coordinateCache[i];\n\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n\n          renderer(coords, state);\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_IMAGE:\n          d = instruction[1];\n          dd = instruction[2];\n          image = instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order\n\n          anchorX = instruction[4];\n          anchorY = instruction[5];\n          var height = instruction[6];\n          var opacity = instruction[7];\n          var originX = instruction[8];\n          var originY = instruction[9];\n          var rotateWithView = instruction[10];\n          var rotation = instruction[11];\n          var scale = instruction[12];\n          var width = instruction[13];\n          var declutterImageWithText = instruction[14];\n\n          if (!image && instruction.length >= 19) {\n            // create label images\n            text = instruction[18];\n            textKey = instruction[19];\n            strokeKey = instruction[20];\n            fillKey = instruction[21];\n            var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            var textOffsetX = instruction[22];\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            var textOffsetY = instruction[23];\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[6] = height;\n            width = image.width;\n            instruction[13] = width;\n          }\n\n          var geometryWidths = void 0;\n\n          if (instruction.length > 24) {\n            geometryWidths = instruction[24];\n          }\n\n          var padding = void 0,\n              backgroundFill = void 0,\n              backgroundStroke = void 0;\n\n          if (instruction.length > 16) {\n            padding = instruction[15];\n            backgroundFill = instruction[16];\n            backgroundStroke = instruction[17];\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n\n          var widthIndex = 0;\n\n          for (; d < dd; d += 2) {\n            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {\n              continue;\n            }\n\n            var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);\n            /** @type {ReplayImageOrLabelArgs} */\n\n            var args = [context, contextScale, image, dimensions, opacity, backgroundFill ? lastFillInstruction : null, backgroundStroke ? lastStrokeInstruction : null];\n            var imageArgs = void 0;\n            var imageDeclutterBox = void 0;\n\n            if (opt_declutterTree && declutterImageWithText) {\n              var index = dd - d;\n\n              if (!declutterImageWithText[index]) {\n                // We now have the image for an image+text combination.\n                declutterImageWithText[index] = args; // Don't render anything for now, wait for the text.\n\n                continue;\n              }\n\n              imageArgs = declutterImageWithText[index];\n              delete declutterImageWithText[index];\n              imageDeclutterBox = getDeclutterBox(imageArgs);\n\n              if (opt_declutterTree.collides(imageDeclutterBox)) {\n                continue;\n              }\n            }\n\n            if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n              continue;\n            }\n\n            if (imageArgs) {\n              // We now have image and text for an image+text combination.\n              if (opt_declutterTree) {\n                opt_declutterTree.insert(imageDeclutterBox);\n              } // Render the image before we render the text.\n\n\n              this.replayImageOrLabel_.apply(this, imageArgs);\n            }\n\n            if (opt_declutterTree) {\n              opt_declutterTree.insert(dimensions.declutterBox);\n            }\n\n            this.replayImageOrLabel_.apply(this, args);\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_CHARS:\n          var begin = instruction[1];\n          var end = instruction[2];\n          var baseline = instruction[3];\n          var overflow = instruction[4];\n          fillKey = instruction[5];\n          var maxAngle = instruction[6];\n          var measurePixelRatio = instruction[7];\n          var offsetY = instruction[8];\n          strokeKey = instruction[9];\n          var strokeWidth = instruction[10];\n          text = instruction[11];\n          textKey = instruction[12];\n          var pixelRatioScale = [\n            /** @type {number} */\n\n            /** @type {number} */\n          instruction[13], instruction[13]];\n          var textState = this.textStates[textKey];\n          var font = textState.font;\n          var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];\n          var cachedWidths = void 0;\n\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n\n          var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);\n\n          if (overflow || textLength <= pathLength) {\n            var textAlign = this.textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n\n            drawChars: if (parts) {\n              /** @type {Array<ReplayImageOrLabelArgs>} */\n              var replayImageOrLabelArgs = [];\n              var c = void 0,\n                  cc = void 0,\n                  chars = void 0,\n                  label = void 0,\n                  part = void 0;\n\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars = part[4];\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX =\n                  /** @type {number} */\n                  part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;\n                  var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n\n                  if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n                    break drawChars;\n                  }\n\n                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);\n                }\n              }\n\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars = part[4];\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX = part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n\n                  if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n                    break drawChars;\n                  }\n\n                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);\n                }\n              }\n\n              if (opt_declutterTree) {\n                opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n              }\n\n              for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {\n                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);\n              }\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.END_GEOMETRY:\n          if (opt_featureCallback !== undefined) {\n            feature = instruction[1];\n            var result = opt_featureCallback(feature, currentGeometry);\n\n            if (result) {\n              return result;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d = instruction[1];\n          dd = instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle = instruction[1];\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          this.setStrokeStyle_(context, instruction);\n          ++i;\n          break;\n\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n\n          ++i;\n          break;\n\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n\n          break;\n      }\n    }\n\n    if (pendingFill) {\n      this.fill_(context);\n    }\n\n    if (pendingStroke) {\n      context.stroke();\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n   */\n\n\n  Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n   *     features that intersect this extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n  };\n\n  return Executor;\n}();\n\nexport default Executor;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/render/canvas/Executor.js"],"names":["CanvasInstruction","TEXT_ALIGN","WORKER_OFFSCREEN_CANVAS","apply","applyTransform","compose","composeTransform","create","createTransform","setFromArray","transformSetFromArray","createEmpty","createOrUpdate","intersects","defaultPadding","defaultTextBaseline","drawImageOrLabel","defaultTextAlign","measureAndCacheTextWidth","measureTextHeight","measureTextWidths","drawTextOnPath","equals","lineStringLength","transform2D","tmpExtent","p1","p2","p3","p4","getDeclutterBox","replayImageOrLabelArgs","declutterBox","rtlRegEx","RegExp","String","fromCharCode","horizontalTextAlign","text","align","test","Executor","resolution","pixelRatio","overlaps","instructions","alignFill_","coordinates","coordinateCache_","renderedTransform_","hitDetectionInstructions","pixelCoordinates_","viewRotation_","fillStates","strokeStates","textStates","widths_","labels_","prototype","createLabel","textKey","fillKey","strokeKey","key","strokeState","fillState","textState","scale","textAlign","strokeWidth","lineWidth","lines","split","numLines","length","widths","width","font","lineHeight","height","renderWidth","contextInstructions","w","h","label","Math","floor","ceil","push","strokeStyle","lineCap","lineJoin","miterLimit","Context","OffscreenCanvasRenderingContext2D","CanvasRenderingContext2D","setLineDash","lineDash","lineDashOffset","fillStyle","leftRight","x","i","replayTextBackground_","context","fillInstruction","strokeInstruction","beginPath","moveTo","lineTo","fill_","setStrokeStyle_","stroke","calculateImageOrLabelDimensions_","sheetWidth","sheetHeight","centerX","centerY","anchorX","anchorY","originX","originY","rotation","snapToPixel","padding","fillStroke","feature","y","boxW","boxH","boxX","boxY","transform","min","max","round","drawImageX","drawImageY","drawImageW","drawImageH","minX","minY","maxX","maxY","value","canvasTransform","replayImageOrLabel_","contextScale","imageOrLabel","dimensions","opacity","box","canvas","strokePadding","origin_1","repeatSize","save","translate","rotate","fill","restore","instruction","drawLabelWithPointPlacement_","baseline","textBaseline","execute_","opt_featureCallback","opt_hitExtent","opt_declutterTree","pixelCoordinates","ii","d","dd","prevX","prevY","roundX","roundY","image","pendingFill","pendingStroke","lastFillInstruction","lastStrokeInstruction","coordinateCache","viewRotation","viewRotationFromTransform","atan2","state","batchSize","currentGeometry","type","BEGIN_GEOMETRY","getGeometry","undefined","getExtent","BEGIN_PATH","NaN","CIRCLE","x1","y1","x2","y2","dx","dy","r","sqrt","arc","PI","CLOSE_PATH","closePath","CUSTOM","geometry","renderer","fn","coords","DRAW_IMAGE","rotateWithView","declutterImageWithText","labelWithAnchor","textOffsetX","textOffsetY","geometryWidths","backgroundFill","backgroundStroke","widthIndex","args","imageArgs","imageDeclutterBox","index","collides","insert","DRAW_CHARS","begin","end","overflow","maxAngle","measurePixelRatio","offsetY","pixelRatioScale","textScale","cachedWidths","pathLength","textLength","abs","startM","parts","drawChars","c","cc","chars","part","load","map","i_1","ii_1","END_GEOMETRY","result","FILL","MOVE_TO_LINE_TO","SET_FILL_STYLE","SET_STROKE_STYLE","STROKE","execute","executeHitDetection"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,iBAAP,MAA8B,kBAA9B;AACA,SAASC,UAAT,QAA2B,kBAA3B;AACA,SAASC,uBAAT,QAAwC,cAAxC;AACA,SAASC,KAAK,IAAIC,cAAlB,EAAkCC,OAAO,IAAIC,gBAA7C,EAA+DC,MAAM,IAAIC,eAAzE,EAA0FC,YAAY,IAAIC,qBAA1G,QAAwI,oBAAxI;AACA,SAASC,WAAT,EAAsBC,cAAtB,EAAsCC,UAAtC,QAAwD,iBAAxD;AACA,SAASC,cAAT,EAAyBC,mBAAzB,EAA8CC,gBAA9C,QAAuE,cAAvE;AACA,SAASC,gBAAT,EAA2BC,wBAA3B,EAAqDC,iBAArD,EAAwEC,iBAAxE,QAAkG,cAAlG;AACA,SAASC,cAAT,QAA+B,6BAA/B;AACA,SAASC,MAAT,QAAuB,gBAAvB;AACA,SAASC,gBAAT,QAAiC,2BAAjC;AACA,SAASC,WAAT,QAA4B,8BAA5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA,IAAIC,SAAS,GAAGd,WAAW,EAA3B;AACA;;AACA,IAAIe,EAAE,GAAG,EAAT;AACA;;AACA,IAAIC,EAAE,GAAG,EAAT;AACA;;AACA,IAAIC,EAAE,GAAG,EAAT;AACA;;AACA,IAAIC,EAAE,GAAG,EAAT;AACA;AACA;AACA;AACA;;AACA,SAASC,eAAT,CAAyBC,sBAAzB,EAAiD;AAC7C,SAAOA,sBAAsB,CAAC,CAAD,CAAtB,CAA0BC,YAAjC;AACH;;AACD,IAAIC,QAAQ,GAAG,IAAIC,MAAJ;AACf;AACA,MACIC,MAAM,CAACC,YAAP,CAAoB,OAApB,CADJ,GACmC,GADnC,GACyCD,MAAM,CAACC,YAAP,CAAoB,OAApB,CADzC,GAEID,MAAM,CAACC,YAAP,CAAoB,OAApB,CAFJ,GAEmC,GAFnC,GAEyCD,MAAM,CAACC,YAAP,CAAoB,OAApB,CAFzC,GAGID,MAAM,CAACC,YAAP,CAAoB,OAApB,CAHJ,GAGmC,GAHnC,GAGyCD,MAAM,CAACC,YAAP,CAAoB,OAApB,CAHzC,GAIID,MAAM,CAACC,YAAP,CAAoB,OAApB,CAJJ,GAImC,GAJnC,GAIyCD,MAAM,CAACC,YAAP,CAAoB,OAApB,CAJzC,GAKID,MAAM,CAACC,YAAP,CAAoB,OAApB,CALJ,GAKmC,GALnC,GAKyCD,MAAM,CAACC,YAAP,CAAoB,OAApB,CALzC,GAMI;AACJ;AATe,CAAf;AAWA;AACA;AACA;AACA;AACA;;AACA,SAASC,mBAAT,CAA6BC,IAA7B,EAAmCC,KAAnC,EAA0C;AACtC,MAAI,CAACA,KAAK,KAAK,OAAV,IAAqBA,KAAK,KAAK,KAAhC,KAA0C,CAACN,QAAQ,CAACO,IAAT,CAAcF,IAAd,CAA/C,EAAoE;AAChEC,IAAAA,KAAK,GAAGA,KAAK,KAAK,OAAV,GAAoB,MAApB,GAA6B,OAArC;AACH;;AACD,SAAOtC,UAAU,CAACsC,KAAD,CAAjB;AACH;;AACD,IAAIE,QAAQ,GAAkB,YAAY;AACtC;AACJ;AACA;AACA;AACA;AACA;AACI,WAASA,QAAT,CAAkBC,UAAlB,EAA8BC,UAA9B,EAA0CC,QAA1C,EAAoDC,YAApD,EAAkE;AAC9D;AACR;AACA;AACA;AACQ,SAAKD,QAAL,GAAgBA,QAAhB;AACA;AACR;AACA;AACA;;AACQ,SAAKD,UAAL,GAAkBA,UAAlB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKD,UAAL,GAAkBA,UAAlB;AACA;AACR;AACA;AACA;;AACQ,SAAKI,UAAL;AACA;AACR;AACA;AACA;;AACQ,SAAKD,YAAL,GAAoBA,YAAY,CAACA,YAAjC;AACA;AACR;AACA;AACA;;AACQ,SAAKE,WAAL,GAAmBF,YAAY,CAACE,WAAhC;AACA;AACR;AACA;AACA;;AACQ,SAAKC,gBAAL,GAAwB,EAAxB;AACA;AACR;AACA;AACA;;AACQ,SAAKC,kBAAL,GAA0BzC,eAAe,EAAzC;AACA;AACR;AACA;AACA;;AACQ,SAAK0C,wBAAL,GAAgCL,YAAY,CAACK,wBAA7C;AACA;AACR;AACA;AACA;;AACQ,SAAKC,iBAAL,GAAyB,IAAzB;AACA;AACR;AACA;AACA;;AACQ,SAAKC,aAAL,GAAqB,CAArB;AACA;AACR;AACA;;AACQ,SAAKC,UAAL,GAAkBR,YAAY,CAACQ,UAAb,IAA2B,EAA7C;AACA;AACR;AACA;;AACQ,SAAKC,YAAL,GAAoBT,YAAY,CAACS,YAAb,IAA6B,EAAjD;AACA;AACR;AACA;;AACQ,SAAKC,UAAL,GAAkBV,YAAY,CAACU,UAAb,IAA2B,EAA7C;AACA;AACR;AACA;AACA;;AACQ,SAAKC,OAAL,GAAe,EAAf;AACA;AACR;AACA;AACA;;AACQ,SAAKC,OAAL,GAAe,EAAf;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIhB,EAAAA,QAAQ,CAACiB,SAAT,CAAmBC,WAAnB,GAAiC,UAAUrB,IAAV,EAAgBsB,OAAhB,EAAyBC,OAAzB,EAAkCC,SAAlC,EAA6C;AAC1E,QAAIC,GAAG,GAAGzB,IAAI,GAAGsB,OAAP,GAAiBC,OAAjB,GAA2BC,SAArC;;AACA,QAAI,KAAKL,OAAL,CAAaM,GAAb,CAAJ,EAAuB;AACnB,aAAO,KAAKN,OAAL,CAAaM,GAAb,CAAP;AACH;;AACD,QAAIC,WAAW,GAAGF,SAAS,GAAG,KAAKR,YAAL,CAAkBQ,SAAlB,CAAH,GAAkC,IAA7D;AACA,QAAIG,SAAS,GAAGJ,OAAO,GAAG,KAAKR,UAAL,CAAgBQ,OAAhB,CAAH,GAA8B,IAArD;AACA,QAAIK,SAAS,GAAG,KAAKX,UAAL,CAAgBK,OAAhB,CAAhB;AACA,QAAIjB,UAAU,GAAG,KAAKA,UAAtB;AACA,QAAIwB,KAAK,GAAG,CACRD,SAAS,CAACC,KAAV,CAAgB,CAAhB,IAAqBxB,UADb,EAERuB,SAAS,CAACC,KAAV,CAAgB,CAAhB,IAAqBxB,UAFb,CAAZ;AAIA,QAAIJ,KAAK,GAAGF,mBAAmB,CAACC,IAAD,EAAO4B,SAAS,CAACE,SAAV,IAAuBnD,gBAA9B,CAA/B;AACA,QAAIoD,WAAW,GAAGP,SAAS,IAAIE,WAAW,CAACM,SAAzB,GAAqCN,WAAW,CAACM,SAAjD,GAA6D,CAA/E;AACA,QAAIC,KAAK,GAAGjC,IAAI,CAACkC,KAAL,CAAW,IAAX,CAAZ;AACA,QAAIC,QAAQ,GAAGF,KAAK,CAACG,MAArB;AACA,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,KAAK,GAAGxD,iBAAiB,CAAC8C,SAAS,CAACW,IAAX,EAAiBN,KAAjB,EAAwBI,MAAxB,CAA7B;AACA,QAAIG,UAAU,GAAG3D,iBAAiB,CAAC+C,SAAS,CAACW,IAAX,CAAlC;AACA,QAAIE,MAAM,GAAGD,UAAU,GAAGL,QAA1B;AACA,QAAIO,WAAW,GAAGJ,KAAK,GAAGP,WAA1B;AACA,QAAIY,mBAAmB,GAAG,EAA1B,CAtB0E,CAuB1E;;AACA,QAAIC,CAAC,GAAG,CAACF,WAAW,GAAG,CAAf,IAAoBb,KAAK,CAAC,CAAD,CAAjC;AACA,QAAIgB,CAAC,GAAG,CAACJ,MAAM,GAAGV,WAAV,IAAyBF,KAAK,CAAC,CAAD,CAAtC;AACA;;AACA,QAAIiB,KAAK,GAAG;AACRR,MAAAA,KAAK,EAAEM,CAAC,GAAG,CAAJ,GAAQG,IAAI,CAACC,KAAL,CAAWJ,CAAX,CAAR,GAAwBG,IAAI,CAACE,IAAL,CAAUL,CAAV,CADvB;AAERH,MAAAA,MAAM,EAAEI,CAAC,GAAG,CAAJ,GAAQE,IAAI,CAACC,KAAL,CAAWH,CAAX,CAAR,GAAwBE,IAAI,CAACE,IAAL,CAAUJ,CAAV,CAFxB;AAGRF,MAAAA,mBAAmB,EAAEA;AAHb,KAAZ;;AAKA,QAAId,KAAK,CAAC,CAAD,CAAL,IAAY,CAAZ,IAAiBA,KAAK,CAAC,CAAD,CAAL,IAAY,CAAjC,EAAoC;AAChCc,MAAAA,mBAAmB,CAACO,IAApB,CAAyB,OAAzB,EAAkCrB,KAAlC;AACH;;AACDc,IAAAA,mBAAmB,CAACO,IAApB,CAAyB,MAAzB,EAAiCtB,SAAS,CAACW,IAA3C;;AACA,QAAIf,SAAJ,EAAe;AACXmB,MAAAA,mBAAmB,CAACO,IAApB,CAAyB,aAAzB,EAAwCxB,WAAW,CAACyB,WAApD;AACAR,MAAAA,mBAAmB,CAACO,IAApB,CAAyB,WAAzB,EAAsCnB,WAAtC;AACAY,MAAAA,mBAAmB,CAACO,IAApB,CAAyB,SAAzB,EAAoCxB,WAAW,CAAC0B,OAAhD;AACAT,MAAAA,mBAAmB,CAACO,IAApB,CAAyB,UAAzB,EAAqCxB,WAAW,CAAC2B,QAAjD;AACAV,MAAAA,mBAAmB,CAACO,IAApB,CAAyB,YAAzB,EAAuCxB,WAAW,CAAC4B,UAAnD,EALW,CAMX;;AACA,UAAIC,OAAO,GAAG3F,uBAAuB,GAAG4F,iCAAH,GAAuCC,wBAA5E;;AACA,UAAIF,OAAO,CAACnC,SAAR,CAAkBsC,WAAtB,EAAmC;AAC/Bf,QAAAA,mBAAmB,CAACO,IAApB,CAAyB,aAAzB,EAAwC,CAACxB,WAAW,CAACiC,QAAb,CAAxC;AACAhB,QAAAA,mBAAmB,CAACO,IAApB,CAAyB,gBAAzB,EAA2CxB,WAAW,CAACkC,cAAvD;AACH;AACJ;;AACD,QAAIrC,OAAJ,EAAa;AACToB,MAAAA,mBAAmB,CAACO,IAApB,CAAyB,WAAzB,EAAsCvB,SAAS,CAACkC,SAAhD;AACH;;AACDlB,IAAAA,mBAAmB,CAACO,IAApB,CAAyB,cAAzB,EAAyC,QAAzC;AACAP,IAAAA,mBAAmB,CAACO,IAApB,CAAyB,WAAzB,EAAsC,QAAtC;AACA,QAAIY,SAAS,GAAG,MAAM7D,KAAtB;AACA,QAAI8D,CAAC,GAAG9D,KAAK,GAAGyC,WAAR,GAAsBoB,SAAS,GAAG/B,WAA1C;AACA,QAAIiC,CAAJ;;AACA,QAAIxC,SAAJ,EAAe;AACX,WAAKwC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG7B,QAAhB,EAA0B,EAAE6B,CAA5B,EAA+B;AAC3BrB,QAAAA,mBAAmB,CAACO,IAApB,CAAyB,YAAzB,EAAuC,CACnCjB,KAAK,CAAC+B,CAAD,CAD8B,EAEnCD,CAAC,GAAGD,SAAS,GAAGzB,MAAM,CAAC2B,CAAD,CAFa,EAGnC,OAAOjC,WAAW,GAAGS,UAArB,IAAmCwB,CAAC,GAAGxB,UAHJ,CAAvC;AAKH;AACJ;;AACD,QAAIjB,OAAJ,EAAa;AACT,WAAKyC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG7B,QAAhB,EAA0B,EAAE6B,CAA5B,EAA+B;AAC3BrB,QAAAA,mBAAmB,CAACO,IAApB,CAAyB,UAAzB,EAAqC,CACjCjB,KAAK,CAAC+B,CAAD,CAD4B,EAEjCD,CAAC,GAAGD,SAAS,GAAGzB,MAAM,CAAC2B,CAAD,CAFW,EAGjC,OAAOjC,WAAW,GAAGS,UAArB,IAAmCwB,CAAC,GAAGxB,UAHN,CAArC;AAKH;AACJ;;AACD,SAAKrB,OAAL,CAAaM,GAAb,IAAoBqB,KAApB;AACA,WAAOA,KAAP;AACH,GA7ED;AA8EA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI3C,EAAAA,QAAQ,CAACiB,SAAT,CAAmB6C,qBAAnB,GAA2C,UAAUC,OAAV,EAAmB9E,EAAnB,EAAuBC,EAAvB,EAA2BC,EAA3B,EAA+BC,EAA/B,EAAmC4E,eAAnC,EAAoDC,iBAApD,EAAuE;AAC9GF,IAAAA,OAAO,CAACG,SAAR;AACAH,IAAAA,OAAO,CAACI,MAAR,CAAezG,KAAf,CAAqBqG,OAArB,EAA8B9E,EAA9B;AACA8E,IAAAA,OAAO,CAACK,MAAR,CAAe1G,KAAf,CAAqBqG,OAArB,EAA8B7E,EAA9B;AACA6E,IAAAA,OAAO,CAACK,MAAR,CAAe1G,KAAf,CAAqBqG,OAArB,EAA8B5E,EAA9B;AACA4E,IAAAA,OAAO,CAACK,MAAR,CAAe1G,KAAf,CAAqBqG,OAArB,EAA8B3E,EAA9B;AACA2E,IAAAA,OAAO,CAACK,MAAR,CAAe1G,KAAf,CAAqBqG,OAArB,EAA8B9E,EAA9B;;AACA,QAAI+E,eAAJ,EAAqB;AACjB,WAAK3D,UAAL,GAA0C2D,eAAe,CAAC,CAAD,CAAzD;AACA,WAAKK,KAAL,CAAWN,OAAX;AACH;;AACD,QAAIE,iBAAJ,EAAuB;AACnB,WAAKK,eAAL,CAAqBP,OAArB,EACyBE,iBADzB;AAEAF,MAAAA,OAAO,CAACQ,MAAR;AACH;AACJ,GAhBD;AAiBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIvE,EAAAA,QAAQ,CAACiB,SAAT,CAAmBuD,gCAAnB,GAAsD,UAAUC,UAAV,EAAsBC,WAAtB,EAAmCC,OAAnC,EAA4CC,OAA5C,EAAqDzC,KAArD,EAA4DG,MAA5D,EAAoEuC,OAApE,EAA6EC,OAA7E,EAAsFC,OAAtF,EAA+FC,OAA/F,EAAwGC,QAAxG,EAAkHvD,KAAlH,EAAyHwD,WAAzH,EAAsIC,OAAtI,EAA+IC,UAA/I,EAA2JC,OAA3J,EAAoK;AACtNR,IAAAA,OAAO,IAAInD,KAAK,CAAC,CAAD,CAAhB;AACAoD,IAAAA,OAAO,IAAIpD,KAAK,CAAC,CAAD,CAAhB;AACA,QAAIkC,CAAC,GAAGe,OAAO,GAAGE,OAAlB;AACA,QAAIS,CAAC,GAAGV,OAAO,GAAGE,OAAlB;AACA,QAAIrC,CAAC,GAAGN,KAAK,GAAG4C,OAAR,GAAkBN,UAAlB,GAA+BA,UAAU,GAAGM,OAA5C,GAAsD5C,KAA9D;AACA,QAAIO,CAAC,GAAGJ,MAAM,GAAG0C,OAAT,GAAmBN,WAAnB,GAAiCA,WAAW,GAAGM,OAA/C,GAAyD1C,MAAjE;AACA,QAAIiD,IAAI,GAAGJ,OAAO,CAAC,CAAD,CAAP,GAAa1C,CAAC,GAAGf,KAAK,CAAC,CAAD,CAAtB,GAA4ByD,OAAO,CAAC,CAAD,CAA9C;AACA,QAAIK,IAAI,GAAGL,OAAO,CAAC,CAAD,CAAP,GAAazC,CAAC,GAAGhB,KAAK,CAAC,CAAD,CAAtB,GAA4ByD,OAAO,CAAC,CAAD,CAA9C;AACA,QAAIM,IAAI,GAAG7B,CAAC,GAAGuB,OAAO,CAAC,CAAD,CAAtB;AACA,QAAIO,IAAI,GAAGJ,CAAC,GAAGH,OAAO,CAAC,CAAD,CAAtB;;AACA,QAAIC,UAAU,IAAIH,QAAQ,KAAK,CAA/B,EAAkC;AAC9BhG,MAAAA,EAAE,CAAC,CAAD,CAAF,GAAQwG,IAAR;AACArG,MAAAA,EAAE,CAAC,CAAD,CAAF,GAAQqG,IAAR;AACAxG,MAAAA,EAAE,CAAC,CAAD,CAAF,GAAQyG,IAAR;AACAxG,MAAAA,EAAE,CAAC,CAAD,CAAF,GAAQwG,IAAR;AACAxG,MAAAA,EAAE,CAAC,CAAD,CAAF,GAAQuG,IAAI,GAAGF,IAAf;AACApG,MAAAA,EAAE,CAAC,CAAD,CAAF,GAAQD,EAAE,CAAC,CAAD,CAAV;AACAC,MAAAA,EAAE,CAAC,CAAD,CAAF,GAAQuG,IAAI,GAAGF,IAAf;AACApG,MAAAA,EAAE,CAAC,CAAD,CAAF,GAAQD,EAAE,CAAC,CAAD,CAAV;AACH;;AACD,QAAIwG,SAAJ;;AACA,QAAIV,QAAQ,KAAK,CAAjB,EAAoB;AAChBU,MAAAA,SAAS,GAAG9H,gBAAgB,CAACE,eAAe,EAAhB,EAAoB4G,OAApB,EAA6BC,OAA7B,EAAsC,CAAtC,EAAyC,CAAzC,EAA4CK,QAA5C,EAAsD,CAACN,OAAvD,EAAgE,CAACC,OAAjE,CAA5B;AACAjH,MAAAA,cAAc,CAACgI,SAAD,EAAY1G,EAAZ,CAAd;AACAtB,MAAAA,cAAc,CAACgI,SAAD,EAAYzG,EAAZ,CAAd;AACAvB,MAAAA,cAAc,CAACgI,SAAD,EAAYxG,EAAZ,CAAd;AACAxB,MAAAA,cAAc,CAACgI,SAAD,EAAYvG,EAAZ,CAAd;AACAjB,MAAAA,cAAc,CAACyE,IAAI,CAACgD,GAAL,CAAS3G,EAAE,CAAC,CAAD,CAAX,EAAgBC,EAAE,CAAC,CAAD,CAAlB,EAAuBC,EAAE,CAAC,CAAD,CAAzB,EAA8BC,EAAE,CAAC,CAAD,CAAhC,CAAD,EAAuCwD,IAAI,CAACgD,GAAL,CAAS3G,EAAE,CAAC,CAAD,CAAX,EAAgBC,EAAE,CAAC,CAAD,CAAlB,EAAuBC,EAAE,CAAC,CAAD,CAAzB,EAA8BC,EAAE,CAAC,CAAD,CAAhC,CAAvC,EAA6EwD,IAAI,CAACiD,GAAL,CAAS5G,EAAE,CAAC,CAAD,CAAX,EAAgBC,EAAE,CAAC,CAAD,CAAlB,EAAuBC,EAAE,CAAC,CAAD,CAAzB,EAA8BC,EAAE,CAAC,CAAD,CAAhC,CAA7E,EAAmHwD,IAAI,CAACiD,GAAL,CAAS5G,EAAE,CAAC,CAAD,CAAX,EAAgBC,EAAE,CAAC,CAAD,CAAlB,EAAuBC,EAAE,CAAC,CAAD,CAAzB,EAA8BC,EAAE,CAAC,CAAD,CAAhC,CAAnH,EAAyJJ,SAAzJ,CAAd;AACH,KAPD,MAQK;AACDb,MAAAA,cAAc,CAACyE,IAAI,CAACgD,GAAL,CAASH,IAAT,EAAeA,IAAI,GAAGF,IAAtB,CAAD,EAA8B3C,IAAI,CAACgD,GAAL,CAASF,IAAT,EAAeA,IAAI,GAAGF,IAAtB,CAA9B,EAA2D5C,IAAI,CAACiD,GAAL,CAASJ,IAAT,EAAeA,IAAI,GAAGF,IAAtB,CAA3D,EAAwF3C,IAAI,CAACiD,GAAL,CAASH,IAAT,EAAeA,IAAI,GAAGF,IAAtB,CAAxF,EAAqHxG,SAArH,CAAd;AACH;;AACD,QAAIkG,WAAJ,EAAiB;AACbtB,MAAAA,CAAC,GAAGhB,IAAI,CAACkD,KAAL,CAAWlC,CAAX,CAAJ;AACA0B,MAAAA,CAAC,GAAG1C,IAAI,CAACkD,KAAL,CAAWR,CAAX,CAAJ;AACH;;AACD,WAAO;AACHS,MAAAA,UAAU,EAAEnC,CADT;AAEHoC,MAAAA,UAAU,EAAEV,CAFT;AAGHW,MAAAA,UAAU,EAAExD,CAHT;AAIHyD,MAAAA,UAAU,EAAExD,CAJT;AAKHqC,MAAAA,OAAO,EAAEA,OALN;AAMHC,MAAAA,OAAO,EAAEA,OANN;AAOHzF,MAAAA,YAAY,EAAE;AACV4G,QAAAA,IAAI,EAAEnH,SAAS,CAAC,CAAD,CADL;AAEVoH,QAAAA,IAAI,EAAEpH,SAAS,CAAC,CAAD,CAFL;AAGVqH,QAAAA,IAAI,EAAErH,SAAS,CAAC,CAAD,CAHL;AAIVsH,QAAAA,IAAI,EAAEtH,SAAS,CAAC,CAAD,CAJL;AAKVuH,QAAAA,KAAK,EAAElB;AALG,OAPX;AAcHmB,MAAAA,eAAe,EAAEb,SAdd;AAeHjE,MAAAA,KAAK,EAAEA;AAfJ,KAAP;AAiBH,GAtDD;AAuDA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI1B,EAAAA,QAAQ,CAACiB,SAAT,CAAmBwF,mBAAnB,GAAyC,UAAU1C,OAAV,EAAmB2C,YAAnB,EAAiCC,YAAjC,EAA+CC,UAA/C,EAA2DC,OAA3D,EAAoE7C,eAApE,EAAqFC,iBAArF,EAAwG;AAC7I,QAAImB,UAAU,GAAG,CAAC,EAAEpB,eAAe,IAAIC,iBAArB,CAAlB;AACA,QAAI6C,GAAG,GAAGF,UAAU,CAACrH,YAArB;AACA,QAAIwH,MAAM,GAAGhD,OAAO,CAACgD,MAArB;AACA,QAAIC,aAAa,GAAG/C,iBAAiB,GAC9BA,iBAAiB,CAAC,CAAD,CAAjB,GAAuB2C,UAAU,CAAClF,KAAX,CAAiB,CAAjB,CAAxB,GAA+C,CADhB,GAE/B,CAFN;AAGA,QAAItD,UAAU,GAAG0I,GAAG,CAACX,IAAJ,GAAWa,aAAX,IAA4BD,MAAM,CAAC5E,KAAP,GAAeuE,YAA3C,IACbI,GAAG,CAACT,IAAJ,GAAWW,aAAX,IAA4B,CADf,IAEbF,GAAG,CAACV,IAAJ,GAAWY,aAAX,IAA4BD,MAAM,CAACzE,MAAP,GAAgBoE,YAF/B,IAGbI,GAAG,CAACR,IAAJ,GAAWU,aAAX,IAA4B,CAHhC;;AAIA,QAAI5I,UAAJ,EAAgB;AACZ,UAAIgH,UAAJ,EAAgB;AACZ,aAAKtB,qBAAL,CAA2BC,OAA3B,EAAoC9E,EAApC,EAAwCC,EAAxC,EAA4CC,EAA5C,EAAgDC,EAAhD,EACyB4E,eADzB,EAEyBC,iBAFzB;AAGH;;AACD1F,MAAAA,gBAAgB,CAACwF,OAAD,EAAU6C,UAAU,CAACJ,eAArB,EAAsCK,OAAtC,EAA+CF,YAA/C,EAA6DC,UAAU,CAAC7B,OAAxE,EAAiF6B,UAAU,CAAC5B,OAA5F,EAAqG4B,UAAU,CAACX,UAAhH,EAA4HW,UAAU,CAACV,UAAvI,EAAmJU,UAAU,CAACb,UAA9J,EAA0Ka,UAAU,CAACZ,UAArL,EAAiMY,UAAU,CAAClF,KAA5M,CAAhB;AACH;;AACD,WAAO,IAAP;AACH,GApBD;AAqBA;AACJ;AACA;AACA;;;AACI1B,EAAAA,QAAQ,CAACiB,SAAT,CAAmBoD,KAAnB,GAA2B,UAAUN,OAAV,EAAmB;AAC1C,QAAI,KAAK1D,UAAT,EAAqB;AACjB,UAAI4G,QAAQ,GAAGtJ,cAAc,CAAC,KAAK6C,kBAAN,EAA0B,CAAC,CAAD,EAAI,CAAJ,CAA1B,CAA7B;AACA,UAAI0G,UAAU,GAAG,MAAM,KAAKhH,UAA5B;AACA6D,MAAAA,OAAO,CAACoD,IAAR;AACApD,MAAAA,OAAO,CAACqD,SAAR,CAAkBH,QAAQ,CAAC,CAAD,CAAR,GAAcC,UAAhC,EAA4CD,QAAQ,CAAC,CAAD,CAAR,GAAcC,UAA1D;AACAnD,MAAAA,OAAO,CAACsD,MAAR,CAAe,KAAK1G,aAApB;AACH;;AACDoD,IAAAA,OAAO,CAACuD,IAAR;;AACA,QAAI,KAAKjH,UAAT,EAAqB;AACjB0D,MAAAA,OAAO,CAACwD,OAAR;AACH;AACJ,GAZD;AAaA;AACJ;AACA;AACA;AACA;;;AACIvH,EAAAA,QAAQ,CAACiB,SAAT,CAAmBqD,eAAnB,GAAqC,UAAUP,OAAV,EAAmByD,WAAnB,EAAgC;AACjEzD,IAAAA,OAAO,CAAC,aAAD,CAAP,GAC2DyD,WAAW,CAAC,CAAD,CADtE;AAEAzD,IAAAA,OAAO,CAAClC,SAAR,GAA2C2F,WAAW,CAAC,CAAD,CAAtD;AACAzD,IAAAA,OAAO,CAACd,OAAR,GAAgDuE,WAAW,CAAC,CAAD,CAA3D;AACAzD,IAAAA,OAAO,CAACb,QAAR,GAAkDsE,WAAW,CAAC,CAAD,CAA7D;AACAzD,IAAAA,OAAO,CAACZ,UAAR,GAA4CqE,WAAW,CAAC,CAAD,CAAvD;;AACA,QAAIzD,OAAO,CAACR,WAAZ,EAAyB;AACrBQ,MAAAA,OAAO,CAACN,cAAR,GAAgD+D,WAAW,CAAC,CAAD,CAA3D;AACAzD,MAAAA,OAAO,CAACR,WAAR,CAAkDiE,WAAW,CAAC,CAAD,CAA7D;AACH;AACJ,GAXD;AAYA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIxH,EAAAA,QAAQ,CAACiB,SAAT,CAAmBwG,4BAAnB,GAAkD,UAAU5H,IAAV,EAAgBsB,OAAhB,EAAyBE,SAAzB,EAAoCD,OAApC,EAA6C;AAC3F,QAAIK,SAAS,GAAG,KAAKX,UAAL,CAAgBK,OAAhB,CAAhB;AACA,QAAIwB,KAAK,GAAG,KAAKzB,WAAL,CAAiBrB,IAAjB,EAAuBsB,OAAvB,EAAgCC,OAAhC,EAAyCC,SAAzC,CAAZ;AACA,QAAIE,WAAW,GAAG,KAAKV,YAAL,CAAkBQ,SAAlB,CAAlB;AACA,QAAInB,UAAU,GAAG,KAAKA,UAAtB;AACA,QAAIJ,KAAK,GAAGF,mBAAmB,CAACC,IAAD,EAAO4B,SAAS,CAACE,SAAV,IAAuBnD,gBAA9B,CAA/B;AACA,QAAIkJ,QAAQ,GAAGlK,UAAU,CAACiE,SAAS,CAACkG,YAAV,IAA0BrJ,mBAA3B,CAAzB;AACA,QAAIsD,WAAW,GAAGL,WAAW,IAAIA,WAAW,CAACM,SAA3B,GAAuCN,WAAW,CAACM,SAAnD,GAA+D,CAAjF,CAP2F,CAQ3F;;AACA,QAAIM,KAAK,GAAGQ,KAAK,CAACR,KAAN,GAAcjC,UAAd,GAA2B,IAAIuB,SAAS,CAACC,KAAV,CAAgB,CAAhB,CAA3C;AACA,QAAImD,OAAO,GAAG/E,KAAK,GAAGqC,KAAR,GAAgB,KAAK,MAAMrC,KAAX,IAAoB8B,WAAlD;AACA,QAAIkD,OAAO,GAAI4C,QAAQ,GAAG/E,KAAK,CAACL,MAAlB,GAA4BpC,UAA5B,GACV,KAAK,MAAMwH,QAAX,IAAuB9F,WAD3B;AAEA,WAAO;AACHe,MAAAA,KAAK,EAAEA,KADJ;AAEHkC,MAAAA,OAAO,EAAEA,OAFN;AAGHC,MAAAA,OAAO,EAAEA;AAHN,KAAP;AAKH,GAlBD;AAmBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI9E,EAAAA,QAAQ,CAACiB,SAAT,CAAmB2G,QAAnB,GAA8B,UAAU7D,OAAV,EAAmB2C,YAAnB,EAAiCf,SAAjC,EAA4CvF,YAA5C,EAA0D8E,WAA1D,EAAuE2C,mBAAvE,EAA4FC,aAA5F,EAA2GC,iBAA3G,EAA8H;AACxJ;AACA,QAAIC,gBAAJ;;AACA,QAAI,KAAKtH,iBAAL,IAA0B7B,MAAM,CAAC8G,SAAD,EAAY,KAAKnF,kBAAjB,CAApC,EAA0E;AACtEwH,MAAAA,gBAAgB,GAAG,KAAKtH,iBAAxB;AACH,KAFD,MAGK;AACD,UAAI,CAAC,KAAKA,iBAAV,EAA6B;AACzB,aAAKA,iBAAL,GAAyB,EAAzB;AACH;;AACDsH,MAAAA,gBAAgB,GAAGjJ,WAAW,CAAC,KAAKuB,WAAN,EAAmB,CAAnB,EAAsB,KAAKA,WAAL,CAAiB2B,MAAvC,EAA+C,CAA/C,EAAkD0D,SAAlD,EAA6D,KAAKjF,iBAAlE,CAA9B;AACAzC,MAAAA,qBAAqB,CAAC,KAAKuC,kBAAN,EAA0BmF,SAA1B,CAArB;AACH;;AACD,QAAI9B,CAAC,GAAG,CAAR,CAbwJ,CAa7I;;AACX,QAAIoE,EAAE,GAAG7H,YAAY,CAAC6B,MAAtB,CAdwJ,CAc1H;;AAC9B,QAAIiG,CAAC,GAAG,CAAR,CAfwJ,CAe7I;;AACX,QAAIC,EAAJ,CAhBwJ,CAgBhJ;;AACR,QAAItD,OAAJ,EAAaC,OAAb,EAAsBsD,KAAtB,EAA6BC,KAA7B,EAAoCC,MAApC,EAA4CC,MAA5C,EAAoDC,KAApD,EAA2D3I,IAA3D,EAAiEsB,OAAjE,EAA0EE,SAA1E,EAAqFD,OAArF;AACA,QAAIqH,WAAW,GAAG,CAAlB;AACA,QAAIC,aAAa,GAAG,CAApB;AACA,QAAIC,mBAAmB,GAAG,IAA1B;AACA,QAAIC,qBAAqB,GAAG,IAA5B;AACA,QAAIC,eAAe,GAAG,KAAKtI,gBAA3B;AACA,QAAIuI,YAAY,GAAG,KAAKnI,aAAxB;AACA,QAAIoI,yBAAyB,GAAGnG,IAAI,CAACkD,KAAL,CAAWlD,IAAI,CAACoG,KAAL,CAAW,CAACrD,SAAS,CAAC,CAAD,CAArB,EAA0BA,SAAS,CAAC,CAAD,CAAnC,IAA0C,IAArD,IAA6D,IAA7F;AACA,QAAIsD,KAAK,GAAmD;AACxDlF,MAAAA,OAAO,EAAEA,OAD+C;AAExD7D,MAAAA,UAAU,EAAE,KAAKA,UAFuC;AAGxDD,MAAAA,UAAU,EAAE,KAAKA,UAHuC;AAIxDgF,MAAAA,QAAQ,EAAE6D;AAJ8C,KAA5D,CAzBwJ,CA+BxJ;AACA;;AACA,QAAII,SAAS,GAAG,KAAK9I,YAAL,IAAqBA,YAArB,IAAqC,KAAKD,QAA1C,GAAqD,CAArD,GAAyD,GAAzE;AACA;AAAI;AAAsDkF,IAAAA,OAA1D;AACA,QAAIzB,CAAJ,EAAO0B,CAAP,EAAU6D,eAAV;;AACA,WAAOtF,CAAC,GAAGoE,EAAX,EAAe;AACX,UAAIT,WAAW,GAAGpH,YAAY,CAACyD,CAAD,CAA9B;AACA,UAAIuF,IAAI,GAAsD5B,WAAW,CAAC,CAAD,CAAzE;;AACA,cAAQ4B,IAAR;AACI,aAAK7L,iBAAiB,CAAC8L,cAAvB;AACIhE,UAAAA,OAAO,GAA0DmC,WAAW,CAAC,CAAD,CAA5E;AACA2B,UAAAA,eAAe,GAAG3B,WAAW,CAAC,CAAD,CAA7B;;AACA,cAAI,CAACnC,OAAO,CAACiE,WAAR,EAAL,EAA4B;AACxBzF,YAAAA,CAAC,GAA0B2D,WAAW,CAAC,CAAD,CAAtC;AACH,WAFD,MAGK,IAAIM,aAAa,KAAKyB,SAAlB,IACL,CAACnL,UAAU,CAAC0J,aAAD,EAAgBqB,eAAe,CAACK,SAAhB,EAAhB,CADV,EACwD;AACzD3F,YAAAA,CAAC;AAAG;AAAuB2D,YAAAA,WAAW,CAAC,CAAD,CAAZ,GAAmB,CAA7C;AACH,WAHI,MAIA;AACD,cAAE3D,CAAF;AACH;;AACD;;AACJ,aAAKtG,iBAAiB,CAACkM,UAAvB;AACI,cAAIhB,WAAW,GAAGS,SAAlB,EAA6B;AACzB,iBAAK7E,KAAL,CAAWN,OAAX;AACA0E,YAAAA,WAAW,GAAG,CAAd;AACH;;AACD,cAAIC,aAAa,GAAGQ,SAApB,EAA+B;AAC3BnF,YAAAA,OAAO,CAACQ,MAAR;AACAmE,YAAAA,aAAa,GAAG,CAAhB;AACH;;AACD,cAAI,CAACD,WAAD,IAAgB,CAACC,aAArB,EAAoC;AAChC3E,YAAAA,OAAO,CAACG,SAAR;AACAkE,YAAAA,KAAK,GAAGsB,GAAR;AACArB,YAAAA,KAAK,GAAGqB,GAAR;AACH;;AACD,YAAE7F,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAACoM,MAAvB;AACIzB,UAAAA,CAAC,GAA0BV,WAAW,CAAC,CAAD,CAAtC;AACA,cAAIoC,EAAE,GAAG5B,gBAAgB,CAACE,CAAD,CAAzB;AACA,cAAI2B,EAAE,GAAG7B,gBAAgB,CAACE,CAAC,GAAG,CAAL,CAAzB;AACA,cAAI4B,EAAE,GAAG9B,gBAAgB,CAACE,CAAC,GAAG,CAAL,CAAzB;AACA,cAAI6B,EAAE,GAAG/B,gBAAgB,CAACE,CAAC,GAAG,CAAL,CAAzB;AACA,cAAI8B,EAAE,GAAGF,EAAE,GAAGF,EAAd;AACA,cAAIK,EAAE,GAAGF,EAAE,GAAGF,EAAd;AACA,cAAIK,CAAC,GAAGtH,IAAI,CAACuH,IAAL,CAAUH,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAzB,CAAR;AACAlG,UAAAA,OAAO,CAACI,MAAR,CAAeyF,EAAE,GAAGM,CAApB,EAAuBL,EAAvB;AACA9F,UAAAA,OAAO,CAACqG,GAAR,CAAYR,EAAZ,EAAgBC,EAAhB,EAAoBK,CAApB,EAAuB,CAAvB,EAA0B,IAAItH,IAAI,CAACyH,EAAnC,EAAuC,IAAvC;AACA,YAAExG,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAAC+M,UAAvB;AACIvG,UAAAA,OAAO,CAACwG,SAAR;AACA,YAAE1G,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAACiN,MAAvB;AACItC,UAAAA,CAAC,GAA0BV,WAAW,CAAC,CAAD,CAAtC;AACAW,UAAAA,EAAE,GAAGX,WAAW,CAAC,CAAD,CAAhB;AACA,cAAIiD,QAAQ,GACmDjD,WAAW,CAAC,CAAD,CAD1E;AAEA,cAAIkD,QAAQ,GAAGlD,WAAW,CAAC,CAAD,CAA1B;AACA,cAAImD,EAAE,GAAGnD,WAAW,CAACvF,MAAZ,IAAsB,CAAtB,GAA0BuF,WAAW,CAAC,CAAD,CAArC,GAA2C+B,SAApD;AACAN,UAAAA,KAAK,CAACwB,QAAN,GAAiBA,QAAjB;AACAxB,UAAAA,KAAK,CAAC5D,OAAN,GAAgBA,OAAhB;;AACA,cAAI,EAAExB,CAAC,IAAIgF,eAAP,CAAJ,EAA6B;AACzBA,YAAAA,eAAe,CAAChF,CAAD,CAAf,GAAqB,EAArB;AACH;;AACD,cAAI+G,MAAM,GAAG/B,eAAe,CAAChF,CAAD,CAA5B;;AACA,cAAI8G,EAAJ,EAAQ;AACJA,YAAAA,EAAE,CAAC3C,gBAAD,EAAmBE,CAAnB,EAAsBC,EAAtB,EAA0B,CAA1B,EAA6ByC,MAA7B,CAAF;AACH,WAFD,MAGK;AACDA,YAAAA,MAAM,CAAC,CAAD,CAAN,GAAY5C,gBAAgB,CAACE,CAAD,CAA5B;AACA0C,YAAAA,MAAM,CAAC,CAAD,CAAN,GAAY5C,gBAAgB,CAACE,CAAC,GAAG,CAAL,CAA5B;AACA0C,YAAAA,MAAM,CAAC3I,MAAP,GAAgB,CAAhB;AACH;;AACDyI,UAAAA,QAAQ,CAACE,MAAD,EAAS3B,KAAT,CAAR;AACA,YAAEpF,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAACsN,UAAvB;AACI3C,UAAAA,CAAC,GAA0BV,WAAW,CAAC,CAAD,CAAtC;AACAW,UAAAA,EAAE,GAA0BX,WAAW,CAAC,CAAD,CAAvC;AACAgB,UAAAA,KAAK,GACmEhB,WAAW,CAAC,CAAD,CADnF,CAHJ,CAKI;;AACA3C,UAAAA,OAAO,GAA0B2C,WAAW,CAAC,CAAD,CAA5C;AACA1C,UAAAA,OAAO,GAA0B0C,WAAW,CAAC,CAAD,CAA5C;AACA,cAAIlF,MAAM,GAA0BkF,WAAW,CAAC,CAAD,CAA/C;AACA,cAAIX,OAAO,GAA0BW,WAAW,CAAC,CAAD,CAAhD;AACA,cAAIzC,OAAO,GAA0ByC,WAAW,CAAC,CAAD,CAAhD;AACA,cAAIxC,OAAO,GAA0BwC,WAAW,CAAC,CAAD,CAAhD;AACA,cAAIsD,cAAc,GAA2BtD,WAAW,CAAC,EAAD,CAAxD;AACA,cAAIvC,QAAQ,GAA0BuC,WAAW,CAAC,EAAD,CAAjD;AACA,cAAI9F,KAAK,GAAgD8F,WAAW,CAAC,EAAD,CAApE;AACA,cAAIrF,KAAK,GAA0BqF,WAAW,CAAC,EAAD,CAA9C;AACA,cAAIuD,sBAAsB,GACoCvD,WAAW,CAAC,EAAD,CADzE;;AAEA,cAAI,CAACgB,KAAD,IAAUhB,WAAW,CAACvF,MAAZ,IAAsB,EAApC,EAAwC;AACpC;AACApC,YAAAA,IAAI,GAA0B2H,WAAW,CAAC,EAAD,CAAzC;AACArG,YAAAA,OAAO,GAA0BqG,WAAW,CAAC,EAAD,CAA5C;AACAnG,YAAAA,SAAS,GAA0BmG,WAAW,CAAC,EAAD,CAA9C;AACApG,YAAAA,OAAO,GAA0BoG,WAAW,CAAC,EAAD,CAA5C;AACA,gBAAIwD,eAAe,GAAG,KAAKvD,4BAAL,CAAkC5H,IAAlC,EAAwCsB,OAAxC,EAAiDE,SAAjD,EAA4DD,OAA5D,CAAtB;AACAoH,YAAAA,KAAK,GAAGwC,eAAe,CAACrI,KAAxB;AACA6E,YAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBgB,KAAjB;AACA,gBAAIyC,WAAW,GAA0BzD,WAAW,CAAC,EAAD,CAApD;AACA3C,YAAAA,OAAO,GAAG,CAACmG,eAAe,CAACnG,OAAhB,GAA0BoG,WAA3B,IAA0C,KAAK/K,UAAzD;AACAsH,YAAAA,WAAW,CAAC,CAAD,CAAX,GAAiB3C,OAAjB;AACA,gBAAIqG,WAAW,GAA0B1D,WAAW,CAAC,EAAD,CAApD;AACA1C,YAAAA,OAAO,GAAG,CAACkG,eAAe,CAAClG,OAAhB,GAA0BoG,WAA3B,IAA0C,KAAKhL,UAAzD;AACAsH,YAAAA,WAAW,CAAC,CAAD,CAAX,GAAiB1C,OAAjB;AACAxC,YAAAA,MAAM,GAAGkG,KAAK,CAAClG,MAAf;AACAkF,YAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBlF,MAAjB;AACAH,YAAAA,KAAK,GAAGqG,KAAK,CAACrG,KAAd;AACAqF,YAAAA,WAAW,CAAC,EAAD,CAAX,GAAkBrF,KAAlB;AACH;;AACD,cAAIgJ,cAAc,GAAG,KAAK,CAA1B;;AACA,cAAI3D,WAAW,CAACvF,MAAZ,GAAqB,EAAzB,EAA6B;AACzBkJ,YAAAA,cAAc,GAA0B3D,WAAW,CAAC,EAAD,CAAnD;AACH;;AACD,cAAIrC,OAAO,GAAG,KAAK,CAAnB;AAAA,cAAsBiG,cAAc,GAAG,KAAK,CAA5C;AAAA,cAA+CC,gBAAgB,GAAG,KAAK,CAAvE;;AACA,cAAI7D,WAAW,CAACvF,MAAZ,GAAqB,EAAzB,EAA6B;AACzBkD,YAAAA,OAAO,GAAiCqC,WAAW,CAAC,EAAD,CAAnD;AACA4D,YAAAA,cAAc,GAA2B5D,WAAW,CAAC,EAAD,CAApD;AACA6D,YAAAA,gBAAgB,GAA2B7D,WAAW,CAAC,EAAD,CAAtD;AACH,WAJD,MAKK;AACDrC,YAAAA,OAAO,GAAG9G,cAAV;AACA+M,YAAAA,cAAc,GAAG,KAAjB;AACAC,YAAAA,gBAAgB,GAAG,KAAnB;AACH;;AACD,cAAIP,cAAc,IAAI/B,yBAAtB,EAAiD;AAC7C;AACA9D,YAAAA,QAAQ,IAAI6D,YAAZ;AACH,WAHD,MAIK,IAAI,CAACgC,cAAD,IAAmB,CAAC/B,yBAAxB,EAAmD;AACpD;AACA9D,YAAAA,QAAQ,IAAI6D,YAAZ;AACH;;AACD,cAAIwC,UAAU,GAAG,CAAjB;;AACA,iBAAOpD,CAAC,GAAGC,EAAX,EAAeD,CAAC,IAAI,CAApB,EAAuB;AACnB,gBAAIiD,cAAc,IACdA,cAAc,CAACG,UAAU,EAAX,CAAd,GAA+BnJ,KAAK,GAAG,KAAKjC,UADhD,EAC4D;AACxD;AACH;;AACD,gBAAI0G,UAAU,GAAG,KAAKpC,gCAAL,CAAsCgE,KAAK,CAACrG,KAA5C,EAAmDqG,KAAK,CAAClG,MAAzD,EAAiE0F,gBAAgB,CAACE,CAAD,CAAjF,EAAsFF,gBAAgB,CAACE,CAAC,GAAG,CAAL,CAAtG,EAA+G/F,KAA/G,EAAsHG,MAAtH,EAA8HuC,OAA9H,EAAuIC,OAAvI,EAAgJC,OAAhJ,EAAyJC,OAAzJ,EAAkKC,QAAlK,EAA4KvD,KAA5K,EAAmLwD,WAAnL,EAAgMC,OAAhM,EAAyMiG,cAAc,IAAIC,gBAA3N,EAA6OhG,OAA7O,CAAjB;AACA;;AACA,gBAAIkG,IAAI,GAAG,CACPxH,OADO,EAEP2C,YAFO,EAGP8B,KAHO,EAIP5B,UAJO,EAKPC,OALO,EAMPuE,cAAc,GACiBzC,mBADjB,GAER,IARC,EASP0C,gBAAgB,GACezC,qBADf,GAEV,IAXC,CAAX;AAaA,gBAAI4C,SAAS,GAAG,KAAK,CAArB;AACA,gBAAIC,iBAAiB,GAAG,KAAK,CAA7B;;AACA,gBAAI1D,iBAAiB,IAAIgD,sBAAzB,EAAiD;AAC7C,kBAAIW,KAAK,GAAGvD,EAAE,GAAGD,CAAjB;;AACA,kBAAI,CAAC6C,sBAAsB,CAACW,KAAD,CAA3B,EAAoC;AAChC;AACAX,gBAAAA,sBAAsB,CAACW,KAAD,CAAtB,GAAgCH,IAAhC,CAFgC,CAGhC;;AACA;AACH;;AACDC,cAAAA,SAAS,GAAGT,sBAAsB,CAACW,KAAD,CAAlC;AACA,qBAAOX,sBAAsB,CAACW,KAAD,CAA7B;AACAD,cAAAA,iBAAiB,GAAGpM,eAAe,CAACmM,SAAD,CAAnC;;AACA,kBAAIzD,iBAAiB,CAAC4D,QAAlB,CAA2BF,iBAA3B,CAAJ,EAAmD;AAC/C;AACH;AACJ;;AACD,gBAAI1D,iBAAiB,IACjBA,iBAAiB,CAAC4D,QAAlB,CAA2B/E,UAAU,CAACrH,YAAtC,CADJ,EACyD;AACrD;AACH;;AACD,gBAAIiM,SAAJ,EAAe;AACX;AACA,kBAAIzD,iBAAJ,EAAuB;AACnBA,gBAAAA,iBAAiB,CAAC6D,MAAlB,CAAyBH,iBAAzB;AACH,eAJU,CAKX;;;AACA,mBAAKhF,mBAAL,CAAyB/I,KAAzB,CAA+B,IAA/B,EAAqC8N,SAArC;AACH;;AACD,gBAAIzD,iBAAJ,EAAuB;AACnBA,cAAAA,iBAAiB,CAAC6D,MAAlB,CAAyBhF,UAAU,CAACrH,YAApC;AACH;;AACD,iBAAKkH,mBAAL,CAAyB/I,KAAzB,CAA+B,IAA/B,EAAqC6N,IAArC;AACH;;AACD,YAAE1H,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAACsO,UAAvB;AACI,cAAIC,KAAK,GAA0BtE,WAAW,CAAC,CAAD,CAA9C;AACA,cAAIuE,GAAG,GAA0BvE,WAAW,CAAC,CAAD,CAA5C;AACA,cAAIE,QAAQ,GAA0BF,WAAW,CAAC,CAAD,CAAjD;AACA,cAAIwE,QAAQ,GAA0BxE,WAAW,CAAC,CAAD,CAAjD;AACApG,UAAAA,OAAO,GAA0BoG,WAAW,CAAC,CAAD,CAA5C;AACA,cAAIyE,QAAQ,GAA0BzE,WAAW,CAAC,CAAD,CAAjD;AACA,cAAI0E,iBAAiB,GAA0B1E,WAAW,CAAC,CAAD,CAA1D;AACA,cAAI2E,OAAO,GAA0B3E,WAAW,CAAC,CAAD,CAAhD;AACAnG,UAAAA,SAAS,GAA0BmG,WAAW,CAAC,CAAD,CAA9C;AACA,cAAI5F,WAAW,GAA0B4F,WAAW,CAAC,EAAD,CAApD;AACA3H,UAAAA,IAAI,GAA0B2H,WAAW,CAAC,EAAD,CAAzC;AACArG,UAAAA,OAAO,GAA0BqG,WAAW,CAAC,EAAD,CAA5C;AACA,cAAI4E,eAAe,GAAG;AAClB;;AACA;AADuB5E,UAAAA,WAAW,CAAC,EAAD,CADhB,EAEKA,WAAW,CAAC,EAAD,CAFhB,CAAtB;AAIA,cAAI/F,SAAS,GAAG,KAAKX,UAAL,CAAgBK,OAAhB,CAAhB;AACA,cAAIiB,IAAI,GAAGX,SAAS,CAACW,IAArB;AACA,cAAIiK,SAAS,GAAG,CACZ5K,SAAS,CAACC,KAAV,CAAgB,CAAhB,IAAqBwK,iBADT,EAEZzK,SAAS,CAACC,KAAV,CAAgB,CAAhB,IAAqBwK,iBAFT,CAAhB;AAIA,cAAII,YAAY,GAAG,KAAK,CAAxB;;AACA,cAAIlK,IAAI,IAAI,KAAKrB,OAAjB,EAA0B;AACtBuL,YAAAA,YAAY,GAAG,KAAKvL,OAAL,CAAaqB,IAAb,CAAf;AACH,WAFD,MAGK;AACDkK,YAAAA,YAAY,GAAG,EAAf;AACA,iBAAKvL,OAAL,CAAaqB,IAAb,IAAqBkK,YAArB;AACH;;AACD,cAAIC,UAAU,GAAGzN,gBAAgB,CAACkJ,gBAAD,EAAmB8D,KAAnB,EAA0BC,GAA1B,EAA+B,CAA/B,CAAjC;AACA,cAAIS,UAAU,GAAG5J,IAAI,CAAC6J,GAAL,CAASJ,SAAS,CAAC,CAAD,CAAlB,IACb5N,wBAAwB,CAAC2D,IAAD,EAAOvC,IAAP,EAAayM,YAAb,CAD5B;;AAEA,cAAIN,QAAQ,IAAIQ,UAAU,IAAID,UAA9B,EAA0C;AACtC,gBAAI5K,SAAS,GAAG,KAAKb,UAAL,CAAgBK,OAAhB,EAAyBQ,SAAzC;AACA,gBAAI+K,MAAM,GAAG,CAACH,UAAU,GAAGC,UAAd,IAA4BhP,UAAU,CAACmE,SAAD,CAAnD;AACA,gBAAIgL,KAAK,GAAG/N,cAAc,CAACoJ,gBAAD,EAAmB8D,KAAnB,EAA0BC,GAA1B,EAA+B,CAA/B,EAAkClM,IAAlC,EAAwC6M,MAAxC,EAAgDT,QAAhD,EAA0DrJ,IAAI,CAAC6J,GAAL,CAASJ,SAAS,CAAC,CAAD,CAAlB,CAA1D,EAAkF5N,wBAAlF,EAA4G2D,IAA5G,EAAkHkK,YAAlH,EAAgIvD,yBAAyB,GAAG,CAAH,GAAO,KAAKpI,aAArK,CAA1B;;AACAiM,YAAAA,SAAS,EAAE,IAAID,KAAJ,EAAW;AAClB;AACA,kBAAIrN,sBAAsB,GAAG,EAA7B;AACA,kBAAIuN,CAAC,GAAG,KAAK,CAAb;AAAA,kBAAgBC,EAAE,GAAG,KAAK,CAA1B;AAAA,kBAA6BC,KAAK,GAAG,KAAK,CAA1C;AAAA,kBAA6CpK,KAAK,GAAG,KAAK,CAA1D;AAAA,kBAA6DqK,IAAI,GAAG,KAAK,CAAzE;;AACA,kBAAI3L,SAAJ,EAAe;AACX,qBAAKwL,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGH,KAAK,CAAC1K,MAAvB,EAA+B4K,CAAC,GAAGC,EAAnC,EAAuC,EAAED,CAAzC,EAA4C;AACxCG,kBAAAA,IAAI,GAAGL,KAAK,CAACE,CAAD,CAAZ,CADwC,CACvB;;AACjBE,kBAAAA,KAAK,GAA0BC,IAAI,CAAC,CAAD,CAAnC;AACArK,kBAAAA,KAAK,GAAG,KAAKzB,WAAL,CAAiB6L,KAAjB,EAAwB5L,OAAxB,EAAiC,EAAjC,EAAqCE,SAArC,CAAR;AACAwD,kBAAAA,OAAO;AACH;AAAuBmI,kBAAAA,IAAI,CAAC,CAAD,CAAL,IACjBX,SAAS,CAAC,CAAD,CAAT,GAAe,CAAf,GAAmB,CAACzK,WAApB,GAAkCA,WADjB,CAD1B;AAGAkD,kBAAAA,OAAO,GACH4C,QAAQ,GAAG/E,KAAK,CAACL,MAAjB,GACK,CAAC,MAAMoF,QAAP,IAAmB,CAAnB,GAAuB9F,WAAvB,GAAqCyK,SAAS,CAAC,CAAD,CAA/C,GACIA,SAAS,CAAC,CAAD,CAFjB,GAGIF,OAJR;AAKA,sBAAIvF,UAAU,GAAG,KAAKpC,gCAAL,CAAsC7B,KAAK,CAACR,KAA5C,EAAmDQ,KAAK,CAACL,MAAzD,EAAiE0K,IAAI,CAAC,CAAD,CAArE,EAA0EA,IAAI,CAAC,CAAD,CAA9E,EAAmFrK,KAAK,CAACR,KAAzF,EAAgGQ,KAAK,CAACL,MAAtG,EAA8GuC,OAA9G,EAAuHC,OAAvH,EAAgI,CAAhI,EAAmI,CAAnI,EAAsIkI,IAAI,CAAC,CAAD,CAA1I,EAA+IZ,eAA/I,EAAgK,KAAhK,EAAuK/N,cAAvK,EAAuL,KAAvL,EAA8LgH,OAA9L,CAAjB;;AACA,sBAAI0C,iBAAiB,IACjBA,iBAAiB,CAAC4D,QAAlB,CAA2B/E,UAAU,CAACrH,YAAtC,CADJ,EACyD;AACrD,0BAAMqN,SAAN;AACH;;AACDtN,kBAAAA,sBAAsB,CAACyD,IAAvB,CAA4B,CACxBgB,OADwB,EAExB2C,YAFwB,EAGxB/D,KAHwB,EAIxBiE,UAJwB,EAKxB,CALwB,EAMxB,IANwB,EAOxB,IAPwB,CAA5B;AASH;AACJ;;AACD,kBAAIxF,OAAJ,EAAa;AACT,qBAAKyL,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGH,KAAK,CAAC1K,MAAvB,EAA+B4K,CAAC,GAAGC,EAAnC,EAAuC,EAAED,CAAzC,EAA4C;AACxCG,kBAAAA,IAAI,GAAGL,KAAK,CAACE,CAAD,CAAZ,CADwC,CACvB;;AACjBE,kBAAAA,KAAK,GAA0BC,IAAI,CAAC,CAAD,CAAnC;AACArK,kBAAAA,KAAK,GAAG,KAAKzB,WAAL,CAAiB6L,KAAjB,EAAwB5L,OAAxB,EAAiCC,OAAjC,EAA0C,EAA1C,CAAR;AACAyD,kBAAAA,OAAO,GAA0BmI,IAAI,CAAC,CAAD,CAArC;AACAlI,kBAAAA,OAAO,GAAG4C,QAAQ,GAAG/E,KAAK,CAACL,MAAjB,GAA0B6J,OAApC;AACA,sBAAIvF,UAAU,GAAG,KAAKpC,gCAAL,CAAsC7B,KAAK,CAACR,KAA5C,EAAmDQ,KAAK,CAACL,MAAzD,EAAiE0K,IAAI,CAAC,CAAD,CAArE,EAA0EA,IAAI,CAAC,CAAD,CAA9E,EAAmFrK,KAAK,CAACR,KAAzF,EAAgGQ,KAAK,CAACL,MAAtG,EAA8GuC,OAA9G,EAAuHC,OAAvH,EAAgI,CAAhI,EAAmI,CAAnI,EAAsIkI,IAAI,CAAC,CAAD,CAA1I,EAA+IZ,eAA/I,EAAgK,KAAhK,EAAuK/N,cAAvK,EAAuL,KAAvL,EAA8LgH,OAA9L,CAAjB;;AACA,sBAAI0C,iBAAiB,IACjBA,iBAAiB,CAAC4D,QAAlB,CAA2B/E,UAAU,CAACrH,YAAtC,CADJ,EACyD;AACrD,0BAAMqN,SAAN;AACH;;AACDtN,kBAAAA,sBAAsB,CAACyD,IAAvB,CAA4B,CACxBgB,OADwB,EAExB2C,YAFwB,EAGxB/D,KAHwB,EAIxBiE,UAJwB,EAKxB,CALwB,EAMxB,IANwB,EAOxB,IAPwB,CAA5B;AASH;AACJ;;AACD,kBAAImB,iBAAJ,EAAuB;AACnBA,gBAAAA,iBAAiB,CAACkF,IAAlB,CAAuB3N,sBAAsB,CAAC4N,GAAvB,CAA2B7N,eAA3B,CAAvB;AACH;;AACD,mBAAK,IAAI8N,GAAG,GAAG,CAAV,EAAaC,IAAI,GAAG9N,sBAAsB,CAAC2C,MAAhD,EAAwDkL,GAAG,GAAGC,IAA9D,EAAoE,EAAED,GAAtE,EAA2E;AACvE,qBAAK1G,mBAAL,CAAyB/I,KAAzB,CAA+B,IAA/B,EAAqC4B,sBAAsB,CAAC6N,GAAD,CAA3D;AACH;AACJ;AACJ;;AACD,YAAEtJ,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAAC8P,YAAvB;AACI,cAAIxF,mBAAmB,KAAK0B,SAA5B,EAAuC;AACnClE,YAAAA,OAAO,GAA0DmC,WAAW,CAAC,CAAD,CAA5E;AACA,gBAAI8F,MAAM,GAAGzF,mBAAmB,CAACxC,OAAD,EAAU8D,eAAV,CAAhC;;AACA,gBAAImE,MAAJ,EAAY;AACR,qBAAOA,MAAP;AACH;AACJ;;AACD,YAAEzJ,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAACgQ,IAAvB;AACI,cAAIrE,SAAJ,EAAe;AACXT,YAAAA,WAAW;AACd,WAFD,MAGK;AACD,iBAAKpE,KAAL,CAAWN,OAAX;AACH;;AACD,YAAEF,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAACiQ,eAAvB;AACItF,UAAAA,CAAC,GAA0BV,WAAW,CAAC,CAAD,CAAtC;AACAW,UAAAA,EAAE,GAA0BX,WAAW,CAAC,CAAD,CAAvC;AACA5D,UAAAA,CAAC,GAAGoE,gBAAgB,CAACE,CAAD,CAApB;AACA5C,UAAAA,CAAC,GAAG0C,gBAAgB,CAACE,CAAC,GAAG,CAAL,CAApB;AACAI,UAAAA,MAAM,GAAI1E,CAAC,GAAG,GAAL,GAAY,CAArB;AACA2E,UAAAA,MAAM,GAAIjD,CAAC,GAAG,GAAL,GAAY,CAArB;;AACA,cAAIgD,MAAM,KAAKF,KAAX,IAAoBG,MAAM,KAAKF,KAAnC,EAA0C;AACtCtE,YAAAA,OAAO,CAACI,MAAR,CAAeP,CAAf,EAAkB0B,CAAlB;AACA8C,YAAAA,KAAK,GAAGE,MAAR;AACAD,YAAAA,KAAK,GAAGE,MAAR;AACH;;AACD,eAAKL,CAAC,IAAI,CAAV,EAAaA,CAAC,GAAGC,EAAjB,EAAqBD,CAAC,IAAI,CAA1B,EAA6B;AACzBtE,YAAAA,CAAC,GAAGoE,gBAAgB,CAACE,CAAD,CAApB;AACA5C,YAAAA,CAAC,GAAG0C,gBAAgB,CAACE,CAAC,GAAG,CAAL,CAApB;AACAI,YAAAA,MAAM,GAAI1E,CAAC,GAAG,GAAL,GAAY,CAArB;AACA2E,YAAAA,MAAM,GAAIjD,CAAC,GAAG,GAAL,GAAY,CAArB;;AACA,gBAAI4C,CAAC,IAAIC,EAAE,GAAG,CAAV,IAAeG,MAAM,KAAKF,KAA1B,IAAmCG,MAAM,KAAKF,KAAlD,EAAyD;AACrDtE,cAAAA,OAAO,CAACK,MAAR,CAAeR,CAAf,EAAkB0B,CAAlB;AACA8C,cAAAA,KAAK,GAAGE,MAAR;AACAD,cAAAA,KAAK,GAAGE,MAAR;AACH;AACJ;;AACD,YAAE1E,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAACkQ,cAAvB;AACI9E,UAAAA,mBAAmB,GAAGnB,WAAtB;AACA,eAAKnH,UAAL,GAAkBmH,WAAW,CAAC,CAAD,CAA7B;;AACA,cAAIiB,WAAJ,EAAiB;AACb,iBAAKpE,KAAL,CAAWN,OAAX;AACA0E,YAAAA,WAAW,GAAG,CAAd;;AACA,gBAAIC,aAAJ,EAAmB;AACf3E,cAAAA,OAAO,CAACQ,MAAR;AACAmE,cAAAA,aAAa,GAAG,CAAhB;AACH;AACJ;;AACD3E,UAAAA,OAAO,CAACL,SAAR,GAC2D8D,WAAW,CAAC,CAAD,CADtE;AAEA,YAAE3D,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAACmQ,gBAAvB;AACI9E,UAAAA,qBAAqB,GAAGpB,WAAxB;;AACA,cAAIkB,aAAJ,EAAmB;AACf3E,YAAAA,OAAO,CAACQ,MAAR;AACAmE,YAAAA,aAAa,GAAG,CAAhB;AACH;;AACD,eAAKpE,eAAL,CAAqBP,OAArB,EAAuDyD,WAAvD;AACA,YAAE3D,CAAF;AACA;;AACJ,aAAKtG,iBAAiB,CAACoQ,MAAvB;AACI,cAAIzE,SAAJ,EAAe;AACXR,YAAAA,aAAa;AAChB,WAFD,MAGK;AACD3E,YAAAA,OAAO,CAACQ,MAAR;AACH;;AACD,YAAEV,CAAF;AACA;;AACJ;AACI,YAAEA,CAAF,CADJ,CACS;;AACL;AArXR;AAuXH;;AACD,QAAI4E,WAAJ,EAAiB;AACb,WAAKpE,KAAL,CAAWN,OAAX;AACH;;AACD,QAAI2E,aAAJ,EAAmB;AACf3E,MAAAA,OAAO,CAACQ,MAAR;AACH;;AACD,WAAOgF,SAAP;AACH,GAtaD;AAuaA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIvJ,EAAAA,QAAQ,CAACiB,SAAT,CAAmB2M,OAAnB,GAA6B,UAAU7J,OAAV,EAAmB2C,YAAnB,EAAiCf,SAAjC,EAA4CmD,YAA5C,EAA0D5D,WAA1D,EAAuE6C,iBAAvE,EAA0F;AACnH,SAAKpH,aAAL,GAAqBmI,YAArB;AACA,SAAKlB,QAAL,CAAc7D,OAAd,EAAuB2C,YAAvB,EAAqCf,SAArC,EAAgD,KAAKvF,YAArD,EAAmE8E,WAAnE,EAAgFqE,SAAhF,EAA2FA,SAA3F,EAAsGxB,iBAAtG;AACH,GAHD;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/H,EAAAA,QAAQ,CAACiB,SAAT,CAAmB4M,mBAAnB,GAAyC,UAAU9J,OAAV,EAAmB4B,SAAnB,EAA8BmD,YAA9B,EAA4CjB,mBAA5C,EAAiEC,aAAjE,EAAgF;AACrH,SAAKnH,aAAL,GAAqBmI,YAArB;AACA,WAAO,KAAKlB,QAAL,CAAc7D,OAAd,EAAuB,CAAvB,EAA0B4B,SAA1B,EAAqC,KAAKlF,wBAA1C,EAAoE,IAApE,EAA0EoH,mBAA1E,EAA+FC,aAA/F,CAAP;AACH,GAHD;;AAIA,SAAO9H,QAAP;AACH,CA9zB6B,EAA9B;;AA+zBA,eAAeA,QAAf","sourcesContent":["/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../../has.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray, } from '../../transform.js';\nimport { createEmpty, createOrUpdate, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextBaseline, drawImageOrLabel, } from '../canvas.js';\nimport { defaultTextAlign, measureAndCacheTextWidth, measureTextHeight, measureTextWidths, } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @typedef {Object} BBox\n * @property {number} minX Minimal x.\n * @property {number} minY Minimal y.\n * @property {number} maxX Maximal x.\n * @property {number} maxY Maximal y\n * @property {*} value Value.\n */\n/**\n * @typedef {Object} ImageOrLabelDimensions\n * @property {number} drawImageX DrawImageX.\n * @property {number} drawImageY DrawImageY.\n * @property {number} drawImageW DrawImageW.\n * @property {number} drawImageH DrawImageH.\n * @property {number} originX OriginX.\n * @property {number} originY OriginY.\n * @property {Array<number>} scale Scale.\n * @property {BBox} declutterBox DeclutterBox.\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\n */\n/**\n * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\n */\n/**\n * @template T\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nvar tmpExtent = createEmpty();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p4 = [];\n/**\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\n * @return {BBox} Declutter bbox.\n */\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n    return replayImageOrLabelArgs[3].declutterBox;\n}\nvar rtlRegEx = new RegExp(\n/* eslint-disable prettier/prettier */\n'[' +\n    String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) +\n    String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) +\n    String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) +\n    String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) +\n    String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) +\n    ']'\n/* eslint-enable prettier/prettier */\n);\n/**\n * @param {string} text Text.\n * @param {string} align Alignment.\n * @return {number} Text alignment.\n */\nfunction horizontalTextAlign(text, align) {\n    if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {\n        align = align === 'start' ? 'left' : 'right';\n    }\n    return TEXT_ALIGN[align];\n}\nvar Executor = /** @class */ (function () {\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {boolean} overlaps The replay can have overlapping geometries.\n     * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions\n     */\n    function Executor(resolution, pixelRatio, overlaps, instructions) {\n        /**\n         * @protected\n         * @type {boolean}\n         */\n        this.overlaps = overlaps;\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.pixelRatio = pixelRatio;\n        /**\n         * @protected\n         * @const\n         * @type {number}\n         */\n        this.resolution = resolution;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this.alignFill_;\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        this.instructions = instructions.instructions;\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        this.coordinates = instructions.coordinates;\n        /**\n         * @private\n         * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n         */\n        this.coordinateCache_ = {};\n        /**\n         * @private\n         * @type {!import(\"../../transform.js\").Transform}\n         */\n        this.renderedTransform_ = createTransform();\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        this.pixelCoordinates_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.viewRotation_ = 0;\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").FillState>}\n         */\n        this.fillStates = instructions.fillStates || {};\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n         */\n        this.strokeStates = instructions.strokeStates || {};\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").TextState>}\n         */\n        this.textStates = instructions.textStates || {};\n        /**\n         * @private\n         * @type {Object<string, Object<string, number>>}\n         */\n        this.widths_ = {};\n        /**\n         * @private\n         * @type {Object<string, import(\"../canvas.js\").Label>}\n         */\n        this.labels_ = {};\n    }\n    /**\n     * @param {string} text Text.\n     * @param {string} textKey Text style key.\n     * @param {string} fillKey Fill style key.\n     * @param {string} strokeKey Stroke style key.\n     * @return {import(\"../canvas.js\").Label} Label.\n     */\n    Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {\n        var key = text + textKey + fillKey + strokeKey;\n        if (this.labels_[key]) {\n            return this.labels_[key];\n        }\n        var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n        var fillState = fillKey ? this.fillStates[fillKey] : null;\n        var textState = this.textStates[textKey];\n        var pixelRatio = this.pixelRatio;\n        var scale = [\n            textState.scale[0] * pixelRatio,\n            textState.scale[1] * pixelRatio,\n        ];\n        var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);\n        var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n        var lines = text.split('\\n');\n        var numLines = lines.length;\n        var widths = [];\n        var width = measureTextWidths(textState.font, lines, widths);\n        var lineHeight = measureTextHeight(textState.font);\n        var height = lineHeight * numLines;\n        var renderWidth = width + strokeWidth;\n        var contextInstructions = [];\n        // make canvas 2 pixels wider to account for italic text width measurement errors\n        var w = (renderWidth + 2) * scale[0];\n        var h = (height + strokeWidth) * scale[1];\n        /** @type {import(\"../canvas.js\").Label} */\n        var label = {\n            width: w < 0 ? Math.floor(w) : Math.ceil(w),\n            height: h < 0 ? Math.floor(h) : Math.ceil(h),\n            contextInstructions: contextInstructions,\n        };\n        if (scale[0] != 1 || scale[1] != 1) {\n            contextInstructions.push('scale', scale);\n        }\n        contextInstructions.push('font', textState.font);\n        if (strokeKey) {\n            contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n            contextInstructions.push('lineWidth', strokeWidth);\n            contextInstructions.push('lineCap', strokeState.lineCap);\n            contextInstructions.push('lineJoin', strokeState.lineJoin);\n            contextInstructions.push('miterLimit', strokeState.miterLimit);\n            // eslint-disable-next-line\n            var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n            if (Context.prototype.setLineDash) {\n                contextInstructions.push('setLineDash', [strokeState.lineDash]);\n                contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n            }\n        }\n        if (fillKey) {\n            contextInstructions.push('fillStyle', fillState.fillStyle);\n        }\n        contextInstructions.push('textBaseline', 'middle');\n        contextInstructions.push('textAlign', 'center');\n        var leftRight = 0.5 - align;\n        var x = align * renderWidth + leftRight * strokeWidth;\n        var i;\n        if (strokeKey) {\n            for (i = 0; i < numLines; ++i) {\n                contextInstructions.push('strokeText', [\n                    lines[i],\n                    x + leftRight * widths[i],\n                    0.5 * (strokeWidth + lineHeight) + i * lineHeight,\n                ]);\n            }\n        }\n        if (fillKey) {\n            for (i = 0; i < numLines; ++i) {\n                contextInstructions.push('fillText', [\n                    lines[i],\n                    x + leftRight * widths[i],\n                    0.5 * (strokeWidth + lineHeight) + i * lineHeight,\n                ]);\n            }\n        }\n        this.labels_[key] = label;\n        return label;\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n     * @param {Array<*>} fillInstruction Fill instruction.\n     * @param {Array<*>} strokeInstruction Stroke instruction.\n     */\n    Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n        context.beginPath();\n        context.moveTo.apply(context, p1);\n        context.lineTo.apply(context, p2);\n        context.lineTo.apply(context, p3);\n        context.lineTo.apply(context, p4);\n        context.lineTo.apply(context, p1);\n        if (fillInstruction) {\n            this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);\n            this.fill_(context);\n        }\n        if (strokeInstruction) {\n            this.setStrokeStyle_(context, \n            /** @type {Array<*>} */ (strokeInstruction));\n            context.stroke();\n        }\n    };\n    /**\n     * @private\n     * @param {number} sheetWidth Width of the sprite sheet.\n     * @param {number} sheetHeight Height of the sprite sheet.\n     * @param {number} centerX X.\n     * @param {number} centerY Y.\n     * @param {number} width Width.\n     * @param {number} height Height.\n     * @param {number} anchorX Anchor X.\n     * @param {number} anchorY Anchor Y.\n     * @param {number} originX Origin X.\n     * @param {number} originY Origin Y.\n     * @param {number} rotation Rotation.\n     * @param {import(\"../../size.js\").Size} scale Scale.\n     * @param {boolean} snapToPixel Snap to pixel.\n     * @param {Array<number>} padding Padding.\n     * @param {boolean} fillStroke Background fill or stroke.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\n     */\n    Executor.prototype.calculateImageOrLabelDimensions_ = function (sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {\n        anchorX *= scale[0];\n        anchorY *= scale[1];\n        var x = centerX - anchorX;\n        var y = centerY - anchorY;\n        var w = width + originX > sheetWidth ? sheetWidth - originX : width;\n        var h = height + originY > sheetHeight ? sheetHeight - originY : height;\n        var boxW = padding[3] + w * scale[0] + padding[1];\n        var boxH = padding[0] + h * scale[1] + padding[2];\n        var boxX = x - padding[3];\n        var boxY = y - padding[0];\n        if (fillStroke || rotation !== 0) {\n            p1[0] = boxX;\n            p4[0] = boxX;\n            p1[1] = boxY;\n            p2[1] = boxY;\n            p2[0] = boxX + boxW;\n            p3[0] = p2[0];\n            p3[1] = boxY + boxH;\n            p4[1] = p3[1];\n        }\n        var transform;\n        if (rotation !== 0) {\n            transform = composeTransform(createTransform(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n            applyTransform(transform, p1);\n            applyTransform(transform, p2);\n            applyTransform(transform, p3);\n            applyTransform(transform, p4);\n            createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n        }\n        else {\n            createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);\n        }\n        if (snapToPixel) {\n            x = Math.round(x);\n            y = Math.round(y);\n        }\n        return {\n            drawImageX: x,\n            drawImageY: y,\n            drawImageW: w,\n            drawImageH: h,\n            originX: originX,\n            originY: originY,\n            declutterBox: {\n                minX: tmpExtent[0],\n                minY: tmpExtent[1],\n                maxX: tmpExtent[2],\n                maxY: tmpExtent[3],\n                value: feature,\n            },\n            canvasTransform: transform,\n            scale: scale,\n        };\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n     * @param {ImageOrLabelDimensions} dimensions Dimensions.\n     * @param {number} opacity Opacity.\n     * @param {Array<*>} fillInstruction Fill instruction.\n     * @param {Array<*>} strokeInstruction Stroke instruction.\n     * @return {boolean} The image or label was rendered.\n     */\n    Executor.prototype.replayImageOrLabel_ = function (context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {\n        var fillStroke = !!(fillInstruction || strokeInstruction);\n        var box = dimensions.declutterBox;\n        var canvas = context.canvas;\n        var strokePadding = strokeInstruction\n            ? (strokeInstruction[2] * dimensions.scale[0]) / 2\n            : 0;\n        var intersects = box.minX - strokePadding <= canvas.width / contextScale &&\n            box.maxX + strokePadding >= 0 &&\n            box.minY - strokePadding <= canvas.height / contextScale &&\n            box.maxY + strokePadding >= 0;\n        if (intersects) {\n            if (fillStroke) {\n                this.replayTextBackground_(context, p1, p2, p3, p4, \n                /** @type {Array<*>} */ (fillInstruction), \n                /** @type {Array<*>} */ (strokeInstruction));\n            }\n            drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);\n        }\n        return true;\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     */\n    Executor.prototype.fill_ = function (context) {\n        if (this.alignFill_) {\n            var origin_1 = applyTransform(this.renderedTransform_, [0, 0]);\n            var repeatSize = 512 * this.pixelRatio;\n            context.save();\n            context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n            context.rotate(this.viewRotation_);\n        }\n        context.fill();\n        if (this.alignFill_) {\n            context.restore();\n        }\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {Array<*>} instruction Instruction.\n     */\n    Executor.prototype.setStrokeStyle_ = function (context, instruction) {\n        context['strokeStyle'] =\n            /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n        context.lineWidth = /** @type {number} */ (instruction[2]);\n        context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);\n        context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);\n        context.miterLimit = /** @type {number} */ (instruction[5]);\n        if (context.setLineDash) {\n            context.lineDashOffset = /** @type {number} */ (instruction[7]);\n            context.setLineDash(/** @type {Array<number>} */ (instruction[6]));\n        }\n    };\n    /**\n     * @private\n     * @param {string} text The text to draw.\n     * @param {string} textKey The key of the text state.\n     * @param {string} strokeKey The key for the stroke state.\n     * @param {string} fillKey The key for the fill state.\n     * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n     */\n    Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {\n        var textState = this.textStates[textKey];\n        var label = this.createLabel(text, textKey, fillKey, strokeKey);\n        var strokeState = this.strokeStates[strokeKey];\n        var pixelRatio = this.pixelRatio;\n        var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);\n        var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n        var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n        // Remove the 2 pixels we added in createLabel() for the anchor\n        var width = label.width / pixelRatio - 2 * textState.scale[0];\n        var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n        var anchorY = (baseline * label.height) / pixelRatio +\n            2 * (0.5 - baseline) * strokeWidth;\n        return {\n            label: label,\n            anchorX: anchorX,\n            anchorY: anchorY,\n        };\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {Array<*>} instructions Instructions array.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n     * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n     *     features that intersect this extent.\n     * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {\n        /** @type {Array<number>} */\n        var pixelCoordinates;\n        if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n            pixelCoordinates = this.pixelCoordinates_;\n        }\n        else {\n            if (!this.pixelCoordinates_) {\n                this.pixelCoordinates_ = [];\n            }\n            pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n            transformSetFromArray(this.renderedTransform_, transform);\n        }\n        var i = 0; // instruction index\n        var ii = instructions.length; // end of instructions\n        var d = 0; // data index\n        var dd; // end of per-instruction data\n        var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;\n        var pendingFill = 0;\n        var pendingStroke = 0;\n        var lastFillInstruction = null;\n        var lastStrokeInstruction = null;\n        var coordinateCache = this.coordinateCache_;\n        var viewRotation = this.viewRotation_;\n        var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n        var state = /** @type {import(\"../../render.js\").State} */ ({\n            context: context,\n            pixelRatio: this.pixelRatio,\n            resolution: this.resolution,\n            rotation: viewRotation,\n        });\n        // When the batch size gets too big, performance decreases. 200 is a good\n        // balance between batch size and number of fill/stroke instructions.\n        var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n        var /** @type {import(\"../../Feature.js\").FeatureLike} */ feature;\n        var x, y, currentGeometry;\n        while (i < ii) {\n            var instruction = instructions[i];\n            var type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n            switch (type) {\n                case CanvasInstruction.BEGIN_GEOMETRY:\n                    feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (instruction[1]);\n                    currentGeometry = instruction[3];\n                    if (!feature.getGeometry()) {\n                        i = /** @type {number} */ (instruction[2]);\n                    }\n                    else if (opt_hitExtent !== undefined &&\n                        !intersects(opt_hitExtent, currentGeometry.getExtent())) {\n                        i = /** @type {number} */ (instruction[2]) + 1;\n                    }\n                    else {\n                        ++i;\n                    }\n                    break;\n                case CanvasInstruction.BEGIN_PATH:\n                    if (pendingFill > batchSize) {\n                        this.fill_(context);\n                        pendingFill = 0;\n                    }\n                    if (pendingStroke > batchSize) {\n                        context.stroke();\n                        pendingStroke = 0;\n                    }\n                    if (!pendingFill && !pendingStroke) {\n                        context.beginPath();\n                        prevX = NaN;\n                        prevY = NaN;\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.CIRCLE:\n                    d = /** @type {number} */ (instruction[1]);\n                    var x1 = pixelCoordinates[d];\n                    var y1 = pixelCoordinates[d + 1];\n                    var x2 = pixelCoordinates[d + 2];\n                    var y2 = pixelCoordinates[d + 3];\n                    var dx = x2 - x1;\n                    var dy = y2 - y1;\n                    var r = Math.sqrt(dx * dx + dy * dy);\n                    context.moveTo(x1 + r, y1);\n                    context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n                    ++i;\n                    break;\n                case CanvasInstruction.CLOSE_PATH:\n                    context.closePath();\n                    ++i;\n                    break;\n                case CanvasInstruction.CUSTOM:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = instruction[2];\n                    var geometry = \n                    /** @type {import(\"../../geom/SimpleGeometry.js\").default} */ (instruction[3]);\n                    var renderer = instruction[4];\n                    var fn = instruction.length == 6 ? instruction[5] : undefined;\n                    state.geometry = geometry;\n                    state.feature = feature;\n                    if (!(i in coordinateCache)) {\n                        coordinateCache[i] = [];\n                    }\n                    var coords = coordinateCache[i];\n                    if (fn) {\n                        fn(pixelCoordinates, d, dd, 2, coords);\n                    }\n                    else {\n                        coords[0] = pixelCoordinates[d];\n                        coords[1] = pixelCoordinates[d + 1];\n                        coords.length = 2;\n                    }\n                    renderer(coords, state);\n                    ++i;\n                    break;\n                case CanvasInstruction.DRAW_IMAGE:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = /** @type {number} */ (instruction[2]);\n                    image =\n                        /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (instruction[3]);\n                    // Remaining arguments in DRAW_IMAGE are in alphabetical order\n                    anchorX = /** @type {number} */ (instruction[4]);\n                    anchorY = /** @type {number} */ (instruction[5]);\n                    var height = /** @type {number} */ (instruction[6]);\n                    var opacity = /** @type {number} */ (instruction[7]);\n                    var originX = /** @type {number} */ (instruction[8]);\n                    var originY = /** @type {number} */ (instruction[9]);\n                    var rotateWithView = /** @type {boolean} */ (instruction[10]);\n                    var rotation = /** @type {number} */ (instruction[11]);\n                    var scale = /** @type {import(\"../../size.js\").Size} */ (instruction[12]);\n                    var width = /** @type {number} */ (instruction[13]);\n                    var declutterImageWithText = \n                    /** @type {import(\"../canvas.js\").DeclutterImageWithText} */ (instruction[14]);\n                    if (!image && instruction.length >= 19) {\n                        // create label images\n                        text = /** @type {string} */ (instruction[18]);\n                        textKey = /** @type {string} */ (instruction[19]);\n                        strokeKey = /** @type {string} */ (instruction[20]);\n                        fillKey = /** @type {string} */ (instruction[21]);\n                        var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n                        image = labelWithAnchor.label;\n                        instruction[3] = image;\n                        var textOffsetX = /** @type {number} */ (instruction[22]);\n                        anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n                        instruction[4] = anchorX;\n                        var textOffsetY = /** @type {number} */ (instruction[23]);\n                        anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n                        instruction[5] = anchorY;\n                        height = image.height;\n                        instruction[6] = height;\n                        width = image.width;\n                        instruction[13] = width;\n                    }\n                    var geometryWidths = void 0;\n                    if (instruction.length > 24) {\n                        geometryWidths = /** @type {number} */ (instruction[24]);\n                    }\n                    var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;\n                    if (instruction.length > 16) {\n                        padding = /** @type {Array<number>} */ (instruction[15]);\n                        backgroundFill = /** @type {boolean} */ (instruction[16]);\n                        backgroundStroke = /** @type {boolean} */ (instruction[17]);\n                    }\n                    else {\n                        padding = defaultPadding;\n                        backgroundFill = false;\n                        backgroundStroke = false;\n                    }\n                    if (rotateWithView && viewRotationFromTransform) {\n                        // Canvas is expected to be rotated to reverse view rotation.\n                        rotation += viewRotation;\n                    }\n                    else if (!rotateWithView && !viewRotationFromTransform) {\n                        // Canvas is not rotated, images need to be rotated back to be north-up.\n                        rotation -= viewRotation;\n                    }\n                    var widthIndex = 0;\n                    for (; d < dd; d += 2) {\n                        if (geometryWidths &&\n                            geometryWidths[widthIndex++] < width / this.pixelRatio) {\n                            continue;\n                        }\n                        var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);\n                        /** @type {ReplayImageOrLabelArgs} */\n                        var args = [\n                            context,\n                            contextScale,\n                            image,\n                            dimensions,\n                            opacity,\n                            backgroundFill\n                                ? /** @type {Array<*>} */ (lastFillInstruction)\n                                : null,\n                            backgroundStroke\n                                ? /** @type {Array<*>} */ (lastStrokeInstruction)\n                                : null,\n                        ];\n                        var imageArgs = void 0;\n                        var imageDeclutterBox = void 0;\n                        if (opt_declutterTree && declutterImageWithText) {\n                            var index = dd - d;\n                            if (!declutterImageWithText[index]) {\n                                // We now have the image for an image+text combination.\n                                declutterImageWithText[index] = args;\n                                // Don't render anything for now, wait for the text.\n                                continue;\n                            }\n                            imageArgs = declutterImageWithText[index];\n                            delete declutterImageWithText[index];\n                            imageDeclutterBox = getDeclutterBox(imageArgs);\n                            if (opt_declutterTree.collides(imageDeclutterBox)) {\n                                continue;\n                            }\n                        }\n                        if (opt_declutterTree &&\n                            opt_declutterTree.collides(dimensions.declutterBox)) {\n                            continue;\n                        }\n                        if (imageArgs) {\n                            // We now have image and text for an image+text combination.\n                            if (opt_declutterTree) {\n                                opt_declutterTree.insert(imageDeclutterBox);\n                            }\n                            // Render the image before we render the text.\n                            this.replayImageOrLabel_.apply(this, imageArgs);\n                        }\n                        if (opt_declutterTree) {\n                            opt_declutterTree.insert(dimensions.declutterBox);\n                        }\n                        this.replayImageOrLabel_.apply(this, args);\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.DRAW_CHARS:\n                    var begin = /** @type {number} */ (instruction[1]);\n                    var end = /** @type {number} */ (instruction[2]);\n                    var baseline = /** @type {number} */ (instruction[3]);\n                    var overflow = /** @type {number} */ (instruction[4]);\n                    fillKey = /** @type {string} */ (instruction[5]);\n                    var maxAngle = /** @type {number} */ (instruction[6]);\n                    var measurePixelRatio = /** @type {number} */ (instruction[7]);\n                    var offsetY = /** @type {number} */ (instruction[8]);\n                    strokeKey = /** @type {string} */ (instruction[9]);\n                    var strokeWidth = /** @type {number} */ (instruction[10]);\n                    text = /** @type {string} */ (instruction[11]);\n                    textKey = /** @type {string} */ (instruction[12]);\n                    var pixelRatioScale = [\n                        /** @type {number} */ (instruction[13]),\n                        /** @type {number} */ (instruction[13]),\n                    ];\n                    var textState = this.textStates[textKey];\n                    var font = textState.font;\n                    var textScale = [\n                        textState.scale[0] * measurePixelRatio,\n                        textState.scale[1] * measurePixelRatio,\n                    ];\n                    var cachedWidths = void 0;\n                    if (font in this.widths_) {\n                        cachedWidths = this.widths_[font];\n                    }\n                    else {\n                        cachedWidths = {};\n                        this.widths_[font] = cachedWidths;\n                    }\n                    var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n                    var textLength = Math.abs(textScale[0]) *\n                        measureAndCacheTextWidth(font, text, cachedWidths);\n                    if (overflow || textLength <= pathLength) {\n                        var textAlign = this.textStates[textKey].textAlign;\n                        var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n                        var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n                        drawChars: if (parts) {\n                            /** @type {Array<ReplayImageOrLabelArgs>} */\n                            var replayImageOrLabelArgs = [];\n                            var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;\n                            if (strokeKey) {\n                                for (c = 0, cc = parts.length; c < cc; ++c) {\n                                    part = parts[c]; // x, y, anchorX, rotation, chunk\n                                    chars = /** @type {string} */ (part[4]);\n                                    label = this.createLabel(chars, textKey, '', strokeKey);\n                                    anchorX =\n                                        /** @type {number} */ (part[2]) +\n                                            (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                                    anchorY =\n                                        baseline * label.height +\n                                            ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /\n                                                textScale[0] -\n                                            offsetY;\n                                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n                                    if (opt_declutterTree &&\n                                        opt_declutterTree.collides(dimensions.declutterBox)) {\n                                        break drawChars;\n                                    }\n                                    replayImageOrLabelArgs.push([\n                                        context,\n                                        contextScale,\n                                        label,\n                                        dimensions,\n                                        1,\n                                        null,\n                                        null,\n                                    ]);\n                                }\n                            }\n                            if (fillKey) {\n                                for (c = 0, cc = parts.length; c < cc; ++c) {\n                                    part = parts[c]; // x, y, anchorX, rotation, chunk\n                                    chars = /** @type {string} */ (part[4]);\n                                    label = this.createLabel(chars, textKey, fillKey, '');\n                                    anchorX = /** @type {number} */ (part[2]);\n                                    anchorY = baseline * label.height - offsetY;\n                                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n                                    if (opt_declutterTree &&\n                                        opt_declutterTree.collides(dimensions.declutterBox)) {\n                                        break drawChars;\n                                    }\n                                    replayImageOrLabelArgs.push([\n                                        context,\n                                        contextScale,\n                                        label,\n                                        dimensions,\n                                        1,\n                                        null,\n                                        null,\n                                    ]);\n                                }\n                            }\n                            if (opt_declutterTree) {\n                                opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n                            }\n                            for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {\n                                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);\n                            }\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.END_GEOMETRY:\n                    if (opt_featureCallback !== undefined) {\n                        feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (instruction[1]);\n                        var result = opt_featureCallback(feature, currentGeometry);\n                        if (result) {\n                            return result;\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.FILL:\n                    if (batchSize) {\n                        pendingFill++;\n                    }\n                    else {\n                        this.fill_(context);\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.MOVE_TO_LINE_TO:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = /** @type {number} */ (instruction[2]);\n                    x = pixelCoordinates[d];\n                    y = pixelCoordinates[d + 1];\n                    roundX = (x + 0.5) | 0;\n                    roundY = (y + 0.5) | 0;\n                    if (roundX !== prevX || roundY !== prevY) {\n                        context.moveTo(x, y);\n                        prevX = roundX;\n                        prevY = roundY;\n                    }\n                    for (d += 2; d < dd; d += 2) {\n                        x = pixelCoordinates[d];\n                        y = pixelCoordinates[d + 1];\n                        roundX = (x + 0.5) | 0;\n                        roundY = (y + 0.5) | 0;\n                        if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n                            context.lineTo(x, y);\n                            prevX = roundX;\n                            prevY = roundY;\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.SET_FILL_STYLE:\n                    lastFillInstruction = instruction;\n                    this.alignFill_ = instruction[2];\n                    if (pendingFill) {\n                        this.fill_(context);\n                        pendingFill = 0;\n                        if (pendingStroke) {\n                            context.stroke();\n                            pendingStroke = 0;\n                        }\n                    }\n                    context.fillStyle =\n                        /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n                    ++i;\n                    break;\n                case CanvasInstruction.SET_STROKE_STYLE:\n                    lastStrokeInstruction = instruction;\n                    if (pendingStroke) {\n                        context.stroke();\n                        pendingStroke = 0;\n                    }\n                    this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));\n                    ++i;\n                    break;\n                case CanvasInstruction.STROKE:\n                    if (batchSize) {\n                        pendingStroke++;\n                    }\n                    else {\n                        context.stroke();\n                    }\n                    ++i;\n                    break;\n                default:\n                    ++i; // consume the instruction anyway, to avoid an infinite loop\n                    break;\n            }\n        }\n        if (pendingFill) {\n            this.fill_(context);\n        }\n        if (pendingStroke) {\n            context.stroke();\n        }\n        return undefined;\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n     */\n    Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {\n        this.viewRotation_ = viewRotation;\n        this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n     * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n     *     features that intersect this extent.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {\n        this.viewRotation_ = viewRotation;\n        return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n    };\n    return Executor;\n}());\nexport default Executor;\n"]},"metadata":{},"sourceType":"module"}