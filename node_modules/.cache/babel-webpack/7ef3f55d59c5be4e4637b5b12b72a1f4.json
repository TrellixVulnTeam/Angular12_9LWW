{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/WKT\n */\n\n\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport TextFeature from './TextFeature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, import(\"../geom/GeometryLayout.js\").default)}\n */\n\nvar GeometryConstructor = {\n  'POINT': Point,\n  'LINESTRING': LineString,\n  'POLYGON': Polygon,\n  'MULTIPOINT': MultiPoint,\n  'MULTILINESTRING': MultiLineString,\n  'MULTIPOLYGON': MultiPolygon\n};\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type Type.\n * @property {number|string} [value] Value.\n * @property {number} position Position.\n */\n\n/**\n * @const\n * @type {string}\n */\n\nvar EMPTY = 'EMPTY';\n/**\n * @const\n * @type {string}\n */\n\nvar Z = 'Z';\n/**\n * @const\n * @type {string}\n */\n\nvar M = 'M';\n/**\n * @const\n * @type {string}\n */\n\nvar ZM = 'ZM';\n/**\n * @const\n * @enum {number}\n */\n\nvar TokenType = {\n  START: 0,\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6\n};\n/**\n * @const\n * @type {Object<string, string>}\n */\n\nvar WKTGeometryType = {};\n\nfor (var type in GeometryType) {\n  WKTGeometryType[type] = GeometryType[type].toUpperCase();\n}\n/**\n * Class to tokenize a WKT string.\n */\n\n\nvar Lexer = function () {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  function Lexer(wkt) {\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.index_ = -1;\n  }\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n\n\n  Lexer.prototype.isAlpha_ = function (c) {\n    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';\n  };\n  /**\n   * @param {string} c Character.\n   * @param {boolean} [opt_decimal] Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n\n\n  Lexer.prototype.isNumeric_ = function (c, opt_decimal) {\n    var decimal = opt_decimal !== undefined ? opt_decimal : false;\n    return c >= '0' && c <= '9' || c == '.' && !decimal;\n  };\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n\n\n  Lexer.prototype.isWhiteSpace_ = function (c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n  };\n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n\n\n  Lexer.prototype.nextChar_ = function () {\n    return this.wkt.charAt(++this.index_);\n  };\n  /**\n   * Fetch and return the next token.\n   * @return {Token} Next string token.\n   */\n\n\n  Lexer.prototype.nextToken = function () {\n    var c = this.nextChar_();\n    var position = this.index_;\n    /** @type {number|string} */\n\n    var value = c;\n    var type;\n\n    if (c == '(') {\n      type = TokenType.LEFT_PAREN;\n    } else if (c == ',') {\n      type = TokenType.COMMA;\n    } else if (c == ')') {\n      type = TokenType.RIGHT_PAREN;\n    } else if (this.isNumeric_(c) || c == '-') {\n      type = TokenType.NUMBER;\n      value = this.readNumber_();\n    } else if (this.isAlpha_(c)) {\n      type = TokenType.TEXT;\n      value = this.readText_();\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken();\n    } else if (c === '') {\n      type = TokenType.EOF;\n    } else {\n      throw new Error('Unexpected character: ' + c);\n    }\n\n    return {\n      position: position,\n      value: value,\n      type: type\n    };\n  };\n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n\n\n  Lexer.prototype.readNumber_ = function () {\n    var c;\n    var index = this.index_;\n    var decimal = false;\n    var scientificNotation = false;\n\n    do {\n      if (c == '.') {\n        decimal = true;\n      } else if (c == 'e' || c == 'E') {\n        scientificNotation = true;\n      }\n\n      c = this.nextChar_();\n    } while (this.isNumeric_(c, decimal) || !scientificNotation && (c == 'e' || c == 'E') || scientificNotation && (c == '-' || c == '+'));\n\n    return parseFloat(this.wkt.substring(index, this.index_--));\n  };\n  /**\n   * @return {string} String token value.\n   * @private\n   */\n\n\n  Lexer.prototype.readText_ = function () {\n    var c;\n    var index = this.index_;\n\n    do {\n      c = this.nextChar_();\n    } while (this.isAlpha_(c));\n\n    return this.wkt.substring(index, this.index_--).toUpperCase();\n  };\n\n  return Lexer;\n}();\n/**\n * Class to parse the tokens from the WKT string.\n */\n\n\nvar Parser = function () {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  function Parser(lexer) {\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer;\n    /**\n     * @type {Token}\n     * @private\n     */\n\n    this.token_ = {\n      position: 0,\n      type: TokenType.START\n    };\n    /**\n     * @type {import(\"../geom/GeometryLayout.js\").default}\n     * @private\n     */\n\n    this.layout_ = GeometryLayout.XY;\n  }\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n\n\n  Parser.prototype.consume_ = function () {\n    this.token_ = this.lexer_.nextToken();\n  };\n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n\n\n  Parser.prototype.isTokenType = function (type) {\n    return this.token_.type == type;\n  };\n  /**\n   * If the given type matches the current token, consume it.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n\n\n  Parser.prototype.match = function (type) {\n    var isMatch = this.isTokenType(type);\n\n    if (isMatch) {\n      this.consume_();\n    }\n\n    return isMatch;\n  };\n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   */\n\n\n  Parser.prototype.parse = function () {\n    this.consume_();\n    return this.parseGeometry_();\n  };\n  /**\n   * Try to parse the dimensional info.\n   * @return {import(\"../geom/GeometryLayout.js\").default} The layout.\n   * @private\n   */\n\n\n  Parser.prototype.parseGeometryLayout_ = function () {\n    var layout = GeometryLayout.XY;\n    var dimToken = this.token_;\n\n    if (this.isTokenType(TokenType.TEXT)) {\n      var dimInfo = dimToken.value;\n\n      if (dimInfo === Z) {\n        layout = GeometryLayout.XYZ;\n      } else if (dimInfo === M) {\n        layout = GeometryLayout.XYM;\n      } else if (dimInfo === ZM) {\n        layout = GeometryLayout.XYZM;\n      }\n\n      if (layout !== GeometryLayout.XY) {\n        this.consume_();\n      }\n    }\n\n    return layout;\n  };\n  /**\n   * @return {Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n   * @private\n   */\n\n\n  Parser.prototype.parseGeometryCollectionText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var geometries = [];\n\n      do {\n        geometries.push(this.parseGeometry_());\n      } while (this.match(TokenType.COMMA));\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return geometries;\n      }\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {Array<number>} All values in a point.\n   * @private\n   */\n\n\n  Parser.prototype.parsePointText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = this.parsePoint_();\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {Array<Array<number>>} All points in a linestring.\n   * @private\n   */\n\n\n  Parser.prototype.parseLineStringText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = this.parsePointList_();\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {Array<Array<Array<number>>>} All points in a polygon.\n   * @private\n   */\n\n\n  Parser.prototype.parsePolygonText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = this.parseLineStringTextList_();\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {Array<Array<number>>} All points in a multipoint.\n   * @private\n   */\n\n\n  Parser.prototype.parseMultiPointText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = void 0;\n\n      if (this.token_.type == TokenType.LEFT_PAREN) {\n        coordinates = this.parsePointTextList_();\n      } else {\n        coordinates = this.parsePointList_();\n      }\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {Array<Array<Array<number>>>} All linestring points\n   *                                          in a multilinestring.\n   * @private\n   */\n\n\n  Parser.prototype.parseMultiLineStringText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = this.parseLineStringTextList_();\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.\n   * @private\n   */\n\n\n  Parser.prototype.parseMultiPolygonText_ = function () {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates = this.parsePolygonTextList_();\n\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {Array<number>} A point.\n   * @private\n   */\n\n\n  Parser.prototype.parsePoint_ = function () {\n    var coordinates = [];\n    var dimensions = this.layout_.length;\n\n    for (var i = 0; i < dimensions; ++i) {\n      var token = this.token_;\n\n      if (this.match(TokenType.NUMBER)) {\n        coordinates.push(token.value);\n      } else {\n        break;\n      }\n    }\n\n    if (coordinates.length == dimensions) {\n      return coordinates;\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n\n\n  Parser.prototype.parsePointList_ = function () {\n    var coordinates = [this.parsePoint_()];\n\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePoint_());\n    }\n\n    return coordinates;\n  };\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n\n\n  Parser.prototype.parsePointTextList_ = function () {\n    var coordinates = [this.parsePointText_()];\n\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePointText_());\n    }\n\n    return coordinates;\n  };\n  /**\n   * @return {Array<Array<Array<number>>>} An array of points.\n   * @private\n   */\n\n\n  Parser.prototype.parseLineStringTextList_ = function () {\n    var coordinates = [this.parseLineStringText_()];\n\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parseLineStringText_());\n    }\n\n    return coordinates;\n  };\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} An array of points.\n   * @private\n   */\n\n\n  Parser.prototype.parsePolygonTextList_ = function () {\n    var coordinates = [this.parsePolygonText_()];\n\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePolygonText_());\n    }\n\n    return coordinates;\n  };\n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n\n\n  Parser.prototype.isEmptyGeometry_ = function () {\n    var isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n\n    if (isEmpty) {\n      this.consume_();\n    }\n\n    return isEmpty;\n  };\n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n\n\n  Parser.prototype.formatErrorMessage_ = function () {\n    return 'Unexpected `' + this.token_.value + '` at position ' + this.token_.position + ' in `' + this.lexer_.wkt + '`';\n  };\n  /**\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   * @private\n   */\n\n\n  Parser.prototype.parseGeometry_ = function () {\n    var token = this.token_;\n\n    if (this.match(TokenType.TEXT)) {\n      var geomType = token.value;\n      this.layout_ = this.parseGeometryLayout_();\n      var isEmpty = this.isEmptyGeometry_();\n\n      if (geomType == 'GEOMETRYCOLLECTION') {\n        if (isEmpty) {\n          return new GeometryCollection([]);\n        }\n\n        var geometries = this.parseGeometryCollectionText_();\n        return new GeometryCollection(geometries);\n      } else {\n        var ctor = GeometryConstructor[geomType];\n\n        if (!ctor) {\n          throw new Error('Invalid geometry type: ' + geomType);\n        }\n\n        var coordinates = void 0;\n\n        if (isEmpty) {\n          if (geomType == 'POINT') {\n            coordinates = [NaN, NaN];\n          } else {\n            coordinates = [];\n          }\n        } else {\n          switch (geomType) {\n            case 'POINT':\n              {\n                coordinates = this.parsePointText_();\n                break;\n              }\n\n            case 'LINESTRING':\n              {\n                coordinates = this.parseLineStringText_();\n                break;\n              }\n\n            case 'POLYGON':\n              {\n                coordinates = this.parsePolygonText_();\n                break;\n              }\n\n            case 'MULTIPOINT':\n              {\n                coordinates = this.parseMultiPointText_();\n                break;\n              }\n\n            case 'MULTILINESTRING':\n              {\n                coordinates = this.parseMultiLineStringText_();\n                break;\n              }\n\n            case 'MULTIPOLYGON':\n              {\n                coordinates = this.parseMultiPolygonText_();\n                break;\n              }\n\n            default:\n              break;\n          }\n        }\n\n        return new ctor(coordinates, this.layout_);\n      }\n    }\n\n    throw new Error(this.formatErrorMessage_());\n  };\n\n  return Parser;\n}();\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\n\n\nvar WKT = function (_super) {\n  __extends(WKT, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n\n\n  function WKT(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    /**\n     * Split GeometryCollection into multiple features.\n     * @type {boolean}\n     * @private\n     */\n\n    _this.splitCollection_ = options.splitCollection !== undefined ? options.splitCollection : false;\n    return _this;\n  }\n  /**\n   * Parse a WKT string.\n   * @param {string} wkt WKT string.\n   * @return {import(\"../geom/Geometry.js\").default}\n   *     The geometry created.\n   * @private\n   */\n\n\n  WKT.prototype.parse_ = function (wkt) {\n    var lexer = new Lexer(wkt);\n    var parser = new Parser(lexer);\n    return parser.parse();\n  };\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n\n\n  WKT.prototype.readFeatureFromText = function (text, opt_options) {\n    var geom = this.readGeometryFromText(text, opt_options);\n    var feature = new Feature();\n    feature.setGeometry(geom);\n    return feature;\n  };\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n\n\n  WKT.prototype.readFeaturesFromText = function (text, opt_options) {\n    var geometries = [];\n    var geometry = this.readGeometryFromText(text, opt_options);\n\n    if (this.splitCollection_ && geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n      geometries =\n      /** @type {GeometryCollection} */\n      geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n\n    var features = [];\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      var feature = new Feature();\n      feature.setGeometry(geometries[i]);\n      features.push(feature);\n    }\n\n    return features;\n  };\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n\n\n  WKT.prototype.readGeometryFromText = function (text, opt_options) {\n    var geometry = this.parse_(text);\n    return transformGeometryWithOptions(geometry, false, opt_options);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n\n\n  WKT.prototype.writeFeatureText = function (feature, opt_options) {\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      return this.writeGeometryText(geometry, opt_options);\n    }\n\n    return '';\n  };\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n\n\n  WKT.prototype.writeFeaturesText = function (features, opt_options) {\n    if (features.length == 1) {\n      return this.writeFeatureText(features[0], opt_options);\n    }\n\n    var geometries = [];\n\n    for (var i = 0, ii = features.length; i < ii; ++i) {\n      geometries.push(features[i].getGeometry());\n    }\n\n    var collection = new GeometryCollection(geometries);\n    return this.writeGeometryText(collection, opt_options);\n  };\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n\n\n  WKT.prototype.writeGeometryText = function (geometry, opt_options) {\n    return encode(transformGeometryWithOptions(geometry, true, opt_options));\n  };\n\n  return WKT;\n}(TextFeature);\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\n\n\nfunction encodePointGeometry(geom) {\n  var coordinates = geom.getCoordinates();\n\n  if (coordinates.length === 0) {\n    return '';\n  }\n\n  return coordinates.join(' ');\n}\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\n\n\nfunction encodeMultiPointGeometry(geom) {\n  var array = [];\n  var components = geom.getPoints();\n\n  for (var i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePointGeometry(components[i]) + ')');\n  }\n\n  return array.join(',');\n}\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\n\n\nfunction encodeGeometryCollectionGeometry(geom) {\n  var array = [];\n  var geoms = geom.getGeometries();\n\n  for (var i = 0, ii = geoms.length; i < ii; ++i) {\n    array.push(encode(geoms[i]));\n  }\n\n  return array.join(',');\n}\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\n\n\nfunction encodeLineStringGeometry(geom) {\n  var coordinates = geom.getCoordinates();\n  var array = [];\n\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    array.push(coordinates[i].join(' '));\n  }\n\n  return array.join(',');\n}\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\n\n\nfunction encodeMultiLineStringGeometry(geom) {\n  var array = [];\n  var components = geom.getLineStrings();\n\n  for (var i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n  }\n\n  return array.join(',');\n}\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\n\n\nfunction encodePolygonGeometry(geom) {\n  var array = [];\n  var rings = geom.getLinearRings();\n\n  for (var i = 0, ii = rings.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n  }\n\n  return array.join(',');\n}\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\n\n\nfunction encodeMultiPolygonGeometry(geom) {\n  var array = [];\n  var components = geom.getPolygons();\n\n  for (var i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePolygonGeometry(components[i]) + ')');\n  }\n\n  return array.join(',');\n}\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\n\n\nfunction encodeGeometryLayout(geom) {\n  var layout = geom.getLayout();\n  var dimInfo = '';\n\n  if (layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM) {\n    dimInfo += Z;\n  }\n\n  if (layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM) {\n    dimInfo += M;\n  }\n\n  return dimInfo;\n}\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\n\n\nvar GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry\n};\n/**\n * Encode a geometry as WKT.\n * @param {import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\n\nfunction encode(geom) {\n  var type = geom.getType();\n  var geometryEncoder = GeometryEncoder[type];\n  var enc = geometryEncoder(geom);\n  type = type.toUpperCase();\n\n  if (typeof\n  /** @type {?} */\n  geom.getFlatCoordinates === 'function') {\n    var dimInfo = encodeGeometryLayout(geom);\n\n    if (dimInfo.length > 0) {\n      type += ' ' + dimInfo;\n    }\n  }\n\n  if (enc.length === 0) {\n    return type + ' ' + EMPTY;\n  }\n\n  return type + '(' + enc + ')';\n}\n\nexport default WKT;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/format/WKT.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","Feature","GeometryCollection","GeometryLayout","GeometryType","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","TextFeature","transformGeometryWithOptions","GeometryConstructor","EMPTY","Z","M","ZM","TokenType","START","TEXT","LEFT_PAREN","RIGHT_PAREN","NUMBER","COMMA","EOF","WKTGeometryType","type","toUpperCase","Lexer","wkt","index_","isAlpha_","c","isNumeric_","opt_decimal","decimal","undefined","isWhiteSpace_","nextChar_","charAt","nextToken","position","value","readNumber_","readText_","Error","index","scientificNotation","parseFloat","substring","Parser","lexer","lexer_","token_","layout_","XY","consume_","isTokenType","match","isMatch","parse","parseGeometry_","parseGeometryLayout_","layout","dimToken","dimInfo","XYZ","XYM","XYZM","parseGeometryCollectionText_","geometries","push","formatErrorMessage_","parsePointText_","coordinates","parsePoint_","parseLineStringText_","parsePointList_","parsePolygonText_","parseLineStringTextList_","parseMultiPointText_","parsePointTextList_","parseMultiLineStringText_","parseMultiPolygonText_","parsePolygonTextList_","dimensions","length","i","token","isEmptyGeometry_","isEmpty","geomType","ctor","NaN","WKT","_super","opt_options","_this","options","splitCollection_","splitCollection","parse_","parser","readFeatureFromText","text","geom","readGeometryFromText","feature","setGeometry","readFeaturesFromText","geometry","getType","GEOMETRY_COLLECTION","getGeometriesArray","features","ii","writeFeatureText","getGeometry","writeGeometryText","writeFeaturesText","collection","encode","encodePointGeometry","getCoordinates","join","encodeMultiPointGeometry","array","components","getPoints","encodeGeometryCollectionGeometry","geoms","getGeometries","encodeLineStringGeometry","encodeMultiLineStringGeometry","getLineStrings","encodePolygonGeometry","rings","getLinearRings","encodeMultiPolygonGeometry","getPolygons","encodeGeometryLayout","getLayout","GeometryEncoder","geometryEncoder","enc","getFlatCoordinates"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/WKT\n */\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport TextFeature from './TextFeature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, import(\"../geom/GeometryLayout.js\").default)}\n */\nvar GeometryConstructor = {\n    'POINT': Point,\n    'LINESTRING': LineString,\n    'POLYGON': Polygon,\n    'MULTIPOINT': MultiPoint,\n    'MULTILINESTRING': MultiLineString,\n    'MULTIPOLYGON': MultiPolygon,\n};\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n/**\n * @typedef {Object} Token\n * @property {number} type Type.\n * @property {number|string} [value] Value.\n * @property {number} position Position.\n */\n/**\n * @const\n * @type {string}\n */\nvar EMPTY = 'EMPTY';\n/**\n * @const\n * @type {string}\n */\nvar Z = 'Z';\n/**\n * @const\n * @type {string}\n */\nvar M = 'M';\n/**\n * @const\n * @type {string}\n */\nvar ZM = 'ZM';\n/**\n * @const\n * @enum {number}\n */\nvar TokenType = {\n    START: 0,\n    TEXT: 1,\n    LEFT_PAREN: 2,\n    RIGHT_PAREN: 3,\n    NUMBER: 4,\n    COMMA: 5,\n    EOF: 6,\n};\n/**\n * @const\n * @type {Object<string, string>}\n */\nvar WKTGeometryType = {};\nfor (var type in GeometryType) {\n    WKTGeometryType[type] = GeometryType[type].toUpperCase();\n}\n/**\n * Class to tokenize a WKT string.\n */\nvar Lexer = /** @class */ (function () {\n    /**\n     * @param {string} wkt WKT string.\n     */\n    function Lexer(wkt) {\n        /**\n         * @type {string}\n         */\n        this.wkt = wkt;\n        /**\n         * @type {number}\n         * @private\n         */\n        this.index_ = -1;\n    }\n    /**\n     * @param {string} c Character.\n     * @return {boolean} Whether the character is alphabetic.\n     * @private\n     */\n    Lexer.prototype.isAlpha_ = function (c) {\n        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n    };\n    /**\n     * @param {string} c Character.\n     * @param {boolean} [opt_decimal] Whether the string number\n     *     contains a dot, i.e. is a decimal number.\n     * @return {boolean} Whether the character is numeric.\n     * @private\n     */\n    Lexer.prototype.isNumeric_ = function (c, opt_decimal) {\n        var decimal = opt_decimal !== undefined ? opt_decimal : false;\n        return (c >= '0' && c <= '9') || (c == '.' && !decimal);\n    };\n    /**\n     * @param {string} c Character.\n     * @return {boolean} Whether the character is whitespace.\n     * @private\n     */\n    Lexer.prototype.isWhiteSpace_ = function (c) {\n        return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n    };\n    /**\n     * @return {string} Next string character.\n     * @private\n     */\n    Lexer.prototype.nextChar_ = function () {\n        return this.wkt.charAt(++this.index_);\n    };\n    /**\n     * Fetch and return the next token.\n     * @return {Token} Next string token.\n     */\n    Lexer.prototype.nextToken = function () {\n        var c = this.nextChar_();\n        var position = this.index_;\n        /** @type {number|string} */\n        var value = c;\n        var type;\n        if (c == '(') {\n            type = TokenType.LEFT_PAREN;\n        }\n        else if (c == ',') {\n            type = TokenType.COMMA;\n        }\n        else if (c == ')') {\n            type = TokenType.RIGHT_PAREN;\n        }\n        else if (this.isNumeric_(c) || c == '-') {\n            type = TokenType.NUMBER;\n            value = this.readNumber_();\n        }\n        else if (this.isAlpha_(c)) {\n            type = TokenType.TEXT;\n            value = this.readText_();\n        }\n        else if (this.isWhiteSpace_(c)) {\n            return this.nextToken();\n        }\n        else if (c === '') {\n            type = TokenType.EOF;\n        }\n        else {\n            throw new Error('Unexpected character: ' + c);\n        }\n        return { position: position, value: value, type: type };\n    };\n    /**\n     * @return {number} Numeric token value.\n     * @private\n     */\n    Lexer.prototype.readNumber_ = function () {\n        var c;\n        var index = this.index_;\n        var decimal = false;\n        var scientificNotation = false;\n        do {\n            if (c == '.') {\n                decimal = true;\n            }\n            else if (c == 'e' || c == 'E') {\n                scientificNotation = true;\n            }\n            c = this.nextChar_();\n        } while (this.isNumeric_(c, decimal) ||\n            // if we haven't detected a scientific number before, 'e' or 'E'\n            // hint that we should continue to read\n            (!scientificNotation && (c == 'e' || c == 'E')) ||\n            // once we know that we have a scientific number, both '-' and '+'\n            // are allowed\n            (scientificNotation && (c == '-' || c == '+')));\n        return parseFloat(this.wkt.substring(index, this.index_--));\n    };\n    /**\n     * @return {string} String token value.\n     * @private\n     */\n    Lexer.prototype.readText_ = function () {\n        var c;\n        var index = this.index_;\n        do {\n            c = this.nextChar_();\n        } while (this.isAlpha_(c));\n        return this.wkt.substring(index, this.index_--).toUpperCase();\n    };\n    return Lexer;\n}());\n/**\n * Class to parse the tokens from the WKT string.\n */\nvar Parser = /** @class */ (function () {\n    /**\n     * @param {Lexer} lexer The lexer.\n     */\n    function Parser(lexer) {\n        /**\n         * @type {Lexer}\n         * @private\n         */\n        this.lexer_ = lexer;\n        /**\n         * @type {Token}\n         * @private\n         */\n        this.token_ = {\n            position: 0,\n            type: TokenType.START,\n        };\n        /**\n         * @type {import(\"../geom/GeometryLayout.js\").default}\n         * @private\n         */\n        this.layout_ = GeometryLayout.XY;\n    }\n    /**\n     * Fetch the next token form the lexer and replace the active token.\n     * @private\n     */\n    Parser.prototype.consume_ = function () {\n        this.token_ = this.lexer_.nextToken();\n    };\n    /**\n     * Tests if the given type matches the type of the current token.\n     * @param {TokenType} type Token type.\n     * @return {boolean} Whether the token matches the given type.\n     */\n    Parser.prototype.isTokenType = function (type) {\n        return this.token_.type == type;\n    };\n    /**\n     * If the given type matches the current token, consume it.\n     * @param {TokenType} type Token type.\n     * @return {boolean} Whether the token matches the given type.\n     */\n    Parser.prototype.match = function (type) {\n        var isMatch = this.isTokenType(type);\n        if (isMatch) {\n            this.consume_();\n        }\n        return isMatch;\n    };\n    /**\n     * Try to parse the tokens provided by the lexer.\n     * @return {import(\"../geom/Geometry.js\").default} The geometry.\n     */\n    Parser.prototype.parse = function () {\n        this.consume_();\n        return this.parseGeometry_();\n    };\n    /**\n     * Try to parse the dimensional info.\n     * @return {import(\"../geom/GeometryLayout.js\").default} The layout.\n     * @private\n     */\n    Parser.prototype.parseGeometryLayout_ = function () {\n        var layout = GeometryLayout.XY;\n        var dimToken = this.token_;\n        if (this.isTokenType(TokenType.TEXT)) {\n            var dimInfo = dimToken.value;\n            if (dimInfo === Z) {\n                layout = GeometryLayout.XYZ;\n            }\n            else if (dimInfo === M) {\n                layout = GeometryLayout.XYM;\n            }\n            else if (dimInfo === ZM) {\n                layout = GeometryLayout.XYZM;\n            }\n            if (layout !== GeometryLayout.XY) {\n                this.consume_();\n            }\n        }\n        return layout;\n    };\n    /**\n     * @return {Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n     * @private\n     */\n    Parser.prototype.parseGeometryCollectionText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var geometries = [];\n            do {\n                geometries.push(this.parseGeometry_());\n            } while (this.match(TokenType.COMMA));\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return geometries;\n            }\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {Array<number>} All values in a point.\n     * @private\n     */\n    Parser.prototype.parsePointText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = this.parsePoint_();\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {Array<Array<number>>} All points in a linestring.\n     * @private\n     */\n    Parser.prototype.parseLineStringText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = this.parsePointList_();\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {Array<Array<Array<number>>>} All points in a polygon.\n     * @private\n     */\n    Parser.prototype.parsePolygonText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = this.parseLineStringTextList_();\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {Array<Array<number>>} All points in a multipoint.\n     * @private\n     */\n    Parser.prototype.parseMultiPointText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = void 0;\n            if (this.token_.type == TokenType.LEFT_PAREN) {\n                coordinates = this.parsePointTextList_();\n            }\n            else {\n                coordinates = this.parsePointList_();\n            }\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {Array<Array<Array<number>>>} All linestring points\n     *                                          in a multilinestring.\n     * @private\n     */\n    Parser.prototype.parseMultiLineStringText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = this.parseLineStringTextList_();\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.\n     * @private\n     */\n    Parser.prototype.parseMultiPolygonText_ = function () {\n        if (this.match(TokenType.LEFT_PAREN)) {\n            var coordinates = this.parsePolygonTextList_();\n            if (this.match(TokenType.RIGHT_PAREN)) {\n                return coordinates;\n            }\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {Array<number>} A point.\n     * @private\n     */\n    Parser.prototype.parsePoint_ = function () {\n        var coordinates = [];\n        var dimensions = this.layout_.length;\n        for (var i = 0; i < dimensions; ++i) {\n            var token = this.token_;\n            if (this.match(TokenType.NUMBER)) {\n                coordinates.push(/** @type {number} */ (token.value));\n            }\n            else {\n                break;\n            }\n        }\n        if (coordinates.length == dimensions) {\n            return coordinates;\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    /**\n     * @return {Array<Array<number>>} An array of points.\n     * @private\n     */\n    Parser.prototype.parsePointList_ = function () {\n        var coordinates = [this.parsePoint_()];\n        while (this.match(TokenType.COMMA)) {\n            coordinates.push(this.parsePoint_());\n        }\n        return coordinates;\n    };\n    /**\n     * @return {Array<Array<number>>} An array of points.\n     * @private\n     */\n    Parser.prototype.parsePointTextList_ = function () {\n        var coordinates = [this.parsePointText_()];\n        while (this.match(TokenType.COMMA)) {\n            coordinates.push(this.parsePointText_());\n        }\n        return coordinates;\n    };\n    /**\n     * @return {Array<Array<Array<number>>>} An array of points.\n     * @private\n     */\n    Parser.prototype.parseLineStringTextList_ = function () {\n        var coordinates = [this.parseLineStringText_()];\n        while (this.match(TokenType.COMMA)) {\n            coordinates.push(this.parseLineStringText_());\n        }\n        return coordinates;\n    };\n    /**\n     * @return {Array<Array<Array<Array<number>>>>} An array of points.\n     * @private\n     */\n    Parser.prototype.parsePolygonTextList_ = function () {\n        var coordinates = [this.parsePolygonText_()];\n        while (this.match(TokenType.COMMA)) {\n            coordinates.push(this.parsePolygonText_());\n        }\n        return coordinates;\n    };\n    /**\n     * @return {boolean} Whether the token implies an empty geometry.\n     * @private\n     */\n    Parser.prototype.isEmptyGeometry_ = function () {\n        var isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n        if (isEmpty) {\n            this.consume_();\n        }\n        return isEmpty;\n    };\n    /**\n     * Create an error message for an unexpected token error.\n     * @return {string} Error message.\n     * @private\n     */\n    Parser.prototype.formatErrorMessage_ = function () {\n        return ('Unexpected `' +\n            this.token_.value +\n            '` at position ' +\n            this.token_.position +\n            ' in `' +\n            this.lexer_.wkt +\n            '`');\n    };\n    /**\n     * @return {import(\"../geom/Geometry.js\").default} The geometry.\n     * @private\n     */\n    Parser.prototype.parseGeometry_ = function () {\n        var token = this.token_;\n        if (this.match(TokenType.TEXT)) {\n            var geomType = /** @type {string} */ (token.value);\n            this.layout_ = this.parseGeometryLayout_();\n            var isEmpty = this.isEmptyGeometry_();\n            if (geomType == 'GEOMETRYCOLLECTION') {\n                if (isEmpty) {\n                    return new GeometryCollection([]);\n                }\n                var geometries = this.parseGeometryCollectionText_();\n                return new GeometryCollection(geometries);\n            }\n            else {\n                var ctor = GeometryConstructor[geomType];\n                if (!ctor) {\n                    throw new Error('Invalid geometry type: ' + geomType);\n                }\n                var coordinates = void 0;\n                if (isEmpty) {\n                    if (geomType == 'POINT') {\n                        coordinates = [NaN, NaN];\n                    }\n                    else {\n                        coordinates = [];\n                    }\n                }\n                else {\n                    switch (geomType) {\n                        case 'POINT': {\n                            coordinates = this.parsePointText_();\n                            break;\n                        }\n                        case 'LINESTRING': {\n                            coordinates = this.parseLineStringText_();\n                            break;\n                        }\n                        case 'POLYGON': {\n                            coordinates = this.parsePolygonText_();\n                            break;\n                        }\n                        case 'MULTIPOINT': {\n                            coordinates = this.parseMultiPointText_();\n                            break;\n                        }\n                        case 'MULTILINESTRING': {\n                            coordinates = this.parseMultiLineStringText_();\n                            break;\n                        }\n                        case 'MULTIPOLYGON': {\n                            coordinates = this.parseMultiPolygonText_();\n                            break;\n                        }\n                        default:\n                            break;\n                    }\n                }\n                return new ctor(coordinates, this.layout_);\n            }\n        }\n        throw new Error(this.formatErrorMessage_());\n    };\n    return Parser;\n}());\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\nvar WKT = /** @class */ (function (_super) {\n    __extends(WKT, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function WKT(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * Split GeometryCollection into multiple features.\n         * @type {boolean}\n         * @private\n         */\n        _this.splitCollection_ =\n            options.splitCollection !== undefined ? options.splitCollection : false;\n        return _this;\n    }\n    /**\n     * Parse a WKT string.\n     * @param {string} wkt WKT string.\n     * @return {import(\"../geom/Geometry.js\").default}\n     *     The geometry created.\n     * @private\n     */\n    WKT.prototype.parse_ = function (wkt) {\n        var lexer = new Lexer(wkt);\n        var parser = new Parser(lexer);\n        return parser.parse();\n    };\n    /**\n     * @protected\n     * @param {string} text Text.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @return {import(\"../Feature.js\").default} Feature.\n     */\n    WKT.prototype.readFeatureFromText = function (text, opt_options) {\n        var geom = this.readGeometryFromText(text, opt_options);\n        var feature = new Feature();\n        feature.setGeometry(geom);\n        return feature;\n    };\n    /**\n     * @param {string} text Text.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {Array<Feature>} Features.\n     */\n    WKT.prototype.readFeaturesFromText = function (text, opt_options) {\n        var geometries = [];\n        var geometry = this.readGeometryFromText(text, opt_options);\n        if (this.splitCollection_ &&\n            geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n            geometries = /** @type {GeometryCollection} */ (geometry).getGeometriesArray();\n        }\n        else {\n            geometries = [geometry];\n        }\n        var features = [];\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            var feature = new Feature();\n            feature.setGeometry(geometries[i]);\n            features.push(feature);\n        }\n        return features;\n    };\n    /**\n     * @param {string} text Text.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n    WKT.prototype.readGeometryFromText = function (text, opt_options) {\n        var geometry = this.parse_(text);\n        return transformGeometryWithOptions(geometry, false, opt_options);\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @protected\n     * @return {string} Text.\n     */\n    WKT.prototype.writeFeatureText = function (feature, opt_options) {\n        var geometry = feature.getGeometry();\n        if (geometry) {\n            return this.writeGeometryText(geometry, opt_options);\n        }\n        return '';\n    };\n    /**\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @protected\n     * @return {string} Text.\n     */\n    WKT.prototype.writeFeaturesText = function (features, opt_options) {\n        if (features.length == 1) {\n            return this.writeFeatureText(features[0], opt_options);\n        }\n        var geometries = [];\n        for (var i = 0, ii = features.length; i < ii; ++i) {\n            geometries.push(features[i].getGeometry());\n        }\n        var collection = new GeometryCollection(geometries);\n        return this.writeGeometryText(collection, opt_options);\n    };\n    /**\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @protected\n     * @return {string} Text.\n     */\n    WKT.prototype.writeGeometryText = function (geometry, opt_options) {\n        return encode(transformGeometryWithOptions(geometry, true, opt_options));\n    };\n    return WKT;\n}(TextFeature));\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n    var coordinates = geom.getCoordinates();\n    if (coordinates.length === 0) {\n        return '';\n    }\n    return coordinates.join(' ');\n}\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n    var array = [];\n    var components = geom.getPoints();\n    for (var i = 0, ii = components.length; i < ii; ++i) {\n        array.push('(' + encodePointGeometry(components[i]) + ')');\n    }\n    return array.join(',');\n}\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n    var array = [];\n    var geoms = geom.getGeometries();\n    for (var i = 0, ii = geoms.length; i < ii; ++i) {\n        array.push(encode(geoms[i]));\n    }\n    return array.join(',');\n}\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n    var coordinates = geom.getCoordinates();\n    var array = [];\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        array.push(coordinates[i].join(' '));\n    }\n    return array.join(',');\n}\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n    var array = [];\n    var components = geom.getLineStrings();\n    for (var i = 0, ii = components.length; i < ii; ++i) {\n        array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n    }\n    return array.join(',');\n}\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n    var array = [];\n    var rings = geom.getLinearRings();\n    for (var i = 0, ii = rings.length; i < ii; ++i) {\n        array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n    }\n    return array.join(',');\n}\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n    var array = [];\n    var components = geom.getPolygons();\n    for (var i = 0, ii = components.length; i < ii; ++i) {\n        array.push('(' + encodePolygonGeometry(components[i]) + ')');\n    }\n    return array.join(',');\n}\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n    var layout = geom.getLayout();\n    var dimInfo = '';\n    if (layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM) {\n        dimInfo += Z;\n    }\n    if (layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM) {\n        dimInfo += M;\n    }\n    return dimInfo;\n}\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nvar GeometryEncoder = {\n    'Point': encodePointGeometry,\n    'LineString': encodeLineStringGeometry,\n    'Polygon': encodePolygonGeometry,\n    'MultiPoint': encodeMultiPointGeometry,\n    'MultiLineString': encodeMultiLineStringGeometry,\n    'MultiPolygon': encodeMultiPolygonGeometry,\n    'GeometryCollection': encodeGeometryCollectionGeometry,\n};\n/**\n * Encode a geometry as WKT.\n * @param {import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n    var type = geom.getType();\n    var geometryEncoder = GeometryEncoder[type];\n    var enc = geometryEncoder(geom);\n    type = type.toUpperCase();\n    if (typeof ( /** @type {?} */(geom).getFlatCoordinates) === 'function') {\n        var dimInfo = encodeGeometryLayout(\n        /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geom));\n        if (dimInfo.length > 0) {\n            type += ' ' + dimInfo;\n        }\n    }\n    if (enc.length === 0) {\n        return type + ' ' + EMPTY;\n    }\n    return type + '(' + enc + ')';\n}\nexport default WKT;\n"]},"metadata":{},"sourceType":"module"}