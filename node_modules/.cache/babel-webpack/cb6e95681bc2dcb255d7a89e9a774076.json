{"ast":null,"code":"import { empty, merge, of, Subject } from 'rxjs';\nimport { delay, finalize, tap, publishReplay, refCount } from 'rxjs/operators';\nimport { DEFAULT_CACHE_RESOLVER, GlobalCacheConfig, DEFAULT_HASHER } from './common';\nexport const globalCacheBusterNotifier = new Subject();\nexport function Cacheable(cacheConfig = {}) {\n  return function (_target, _propertyKey, propertyDescriptor) {\n    const cacheKey = cacheConfig.cacheKey || _target.constructor.name + '#' + _propertyKey;\n    const oldMethod = propertyDescriptor.value;\n\n    if (propertyDescriptor && propertyDescriptor.value) {\n      let storageStrategy = !cacheConfig.storageStrategy ? new GlobalCacheConfig.storageStrategy() : new cacheConfig.storageStrategy();\n      const pendingCachePairs = [];\n\n      if (cacheConfig.cacheModifier) {\n        cacheConfig.cacheModifier.subscribe(callback => storageStrategy.addMany(callback(storageStrategy.getAll(cacheKey, this)), cacheKey, this));\n      }\n      /**\n       * subscribe to the globalCacheBuster\n       * if a custom cacheBusterObserver is passed, subscribe to it as well\n       * subscribe to the cacheBusterObserver and upon emission, clear all caches\n       */\n\n\n      merge(globalCacheBusterNotifier.asObservable(), cacheConfig.cacheBusterObserver ? cacheConfig.cacheBusterObserver : empty()).subscribe(_ => {\n        storageStrategy.removeAll(cacheKey, this);\n        pendingCachePairs.length = 0;\n      });\n      const cacheResolver = cacheConfig.cacheResolver || GlobalCacheConfig.cacheResolver;\n      cacheConfig.cacheResolver = cacheResolver ? cacheResolver : DEFAULT_CACHE_RESOLVER;\n      const cacheHasher = cacheConfig.cacheHasher || GlobalCacheConfig.cacheHasher;\n      cacheConfig.cacheHasher = cacheHasher ? cacheHasher : DEFAULT_HASHER;\n      /* use function instead of an arrow function to keep context of invocation */\n\n      propertyDescriptor.value = function (...parameters) {\n        const cachePairs = storageStrategy.getAll(cacheKey, this);\n        let cacheParameters = cacheConfig.cacheHasher(parameters);\n\n        let _foundCachePair = cachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n\n        const _foundPendingCachePair = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n        /**\n         * check if maxAge is passed and cache has actually expired\n         */\n\n\n        if ((cacheConfig.maxAge || GlobalCacheConfig.maxAge) && _foundCachePair && _foundCachePair.created) {\n          if (new Date().getTime() - new Date(_foundCachePair.created).getTime() > (cacheConfig.maxAge || GlobalCacheConfig.maxAge)) {\n            /**\n             * cache duration has expired - remove it from the cachePairs array\n             */\n            storageStrategy.remove ? storageStrategy.remove(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.removeAtIndex(cachePairs.indexOf(_foundCachePair), cacheKey, this);\n            _foundCachePair = null;\n          } else if (cacheConfig.slidingExpiration || GlobalCacheConfig.slidingExpiration) {\n            /**\n             * renew cache duration\n             */\n            _foundCachePair.created = new Date();\n            storageStrategy.update ? storageStrategy.update(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.updateAtIndex(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this);\n          }\n        }\n\n        if (_foundCachePair) {\n          const cached$ = of(_foundCachePair.response);\n          return cacheConfig.async ? cached$.pipe(delay(0)) : cached$;\n        } else if (_foundPendingCachePair) {\n          return _foundPendingCachePair.response;\n        } else {\n          const response$ = oldMethod.call(this, ...parameters).pipe(finalize(() => {\n            /**\n             * if there has been an observable cache pair for these parameters, when it completes or errors, remove it\n             */\n            const _pendingCachePairToRemove = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n\n            pendingCachePairs.splice(pendingCachePairs.indexOf(_pendingCachePairToRemove), 1);\n          }), tap(response => {\n            /**\n             * if maxCacheCount has not been passed, just shift the cachePair to make room for the new one\n             * if maxCacheCount has been passed, respect that and only shift the cachePairs if the new cachePair will make them exceed the count\n             */\n            if (!cacheConfig.shouldCacheDecider || cacheConfig.shouldCacheDecider(response)) {\n              if (!(cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) || (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) === 1 || (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) && (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) < cachePairs.length + 1) {\n                storageStrategy.remove ? storageStrategy.remove(0, cachePairs[0], cacheKey, this) : storageStrategy.removeAtIndex(0, cacheKey, this);\n              }\n\n              storageStrategy.add({\n                parameters: cacheParameters,\n                response,\n                created: cacheConfig.maxAge || GlobalCacheConfig.maxAge ? new Date() : null\n              }, cacheKey, this);\n            }\n          }), publishReplay(1), refCount());\n          /**\n           * cache the stream\n           */\n\n          pendingCachePairs.push({\n            parameters: cacheParameters,\n            response: response$,\n            created: new Date()\n          });\n          return response$;\n        }\n      };\n    }\n\n    return propertyDescriptor;\n  };\n}\n;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ts-cacheable/dist/esm2015/cacheable.decorator.js"],"names":["empty","merge","of","Subject","delay","finalize","tap","publishReplay","refCount","DEFAULT_CACHE_RESOLVER","GlobalCacheConfig","DEFAULT_HASHER","globalCacheBusterNotifier","Cacheable","cacheConfig","_target","_propertyKey","propertyDescriptor","cacheKey","constructor","name","oldMethod","value","storageStrategy","pendingCachePairs","cacheModifier","subscribe","callback","addMany","getAll","asObservable","cacheBusterObserver","_","removeAll","length","cacheResolver","cacheHasher","parameters","cachePairs","cacheParameters","_foundCachePair","find","cp","_foundPendingCachePair","maxAge","created","Date","getTime","remove","indexOf","removeAtIndex","slidingExpiration","update","updateAtIndex","cached$","response","async","pipe","response$","call","_pendingCachePairToRemove","splice","shouldCacheDecider","maxCacheCount","add","push"],"mappings":"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","sourcesContent":["import { empty, merge, of, Subject } from 'rxjs';\nimport { delay, finalize, tap, publishReplay, refCount } from 'rxjs/operators';\nimport { DEFAULT_CACHE_RESOLVER, GlobalCacheConfig, DEFAULT_HASHER } from './common';\nexport const globalCacheBusterNotifier = new Subject();\nexport function Cacheable(cacheConfig = {}) {\n    return function (_target, _propertyKey, propertyDescriptor) {\n        const cacheKey = cacheConfig.cacheKey || _target.constructor.name + '#' + _propertyKey;\n        const oldMethod = propertyDescriptor.value;\n        if (propertyDescriptor && propertyDescriptor.value) {\n            let storageStrategy = !cacheConfig.storageStrategy\n                ? new GlobalCacheConfig.storageStrategy()\n                : new cacheConfig.storageStrategy();\n            const pendingCachePairs = [];\n            if (cacheConfig.cacheModifier) {\n                cacheConfig.cacheModifier.subscribe(callback => storageStrategy.addMany(callback(storageStrategy.getAll(cacheKey, this)), cacheKey, this));\n            }\n            /**\n             * subscribe to the globalCacheBuster\n             * if a custom cacheBusterObserver is passed, subscribe to it as well\n             * subscribe to the cacheBusterObserver and upon emission, clear all caches\n             */\n            merge(globalCacheBusterNotifier.asObservable(), cacheConfig.cacheBusterObserver\n                ? cacheConfig.cacheBusterObserver\n                : empty()).subscribe(_ => {\n                storageStrategy.removeAll(cacheKey, this);\n                pendingCachePairs.length = 0;\n            });\n            const cacheResolver = cacheConfig.cacheResolver || GlobalCacheConfig.cacheResolver;\n            cacheConfig.cacheResolver = cacheResolver\n                ? cacheResolver\n                : DEFAULT_CACHE_RESOLVER;\n            const cacheHasher = cacheConfig.cacheHasher || GlobalCacheConfig.cacheHasher;\n            cacheConfig.cacheHasher = cacheHasher\n                ? cacheHasher\n                : DEFAULT_HASHER;\n            /* use function instead of an arrow function to keep context of invocation */\n            propertyDescriptor.value = function (...parameters) {\n                const cachePairs = storageStrategy.getAll(cacheKey, this);\n                let cacheParameters = cacheConfig.cacheHasher(parameters);\n                let _foundCachePair = cachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n                const _foundPendingCachePair = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n                /**\n                 * check if maxAge is passed and cache has actually expired\n                 */\n                if ((cacheConfig.maxAge || GlobalCacheConfig.maxAge) && _foundCachePair && _foundCachePair.created) {\n                    if (new Date().getTime() - new Date(_foundCachePair.created).getTime() >\n                        (cacheConfig.maxAge || GlobalCacheConfig.maxAge)) {\n                        /**\n                         * cache duration has expired - remove it from the cachePairs array\n                         */\n                        storageStrategy.remove ? storageStrategy.remove(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.removeAtIndex(cachePairs.indexOf(_foundCachePair), cacheKey, this);\n                        _foundCachePair = null;\n                    }\n                    else if (cacheConfig.slidingExpiration || GlobalCacheConfig.slidingExpiration) {\n                        /**\n                         * renew cache duration\n                         */\n                        _foundCachePair.created = new Date();\n                        storageStrategy.update ? storageStrategy.update(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.updateAtIndex(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this);\n                    }\n                }\n                if (_foundCachePair) {\n                    const cached$ = of(_foundCachePair.response);\n                    return cacheConfig.async ? cached$.pipe(delay(0)) : cached$;\n                }\n                else if (_foundPendingCachePair) {\n                    return _foundPendingCachePair.response;\n                }\n                else {\n                    const response$ = oldMethod.call(this, ...parameters).pipe(finalize(() => {\n                        /**\n                         * if there has been an observable cache pair for these parameters, when it completes or errors, remove it\n                         */\n                        const _pendingCachePairToRemove = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n                        pendingCachePairs.splice(pendingCachePairs.indexOf(_pendingCachePairToRemove), 1);\n                    }), tap(response => {\n                        /**\n                         * if maxCacheCount has not been passed, just shift the cachePair to make room for the new one\n                         * if maxCacheCount has been passed, respect that and only shift the cachePairs if the new cachePair will make them exceed the count\n                         */\n                        if (!cacheConfig.shouldCacheDecider ||\n                            cacheConfig.shouldCacheDecider(response)) {\n                            if (!(cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) ||\n                                (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) === 1 ||\n                                ((cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) &&\n                                    (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) < cachePairs.length + 1)) {\n                                storageStrategy.remove ? storageStrategy.remove(0, cachePairs[0], cacheKey, this) : storageStrategy.removeAtIndex(0, cacheKey, this);\n                            }\n                            storageStrategy.add({\n                                parameters: cacheParameters,\n                                response,\n                                created: (cacheConfig.maxAge || GlobalCacheConfig.maxAge) ? new Date() : null\n                            }, cacheKey, this);\n                        }\n                    }), publishReplay(1), refCount());\n                    /**\n                     * cache the stream\n                     */\n                    pendingCachePairs.push({\n                        parameters: cacheParameters,\n                        response: response$,\n                        created: new Date()\n                    });\n                    return response$;\n                }\n            };\n        }\n        return propertyDescriptor;\n    };\n}\n;\n"]},"metadata":{},"sourceType":"module"}