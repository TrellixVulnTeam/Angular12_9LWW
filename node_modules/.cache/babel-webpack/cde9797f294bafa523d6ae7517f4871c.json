{"ast":null,"code":"/**\n * @module ol/tilegrid/WMTS\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport TileGrid from './TileGrid.js';\nimport { find } from '../array.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\n\nvar WMTSTileGrid = function (_super) {\n  __extends(WMTSTileGrid, _super);\n  /**\n   * @param {Options} options WMTS options.\n   */\n\n\n  function WMTSTileGrid(options) {\n    var _this = _super.call(this, {\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes\n    }) || this;\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n\n\n    _this.matrixIds_ = options.matrixIds;\n    return _this;\n  }\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n\n\n  WMTSTileGrid.prototype.getMatrixId = function (z) {\n    return this.matrixIds_[z];\n  };\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n\n\n  WMTSTileGrid.prototype.getMatrixIds = function () {\n    return this.matrixIds_;\n  };\n\n  return WMTSTileGrid;\n}(TileGrid);\n\nexport default WMTSTileGrid;\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [opt_extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [opt_matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\n\nexport function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {\n  /** @type {!Array<number>} */\n  var resolutions = [];\n  /** @type {!Array<string>} */\n\n  var matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n\n  var origins = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n\n  var tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n\n  var sizes = [];\n  var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];\n  var supportedCRSPropName = 'SupportedCRS';\n  var matrixIdsPropName = 'TileMatrix';\n  var identifierPropName = 'Identifier';\n  var scaleDenominatorPropName = 'ScaleDenominator';\n  var topLeftCornerPropName = 'TopLeftCorner';\n  var tileWidthPropName = 'TileWidth';\n  var tileHeightPropName = 'TileHeight';\n  var code = matrixSet[supportedCRSPropName];\n  var projection = getProjection(code);\n  var metersPerUnit = projection.getMetersPerUnit(); // swap origin x and y coordinates if axis orientation is lat/long\n\n  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    var matrixAvailable; // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n\n    if (matrixLimits.length > 0) {\n      matrixAvailable = find(matrixLimits, function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        } // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n\n\n        if (elt[identifierPropName].indexOf(':') === -1) {\n          return matrixSet[identifierPropName] + ':' + elt[identifierPropName] === elt_ml[matrixIdsPropName];\n        }\n\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      var resolution = elt[scaleDenominatorPropName] * 0.28e-3 / metersPerUnit;\n      var tileWidth = elt[tileWidthPropName];\n      var tileHeight = elt[tileHeightPropName];\n\n      if (switchOriginXY) {\n        origins.push([elt[topLeftCornerPropName][1], elt[topLeftCornerPropName][0]]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n\n      resolutions.push(resolution);\n      tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n  return new WMTSTileGrid({\n    extent: opt_extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes\n  });\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/tilegrid/WMTS.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","TileGrid","find","get","getProjection","WMTSTileGrid","_super","options","_this","extent","origin","origins","resolutions","tileSize","tileSizes","sizes","matrixIds_","matrixIds","getMatrixId","z","getMatrixIds","createFromCapabilitiesMatrixSet","matrixSet","opt_extent","opt_matrixLimits","matrixLimits","undefined","supportedCRSPropName","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","tileWidthPropName","tileHeightPropName","code","projection","metersPerUnit","getMetersPerUnit","switchOriginXY","getAxisOrientation","substr","sort","a","forEach","elt","matrixAvailable","length","elt_ml","indexOf","push","resolution","tileWidth","tileHeight"],"mappings":"AAAA;AACA;AACA;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIC,MAAM,CAACK,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCR,CAArC,EAAwCK,CAAxC,CAAJ,EAAgDN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAFrG;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnB,QAAI,OAAOA,CAAP,KAAa,UAAb,IAA2BA,CAAC,KAAK,IAArC,EACI,MAAM,IAAIS,SAAJ,CAAc,yBAAyBC,MAAM,CAACV,CAAD,CAA/B,GAAqC,+BAAnD,CAAN;AACJF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASW,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBb,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACO,SAAF,GAAcN,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACY,MAAP,CAAcb,CAAd,CAAb,IAAiCW,EAAE,CAACL,SAAH,GAAeN,CAAC,CAACM,SAAjB,EAA4B,IAAIK,EAAJ,EAA7D,CAAd;AACH,GAND;AAOH,CAd2C,EAA5C;;AAeA,OAAOG,QAAP,MAAqB,eAArB;AACA,SAASC,IAAT,QAAqB,aAArB;AACA,SAASC,GAAG,IAAIC,aAAhB,QAAqC,YAArC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,YAAY,GAAkB,UAAUC,MAAV,EAAkB;AAChDtB,EAAAA,SAAS,CAACqB,YAAD,EAAeC,MAAf,CAAT;AACA;AACJ;AACA;;;AACI,WAASD,YAAT,CAAsBE,OAAtB,EAA+B;AAC3B,QAAIC,KAAK,GAAGF,MAAM,CAACX,IAAP,CAAY,IAAZ,EAAkB;AAC1Bc,MAAAA,MAAM,EAAEF,OAAO,CAACE,MADU;AAE1BC,MAAAA,MAAM,EAAEH,OAAO,CAACG,MAFU;AAG1BC,MAAAA,OAAO,EAAEJ,OAAO,CAACI,OAHS;AAI1BC,MAAAA,WAAW,EAAEL,OAAO,CAACK,WAJK;AAK1BC,MAAAA,QAAQ,EAAEN,OAAO,CAACM,QALQ;AAM1BC,MAAAA,SAAS,EAAEP,OAAO,CAACO,SANO;AAO1BC,MAAAA,KAAK,EAAER,OAAO,CAACQ;AAPW,KAAlB,KAQN,IARN;AASA;AACR;AACA;AACA;;;AACQP,IAAAA,KAAK,CAACQ,UAAN,GAAmBT,OAAO,CAACU,SAA3B;AACA,WAAOT,KAAP;AACH;AACD;AACJ;AACA;AACA;;;AACIH,EAAAA,YAAY,CAACZ,SAAb,CAAuByB,WAAvB,GAAqC,UAAUC,CAAV,EAAa;AAC9C,WAAO,KAAKH,UAAL,CAAgBG,CAAhB,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;;;AACId,EAAAA,YAAY,CAACZ,SAAb,CAAuB2B,YAAvB,GAAsC,YAAY;AAC9C,WAAO,KAAKJ,UAAZ;AACH,GAFD;;AAGA,SAAOX,YAAP;AACH,CAtCiC,CAsChCJ,QAtCgC,CAAlC;;AAuCA,eAAeI,YAAf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASgB,+BAAT,CAAyCC,SAAzC,EAAoDC,UAApD,EAAgEC,gBAAhE,EAAkF;AACrF;AACA,MAAIZ,WAAW,GAAG,EAAlB;AACA;;AACA,MAAIK,SAAS,GAAG,EAAhB;AACA;;AACA,MAAIN,OAAO,GAAG,EAAd;AACA;;AACA,MAAIG,SAAS,GAAG,EAAhB;AACA;;AACA,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIU,YAAY,GAAGD,gBAAgB,KAAKE,SAArB,GAAiCF,gBAAjC,GAAoD,EAAvE;AACA,MAAIG,oBAAoB,GAAG,cAA3B;AACA,MAAIC,iBAAiB,GAAG,YAAxB;AACA,MAAIC,kBAAkB,GAAG,YAAzB;AACA,MAAIC,wBAAwB,GAAG,kBAA/B;AACA,MAAIC,qBAAqB,GAAG,eAA5B;AACA,MAAIC,iBAAiB,GAAG,WAAxB;AACA,MAAIC,kBAAkB,GAAG,YAAzB;AACA,MAAIC,IAAI,GAAGZ,SAAS,CAACK,oBAAD,CAApB;AACA,MAAIQ,UAAU,GAAG/B,aAAa,CAAC8B,IAAD,CAA9B;AACA,MAAIE,aAAa,GAAGD,UAAU,CAACE,gBAAX,EAApB,CArBqF,CAsBrF;;AACA,MAAIC,cAAc,GAAGH,UAAU,CAACI,kBAAX,GAAgCC,MAAhC,CAAuC,CAAvC,EAA0C,CAA1C,KAAgD,IAArE;AACAlB,EAAAA,SAAS,CAACM,iBAAD,CAAT,CAA6Ba,IAA7B,CAAkC,UAAUC,CAAV,EAAavD,CAAb,EAAgB;AAC9C,WAAOA,CAAC,CAAC2C,wBAAD,CAAD,GAA8BY,CAAC,CAACZ,wBAAD,CAAtC;AACH,GAFD;AAGAR,EAAAA,SAAS,CAACM,iBAAD,CAAT,CAA6Be,OAA7B,CAAqC,UAAUC,GAAV,EAAe;AAChD,QAAIC,eAAJ,CADgD,CAEhD;AACA;;AACA,QAAIpB,YAAY,CAACqB,MAAb,GAAsB,CAA1B,EAA6B;AACzBD,MAAAA,eAAe,GAAG3C,IAAI,CAACuB,YAAD,EAAe,UAAUsB,MAAV,EAAkB;AACnD,YAAIH,GAAG,CAACf,kBAAD,CAAH,IAA2BkB,MAAM,CAACnB,iBAAD,CAArC,EAA0D;AACtD,iBAAO,IAAP;AACH,SAHkD,CAInD;AACA;;;AACA,YAAIgB,GAAG,CAACf,kBAAD,CAAH,CAAwBmB,OAAxB,CAAgC,GAAhC,MAAyC,CAAC,CAA9C,EAAiD;AAC7C,iBAAQ1B,SAAS,CAACO,kBAAD,CAAT,GAAgC,GAAhC,GAAsCe,GAAG,CAACf,kBAAD,CAAzC,KACJkB,MAAM,CAACnB,iBAAD,CADV;AAEH;;AACD,eAAO,KAAP;AACH,OAXqB,CAAtB;AAYH,KAbD,MAcK;AACDiB,MAAAA,eAAe,GAAG,IAAlB;AACH;;AACD,QAAIA,eAAJ,EAAqB;AACjB5B,MAAAA,SAAS,CAACgC,IAAV,CAAeL,GAAG,CAACf,kBAAD,CAAlB;AACA,UAAIqB,UAAU,GAAIN,GAAG,CAACd,wBAAD,CAAH,GAAgC,OAAjC,GAA4CM,aAA7D;AACA,UAAIe,SAAS,GAAGP,GAAG,CAACZ,iBAAD,CAAnB;AACA,UAAIoB,UAAU,GAAGR,GAAG,CAACX,kBAAD,CAApB;;AACA,UAAIK,cAAJ,EAAoB;AAChB3B,QAAAA,OAAO,CAACsC,IAAR,CAAa,CACTL,GAAG,CAACb,qBAAD,CAAH,CAA2B,CAA3B,CADS,EAETa,GAAG,CAACb,qBAAD,CAAH,CAA2B,CAA3B,CAFS,CAAb;AAIH,OALD,MAMK;AACDpB,QAAAA,OAAO,CAACsC,IAAR,CAAaL,GAAG,CAACb,qBAAD,CAAhB;AACH;;AACDnB,MAAAA,WAAW,CAACqC,IAAZ,CAAiBC,UAAjB;AACApC,MAAAA,SAAS,CAACmC,IAAV,CAAeE,SAAS,IAAIC,UAAb,GAA0BD,SAA1B,GAAsC,CAACA,SAAD,EAAYC,UAAZ,CAArD;AACArC,MAAAA,KAAK,CAACkC,IAAN,CAAW,CAACL,GAAG,CAAC,aAAD,CAAJ,EAAqBA,GAAG,CAAC,cAAD,CAAxB,CAAX;AACH;AACJ,GAvCD;AAwCA,SAAO,IAAIvC,YAAJ,CAAiB;AACpBI,IAAAA,MAAM,EAAEc,UADY;AAEpBZ,IAAAA,OAAO,EAAEA,OAFW;AAGpBC,IAAAA,WAAW,EAAEA,WAHO;AAIpBK,IAAAA,SAAS,EAAEA,SAJS;AAKpBH,IAAAA,SAAS,EAAEA,SALS;AAMpBC,IAAAA,KAAK,EAAEA;AANa,GAAjB,CAAP;AAQH","sourcesContent":["/**\n * @module ol/tilegrid/WMTS\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport TileGrid from './TileGrid.js';\nimport { find } from '../array.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nvar WMTSTileGrid = /** @class */ (function (_super) {\n    __extends(WMTSTileGrid, _super);\n    /**\n     * @param {Options} options WMTS options.\n     */\n    function WMTSTileGrid(options) {\n        var _this = _super.call(this, {\n            extent: options.extent,\n            origin: options.origin,\n            origins: options.origins,\n            resolutions: options.resolutions,\n            tileSize: options.tileSize,\n            tileSizes: options.tileSizes,\n            sizes: options.sizes,\n        }) || this;\n        /**\n         * @private\n         * @type {!Array<string>}\n         */\n        _this.matrixIds_ = options.matrixIds;\n        return _this;\n    }\n    /**\n     * @param {number} z Z.\n     * @return {string} MatrixId..\n     */\n    WMTSTileGrid.prototype.getMatrixId = function (z) {\n        return this.matrixIds_[z];\n    };\n    /**\n     * Get the list of matrix identifiers.\n     * @return {Array<string>} MatrixIds.\n     * @api\n     */\n    WMTSTileGrid.prototype.getMatrixIds = function () {\n        return this.matrixIds_;\n    };\n    return WMTSTileGrid;\n}(TileGrid));\nexport default WMTSTileGrid;\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [opt_extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [opt_matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {\n    /** @type {!Array<number>} */\n    var resolutions = [];\n    /** @type {!Array<string>} */\n    var matrixIds = [];\n    /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n    var origins = [];\n    /** @type {!Array<import(\"../size.js\").Size>} */\n    var tileSizes = [];\n    /** @type {!Array<import(\"../size.js\").Size>} */\n    var sizes = [];\n    var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];\n    var supportedCRSPropName = 'SupportedCRS';\n    var matrixIdsPropName = 'TileMatrix';\n    var identifierPropName = 'Identifier';\n    var scaleDenominatorPropName = 'ScaleDenominator';\n    var topLeftCornerPropName = 'TopLeftCorner';\n    var tileWidthPropName = 'TileWidth';\n    var tileHeightPropName = 'TileHeight';\n    var code = matrixSet[supportedCRSPropName];\n    var projection = getProjection(code);\n    var metersPerUnit = projection.getMetersPerUnit();\n    // swap origin x and y coordinates if axis orientation is lat/long\n    var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n    matrixSet[matrixIdsPropName].sort(function (a, b) {\n        return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n    });\n    matrixSet[matrixIdsPropName].forEach(function (elt) {\n        var matrixAvailable;\n        // use of matrixLimits to filter TileMatrices from GetCapabilities\n        // TileMatrixSet from unavailable matrix levels.\n        if (matrixLimits.length > 0) {\n            matrixAvailable = find(matrixLimits, function (elt_ml) {\n                if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n                    return true;\n                }\n                // Fallback for tileMatrix identifiers that don't get prefixed\n                // by their tileMatrixSet identifiers.\n                if (elt[identifierPropName].indexOf(':') === -1) {\n                    return (matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\n                        elt_ml[matrixIdsPropName]);\n                }\n                return false;\n            });\n        }\n        else {\n            matrixAvailable = true;\n        }\n        if (matrixAvailable) {\n            matrixIds.push(elt[identifierPropName]);\n            var resolution = (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\n            var tileWidth = elt[tileWidthPropName];\n            var tileHeight = elt[tileHeightPropName];\n            if (switchOriginXY) {\n                origins.push([\n                    elt[topLeftCornerPropName][1],\n                    elt[topLeftCornerPropName][0],\n                ]);\n            }\n            else {\n                origins.push(elt[topLeftCornerPropName]);\n            }\n            resolutions.push(resolution);\n            tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);\n            sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n        }\n    });\n    return new WMTSTileGrid({\n        extent: opt_extent,\n        origins: origins,\n        resolutions: resolutions,\n        matrixIds: matrixIds,\n        tileSizes: tileSizes,\n        sizes: sizes,\n    });\n}\n"]},"metadata":{},"sourceType":"module"}