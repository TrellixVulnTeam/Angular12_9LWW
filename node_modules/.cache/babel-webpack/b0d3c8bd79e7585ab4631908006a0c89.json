{"ast":null,"code":"/**\n * @module ol/source/WMTS\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport TileImage from './TileImage.js';\nimport WMTSRequestEncoding from './WMTSRequestEncoding.js';\nimport { appendParams } from '../uri.js';\nimport { assign } from '../obj.js';\nimport { containsExtent } from '../extent.js';\nimport { createFromCapabilitiesMatrixSet } from '../tilegrid/WMTS.js';\nimport { createFromTileUrlFunctions, expandUrl } from '../tileurlfunction.js';\nimport { equivalent, get as getProjection, transformExtent } from '../proj.js';\nimport { find, findIndex, includes } from '../array.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {import(\"../tilegrid/WMTS.js\").default} tileGrid Tile grid.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./WMTSRequestEncoding.js\").default|string} [requestEncoding='KVP'] Request encoding.\n * @property {string} layer Layer name as advertised in the WMTS capabilities.\n * @property {string} style Style name as advertised in the WMTS capabilities.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.\n * @property {string} [version='1.0.0'] WMTS version.\n * @property {string} matrixSet Matrix set.\n * @property {!Object} [dimensions] Additional \"dimensions\" for tile requests.\n * This is an object with properties named like the advertised WMTS dimensions.\n * @property {string} [url]  A URL for the service.\n * For the RESTful request encoding, this is a URL\n * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,\n * for example `subdomain{a-f}.domain.com`, may be used instead of defining\n * each one separately in the `urls` option.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {Array<string>} [urls] An array of URLs.\n * Requests will be distributed among the URLs in this array.\n * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data from WMTS servers.\n * @api\n */\n\nvar WMTS = function (_super) {\n  __extends(WMTS, _super);\n  /**\n   * @param {Options} options WMTS options.\n   */\n\n\n  function WMTS(options) {\n    // TODO: add support for TileMatrixLimits\n    var _this = this;\n\n    var requestEncoding = options.requestEncoding !== undefined ? options.requestEncoding : WMTSRequestEncoding.KVP; // FIXME: should we create a default tileGrid?\n    // we could issue a getCapabilities xhr to retrieve missing configuration\n\n    var tileGrid = options.tileGrid;\n    var urls = options.urls;\n\n    if (urls === undefined && options.url !== undefined) {\n      urls = expandUrl(options.url);\n    }\n\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      imageSmoothing: options.imageSmoothing,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: options.tileClass,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      urls: urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : false,\n      transition: options.transition,\n      zDirection: options.zDirection\n    }) || this;\n    /**\n     * @private\n     * @type {string}\n     */\n\n    _this.version_ = options.version !== undefined ? options.version : '1.0.0';\n    /**\n     * @private\n     * @type {string}\n     */\n\n    _this.format_ = options.format !== undefined ? options.format : 'image/jpeg';\n    /**\n     * @private\n     * @type {!Object}\n     */\n\n    _this.dimensions_ = options.dimensions !== undefined ? options.dimensions : {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    _this.layer_ = options.layer;\n    /**\n     * @private\n     * @type {string}\n     */\n\n    _this.matrixSet_ = options.matrixSet;\n    /**\n     * @private\n     * @type {string}\n     */\n\n    _this.style_ = options.style; // FIXME: should we guess this requestEncoding from options.url(s)\n    //        structure? that would mean KVP only if a template is not provided.\n\n    /**\n     * @private\n     * @type {import(\"./WMTSRequestEncoding.js\").default}\n     */\n\n    _this.requestEncoding_ = requestEncoding;\n\n    _this.setKey(_this.getKeyForDimensions_());\n\n    if (urls && urls.length > 0) {\n      _this.tileUrlFunction = createFromTileUrlFunctions(urls.map(_this.createFromWMTSTemplate.bind(_this)));\n    }\n\n    return _this;\n  }\n  /**\n   * Set the URLs to use for requests.\n   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.\n   * @param {Array<string>} urls URLs.\n   */\n\n\n  WMTS.prototype.setUrls = function (urls) {\n    this.urls = urls;\n    var key = urls.join('\\n');\n    this.setTileUrlFunction(createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate.bind(this))), key);\n  };\n  /**\n   * Get the dimensions, i.e. those passed to the constructor through the\n   * \"dimensions\" option, and possibly updated using the updateDimensions\n   * method.\n   * @return {!Object} Dimensions.\n   * @api\n   */\n\n\n  WMTS.prototype.getDimensions = function () {\n    return this.dimensions_;\n  };\n  /**\n   * Return the image format of the WMTS source.\n   * @return {string} Format.\n   * @api\n   */\n\n\n  WMTS.prototype.getFormat = function () {\n    return this.format_;\n  };\n  /**\n   * Return the layer of the WMTS source.\n   * @return {string} Layer.\n   * @api\n   */\n\n\n  WMTS.prototype.getLayer = function () {\n    return this.layer_;\n  };\n  /**\n   * Return the matrix set of the WMTS source.\n   * @return {string} MatrixSet.\n   * @api\n   */\n\n\n  WMTS.prototype.getMatrixSet = function () {\n    return this.matrixSet_;\n  };\n  /**\n   * Return the request encoding, either \"KVP\" or \"REST\".\n   * @return {import(\"./WMTSRequestEncoding.js\").default} Request encoding.\n   * @api\n   */\n\n\n  WMTS.prototype.getRequestEncoding = function () {\n    return this.requestEncoding_;\n  };\n  /**\n   * Return the style of the WMTS source.\n   * @return {string} Style.\n   * @api\n   */\n\n\n  WMTS.prototype.getStyle = function () {\n    return this.style_;\n  };\n  /**\n   * Return the version of the WMTS source.\n   * @return {string} Version.\n   * @api\n   */\n\n\n  WMTS.prototype.getVersion = function () {\n    return this.version_;\n  };\n  /**\n   * @private\n   * @return {string} The key for the current dimensions.\n   */\n\n\n  WMTS.prototype.getKeyForDimensions_ = function () {\n    var i = 0;\n    var res = [];\n\n    for (var key in this.dimensions_) {\n      res[i++] = key + '-' + this.dimensions_[key];\n    }\n\n    return res.join('/');\n  };\n  /**\n   * Update the dimensions.\n   * @param {Object} dimensions Dimensions.\n   * @api\n   */\n\n\n  WMTS.prototype.updateDimensions = function (dimensions) {\n    assign(this.dimensions_, dimensions);\n    this.setKey(this.getKeyForDimensions_());\n  };\n  /**\n   * @param {string} template Template.\n   * @return {import(\"../Tile.js\").UrlFunction} Tile URL function.\n   */\n\n\n  WMTS.prototype.createFromWMTSTemplate = function (template) {\n    var requestEncoding = this.requestEncoding_; // context property names are lower case to allow for a case insensitive\n    // replacement as some services use different naming conventions\n\n    var context = {\n      'layer': this.layer_,\n      'style': this.style_,\n      'tilematrixset': this.matrixSet_\n    };\n\n    if (requestEncoding == WMTSRequestEncoding.KVP) {\n      assign(context, {\n        'Service': 'WMTS',\n        'Request': 'GetTile',\n        'Version': this.version_,\n        'Format': this.format_\n      });\n    } // TODO: we may want to create our own appendParams function so that params\n    // order conforms to wmts spec guidance, and so that we can avoid to escape\n    // special template params\n\n\n    template = requestEncoding == WMTSRequestEncoding.KVP ? appendParams(template, context) : template.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n      return p.toLowerCase() in context ? context[p.toLowerCase()] : m;\n    });\n    var tileGrid = this.tileGrid;\n    var dimensions = this.dimensions_;\n    return (\n      /**\n       * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @return {string|undefined} Tile URL.\n       */\n      function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n          return undefined;\n        } else {\n          var localContext_1 = {\n            'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),\n            'TileCol': tileCoord[1],\n            'TileRow': tileCoord[2]\n          };\n          assign(localContext_1, dimensions);\n          var url = template;\n\n          if (requestEncoding == WMTSRequestEncoding.KVP) {\n            url = appendParams(url, localContext_1);\n          } else {\n            url = url.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n              return localContext_1[p];\n            });\n          }\n\n          return url;\n        }\n      }\n    );\n  };\n\n  return WMTS;\n}(TileImage);\n\nexport default WMTS;\n/**\n * Generate source options from a capabilities object.\n * @param {Object} wmtsCap An object representing the capabilities document.\n * @param {!Object} config Configuration properties for the layer.  Defaults for\n *                  the layer will apply if not provided.\n *\n * Required config properties:\n *  - layer - {string} The layer identifier.\n *\n * Optional config properties:\n *  - matrixSet - {string} The matrix set identifier, required if there is\n *       more than one matrix set in the layer capabilities.\n *  - projection - {string} The desired CRS when no matrixSet is specified.\n *       eg: \"EPSG:3857\". If the desired projection is not available,\n *       an error is thrown.\n *  - requestEncoding - {string} url encoding format for the layer. Default is\n *       the first tile url format found in the GetCapabilities response.\n *  - style - {string} The name of the style\n *  - format - {string} Image format for the layer. Default is the first\n *       format returned in the GetCapabilities response.\n *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.\n * @return {?Options} WMTS source options object or `null` if the layer was not found.\n * @api\n */\n\nexport function optionsFromCapabilities(wmtsCap, config) {\n  var layers = wmtsCap['Contents']['Layer'];\n  var l = find(layers, function (elt, index, array) {\n    return elt['Identifier'] == config['layer'];\n  });\n\n  if (l === null) {\n    return null;\n  }\n\n  var tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];\n  var idx;\n\n  if (l['TileMatrixSetLink'].length > 1) {\n    if ('projection' in config) {\n      idx = findIndex(l['TileMatrixSetLink'], function (elt, index, array) {\n        var tileMatrixSet = find(tileMatrixSets, function (el) {\n          return el['Identifier'] == elt['TileMatrixSet'];\n        });\n        var supportedCRS = tileMatrixSet['SupportedCRS'];\n        var proj1 = getProjection(supportedCRS);\n        var proj2 = getProjection(config['projection']);\n\n        if (proj1 && proj2) {\n          return equivalent(proj1, proj2);\n        } else {\n          return supportedCRS == config['projection'];\n        }\n      });\n    } else {\n      idx = findIndex(l['TileMatrixSetLink'], function (elt, index, array) {\n        return elt['TileMatrixSet'] == config['matrixSet'];\n      });\n    }\n  } else {\n    idx = 0;\n  }\n\n  if (idx < 0) {\n    idx = 0;\n  }\n\n  var matrixSet = l['TileMatrixSetLink'][idx]['TileMatrixSet'];\n  var matrixLimits = l['TileMatrixSetLink'][idx]['TileMatrixSetLimits'];\n  var format = l['Format'][0];\n\n  if ('format' in config) {\n    format = config['format'];\n  }\n\n  idx = findIndex(l['Style'], function (elt, index, array) {\n    if ('style' in config) {\n      return elt['Title'] == config['style'];\n    } else {\n      return elt['isDefault'];\n    }\n  });\n\n  if (idx < 0) {\n    idx = 0;\n  }\n\n  var style = l['Style'][idx]['Identifier'];\n  var dimensions = {};\n\n  if ('Dimension' in l) {\n    l['Dimension'].forEach(function (elt, index, array) {\n      var key = elt['Identifier'];\n      var value = elt['Default'];\n\n      if (value === undefined) {\n        value = elt['Value'][0];\n      }\n\n      dimensions[key] = value;\n    });\n  }\n\n  var matrixSets = wmtsCap['Contents']['TileMatrixSet'];\n  var matrixSetObj = find(matrixSets, function (elt, index, array) {\n    return elt['Identifier'] == matrixSet;\n  });\n  var projection;\n  var code = matrixSetObj['SupportedCRS'];\n\n  if (code) {\n    projection = getProjection(code);\n  }\n\n  if ('projection' in config) {\n    var projConfig = getProjection(config['projection']);\n\n    if (projConfig) {\n      if (!projection || equivalent(projConfig, projection)) {\n        projection = projConfig;\n      }\n    }\n  }\n\n  var wrapX = false;\n  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n  var matrix = matrixSetObj.TileMatrix[0]; // create default matrixLimit\n\n  var selectedMatrixLimit = {\n    MinTileCol: 0,\n    MinTileRow: 0,\n    // subtract one to end up at tile top left\n    MaxTileCol: matrix.MatrixWidth - 1,\n    MaxTileRow: matrix.MatrixHeight - 1\n  }; //in case of matrix limits, use matrix limits to calculate extent\n\n  if (matrixLimits) {\n    selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];\n    var m = find(matrixSetObj.TileMatrix, function (tileMatrixValue) {\n      return tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix || matrixSetObj.Identifier + ':' + tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix;\n    });\n\n    if (m) {\n      matrix = m;\n    }\n  }\n\n  var resolution = matrix.ScaleDenominator * 0.00028 / projection.getMetersPerUnit(); // WMTS 1.0.0: standardized rendering pixel size\n\n  var origin = switchOriginXY ? [matrix.TopLeftCorner[1], matrix.TopLeftCorner[0]] : matrix.TopLeftCorner;\n  var tileSpanX = matrix.TileWidth * resolution;\n  var tileSpanY = matrix.TileHeight * resolution;\n  var matrixSetExtent = matrixSetObj['BoundingBox'];\n  var extent = [origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol, // add one to get proper bottom/right coordinate\n  origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow), origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol), origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow];\n\n  if (matrixSetExtent !== undefined && !containsExtent(matrixSetExtent, extent)) {\n    var wgs84BoundingBox = l['WGS84BoundingBox'];\n    var wgs84ProjectionExtent = getProjection('EPSG:4326').getExtent();\n    extent = matrixSetExtent;\n\n    if (wgs84BoundingBox) {\n      wrapX = wgs84BoundingBox[0] === wgs84ProjectionExtent[0] && wgs84BoundingBox[2] === wgs84ProjectionExtent[2];\n    } else {\n      var wgs84MatrixSetExtent = transformExtent(matrixSetExtent, matrixSetObj['SupportedCRS'], 'EPSG:4326'); // Ignore slight deviation from the correct x limits\n\n      wrapX = wgs84MatrixSetExtent[0] - 1e-10 <= wgs84ProjectionExtent[0] && wgs84MatrixSetExtent[2] + 1e-10 >= wgs84ProjectionExtent[2];\n    }\n  }\n\n  var tileGrid = createFromCapabilitiesMatrixSet(matrixSetObj, extent, matrixLimits);\n  /** @type {!Array<string>} */\n\n  var urls = [];\n  var requestEncoding = config['requestEncoding'];\n  requestEncoding = requestEncoding !== undefined ? requestEncoding : '';\n\n  if ('OperationsMetadata' in wmtsCap && 'GetTile' in wmtsCap['OperationsMetadata']) {\n    var gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];\n\n    for (var i = 0, ii = gets.length; i < ii; ++i) {\n      if (gets[i]['Constraint']) {\n        var constraint = find(gets[i]['Constraint'], function (element) {\n          return element['name'] == 'GetEncoding';\n        });\n        var encodings = constraint['AllowedValues']['Value'];\n\n        if (requestEncoding === '') {\n          // requestEncoding not provided, use the first encoding from the list\n          requestEncoding = encodings[0];\n        }\n\n        if (requestEncoding === WMTSRequestEncoding.KVP) {\n          if (includes(encodings, WMTSRequestEncoding.KVP)) {\n            urls.push(gets[i]['href']);\n          }\n        } else {\n          break;\n        }\n      } else if (gets[i]['href']) {\n        requestEncoding = WMTSRequestEncoding.KVP;\n        urls.push(gets[i]['href']);\n      }\n    }\n  }\n\n  if (urls.length === 0) {\n    requestEncoding = WMTSRequestEncoding.REST;\n    l['ResourceURL'].forEach(function (element) {\n      if (element['resourceType'] === 'tile') {\n        format = element['format'];\n        urls.push(element['template']);\n      }\n    });\n  }\n\n  return {\n    urls: urls,\n    layer: config['layer'],\n    matrixSet: matrixSet,\n    format: format,\n    projection: projection,\n    requestEncoding: requestEncoding,\n    tileGrid: tileGrid,\n    style: style,\n    dimensions: dimensions,\n    wrapX: wrapX,\n    crossOrigin: config['crossOrigin']\n  };\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/source/WMTS.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","TileImage","WMTSRequestEncoding","appendParams","assign","containsExtent","createFromCapabilitiesMatrixSet","createFromTileUrlFunctions","expandUrl","equivalent","get","getProjection","transformExtent","find","findIndex","includes","WMTS","_super","options","_this","requestEncoding","undefined","KVP","tileGrid","urls","url","attributions","attributionsCollapsible","cacheSize","crossOrigin","imageSmoothing","projection","reprojectionErrorThreshold","tileClass","tileLoadFunction","tilePixelRatio","wrapX","transition","zDirection","version_","version","format_","format","dimensions_","dimensions","layer_","layer","matrixSet_","matrixSet","style_","style","requestEncoding_","setKey","getKeyForDimensions_","length","tileUrlFunction","map","createFromWMTSTemplate","bind","setUrls","key","join","setTileUrlFunction","getDimensions","getFormat","getLayer","getMatrixSet","getRequestEncoding","getStyle","getVersion","i","res","updateDimensions","template","context","replace","m","toLowerCase","tileCoord","pixelRatio","localContext_1","getMatrixId","optionsFromCapabilities","wmtsCap","config","layers","l","elt","index","array","tileMatrixSets","idx","tileMatrixSet","el","supportedCRS","proj1","proj2","matrixLimits","forEach","value","matrixSets","matrixSetObj","code","projConfig","switchOriginXY","getAxisOrientation","substr","matrix","TileMatrix","selectedMatrixLimit","MinTileCol","MinTileRow","MaxTileCol","MatrixWidth","MaxTileRow","MatrixHeight","tileMatrixValue","Identifier","resolution","ScaleDenominator","getMetersPerUnit","origin","TopLeftCorner","tileSpanX","TileWidth","tileSpanY","TileHeight","matrixSetExtent","extent","wgs84BoundingBox","wgs84ProjectionExtent","getExtent","wgs84MatrixSetExtent","gets","ii","constraint","element","encodings","push","REST"],"mappings":"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","sourcesContent":["/**\n * @module ol/source/WMTS\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport TileImage from './TileImage.js';\nimport WMTSRequestEncoding from './WMTSRequestEncoding.js';\nimport { appendParams } from '../uri.js';\nimport { assign } from '../obj.js';\nimport { containsExtent } from '../extent.js';\nimport { createFromCapabilitiesMatrixSet } from '../tilegrid/WMTS.js';\nimport { createFromTileUrlFunctions, expandUrl } from '../tileurlfunction.js';\nimport { equivalent, get as getProjection, transformExtent } from '../proj.js';\nimport { find, findIndex, includes } from '../array.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {import(\"../tilegrid/WMTS.js\").default} tileGrid Tile grid.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./WMTSRequestEncoding.js\").default|string} [requestEncoding='KVP'] Request encoding.\n * @property {string} layer Layer name as advertised in the WMTS capabilities.\n * @property {string} style Style name as advertised in the WMTS capabilities.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.\n * @property {string} [version='1.0.0'] WMTS version.\n * @property {string} matrixSet Matrix set.\n * @property {!Object} [dimensions] Additional \"dimensions\" for tile requests.\n * This is an object with properties named like the advertised WMTS dimensions.\n * @property {string} [url]  A URL for the service.\n * For the RESTful request encoding, this is a URL\n * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,\n * for example `subdomain{a-f}.domain.com`, may be used instead of defining\n * each one separately in the `urls` option.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {Array<string>} [urls] An array of URLs.\n * Requests will be distributed among the URLs in this array.\n * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n/**\n * @classdesc\n * Layer source for tile data from WMTS servers.\n * @api\n */\nvar WMTS = /** @class */ (function (_super) {\n    __extends(WMTS, _super);\n    /**\n     * @param {Options} options WMTS options.\n     */\n    function WMTS(options) {\n        // TODO: add support for TileMatrixLimits\n        var _this = this;\n        var requestEncoding = options.requestEncoding !== undefined\n            ? /** @type {import(\"./WMTSRequestEncoding.js\").default} */ (options.requestEncoding)\n            : WMTSRequestEncoding.KVP;\n        // FIXME: should we create a default tileGrid?\n        // we could issue a getCapabilities xhr to retrieve missing configuration\n        var tileGrid = options.tileGrid;\n        var urls = options.urls;\n        if (urls === undefined && options.url !== undefined) {\n            urls = expandUrl(options.url);\n        }\n        _this = _super.call(this, {\n            attributions: options.attributions,\n            attributionsCollapsible: options.attributionsCollapsible,\n            cacheSize: options.cacheSize,\n            crossOrigin: options.crossOrigin,\n            imageSmoothing: options.imageSmoothing,\n            projection: options.projection,\n            reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n            tileClass: options.tileClass,\n            tileGrid: tileGrid,\n            tileLoadFunction: options.tileLoadFunction,\n            tilePixelRatio: options.tilePixelRatio,\n            urls: urls,\n            wrapX: options.wrapX !== undefined ? options.wrapX : false,\n            transition: options.transition,\n            zDirection: options.zDirection,\n        }) || this;\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.version_ = options.version !== undefined ? options.version : '1.0.0';\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.format_ = options.format !== undefined ? options.format : 'image/jpeg';\n        /**\n         * @private\n         * @type {!Object}\n         */\n        _this.dimensions_ =\n            options.dimensions !== undefined ? options.dimensions : {};\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.layer_ = options.layer;\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.matrixSet_ = options.matrixSet;\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.style_ = options.style;\n        // FIXME: should we guess this requestEncoding from options.url(s)\n        //        structure? that would mean KVP only if a template is not provided.\n        /**\n         * @private\n         * @type {import(\"./WMTSRequestEncoding.js\").default}\n         */\n        _this.requestEncoding_ = requestEncoding;\n        _this.setKey(_this.getKeyForDimensions_());\n        if (urls && urls.length > 0) {\n            _this.tileUrlFunction = createFromTileUrlFunctions(urls.map(_this.createFromWMTSTemplate.bind(_this)));\n        }\n        return _this;\n    }\n    /**\n     * Set the URLs to use for requests.\n     * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.\n     * @param {Array<string>} urls URLs.\n     */\n    WMTS.prototype.setUrls = function (urls) {\n        this.urls = urls;\n        var key = urls.join('\\n');\n        this.setTileUrlFunction(createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate.bind(this))), key);\n    };\n    /**\n     * Get the dimensions, i.e. those passed to the constructor through the\n     * \"dimensions\" option, and possibly updated using the updateDimensions\n     * method.\n     * @return {!Object} Dimensions.\n     * @api\n     */\n    WMTS.prototype.getDimensions = function () {\n        return this.dimensions_;\n    };\n    /**\n     * Return the image format of the WMTS source.\n     * @return {string} Format.\n     * @api\n     */\n    WMTS.prototype.getFormat = function () {\n        return this.format_;\n    };\n    /**\n     * Return the layer of the WMTS source.\n     * @return {string} Layer.\n     * @api\n     */\n    WMTS.prototype.getLayer = function () {\n        return this.layer_;\n    };\n    /**\n     * Return the matrix set of the WMTS source.\n     * @return {string} MatrixSet.\n     * @api\n     */\n    WMTS.prototype.getMatrixSet = function () {\n        return this.matrixSet_;\n    };\n    /**\n     * Return the request encoding, either \"KVP\" or \"REST\".\n     * @return {import(\"./WMTSRequestEncoding.js\").default} Request encoding.\n     * @api\n     */\n    WMTS.prototype.getRequestEncoding = function () {\n        return this.requestEncoding_;\n    };\n    /**\n     * Return the style of the WMTS source.\n     * @return {string} Style.\n     * @api\n     */\n    WMTS.prototype.getStyle = function () {\n        return this.style_;\n    };\n    /**\n     * Return the version of the WMTS source.\n     * @return {string} Version.\n     * @api\n     */\n    WMTS.prototype.getVersion = function () {\n        return this.version_;\n    };\n    /**\n     * @private\n     * @return {string} The key for the current dimensions.\n     */\n    WMTS.prototype.getKeyForDimensions_ = function () {\n        var i = 0;\n        var res = [];\n        for (var key in this.dimensions_) {\n            res[i++] = key + '-' + this.dimensions_[key];\n        }\n        return res.join('/');\n    };\n    /**\n     * Update the dimensions.\n     * @param {Object} dimensions Dimensions.\n     * @api\n     */\n    WMTS.prototype.updateDimensions = function (dimensions) {\n        assign(this.dimensions_, dimensions);\n        this.setKey(this.getKeyForDimensions_());\n    };\n    /**\n     * @param {string} template Template.\n     * @return {import(\"../Tile.js\").UrlFunction} Tile URL function.\n     */\n    WMTS.prototype.createFromWMTSTemplate = function (template) {\n        var requestEncoding = this.requestEncoding_;\n        // context property names are lower case to allow for a case insensitive\n        // replacement as some services use different naming conventions\n        var context = {\n            'layer': this.layer_,\n            'style': this.style_,\n            'tilematrixset': this.matrixSet_,\n        };\n        if (requestEncoding == WMTSRequestEncoding.KVP) {\n            assign(context, {\n                'Service': 'WMTS',\n                'Request': 'GetTile',\n                'Version': this.version_,\n                'Format': this.format_,\n            });\n        }\n        // TODO: we may want to create our own appendParams function so that params\n        // order conforms to wmts spec guidance, and so that we can avoid to escape\n        // special template params\n        template =\n            requestEncoding == WMTSRequestEncoding.KVP\n                ? appendParams(template, context)\n                : template.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n                    return p.toLowerCase() in context ? context[p.toLowerCase()] : m;\n                });\n        var tileGrid = /** @type {import(\"../tilegrid/WMTS.js\").default} */ (this.tileGrid);\n        var dimensions = this.dimensions_;\n        return (\n        /**\n         * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n         * @param {number} pixelRatio Pixel ratio.\n         * @param {import(\"../proj/Projection.js\").default} projection Projection.\n         * @return {string|undefined} Tile URL.\n         */\n        function (tileCoord, pixelRatio, projection) {\n            if (!tileCoord) {\n                return undefined;\n            }\n            else {\n                var localContext_1 = {\n                    'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),\n                    'TileCol': tileCoord[1],\n                    'TileRow': tileCoord[2],\n                };\n                assign(localContext_1, dimensions);\n                var url = template;\n                if (requestEncoding == WMTSRequestEncoding.KVP) {\n                    url = appendParams(url, localContext_1);\n                }\n                else {\n                    url = url.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n                        return localContext_1[p];\n                    });\n                }\n                return url;\n            }\n        });\n    };\n    return WMTS;\n}(TileImage));\nexport default WMTS;\n/**\n * Generate source options from a capabilities object.\n * @param {Object} wmtsCap An object representing the capabilities document.\n * @param {!Object} config Configuration properties for the layer.  Defaults for\n *                  the layer will apply if not provided.\n *\n * Required config properties:\n *  - layer - {string} The layer identifier.\n *\n * Optional config properties:\n *  - matrixSet - {string} The matrix set identifier, required if there is\n *       more than one matrix set in the layer capabilities.\n *  - projection - {string} The desired CRS when no matrixSet is specified.\n *       eg: \"EPSG:3857\". If the desired projection is not available,\n *       an error is thrown.\n *  - requestEncoding - {string} url encoding format for the layer. Default is\n *       the first tile url format found in the GetCapabilities response.\n *  - style - {string} The name of the style\n *  - format - {string} Image format for the layer. Default is the first\n *       format returned in the GetCapabilities response.\n *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.\n * @return {?Options} WMTS source options object or `null` if the layer was not found.\n * @api\n */\nexport function optionsFromCapabilities(wmtsCap, config) {\n    var layers = wmtsCap['Contents']['Layer'];\n    var l = find(layers, function (elt, index, array) {\n        return elt['Identifier'] == config['layer'];\n    });\n    if (l === null) {\n        return null;\n    }\n    var tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];\n    var idx;\n    if (l['TileMatrixSetLink'].length > 1) {\n        if ('projection' in config) {\n            idx = findIndex(l['TileMatrixSetLink'], function (elt, index, array) {\n                var tileMatrixSet = find(tileMatrixSets, function (el) {\n                    return el['Identifier'] == elt['TileMatrixSet'];\n                });\n                var supportedCRS = tileMatrixSet['SupportedCRS'];\n                var proj1 = getProjection(supportedCRS);\n                var proj2 = getProjection(config['projection']);\n                if (proj1 && proj2) {\n                    return equivalent(proj1, proj2);\n                }\n                else {\n                    return supportedCRS == config['projection'];\n                }\n            });\n        }\n        else {\n            idx = findIndex(l['TileMatrixSetLink'], function (elt, index, array) {\n                return elt['TileMatrixSet'] == config['matrixSet'];\n            });\n        }\n    }\n    else {\n        idx = 0;\n    }\n    if (idx < 0) {\n        idx = 0;\n    }\n    var matrixSet = \n    /** @type {string} */\n    (l['TileMatrixSetLink'][idx]['TileMatrixSet']);\n    var matrixLimits = \n    /** @type {Array<Object>} */\n    (l['TileMatrixSetLink'][idx]['TileMatrixSetLimits']);\n    var format = /** @type {string} */ (l['Format'][0]);\n    if ('format' in config) {\n        format = config['format'];\n    }\n    idx = findIndex(l['Style'], function (elt, index, array) {\n        if ('style' in config) {\n            return elt['Title'] == config['style'];\n        }\n        else {\n            return elt['isDefault'];\n        }\n    });\n    if (idx < 0) {\n        idx = 0;\n    }\n    var style = /** @type {string} */ (l['Style'][idx]['Identifier']);\n    var dimensions = {};\n    if ('Dimension' in l) {\n        l['Dimension'].forEach(function (elt, index, array) {\n            var key = elt['Identifier'];\n            var value = elt['Default'];\n            if (value === undefined) {\n                value = elt['Value'][0];\n            }\n            dimensions[key] = value;\n        });\n    }\n    var matrixSets = wmtsCap['Contents']['TileMatrixSet'];\n    var matrixSetObj = find(matrixSets, function (elt, index, array) {\n        return elt['Identifier'] == matrixSet;\n    });\n    var projection;\n    var code = matrixSetObj['SupportedCRS'];\n    if (code) {\n        projection = getProjection(code);\n    }\n    if ('projection' in config) {\n        var projConfig = getProjection(config['projection']);\n        if (projConfig) {\n            if (!projection || equivalent(projConfig, projection)) {\n                projection = projConfig;\n            }\n        }\n    }\n    var wrapX = false;\n    var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n    var matrix = matrixSetObj.TileMatrix[0];\n    // create default matrixLimit\n    var selectedMatrixLimit = {\n        MinTileCol: 0,\n        MinTileRow: 0,\n        // subtract one to end up at tile top left\n        MaxTileCol: matrix.MatrixWidth - 1,\n        MaxTileRow: matrix.MatrixHeight - 1,\n    };\n    //in case of matrix limits, use matrix limits to calculate extent\n    if (matrixLimits) {\n        selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];\n        var m = find(matrixSetObj.TileMatrix, function (tileMatrixValue) {\n            return tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix ||\n                matrixSetObj.Identifier + ':' + tileMatrixValue.Identifier ===\n                    selectedMatrixLimit.TileMatrix;\n        });\n        if (m) {\n            matrix = m;\n        }\n    }\n    var resolution = (matrix.ScaleDenominator * 0.00028) / projection.getMetersPerUnit(); // WMTS 1.0.0: standardized rendering pixel size\n    var origin = switchOriginXY\n        ? [matrix.TopLeftCorner[1], matrix.TopLeftCorner[0]]\n        : matrix.TopLeftCorner;\n    var tileSpanX = matrix.TileWidth * resolution;\n    var tileSpanY = matrix.TileHeight * resolution;\n    var matrixSetExtent = matrixSetObj['BoundingBox'];\n    var extent = [\n        origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol,\n        // add one to get proper bottom/right coordinate\n        origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow),\n        origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol),\n        origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow,\n    ];\n    if (matrixSetExtent !== undefined &&\n        !containsExtent(matrixSetExtent, extent)) {\n        var wgs84BoundingBox = l['WGS84BoundingBox'];\n        var wgs84ProjectionExtent = getProjection('EPSG:4326').getExtent();\n        extent = matrixSetExtent;\n        if (wgs84BoundingBox) {\n            wrapX =\n                wgs84BoundingBox[0] === wgs84ProjectionExtent[0] &&\n                    wgs84BoundingBox[2] === wgs84ProjectionExtent[2];\n        }\n        else {\n            var wgs84MatrixSetExtent = transformExtent(matrixSetExtent, matrixSetObj['SupportedCRS'], 'EPSG:4326');\n            // Ignore slight deviation from the correct x limits\n            wrapX =\n                wgs84MatrixSetExtent[0] - 1e-10 <= wgs84ProjectionExtent[0] &&\n                    wgs84MatrixSetExtent[2] + 1e-10 >= wgs84ProjectionExtent[2];\n        }\n    }\n    var tileGrid = createFromCapabilitiesMatrixSet(matrixSetObj, extent, matrixLimits);\n    /** @type {!Array<string>} */\n    var urls = [];\n    var requestEncoding = config['requestEncoding'];\n    requestEncoding = requestEncoding !== undefined ? requestEncoding : '';\n    if ('OperationsMetadata' in wmtsCap &&\n        'GetTile' in wmtsCap['OperationsMetadata']) {\n        var gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];\n        for (var i = 0, ii = gets.length; i < ii; ++i) {\n            if (gets[i]['Constraint']) {\n                var constraint = find(gets[i]['Constraint'], function (element) {\n                    return element['name'] == 'GetEncoding';\n                });\n                var encodings = constraint['AllowedValues']['Value'];\n                if (requestEncoding === '') {\n                    // requestEncoding not provided, use the first encoding from the list\n                    requestEncoding = encodings[0];\n                }\n                if (requestEncoding === WMTSRequestEncoding.KVP) {\n                    if (includes(encodings, WMTSRequestEncoding.KVP)) {\n                        urls.push(/** @type {string} */ (gets[i]['href']));\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            else if (gets[i]['href']) {\n                requestEncoding = WMTSRequestEncoding.KVP;\n                urls.push(/** @type {string} */ (gets[i]['href']));\n            }\n        }\n    }\n    if (urls.length === 0) {\n        requestEncoding = WMTSRequestEncoding.REST;\n        l['ResourceURL'].forEach(function (element) {\n            if (element['resourceType'] === 'tile') {\n                format = element['format'];\n                urls.push(/** @type {string} */ (element['template']));\n            }\n        });\n    }\n    return {\n        urls: urls,\n        layer: config['layer'],\n        matrixSet: matrixSet,\n        format: format,\n        projection: projection,\n        requestEncoding: requestEncoding,\n        tileGrid: tileGrid,\n        style: style,\n        dimensions: dimensions,\n        wrapX: wrapX,\n        crossOrigin: config['crossOrigin'],\n    };\n}\n"]},"metadata":{},"sourceType":"module"}