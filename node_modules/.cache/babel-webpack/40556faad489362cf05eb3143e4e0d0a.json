{"ast":null,"code":"/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\n\nvar factors = {\n  meters: earthRadius,\n  metres: earthRadius,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  miles: earthRadius / 1609.344,\n  nauticalmiles: earthRadius / 1852,\n  inches: earthRadius * 39.370,\n  yards: earthRadius / 1.0936,\n  feet: earthRadius * 3.28084,\n  radians: 1,\n  degrees: earthRadius / 111325\n};\n/**\n * Units of measurement factors based on 1 meter.\n */\n\nvar unitsFactors = {\n  meters: 1,\n  metres: 1,\n  millimeters: 1000,\n  millimetres: 1000,\n  centimeters: 100,\n  centimetres: 100,\n  kilometers: 1 / 1000,\n  kilometres: 1 / 1000,\n  miles: 1 / 1609.344,\n  nauticalmiles: 1 / 1852,\n  inches: 39.370,\n  yards: 1 / 1.0936,\n  feet: 3.28084,\n  radians: 1 / earthRadius,\n  degrees: 1 / 111325\n};\n/**\n * Area of measurement factors based on 1 square meter.\n */\n\nvar areaFactors = {\n  meters: 1,\n  metres: 1,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  centimeters: 10000,\n  centimetres: 10000,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  acres: 0.000247105,\n  miles: 3.86e-7,\n  yards: 1.195990046,\n  feet: 10.763910417,\n  inches: 1550.003100006\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\n\nfunction feature(geometry, properties, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error('options is invalid');\n  var bbox = options.bbox;\n  var id = options.id; // Validation\n\n  if (geometry === undefined) throw new Error('geometry is required');\n  if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n  if (bbox) validateBBox(bbox);\n  if (id) validateId(id); // Main\n\n  var feat = {\n    type: 'Feature'\n  };\n  if (id) feat.id = id;\n  if (bbox) feat.bbox = bbox;\n  feat.properties = properties || {};\n  feat.geometry = geometry;\n  return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\n\n\nfunction geometry(type, coordinates, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error('options is invalid');\n  var bbox = options.bbox; // Validation\n\n  if (!type) throw new Error('type is required');\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  if (bbox) validateBBox(bbox); // Main\n\n  var geom;\n\n  switch (type) {\n    case 'Point':\n      geom = point(coordinates).geometry;\n      break;\n\n    case 'LineString':\n      geom = lineString(coordinates).geometry;\n      break;\n\n    case 'Polygon':\n      geom = polygon(coordinates).geometry;\n      break;\n\n    case 'MultiPoint':\n      geom = multiPoint(coordinates).geometry;\n      break;\n\n    case 'MultiLineString':\n      geom = multiLineString(coordinates).geometry;\n      break;\n\n    case 'MultiPolygon':\n      geom = multiPolygon(coordinates).geometry;\n      break;\n\n    default:\n      throw new Error(type + ' is invalid');\n  }\n\n  if (bbox) geom.bbox = bbox;\n  return geom;\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\n\n\nfunction point(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n  return feature({\n    type: 'Point',\n    coordinates: coordinates\n  }, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\n\n\nfunction points(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  return featureCollection(coordinates.map(function (coords) {\n    return point(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\n\n\nfunction polygon(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var ring = coordinates[i];\n\n    if (ring.length < 4) {\n      throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n    }\n\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error('First and last Position are not equivalent.');\n      }\n    }\n  }\n\n  return feature({\n    type: 'Polygon',\n    coordinates: coordinates\n  }, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\n\n\nfunction polygons(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  return featureCollection(coordinates.map(function (coords) {\n    return polygon(coords, properties);\n  }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\n\n\nfunction lineString(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions'); // Check if first point of LineString contains two numbers\n\n  if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n  return feature({\n    type: 'LineString',\n    coordinates: coordinates\n  }, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\n\n\nfunction lineStrings(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  return featureCollection(coordinates.map(function (coords) {\n    return lineString(coords, properties);\n  }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\n\n\nfunction featureCollection(features, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error('options is invalid');\n  var bbox = options.bbox;\n  var id = options.id; // Validation\n\n  if (!features) throw new Error('No features passed');\n  if (!Array.isArray(features)) throw new Error('features must be an Array');\n  if (bbox) validateBBox(bbox);\n  if (id) validateId(id); // Main\n\n  var fc = {\n    type: 'FeatureCollection'\n  };\n  if (id) fc.id = id;\n  if (bbox) fc.bbox = bbox;\n  fc.features = features;\n  return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\n\n\nfunction multiLineString(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  return feature({\n    type: 'MultiLineString',\n    coordinates: coordinates\n  }, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\n\n\nfunction multiPoint(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  return feature({\n    type: 'MultiPoint',\n    coordinates: coordinates\n  }, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\n\n\nfunction multiPolygon(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  return feature({\n    type: 'MultiPolygon',\n    coordinates: coordinates\n  }, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\n\n\nfunction geometryCollection(geometries, properties, options) {\n  if (!geometries) throw new Error('geometries is required');\n  if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n  return feature({\n    type: 'GeometryCollection',\n    geometries: geometries\n  }, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\n\n\nfunction round(num, precision) {\n  if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n  if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n  var multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\n\n\nfunction radiansToLength(radians, units) {\n  if (radians === undefined || radians === null) throw new Error('radians is required');\n  if (units && typeof units !== 'string') throw new Error('units must be a string');\n  var factor = factors[units || 'kilometers'];\n  if (!factor) throw new Error(units + ' units is invalid');\n  return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\n\n\nfunction lengthToRadians(distance, units) {\n  if (distance === undefined || distance === null) throw new Error('distance is required');\n  if (units && typeof units !== 'string') throw new Error('units must be a string');\n  var factor = factors[units || 'kilometers'];\n  if (!factor) throw new Error(units + ' units is invalid');\n  return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\n\n\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\n\n\nfunction bearingToAzimuth(bearing) {\n  if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n  var angle = bearing % 360;\n  if (angle < 0) angle += 360;\n  return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\n\n\nfunction radiansToDegrees(radians) {\n  if (radians === null || radians === undefined) throw new Error('radians is required');\n  var degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\n\n\nfunction degreesToRadians(degrees) {\n  if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n  var radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\n\n\nfunction convertLength(length, originalUnit, finalUnit) {\n  if (length === null || length === undefined) throw new Error('length is required');\n  if (!(length >= 0)) throw new Error('length must be a positive number');\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\n\n\nfunction convertArea(area, originalUnit, finalUnit) {\n  if (area === null || area === undefined) throw new Error('area is required');\n  if (!(area >= 0)) throw new Error('area must be a positive number');\n  var startFactor = areaFactors[originalUnit || 'meters'];\n  if (!startFactor) throw new Error('invalid original units');\n  var finalFactor = areaFactors[finalUnit || 'kilometers'];\n  if (!finalFactor) throw new Error('invalid final units');\n  return area / startFactor * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\n\n\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\n\n\nfunction isObject(input) {\n  return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\n\n\nfunction validateBBox(bbox) {\n  if (!bbox) throw new Error('bbox is required');\n  if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n  if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n  bbox.forEach(function (num) {\n    if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n  });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\n\n\nfunction validateId(id) {\n  if (!id) throw new Error('id is required');\n  if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n} // Deprecated methods\n\n\nfunction radians2degrees() {\n  throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n  throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n  throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n  throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n  throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n  throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n  throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/@turf/meta/node_modules/@turf/helpers/main.es.js"],"names":["earthRadius","factors","meters","metres","millimeters","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","radians","degrees","unitsFactors","areaFactors","acres","feature","geometry","properties","options","isObject","Error","bbox","id","undefined","constructor","Object","validateBBox","validateId","feat","type","coordinates","Array","isArray","geom","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","length","isNumber","points","featureCollection","map","coords","i","ring","j","polygons","lineStrings","features","fc","geometryCollection","geometries","round","num","precision","isNaN","multiplier","Math","pow","radiansToLength","units","factor","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","PI","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","input","forEach","indexOf","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance"],"mappings":"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","sourcesContent":["/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n"]},"metadata":{},"sourceType":"module"}