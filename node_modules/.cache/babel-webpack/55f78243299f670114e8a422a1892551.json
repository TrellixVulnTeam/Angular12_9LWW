{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/PluggableMap\n */\n\n\nimport BaseObject from './Object.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport EventType from './events/EventType.js';\nimport LayerGroup from './layer/Group.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport RenderEventType from './render/EventType.js';\nimport TileQueue, { getTilePriority } from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport { DEVICE_PIXEL_RATIO, PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { TRUE } from './functions.js';\nimport { apply as applyTransform, create as createTransform } from './transform.js';\nimport { assert } from './asserts.js';\nimport { clone, createOrUpdateEmpty, equals, getForViewAndSize, isEmpty } from './extent.js';\nimport { fromUserCoordinate, toUserCoordinate } from './proj.js';\nimport { hasArea } from './size.js';\nimport { listen, unlistenByKey } from './events.js';\nimport { removeNode } from './dom.js';\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {import(\"./View.js\").State} viewState The state of the current view.\n * @property {boolean} animate Animate.\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform CoordinateToPixelTransform.\n * @property {import(\"rbush\").default} declutterTree DeclutterTree.\n * @property {null|import(\"./extent.js\").Extent} extent Extent.\n * @property {import(\"./extent.js\").Extent} [nextExtent] Next extent during an animation series.\n * @property {number} index Index.\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray LayerStatesArray.\n * @property {number} layerIndex LayerIndex.\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.\n * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.\n * @property {import(\"./size.js\").Size} size Size.\n * @property {TileQueue} tileQueue TileQueue.\n * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.\n * @property {Array<number>} viewHints ViewHints.\n * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.\n */\n\n/**\n * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction\n */\n\n/**\n * @typedef {Object} AtPixelOptions\n * @property {undefined|function(import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>): boolean} [layerFilter] Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels\n * inside the radius around the given position will be checked for features.\n * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of\n *   +/- 1 world width. Works only if a projection is used that can be wrapped.\n */\n\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {Collection<import(\"./control/Control.js\").default>} [controls] Controls.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions] Interactions.\n * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.\n * @property {Collection<import(\"./Overlay.js\").default>} overlays Overlays.\n * @property {Object<string, *>} values Values.\n */\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *    import(\"./Observable\").OnSignature<MapObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapBrowserEventType\").Types, import(\"./MapBrowserEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapEventType\").Types, import(\"./MapEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./render/EventType\").MapRenderEventTypes, import(\"./render/Event\").default, Return> &\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|MapObjectEventTypes|\n *      import(\"./MapBrowserEventType\").Types|import(\"./MapEventType\").Types|\n *      import(\"./render/EventType\").MapRenderEventTypes, Return>} PluggableMapOnSignature\n */\n\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control.defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction.defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered. If passed by element, the container can be in a secondary document.\n * @property {View|Promise<import(\"./View.js\").ViewOptions>} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n\n/**\n * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\n * @fires import(\"./MapEvent.js\").MapEvent\n * @fires import(\"./render/Event.js\").default#precompose\n * @fires import(\"./render/Event.js\").default#postcompose\n * @fires import(\"./render/Event.js\").default#rendercomplete\n * @api\n */\n\nvar PluggableMap = function (_super) {\n  __extends(PluggableMap, _super);\n  /**\n   * @param {MapOptions} options Map options.\n   */\n\n\n  function PluggableMap(options) {\n    var _this = _super.call(this) || this;\n    /***\n     * @type {PluggableMapOnSignature<import(\"./events\").EventsKey>}\n     */\n\n\n    _this.on;\n    /***\n     * @type {PluggableMapOnSignature<import(\"./events\").EventsKey>}\n     */\n\n    _this.once;\n    /***\n     * @type {PluggableMapOnSignature<void>}\n     */\n\n    _this.un;\n    var optionsInternal = createOptionsInternal(options);\n    /** @private */\n\n    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : DEVICE_PIXEL_RATIO;\n    /**\n     * @private\n     * @type {*}\n     */\n\n    _this.postRenderTimeoutHandle_;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    _this.animationDelayKey_;\n    /**\n     * @private\n     */\n\n    _this.animationDelay_ =\n    /** @this {PluggableMap} */\n    function () {\n      this.animationDelayKey_ = undefined;\n      this.renderFrame_(Date.now());\n    }.bind(_this);\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n\n\n    _this.coordinateToPixelTransform_ = createTransform();\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n\n    _this.pixelToCoordinateTransform_ = createTransform();\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.frameIndex_ = 0;\n    /**\n     * @private\n     * @type {?FrameState}\n     */\n\n    _this.frameState_ = null;\n    /**\n     * The extent at the previous 'moveend' event.\n     * @private\n     * @type {import(\"./extent.js\").Extent}\n     */\n\n    _this.previousExtent_ = null;\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n\n    _this.viewPropertyListenerKey_ = null;\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n\n    _this.viewChangeListenerKey_ = null;\n    /**\n     * @private\n     * @type {?Array<import(\"./events.js\").EventsKey>}\n     */\n\n    _this.layerGroupPropertyListenerKeys_ = null;\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n    _this.viewport_ = document.createElement('div');\n    _this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');\n    _this.viewport_.style.position = 'relative';\n    _this.viewport_.style.overflow = 'hidden';\n    _this.viewport_.style.width = '100%';\n    _this.viewport_.style.height = '100%';\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n    _this.overlayContainer_ = document.createElement('div');\n    _this.overlayContainer_.style.position = 'absolute';\n    _this.overlayContainer_.style.zIndex = '0';\n    _this.overlayContainer_.style.width = '100%';\n    _this.overlayContainer_.style.height = '100%';\n    _this.overlayContainer_.style.pointerEvents = 'none';\n    _this.overlayContainer_.className = 'ol-overlaycontainer';\n\n    _this.viewport_.appendChild(_this.overlayContainer_);\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n\n    _this.overlayContainerStopEvent_ = document.createElement('div');\n    _this.overlayContainerStopEvent_.style.position = 'absolute';\n    _this.overlayContainerStopEvent_.style.zIndex = '0';\n    _this.overlayContainerStopEvent_.style.width = '100%';\n    _this.overlayContainerStopEvent_.style.height = '100%';\n    _this.overlayContainerStopEvent_.style.pointerEvents = 'none';\n    _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n\n    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);\n    /**\n     * @private\n     * @type {MapBrowserEventHandler}\n     */\n\n\n    _this.mapBrowserEventHandler_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.moveTolerance_ = options.moveTolerance;\n    /**\n     * @private\n     * @type {HTMLElement|Document}\n     */\n\n    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n    /**\n     * @private\n     * @type {?Array<import(\"./events.js\").EventsKey>}\n     */\n\n    _this.keyHandlerKeys_ = null;\n    /**\n     * @type {Collection<import(\"./control/Control.js\").default>}\n     * @protected\n     */\n\n    _this.controls = optionsInternal.controls || new Collection();\n    /**\n     * @type {Collection<import(\"./interaction/Interaction.js\").default>}\n     * @protected\n     */\n\n    _this.interactions = optionsInternal.interactions || new Collection();\n    /**\n     * @type {Collection<import(\"./Overlay.js\").default>}\n     * @private\n     */\n\n    _this.overlays_ = optionsInternal.overlays;\n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object<string, import(\"./Overlay.js\").default>}\n     */\n\n    _this.overlayIdIndex_ = {};\n    /**\n     * @type {import(\"./renderer/Map.js\").default}\n     * @private\n     */\n\n    _this.renderer_ = null;\n    /**\n     * @type {undefined|function(Event): void}\n     * @private\n     */\n\n    _this.handleResize_;\n    /**\n     * @private\n     * @type {!Array<PostRenderFunction>}\n     */\n\n    _this.postRenderFunctions_ = [];\n    /**\n     * @private\n     * @type {TileQueue}\n     */\n\n    _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));\n\n    _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);\n\n    _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);\n\n    _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);\n\n    _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_); // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n\n\n    _this.setProperties(optionsInternal.values);\n\n    var map = _this;\n\n    if (options.view && !(options.view instanceof View)) {\n      options.view.then(function (viewOptions) {\n        map.setView(new View(viewOptions));\n      });\n    }\n\n    _this.controls.addEventListener(CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(this);\n    }.bind(_this));\n\n    _this.controls.addEventListener(CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    }.bind(_this));\n\n    _this.interactions.addEventListener(CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(this);\n    }.bind(_this));\n\n    _this.interactions.addEventListener(CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    }.bind(_this));\n\n    _this.overlays_.addEventListener(CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      this.addOverlayInternal_(event.element);\n    }.bind(_this));\n\n    _this.overlays_.addEventListener(CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      var overlay = event.element;\n      var id = overlay.getId();\n\n      if (id !== undefined) {\n        delete this.overlayIdIndex_[id.toString()];\n      }\n\n      event.element.setMap(null);\n    }.bind(_this));\n\n    _this.controls.forEach(\n    /**\n     * @param {import(\"./control/Control.js\").default} control Control.\n     * @this {PluggableMap}\n     */\n    function (control) {\n      control.setMap(this);\n    }.bind(_this));\n\n    _this.interactions.forEach(\n    /**\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\n     * @this {PluggableMap}\n     */\n    function (interaction) {\n      interaction.setMap(this);\n    }.bind(_this));\n\n    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));\n\n    return _this;\n  }\n  /**\n   * @abstract\n   * @return {import(\"./renderer/Map.js\").default} The map renderer\n   */\n\n\n  PluggableMap.prototype.createRenderer = function () {\n    throw new Error('Use a map type that has a createRenderer method');\n  };\n  /**\n   * Add the given control to the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addControl = function (control) {\n    this.getControls().push(control);\n  };\n  /**\n   * Add the given interaction to the map. If you want to add an interaction\n   * at another point of the collection use `getInteraction()` and the methods\n   * available on {@link module:ol/Collection~Collection}. This can be used to\n   * stop the event propagation from the handleEvent function. The interactions\n   * get to handle the events in the reverse order of this collection.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addInteraction = function (interaction) {\n    this.getInteractions().push(interaction);\n  };\n  /**\n   * Adds the given layer to the top of this map. If you want to add a layer\n   * elsewhere in the stack, use `getLayers()` and the methods available on\n   * {@link module:ol/Collection~Collection}.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addLayer = function (layer) {\n    var layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  };\n  /**\n   * Add the given overlay to the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addOverlay = function (overlay) {\n    this.getOverlays().push(overlay);\n  };\n  /**\n   * This deals with map's overlay collection changes.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @private\n   */\n\n\n  PluggableMap.prototype.addOverlayInternal_ = function (overlay) {\n    var id = overlay.getId();\n\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n\n    overlay.setMap(this);\n  };\n  /**\n   *\n   * Clean up.\n   */\n\n\n  PluggableMap.prototype.disposeInternal = function () {\n    this.setTarget(null);\n\n    _super.prototype.disposeInternal.call(this);\n  };\n  /**\n   * Detect features that intersect a pixel on the viewport, and execute a\n   * callback with each intersecting feature. Layers included in the detection can\n   * be configured through the `layerFilter` option in `opt_options`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {function(import(\"./Feature.js\").FeatureLike, import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>, import(\"./geom/SimpleGeometry.js\").default): T} callback Feature callback. The callback will be\n   *     called with two arguments. The first argument is one\n   *     {@link module:ol/Feature feature} or\n   *     {@link module:ol/render/Feature render feature} at the pixel, the second is\n   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\n   *     unmanaged layers. To stop detection, callback functions can return a\n   *     truthy value.\n   * @param {AtPixelOptions} [opt_options] Optional options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template T\n   * @api\n   */\n\n\n  PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n\n    var coordinate = this.getCoordinateFromPixelInternal(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    var checkWrapped = opt_options.checkWrapped !== false;\n    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);\n  };\n  /**\n   * Get all features that intersect a pixel on the viewport.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions} [opt_options] Optional options.\n   * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\n   * an empty array if none were found.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {\n    var features = [];\n    this.forEachFeatureAtPixel(pixel, function (feature) {\n      features.push(feature);\n    }, opt_options);\n    return features;\n  };\n  /**\n   * Detect layers that have a color value at a pixel on the viewport, and\n   * execute a callback with each matching layer. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   *\n   * Note: this may give false positives unless the map layers have had different `className`\n   * properties assigned to them.\n   *\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {function(this: S, import(\"./layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback\n   *     Layer callback. This callback will receive two arguments: first is the\n   *     {@link module:ol/layer/Layer layer}, second argument is an array representing\n   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n   *     that do not currently support this argument. To stop detection, callback\n   *     functions can return a truthy value.\n   * @param {AtPixelOptions} [opt_options] Configuration options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n\n\n  PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n\n    var options = opt_options || {};\n    var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;\n    var layerFilter = options.layerFilter || TRUE;\n    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);\n  };\n  /**\n   * Detect if features intersect a pixel on the viewport. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions} [opt_options] Optional options.\n   * @return {boolean} Is there a feature at the given pixel?\n   * @api\n   */\n\n\n  PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {\n    if (!this.frameState_) {\n      return false;\n    }\n\n    var coordinate = this.getCoordinateFromPixelInternal(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;\n    var checkWrapped = opt_options.checkWrapped !== false;\n    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);\n  };\n  /**\n   * Returns the coordinate in user projection for a browser event.\n   * @param {MouseEvent} event Event.\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getEventCoordinate = function (event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  };\n  /**\n   * Returns the coordinate in view projection for a browser event.\n   * @param {MouseEvent} event Event.\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n   */\n\n\n  PluggableMap.prototype.getEventCoordinateInternal = function (event) {\n    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));\n  };\n  /**\n   * Returns the map pixel position for a browser event relative to the viewport.\n   * @param {UIEvent} event Event.\n   * @return {import(\"./pixel.js\").Pixel} Pixel.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getEventPixel = function (event) {\n    var viewportPosition = this.viewport_.getBoundingClientRect();\n    var eventPosition = //FIXME Are we really calling this with a TouchEvent anywhere?\n    'changedTouches' in event ?\n    /** @type {TouchEvent} */\n    event.changedTouches[0] : event;\n    return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];\n  };\n  /**\n   * Get the target in which this map is rendered.\n   * Note that this returns what is entered as an option or in setTarget:\n   * if that was an element, it returns an element; if a string, it returns that.\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n   *     map is rendered in.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getTarget = function () {\n    return this.get(MapProperty.TARGET);\n  };\n  /**\n   * Get the DOM element into which this map is rendered. In contrast to\n   * `getTarget` this method always return an `Element`, or `null` if the\n   * map has no target.\n   * @return {HTMLElement} The element that the map is rendered in.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getTargetElement = function () {\n    var target = this.getTarget();\n\n    if (target !== undefined) {\n      return typeof target === 'string' ? document.getElementById(target) : target;\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * user projection.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {\n    return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());\n  };\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * map view projection.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n   */\n\n\n  PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {\n    var frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n  };\n  /**\n   * Get the map controls. Modifying this collection changes the controls\n   * associated with the map.\n   * @return {Collection<import(\"./control/Control.js\").default>} Controls.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getControls = function () {\n    return this.controls;\n  };\n  /**\n   * Get the map overlays. Modifying this collection changes the overlays\n   * associated with the map.\n   * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getOverlays = function () {\n    return this.overlays_;\n  };\n  /**\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\n   * Note that the index treats string and numeric identifiers as the same. So\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n   * @param {string|number} id Overlay identifier.\n   * @return {import(\"./Overlay.js\").default} Overlay.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getOverlayById = function (id) {\n    var overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  };\n  /**\n   * Get the map interactions. Modifying this collection changes the interactions\n   * associated with the map.\n   *\n   * Interactions are used for e.g. pan, zoom and rotate.\n   * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getInteractions = function () {\n    return this.interactions;\n  };\n  /**\n   * Get the layergroup associated with this map.\n   * @return {LayerGroup} A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getLayerGroup = function () {\n    return this.get(MapProperty.LAYERGROUP);\n  };\n  /**\n   * Clear any existing layers and add layers to the map.\n   * @param {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>} layers The layers to be added to the map.\n   * @api\n   */\n\n\n  PluggableMap.prototype.setLayers = function (layers) {\n    var group = this.getLayerGroup();\n\n    if (layers instanceof Collection) {\n      group.setLayers(layers);\n      return;\n    }\n\n    var collection = group.getLayers();\n    collection.clear();\n    collection.extend(layers);\n  };\n  /**\n   * Get the collection of layers associated with this map.\n   * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getLayers = function () {\n    var layers = this.getLayerGroup().getLayers();\n    return layers;\n  };\n  /**\n   * @return {boolean} Layers have sources that are still loading.\n   */\n\n\n  PluggableMap.prototype.getLoading = function () {\n    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n\n    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      var layer = layerStatesArray[i].layer;\n      var source =\n      /** @type {import(\"./layer/Layer.js\").default} */\n      layer.getSource();\n\n      if (source && source.loading) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the user\n   * projection and returns the corresponding pixel.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {\n    var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());\n    return this.getPixelFromCoordinateInternal(viewCoordinate);\n  };\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\n   * projection and returns the corresponding pixel.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n   */\n\n\n  PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {\n    var frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n    }\n  };\n  /**\n   * Get the map renderer.\n   * @return {import(\"./renderer/Map.js\").default} Renderer\n   */\n\n\n  PluggableMap.prototype.getRenderer = function () {\n    return this.renderer_;\n  };\n  /**\n   * Get the size of this map.\n   * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getSize = function () {\n    return this.get(MapProperty.SIZE);\n  };\n  /**\n   * Get the view associated with this map. A view manages properties such as\n   * center and resolution.\n   * @return {View} The view that controls this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getView = function () {\n    return this.get(MapProperty.VIEW);\n  };\n  /**\n   * Get the element that serves as the map viewport.\n   * @return {HTMLElement} Viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getViewport = function () {\n    return this.viewport_;\n  };\n  /**\n   * Get the element that serves as the container for overlays.  Elements added to\n   * this container will let mousedown and touchstart events through to the map,\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n   * events.\n   * @return {!HTMLElement} The map's overlay container.\n   */\n\n\n  PluggableMap.prototype.getOverlayContainer = function () {\n    return this.overlayContainer_;\n  };\n  /**\n   * Get the element that serves as a container for overlays that don't allow\n   * event propagation. Elements added to this container won't let mousedown and\n   * touchstart events through to the map, so clicks and gestures on an overlay\n   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   * @return {!HTMLElement} The map's overlay container that stops events.\n   */\n\n\n  PluggableMap.prototype.getOverlayContainerStopEvent = function () {\n    return this.overlayContainerStopEvent_;\n  };\n  /**\n   * @return {!Document} The document where the map is displayed.\n   */\n\n\n  PluggableMap.prototype.getOwnerDocument = function () {\n    var targetElement = this.getTargetElement();\n    return targetElement ? targetElement.ownerDocument : document;\n  };\n  /**\n   * @param {import(\"./Tile.js\").default} tile Tile.\n   * @param {string} tileSourceKey Tile source key.\n   * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n   * @param {number} tileResolution Tile resolution.\n   * @return {number} Tile priority.\n   */\n\n\n  PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {\n    return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);\n  };\n  /**\n   * @param {UIEvent} browserEvent Browser event.\n   * @param {string} [opt_type] Type.\n   */\n\n\n  PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {\n    var type = opt_type || browserEvent.type;\n    var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  };\n  /**\n   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n   */\n\n\n  PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n\n    var originalEvent = mapBrowserEvent.originalEvent;\n    var eventType = originalEvent.type;\n\n    if (eventType === PointerEventType.POINTERDOWN || eventType === EventType.WHEEL || eventType === EventType.KEYDOWN) {\n      var doc = this.getOwnerDocument();\n      var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;\n      var target = originalEvent.target;\n\n      if ( // Abort if the target is a child of the container for elements whose events are not meant\n      // to be handled by map interactions.\n      this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.\n      // It's possible for the target to no longer be in the page if it has been removed in an\n      // event listener, this might happen in a Control that recreates it's content based on\n      // user interaction either manually or via a render in something like https://reactjs.org/\n      !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {\n        return;\n      }\n    }\n\n    mapBrowserEvent.frameState = this.frameState_;\n\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      var interactionsArray = this.getInteractions().getArray().slice();\n\n      for (var i = interactionsArray.length - 1; i >= 0; i--) {\n        var interaction = interactionsArray[i];\n\n        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {\n          continue;\n        }\n\n        var cont = interaction.handleEvent(mapBrowserEvent);\n\n        if (!cont || mapBrowserEvent.propagationStopped) {\n          break;\n        }\n      }\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  PluggableMap.prototype.handlePostRender = function () {\n    var frameState = this.frameState_; // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n\n    var tileQueue = this.tileQueue_;\n\n    if (!tileQueue.isEmpty()) {\n      var maxTotalLoading = this.maxTilesLoading_;\n      var maxNewLoads = maxTotalLoading;\n\n      if (frameState) {\n        var hints = frameState.viewHints;\n\n        if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {\n          var lowOnFrameBudget = Date.now() - frameState.time > 8;\n          maxTotalLoading = lowOnFrameBudget ? 0 : 8;\n          maxNewLoads = lowOnFrameBudget ? 0 : 2;\n        }\n      }\n\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n\n    if (frameState && this.hasListener(RenderEventType.RENDERCOMPLETE) && !frameState.animate && !this.tileQueue_.getTilesLoading() && !this.getLoading()) {\n      this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n    }\n\n    var postRenderFunctions = this.postRenderFunctions_;\n\n    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this, frameState);\n    }\n\n    postRenderFunctions.length = 0;\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleSizeChanged_ = function () {\n    if (this.getView() && !this.getView().getAnimating()) {\n      this.getView().resolveConstraints(0);\n    }\n\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleTargetChanged_ = function () {\n    // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n    var targetElement;\n\n    if (this.getTarget()) {\n      targetElement = this.getTargetElement();\n    }\n\n    if (this.mapBrowserEventHandler_) {\n      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this.keyHandlerKeys_[i]);\n      }\n\n      this.keyHandlerKeys_ = null;\n      this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);\n      this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);\n\n      if (this.handleResize_ !== undefined) {\n        removeEventListener(EventType.RESIZE, this.handleResize_, false);\n        this.handleResize_ = undefined;\n      }\n\n      this.mapBrowserEventHandler_.dispose();\n      this.mapBrowserEventHandler_ = null;\n      removeNode(this.viewport_);\n    }\n\n    if (!targetElement) {\n      if (this.renderer_) {\n        clearTimeout(this.postRenderTimeoutHandle_);\n        this.postRenderTimeoutHandle_ = undefined;\n        this.postRenderFunctions_.length = 0;\n        this.renderer_.dispose();\n        this.renderer_ = null;\n      }\n\n      if (this.animationDelayKey_) {\n        cancelAnimationFrame(this.animationDelayKey_);\n        this.animationDelayKey_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n\n      if (!this.renderer_) {\n        this.renderer_ = this.createRenderer();\n      }\n\n      this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);\n\n      for (var key in MapBrowserEventType) {\n        this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));\n      }\n\n      this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);\n      this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? {\n        passive: false\n      } : false);\n      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;\n      this.keyHandlerKeys_ = [listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)];\n\n      if (!this.handleResize_) {\n        this.handleResize_ = this.updateSize.bind(this);\n        window.addEventListener(EventType.RESIZE, this.handleResize_, false);\n      }\n    }\n\n    this.updateSize(); // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleTileChange_ = function () {\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleViewPropertyChanged_ = function () {\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleViewChanged_ = function () {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n\n    var view = this.getView();\n\n    if (view) {\n      this.updateViewportSize_();\n      this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n      view.resolveConstraints(0);\n    }\n\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleLayerGroupChanged_ = function () {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n\n    var layerGroup = this.getLayerGroup();\n\n    if (layerGroup) {\n      this.layerGroupPropertyListenerKeys_ = [listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(layerGroup, EventType.CHANGE, this.render, this)];\n    }\n\n    this.render();\n  };\n  /**\n   * @return {boolean} Is rendered.\n   */\n\n\n  PluggableMap.prototype.isRendered = function () {\n    return !!this.frameState_;\n  };\n  /**\n   * Requests an immediate render in a synchronous manner.\n   * @api\n   */\n\n\n  PluggableMap.prototype.renderSync = function () {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n\n    this.animationDelay_();\n  };\n  /**\n   * Redraws all text after new fonts have loaded\n   */\n\n\n  PluggableMap.prototype.redrawText = function () {\n    var layerStates = this.getLayerGroup().getLayerStatesArray();\n\n    for (var i = 0, ii = layerStates.length; i < ii; ++i) {\n      var layer = layerStates[i].layer;\n\n      if (layer.hasRenderer()) {\n        layer.getRenderer().handleFontsChanged();\n      }\n    }\n  };\n  /**\n   * Request a map rendering (at the next animation frame).\n   * @api\n   */\n\n\n  PluggableMap.prototype.render = function () {\n    if (this.renderer_ && this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  };\n  /**\n   * Remove the given control from the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\n   *     if the control was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeControl = function (control) {\n    return this.getControls().remove(control);\n  };\n  /**\n   * Remove the given interaction from the map.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\n   * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\n   *     undefined if the interaction was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeInteraction = function (interaction) {\n    return this.getInteractions().remove(interaction);\n  };\n  /**\n   * Removes the given layer from the map.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\n   *     layer was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeLayer = function (layer) {\n    var layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  };\n  /**\n   * Remove the given overlay from the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\n   *     if the overlay was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeOverlay = function (overlay) {\n    return this.getOverlays().remove(overlay);\n  };\n  /**\n   * @param {number} time Time.\n   * @private\n   */\n\n\n  PluggableMap.prototype.renderFrame_ = function (time) {\n    var _this = this;\n\n    var size = this.getSize();\n    var view = this.getView();\n    var previousFrameState = this.frameState_;\n    /** @type {?FrameState} */\n\n    var frameState = null;\n\n    if (size !== undefined && hasArea(size) && view && view.isDef()) {\n      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n      var viewState = view.getState();\n      frameState = {\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        declutterTree: null,\n        extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),\n        index: this.frameIndex_++,\n        layerIndex: 0,\n        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {}\n      };\n\n      if (viewState.nextCenter && viewState.nextResolution) {\n        var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;\n        frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);\n      }\n    }\n\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n\n      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n\n      if (previousFrameState) {\n        var moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equals(frameState.extent, this.previousExtent_);\n\n        if (moveStart) {\n          this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n\n      var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals(frameState.extent, this.previousExtent_);\n\n      if (idle) {\n        this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n        clone(frameState.extent, this.previousExtent_);\n      }\n    }\n\n    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n\n    if (!this.postRenderTimeoutHandle_) {\n      this.postRenderTimeoutHandle_ = setTimeout(function () {\n        _this.postRenderTimeoutHandle_ = undefined;\n\n        _this.handlePostRender();\n      }, 0);\n    }\n  };\n  /**\n   * Sets the layergroup of this map.\n   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setLayerGroup = function (layerGroup) {\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  };\n  /**\n   * Set the size of this map.\n   * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setSize = function (size) {\n    this.set(MapProperty.SIZE, size);\n  };\n  /**\n   * Set the target element to render this map into.\n   * @param {HTMLElement|string} [target] The Element or id of the Element\n   *     that the map is rendered in.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setTarget = function (target) {\n    this.set(MapProperty.TARGET, target);\n  };\n  /**\n   * Set the view for this map.\n   * @param {View|Promise<import(\"./View.js\").ViewOptions>} view The view that controls this map.\n   * It is also possible to pass a promise that resolves to options for constructing a view.  This\n   * alternative allows view properties to be resolved by sources or other components that load\n   * view-related metadata.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setView = function (view) {\n    if (!view || view instanceof View) {\n      this.set(MapProperty.VIEW, view);\n      return;\n    }\n\n    this.set(MapProperty.VIEW, new View());\n    var map = this;\n    view.then(function (viewOptions) {\n      map.setView(new View(viewOptions));\n    });\n  };\n  /**\n   * Force a recalculation of the map viewport size.  This should be called when\n   * third-party code changes the size of the map viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.updateSize = function () {\n    var targetElement = this.getTargetElement();\n    var size = undefined;\n\n    if (targetElement) {\n      var computedStyle = getComputedStyle(targetElement);\n      var width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);\n      var height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);\n\n      if (!isNaN(width) && !isNaN(height)) {\n        size = [width, height];\n\n        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {\n          // eslint-disable-next-line\n          console.warn(\"No map visible because the map container's width or height are 0.\");\n        }\n      }\n    }\n\n    this.setSize(size);\n    this.updateViewportSize_();\n  };\n  /**\n   * Recomputes the viewport size and save it on the view object (if any)\n   * @private\n   */\n\n\n  PluggableMap.prototype.updateViewportSize_ = function () {\n    var view = this.getView();\n\n    if (view) {\n      var size = undefined;\n      var computedStyle = getComputedStyle(this.viewport_);\n\n      if (computedStyle.width && computedStyle.height) {\n        size = [parseInt(computedStyle.width, 10), parseInt(computedStyle.height, 10)];\n      }\n\n      view.setViewportSize(size);\n    }\n  };\n\n  return PluggableMap;\n}(BaseObject);\n/**\n * @param {MapOptions} options Map options.\n * @return {MapOptionsInternal} Internal map options.\n */\n\n\nfunction createOptionsInternal(options) {\n  /**\n   * @type {HTMLElement|Document}\n   */\n  var keyboardEventTarget = null;\n\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;\n  }\n  /**\n   * @type {Object<string, *>}\n   */\n\n\n  var values = {};\n  var layerGroup = options.layers && typeof\n  /** @type {?} */\n  options.layers.getLayers === 'function' ? options.layers : new LayerGroup({\n    layers: options.layers\n  });\n  values[MapProperty.LAYERGROUP] = layerGroup;\n  values[MapProperty.TARGET] = options.target;\n  values[MapProperty.VIEW] = options.view instanceof View ? options.view : new View();\n  var controls;\n\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(typeof\n      /** @type {?} */\n      options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import(\"./Collection.js\").Collection`\n\n      controls = options.controls;\n    }\n  }\n\n  var interactions;\n\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(typeof\n      /** @type {?} */\n      options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import(\"./Collection.js\").Collection`\n\n      interactions = options.interactions;\n    }\n  }\n\n  var overlays;\n\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(typeof\n      /** @type {?} */\n      options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import(\"./Collection.js\").Collection`\n\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values\n  };\n}\n\nexport default PluggableMap;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/PluggableMap.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","BaseObject","Collection","CollectionEventType","EventType","LayerGroup","MapBrowserEvent","MapBrowserEventHandler","MapBrowserEventType","MapEvent","MapEventType","MapProperty","ObjectEventType","PointerEventType","RenderEventType","TileQueue","getTilePriority","View","ViewHint","DEVICE_PIXEL_RATIO","PASSIVE_EVENT_LISTENERS","TRUE","apply","applyTransform","createTransform","assert","clone","createOrUpdateEmpty","equals","getForViewAndSize","isEmpty","fromUserCoordinate","toUserCoordinate","hasArea","listen","unlistenByKey","removeNode","PluggableMap","_super","options","_this","on","once","un","optionsInternal","createOptionsInternal","boundHandleBrowserEvent_","handleBrowserEvent","bind","maxTilesLoading_","maxTilesLoading","undefined","pixelRatio_","pixelRatio","postRenderTimeoutHandle_","animationDelayKey_","animationDelay_","renderFrame_","Date","now","coordinateToPixelTransform_","pixelToCoordinateTransform_","frameIndex_","frameState_","previousExtent_","viewPropertyListenerKey_","viewChangeListenerKey_","layerGroupPropertyListenerKeys_","viewport_","document","createElement","className","window","style","position","overflow","width","height","overlayContainer_","zIndex","pointerEvents","appendChild","overlayContainerStopEvent_","mapBrowserEventHandler_","moveTolerance_","moveTolerance","keyboardEventTarget_","keyboardEventTarget","keyHandlerKeys_","controls","interactions","overlays_","overlays","overlayIdIndex_","renderer_","handleResize_","postRenderFunctions_","tileQueue_","handleTileChange_","addChangeListener","LAYERGROUP","handleLayerGroupChanged_","VIEW","handleViewChanged_","SIZE","handleSizeChanged_","TARGET","handleTargetChanged_","setProperties","values","map","view","then","viewOptions","setView","addEventListener","ADD","event","element","setMap","REMOVE","addOverlayInternal_","overlay","id","getId","toString","forEach","control","interaction","createRenderer","Error","addControl","getControls","push","addInteraction","getInteractions","addLayer","layer","layers","getLayerGroup","getLayers","addOverlay","getOverlays","disposeInternal","setTarget","forEachFeatureAtPixel","pixel","callback","opt_options","coordinate","getCoordinateFromPixelInternal","hitTolerance","layerFilter","checkWrapped","forEachFeatureAtCoordinate","getFeaturesAtPixel","features","feature","forEachLayerAtPixel","hasFeatureAtPixel","hasFeatureAtCoordinate","getEventCoordinate","getCoordinateFromPixel","getEventPixel","getEventCoordinateInternal","viewportPosition","getBoundingClientRect","eventPosition","changedTouches","clientX","left","clientY","top","getTarget","get","getTargetElement","target","getElementById","getView","getProjection","frameState","pixelToCoordinateTransform","slice","getOverlayById","setLayers","group","collection","clear","extend","getLoading","layerStatesArray","getLayerStatesArray","i","ii","length","source","getSource","loading","getPixelFromCoordinate","viewCoordinate","getPixelFromCoordinateInternal","coordinateToPixelTransform","getRenderer","getSize","getViewport","getOverlayContainer","getOverlayContainerStopEvent","getOwnerDocument","targetElement","ownerDocument","tile","tileSourceKey","tileCenter","tileResolution","browserEvent","opt_type","type","mapBrowserEvent","handleMapBrowserEvent","originalEvent","eventType","POINTERDOWN","WHEEL","KEYDOWN","doc","rootNode","getRootNode","contains","documentElement","dispatchEvent","interactionsArray","getArray","getMap","getActive","cont","handleEvent","propagationStopped","handlePostRender","tileQueue","maxTotalLoading","maxNewLoads","hints","viewHints","ANIMATING","INTERACTING","lowOnFrameBudget","time","getTilesLoading","reprioritize","loadMoreTiles","hasListener","RENDERCOMPLETE","animate","dispatchRenderEvent","postRenderFunctions","getAnimating","resolveConstraints","render","removeEventListener","CONTEXTMENU","RESIZE","dispose","clearTimeout","cancelAnimationFrame","key","passive","KEYPRESS","updateSize","handleViewPropertyChanged_","updateViewportSize_","PROPERTYCHANGE","CHANGE","layerGroup","isRendered","renderSync","redrawText","layerStates","hasRenderer","handleFontsChanged","requestAnimationFrame","removeControl","remove","removeInteraction","removeLayer","removeOverlay","size","previousFrameState","isDef","getHints","viewState","getState","declutterTree","extent","center","resolution","rotation","index","layerIndex","usedTiles","wantedTiles","nextCenter","nextResolution","isNaN","nextRotation","nextExtent","renderFrame","moveStart","MOVESTART","idle","MOVEEND","POSTRENDER","setTimeout","setLayerGroup","set","setSize","computedStyle","getComputedStyle","offsetWidth","parseFloat","offsetHeight","getClientRects","console","warn","parseInt","setViewportSize","isArray"],"mappings":"AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIC,MAAM,CAACK,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCR,CAArC,EAAwCK,CAAxC,CAAJ,EAAgDN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAFrG;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnB,QAAI,OAAOA,CAAP,KAAa,UAAb,IAA2BA,CAAC,KAAK,IAArC,EACI,MAAM,IAAIS,SAAJ,CAAc,yBAAyBC,MAAM,CAACV,CAAD,CAA/B,GAAqC,+BAAnD,CAAN;AACJF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASW,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBb,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACO,SAAF,GAAcN,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACY,MAAP,CAAcb,CAAd,CAAb,IAAiCW,EAAE,CAACL,SAAH,GAAeN,CAAC,CAACM,SAAjB,EAA4B,IAAIK,EAAJ,EAA7D,CAAd;AACH,GAND;AAOH,CAd2C,EAA5C;AAeA;AACA;AACA;;;AACA,OAAOG,UAAP,MAAuB,aAAvB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,mBAAP,MAAgC,0BAAhC;AACA,OAAOC,SAAP,MAAsB,uBAAtB;AACA,OAAOC,UAAP,MAAuB,kBAAvB;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AACA,OAAOC,sBAAP,MAAmC,6BAAnC;AACA,OAAOC,mBAAP,MAAgC,0BAAhC;AACA,OAAOC,QAAP,MAAqB,eAArB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,WAAP,MAAwB,kBAAxB;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AACA,OAAOC,gBAAP,MAA6B,wBAA7B;AACA,OAAOC,eAAP,MAA4B,uBAA5B;AACA,OAAOC,SAAP,IAAoBC,eAApB,QAA2C,gBAA3C;AACA,OAAOC,IAAP,MAAiB,WAAjB;AACA,OAAOC,QAAP,MAAqB,eAArB;AACA,SAASC,kBAAT,EAA6BC,uBAA7B,QAA4D,UAA5D;AACA,SAASC,IAAT,QAAqB,gBAArB;AACA,SAASC,KAAK,IAAIC,cAAlB,EAAkCvB,MAAM,IAAIwB,eAA5C,QAAoE,gBAApE;AACA,SAASC,MAAT,QAAuB,cAAvB;AACA,SAASC,KAAT,EAAgBC,mBAAhB,EAAqCC,MAArC,EAA6CC,iBAA7C,EAAgEC,OAAhE,QAAgF,aAAhF;AACA,SAASC,kBAAT,EAA6BC,gBAA7B,QAAqD,WAArD;AACA,SAASC,OAAT,QAAwB,WAAxB;AACA,SAASC,MAAT,EAAiBC,aAAjB,QAAsC,aAAtC;AACA,SAASC,UAAT,QAA2B,UAA3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/PluggableMap\n */\nimport BaseObject from './Object.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport EventType from './events/EventType.js';\nimport LayerGroup from './layer/Group.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport RenderEventType from './render/EventType.js';\nimport TileQueue, { getTilePriority } from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport { DEVICE_PIXEL_RATIO, PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { TRUE } from './functions.js';\nimport { apply as applyTransform, create as createTransform, } from './transform.js';\nimport { assert } from './asserts.js';\nimport { clone, createOrUpdateEmpty, equals, getForViewAndSize, isEmpty, } from './extent.js';\nimport { fromUserCoordinate, toUserCoordinate } from './proj.js';\nimport { hasArea } from './size.js';\nimport { listen, unlistenByKey } from './events.js';\nimport { removeNode } from './dom.js';\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {import(\"./View.js\").State} viewState The state of the current view.\n * @property {boolean} animate Animate.\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform CoordinateToPixelTransform.\n * @property {import(\"rbush\").default} declutterTree DeclutterTree.\n * @property {null|import(\"./extent.js\").Extent} extent Extent.\n * @property {import(\"./extent.js\").Extent} [nextExtent] Next extent during an animation series.\n * @property {number} index Index.\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray LayerStatesArray.\n * @property {number} layerIndex LayerIndex.\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.\n * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.\n * @property {import(\"./size.js\").Size} size Size.\n * @property {TileQueue} tileQueue TileQueue.\n * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.\n * @property {Array<number>} viewHints ViewHints.\n * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.\n */\n/**\n * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction\n */\n/**\n * @typedef {Object} AtPixelOptions\n * @property {undefined|function(import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>): boolean} [layerFilter] Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels\n * inside the radius around the given position will be checked for features.\n * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of\n *   +/- 1 world width. Works only if a projection is used that can be wrapped.\n */\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {Collection<import(\"./control/Control.js\").default>} [controls] Controls.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions] Interactions.\n * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.\n * @property {Collection<import(\"./Overlay.js\").default>} overlays Overlays.\n * @property {Object<string, *>} values Values.\n */\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes\n */\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *    import(\"./Observable\").OnSignature<MapObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapBrowserEventType\").Types, import(\"./MapBrowserEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapEventType\").Types, import(\"./MapEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./render/EventType\").MapRenderEventTypes, import(\"./render/Event\").default, Return> &\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|MapObjectEventTypes|\n *      import(\"./MapBrowserEventType\").Types|import(\"./MapEventType\").Types|\n *      import(\"./render/EventType\").MapRenderEventTypes, Return>} PluggableMapOnSignature\n */\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control.defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction.defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered. If passed by element, the container can be in a secondary document.\n * @property {View|Promise<import(\"./View.js\").ViewOptions>} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n/**\n * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\n * @fires import(\"./MapEvent.js\").MapEvent\n * @fires import(\"./render/Event.js\").default#precompose\n * @fires import(\"./render/Event.js\").default#postcompose\n * @fires import(\"./render/Event.js\").default#rendercomplete\n * @api\n */\nvar PluggableMap = /** @class */ (function (_super) {\n    __extends(PluggableMap, _super);\n    /**\n     * @param {MapOptions} options Map options.\n     */\n    function PluggableMap(options) {\n        var _this = _super.call(this) || this;\n        /***\n         * @type {PluggableMapOnSignature<import(\"./events\").EventsKey>}\n         */\n        _this.on;\n        /***\n         * @type {PluggableMapOnSignature<import(\"./events\").EventsKey>}\n         */\n        _this.once;\n        /***\n         * @type {PluggableMapOnSignature<void>}\n         */\n        _this.un;\n        var optionsInternal = createOptionsInternal(options);\n        /** @private */\n        _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxTilesLoading_ =\n            options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.pixelRatio_ =\n            options.pixelRatio !== undefined\n                ? options.pixelRatio\n                : DEVICE_PIXEL_RATIO;\n        /**\n         * @private\n         * @type {*}\n         */\n        _this.postRenderTimeoutHandle_;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        _this.animationDelayKey_;\n        /**\n         * @private\n         */\n        _this.animationDelay_ = /** @this {PluggableMap} */ function () {\n            this.animationDelayKey_ = undefined;\n            this.renderFrame_(Date.now());\n        }.bind(_this);\n        /**\n         * @private\n         * @type {import(\"./transform.js\").Transform}\n         */\n        _this.coordinateToPixelTransform_ = createTransform();\n        /**\n         * @private\n         * @type {import(\"./transform.js\").Transform}\n         */\n        _this.pixelToCoordinateTransform_ = createTransform();\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.frameIndex_ = 0;\n        /**\n         * @private\n         * @type {?FrameState}\n         */\n        _this.frameState_ = null;\n        /**\n         * The extent at the previous 'moveend' event.\n         * @private\n         * @type {import(\"./extent.js\").Extent}\n         */\n        _this.previousExtent_ = null;\n        /**\n         * @private\n         * @type {?import(\"./events.js\").EventsKey}\n         */\n        _this.viewPropertyListenerKey_ = null;\n        /**\n         * @private\n         * @type {?import(\"./events.js\").EventsKey}\n         */\n        _this.viewChangeListenerKey_ = null;\n        /**\n         * @private\n         * @type {?Array<import(\"./events.js\").EventsKey>}\n         */\n        _this.layerGroupPropertyListenerKeys_ = null;\n        /**\n         * @private\n         * @type {!HTMLElement}\n         */\n        _this.viewport_ = document.createElement('div');\n        _this.viewport_.className =\n            'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');\n        _this.viewport_.style.position = 'relative';\n        _this.viewport_.style.overflow = 'hidden';\n        _this.viewport_.style.width = '100%';\n        _this.viewport_.style.height = '100%';\n        /**\n         * @private\n         * @type {!HTMLElement}\n         */\n        _this.overlayContainer_ = document.createElement('div');\n        _this.overlayContainer_.style.position = 'absolute';\n        _this.overlayContainer_.style.zIndex = '0';\n        _this.overlayContainer_.style.width = '100%';\n        _this.overlayContainer_.style.height = '100%';\n        _this.overlayContainer_.style.pointerEvents = 'none';\n        _this.overlayContainer_.className = 'ol-overlaycontainer';\n        _this.viewport_.appendChild(_this.overlayContainer_);\n        /**\n         * @private\n         * @type {!HTMLElement}\n         */\n        _this.overlayContainerStopEvent_ = document.createElement('div');\n        _this.overlayContainerStopEvent_.style.position = 'absolute';\n        _this.overlayContainerStopEvent_.style.zIndex = '0';\n        _this.overlayContainerStopEvent_.style.width = '100%';\n        _this.overlayContainerStopEvent_.style.height = '100%';\n        _this.overlayContainerStopEvent_.style.pointerEvents = 'none';\n        _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n        _this.viewport_.appendChild(_this.overlayContainerStopEvent_);\n        /**\n         * @private\n         * @type {MapBrowserEventHandler}\n         */\n        _this.mapBrowserEventHandler_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.moveTolerance_ = options.moveTolerance;\n        /**\n         * @private\n         * @type {HTMLElement|Document}\n         */\n        _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n        /**\n         * @private\n         * @type {?Array<import(\"./events.js\").EventsKey>}\n         */\n        _this.keyHandlerKeys_ = null;\n        /**\n         * @type {Collection<import(\"./control/Control.js\").default>}\n         * @protected\n         */\n        _this.controls = optionsInternal.controls || new Collection();\n        /**\n         * @type {Collection<import(\"./interaction/Interaction.js\").default>}\n         * @protected\n         */\n        _this.interactions = optionsInternal.interactions || new Collection();\n        /**\n         * @type {Collection<import(\"./Overlay.js\").default>}\n         * @private\n         */\n        _this.overlays_ = optionsInternal.overlays;\n        /**\n         * A lookup of overlays by id.\n         * @private\n         * @type {Object<string, import(\"./Overlay.js\").default>}\n         */\n        _this.overlayIdIndex_ = {};\n        /**\n         * @type {import(\"./renderer/Map.js\").default}\n         * @private\n         */\n        _this.renderer_ = null;\n        /**\n         * @type {undefined|function(Event): void}\n         * @private\n         */\n        _this.handleResize_;\n        /**\n         * @private\n         * @type {!Array<PostRenderFunction>}\n         */\n        _this.postRenderFunctions_ = [];\n        /**\n         * @private\n         * @type {TileQueue}\n         */\n        _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));\n        _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);\n        _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);\n        _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);\n        _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_);\n        // setProperties will trigger the rendering of the map if the map\n        // is \"defined\" already.\n        _this.setProperties(optionsInternal.values);\n        var map = _this;\n        if (options.view && !(options.view instanceof View)) {\n            options.view.then(function (viewOptions) {\n                map.setView(new View(viewOptions));\n            });\n        }\n        _this.controls.addEventListener(CollectionEventType.ADD, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            event.element.setMap(this);\n        }.bind(_this));\n        _this.controls.addEventListener(CollectionEventType.REMOVE, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            event.element.setMap(null);\n        }.bind(_this));\n        _this.interactions.addEventListener(CollectionEventType.ADD, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            event.element.setMap(this);\n        }.bind(_this));\n        _this.interactions.addEventListener(CollectionEventType.REMOVE, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            event.element.setMap(null);\n        }.bind(_this));\n        _this.overlays_.addEventListener(CollectionEventType.ADD, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            this.addOverlayInternal_(\n            /** @type {import(\"./Overlay.js\").default} */ (event.element));\n        }.bind(_this));\n        _this.overlays_.addEventListener(CollectionEventType.REMOVE, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            var overlay = /** @type {import(\"./Overlay.js\").default} */ (event.element);\n            var id = overlay.getId();\n            if (id !== undefined) {\n                delete this.overlayIdIndex_[id.toString()];\n            }\n            event.element.setMap(null);\n        }.bind(_this));\n        _this.controls.forEach(\n        /**\n         * @param {import(\"./control/Control.js\").default} control Control.\n         * @this {PluggableMap}\n         */\n        function (control) {\n            control.setMap(this);\n        }.bind(_this));\n        _this.interactions.forEach(\n        /**\n         * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\n         * @this {PluggableMap}\n         */\n        function (interaction) {\n            interaction.setMap(this);\n        }.bind(_this));\n        _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));\n        return _this;\n    }\n    /**\n     * @abstract\n     * @return {import(\"./renderer/Map.js\").default} The map renderer\n     */\n    PluggableMap.prototype.createRenderer = function () {\n        throw new Error('Use a map type that has a createRenderer method');\n    };\n    /**\n     * Add the given control to the map.\n     * @param {import(\"./control/Control.js\").default} control Control.\n     * @api\n     */\n    PluggableMap.prototype.addControl = function (control) {\n        this.getControls().push(control);\n    };\n    /**\n     * Add the given interaction to the map. If you want to add an interaction\n     * at another point of the collection use `getInteraction()` and the methods\n     * available on {@link module:ol/Collection~Collection}. This can be used to\n     * stop the event propagation from the handleEvent function. The interactions\n     * get to handle the events in the reverse order of this collection.\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\n     * @api\n     */\n    PluggableMap.prototype.addInteraction = function (interaction) {\n        this.getInteractions().push(interaction);\n    };\n    /**\n     * Adds the given layer to the top of this map. If you want to add a layer\n     * elsewhere in the stack, use `getLayers()` and the methods available on\n     * {@link module:ol/Collection~Collection}.\n     * @param {import(\"./layer/Base.js\").default} layer Layer.\n     * @api\n     */\n    PluggableMap.prototype.addLayer = function (layer) {\n        var layers = this.getLayerGroup().getLayers();\n        layers.push(layer);\n    };\n    /**\n     * Add the given overlay to the map.\n     * @param {import(\"./Overlay.js\").default} overlay Overlay.\n     * @api\n     */\n    PluggableMap.prototype.addOverlay = function (overlay) {\n        this.getOverlays().push(overlay);\n    };\n    /**\n     * This deals with map's overlay collection changes.\n     * @param {import(\"./Overlay.js\").default} overlay Overlay.\n     * @private\n     */\n    PluggableMap.prototype.addOverlayInternal_ = function (overlay) {\n        var id = overlay.getId();\n        if (id !== undefined) {\n            this.overlayIdIndex_[id.toString()] = overlay;\n        }\n        overlay.setMap(this);\n    };\n    /**\n     *\n     * Clean up.\n     */\n    PluggableMap.prototype.disposeInternal = function () {\n        this.setTarget(null);\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * Detect features that intersect a pixel on the viewport, and execute a\n     * callback with each intersecting feature. Layers included in the detection can\n     * be configured through the `layerFilter` option in `opt_options`.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {function(import(\"./Feature.js\").FeatureLike, import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>, import(\"./geom/SimpleGeometry.js\").default): T} callback Feature callback. The callback will be\n     *     called with two arguments. The first argument is one\n     *     {@link module:ol/Feature feature} or\n     *     {@link module:ol/render/Feature render feature} at the pixel, the second is\n     *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\n     *     unmanaged layers. To stop detection, callback functions can return a\n     *     truthy value.\n     * @param {AtPixelOptions} [opt_options] Optional options.\n     * @return {T|undefined} Callback result, i.e. the return value of last\n     * callback execution, or the first truthy callback return value.\n     * @template T\n     * @api\n     */\n    PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {\n        if (!this.frameState_) {\n            return;\n        }\n        var coordinate = this.getCoordinateFromPixelInternal(pixel);\n        opt_options = opt_options !== undefined ? opt_options : {};\n        var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;\n        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n        var checkWrapped = opt_options.checkWrapped !== false;\n        return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);\n    };\n    /**\n     * Get all features that intersect a pixel on the viewport.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {AtPixelOptions} [opt_options] Optional options.\n     * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\n     * an empty array if none were found.\n     * @api\n     */\n    PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {\n        var features = [];\n        this.forEachFeatureAtPixel(pixel, function (feature) {\n            features.push(feature);\n        }, opt_options);\n        return features;\n    };\n    /**\n     * Detect layers that have a color value at a pixel on the viewport, and\n     * execute a callback with each matching layer. Layers included in the\n     * detection can be configured through `opt_layerFilter`.\n     *\n     * Note: this may give false positives unless the map layers have had different `className`\n     * properties assigned to them.\n     *\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {function(this: S, import(\"./layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback\n     *     Layer callback. This callback will receive two arguments: first is the\n     *     {@link module:ol/layer/Layer layer}, second argument is an array representing\n     *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n     *     that do not currently support this argument. To stop detection, callback\n     *     functions can return a truthy value.\n     * @param {AtPixelOptions} [opt_options] Configuration options.\n     * @return {T|undefined} Callback result, i.e. the return value of last\n     * callback execution, or the first truthy callback return value.\n     * @template S,T\n     * @api\n     */\n    PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {\n        if (!this.frameState_) {\n            return;\n        }\n        var options = opt_options || {};\n        var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;\n        var layerFilter = options.layerFilter || TRUE;\n        return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);\n    };\n    /**\n     * Detect if features intersect a pixel on the viewport. Layers included in the\n     * detection can be configured through `opt_layerFilter`.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {AtPixelOptions} [opt_options] Optional options.\n     * @return {boolean} Is there a feature at the given pixel?\n     * @api\n     */\n    PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {\n        if (!this.frameState_) {\n            return false;\n        }\n        var coordinate = this.getCoordinateFromPixelInternal(pixel);\n        opt_options = opt_options !== undefined ? opt_options : {};\n        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n        var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;\n        var checkWrapped = opt_options.checkWrapped !== false;\n        return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);\n    };\n    /**\n     * Returns the coordinate in user projection for a browser event.\n     * @param {MouseEvent} event Event.\n     * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n     * @api\n     */\n    PluggableMap.prototype.getEventCoordinate = function (event) {\n        return this.getCoordinateFromPixel(this.getEventPixel(event));\n    };\n    /**\n     * Returns the coordinate in view projection for a browser event.\n     * @param {MouseEvent} event Event.\n     * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n     */\n    PluggableMap.prototype.getEventCoordinateInternal = function (event) {\n        return this.getCoordinateFromPixelInternal(this.getEventPixel(event));\n    };\n    /**\n     * Returns the map pixel position for a browser event relative to the viewport.\n     * @param {UIEvent} event Event.\n     * @return {import(\"./pixel.js\").Pixel} Pixel.\n     * @api\n     */\n    PluggableMap.prototype.getEventPixel = function (event) {\n        var viewportPosition = this.viewport_.getBoundingClientRect();\n        var eventPosition = \n        //FIXME Are we really calling this with a TouchEvent anywhere?\n        'changedTouches' in event\n            ? /** @type {TouchEvent} */ (event).changedTouches[0]\n            : /** @type {MouseEvent} */ (event);\n        return [\n            eventPosition.clientX - viewportPosition.left,\n            eventPosition.clientY - viewportPosition.top,\n        ];\n    };\n    /**\n     * Get the target in which this map is rendered.\n     * Note that this returns what is entered as an option or in setTarget:\n     * if that was an element, it returns an element; if a string, it returns that.\n     * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n     *     map is rendered in.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.getTarget = function () {\n        return /** @type {HTMLElement|string|undefined} */ (this.get(MapProperty.TARGET));\n    };\n    /**\n     * Get the DOM element into which this map is rendered. In contrast to\n     * `getTarget` this method always return an `Element`, or `null` if the\n     * map has no target.\n     * @return {HTMLElement} The element that the map is rendered in.\n     * @api\n     */\n    PluggableMap.prototype.getTargetElement = function () {\n        var target = this.getTarget();\n        if (target !== undefined) {\n            return typeof target === 'string'\n                ? document.getElementById(target)\n                : target;\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Get the coordinate for a given pixel.  This returns a coordinate in the\n     * user projection.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n     * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n     * @api\n     */\n    PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {\n        return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());\n    };\n    /**\n     * Get the coordinate for a given pixel.  This returns a coordinate in the\n     * map view projection.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n     * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n     */\n    PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {\n        var frameState = this.frameState_;\n        if (!frameState) {\n            return null;\n        }\n        else {\n            return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n        }\n    };\n    /**\n     * Get the map controls. Modifying this collection changes the controls\n     * associated with the map.\n     * @return {Collection<import(\"./control/Control.js\").default>} Controls.\n     * @api\n     */\n    PluggableMap.prototype.getControls = function () {\n        return this.controls;\n    };\n    /**\n     * Get the map overlays. Modifying this collection changes the overlays\n     * associated with the map.\n     * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\n     * @api\n     */\n    PluggableMap.prototype.getOverlays = function () {\n        return this.overlays_;\n    };\n    /**\n     * Get an overlay by its identifier (the value returned by overlay.getId()).\n     * Note that the index treats string and numeric identifiers as the same. So\n     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n     * @param {string|number} id Overlay identifier.\n     * @return {import(\"./Overlay.js\").default} Overlay.\n     * @api\n     */\n    PluggableMap.prototype.getOverlayById = function (id) {\n        var overlay = this.overlayIdIndex_[id.toString()];\n        return overlay !== undefined ? overlay : null;\n    };\n    /**\n     * Get the map interactions. Modifying this collection changes the interactions\n     * associated with the map.\n     *\n     * Interactions are used for e.g. pan, zoom and rotate.\n     * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\n     * @api\n     */\n    PluggableMap.prototype.getInteractions = function () {\n        return this.interactions;\n    };\n    /**\n     * Get the layergroup associated with this map.\n     * @return {LayerGroup} A layer group containing the layers in this map.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.getLayerGroup = function () {\n        return /** @type {LayerGroup} */ (this.get(MapProperty.LAYERGROUP));\n    };\n    /**\n     * Clear any existing layers and add layers to the map.\n     * @param {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>} layers The layers to be added to the map.\n     * @api\n     */\n    PluggableMap.prototype.setLayers = function (layers) {\n        var group = this.getLayerGroup();\n        if (layers instanceof Collection) {\n            group.setLayers(layers);\n            return;\n        }\n        var collection = group.getLayers();\n        collection.clear();\n        collection.extend(layers);\n    };\n    /**\n     * Get the collection of layers associated with this map.\n     * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\n     * @api\n     */\n    PluggableMap.prototype.getLayers = function () {\n        var layers = this.getLayerGroup().getLayers();\n        return layers;\n    };\n    /**\n     * @return {boolean} Layers have sources that are still loading.\n     */\n    PluggableMap.prototype.getLoading = function () {\n        var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n            var layer = layerStatesArray[i].layer;\n            var source = /** @type {import(\"./layer/Layer.js\").default} */ (layer).getSource();\n            if (source && source.loading) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Get the pixel for a coordinate.  This takes a coordinate in the user\n     * projection and returns the corresponding pixel.\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n     * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n     * @api\n     */\n    PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {\n        var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());\n        return this.getPixelFromCoordinateInternal(viewCoordinate);\n    };\n    /**\n     * Get the pixel for a coordinate.  This takes a coordinate in the map view\n     * projection and returns the corresponding pixel.\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n     * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n     */\n    PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {\n        var frameState = this.frameState_;\n        if (!frameState) {\n            return null;\n        }\n        else {\n            return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n        }\n    };\n    /**\n     * Get the map renderer.\n     * @return {import(\"./renderer/Map.js\").default} Renderer\n     */\n    PluggableMap.prototype.getRenderer = function () {\n        return this.renderer_;\n    };\n    /**\n     * Get the size of this map.\n     * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.getSize = function () {\n        return /** @type {import(\"./size.js\").Size|undefined} */ (this.get(MapProperty.SIZE));\n    };\n    /**\n     * Get the view associated with this map. A view manages properties such as\n     * center and resolution.\n     * @return {View} The view that controls this map.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.getView = function () {\n        return /** @type {View} */ (this.get(MapProperty.VIEW));\n    };\n    /**\n     * Get the element that serves as the map viewport.\n     * @return {HTMLElement} Viewport.\n     * @api\n     */\n    PluggableMap.prototype.getViewport = function () {\n        return this.viewport_;\n    };\n    /**\n     * Get the element that serves as the container for overlays.  Elements added to\n     * this container will let mousedown and touchstart events through to the map,\n     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n     * events.\n     * @return {!HTMLElement} The map's overlay container.\n     */\n    PluggableMap.prototype.getOverlayContainer = function () {\n        return this.overlayContainer_;\n    };\n    /**\n     * Get the element that serves as a container for overlays that don't allow\n     * event propagation. Elements added to this container won't let mousedown and\n     * touchstart events through to the map, so clicks and gestures on an overlay\n     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @return {!HTMLElement} The map's overlay container that stops events.\n     */\n    PluggableMap.prototype.getOverlayContainerStopEvent = function () {\n        return this.overlayContainerStopEvent_;\n    };\n    /**\n     * @return {!Document} The document where the map is displayed.\n     */\n    PluggableMap.prototype.getOwnerDocument = function () {\n        var targetElement = this.getTargetElement();\n        return targetElement ? targetElement.ownerDocument : document;\n    };\n    /**\n     * @param {import(\"./Tile.js\").default} tile Tile.\n     * @param {string} tileSourceKey Tile source key.\n     * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n     * @param {number} tileResolution Tile resolution.\n     * @return {number} Tile priority.\n     */\n    PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {\n        return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);\n    };\n    /**\n     * @param {UIEvent} browserEvent Browser event.\n     * @param {string} [opt_type] Type.\n     */\n    PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {\n        var type = opt_type || browserEvent.type;\n        var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n        this.handleMapBrowserEvent(mapBrowserEvent);\n    };\n    /**\n     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n     */\n    PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {\n        if (!this.frameState_) {\n            // With no view defined, we cannot translate pixels into geographical\n            // coordinates so interactions cannot be used.\n            return;\n        }\n        var originalEvent = /** @type {PointerEvent} */ (mapBrowserEvent.originalEvent);\n        var eventType = originalEvent.type;\n        if (eventType === PointerEventType.POINTERDOWN ||\n            eventType === EventType.WHEEL ||\n            eventType === EventType.KEYDOWN) {\n            var doc = this.getOwnerDocument();\n            var rootNode = this.viewport_.getRootNode\n                ? this.viewport_.getRootNode()\n                : doc;\n            var target = /** @type {Node} */ (originalEvent.target);\n            if (\n            // Abort if the target is a child of the container for elements whose events are not meant\n            // to be handled by map interactions.\n            this.overlayContainerStopEvent_.contains(target) ||\n                // Abort if the event target is a child of the container that is no longer in the page.\n                // It's possible for the target to no longer be in the page if it has been removed in an\n                // event listener, this might happen in a Control that recreates it's content based on\n                // user interaction either manually or via a render in something like https://reactjs.org/\n                !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {\n                return;\n            }\n        }\n        mapBrowserEvent.frameState = this.frameState_;\n        if (this.dispatchEvent(mapBrowserEvent) !== false) {\n            var interactionsArray = this.getInteractions().getArray().slice();\n            for (var i = interactionsArray.length - 1; i >= 0; i--) {\n                var interaction = interactionsArray[i];\n                if (interaction.getMap() !== this ||\n                    !interaction.getActive() ||\n                    !this.getTargetElement()) {\n                    continue;\n                }\n                var cont = interaction.handleEvent(mapBrowserEvent);\n                if (!cont || mapBrowserEvent.propagationStopped) {\n                    break;\n                }\n            }\n        }\n    };\n    /**\n     * @protected\n     */\n    PluggableMap.prototype.handlePostRender = function () {\n        var frameState = this.frameState_;\n        // Manage the tile queue\n        // Image loads are expensive and a limited resource, so try to use them\n        // efficiently:\n        // * When the view is static we allow a large number of parallel tile loads\n        //   to complete the frame as quickly as possible.\n        // * When animating or interacting, image loads can cause janks, so we reduce\n        //   the maximum number of loads per frame and limit the number of parallel\n        //   tile loads to remain reactive to view changes and to reduce the chance of\n        //   loading tiles that will quickly disappear from view.\n        var tileQueue = this.tileQueue_;\n        if (!tileQueue.isEmpty()) {\n            var maxTotalLoading = this.maxTilesLoading_;\n            var maxNewLoads = maxTotalLoading;\n            if (frameState) {\n                var hints = frameState.viewHints;\n                if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {\n                    var lowOnFrameBudget = Date.now() - frameState.time > 8;\n                    maxTotalLoading = lowOnFrameBudget ? 0 : 8;\n                    maxNewLoads = lowOnFrameBudget ? 0 : 2;\n                }\n            }\n            if (tileQueue.getTilesLoading() < maxTotalLoading) {\n                tileQueue.reprioritize(); // FIXME only call if view has changed\n                tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n            }\n        }\n        if (frameState &&\n            this.hasListener(RenderEventType.RENDERCOMPLETE) &&\n            !frameState.animate &&\n            !this.tileQueue_.getTilesLoading() &&\n            !this.getLoading()) {\n            this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n        }\n        var postRenderFunctions = this.postRenderFunctions_;\n        for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n            postRenderFunctions[i](this, frameState);\n        }\n        postRenderFunctions.length = 0;\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleSizeChanged_ = function () {\n        if (this.getView() && !this.getView().getAnimating()) {\n            this.getView().resolveConstraints(0);\n        }\n        this.render();\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleTargetChanged_ = function () {\n        // target may be undefined, null, a string or an Element.\n        // If it's a string we convert it to an Element before proceeding.\n        // If it's not now an Element we remove the viewport from the DOM.\n        // If it's an Element we append the viewport element to it.\n        var targetElement;\n        if (this.getTarget()) {\n            targetElement = this.getTargetElement();\n        }\n        if (this.mapBrowserEventHandler_) {\n            for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n                unlistenByKey(this.keyHandlerKeys_[i]);\n            }\n            this.keyHandlerKeys_ = null;\n            this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);\n            this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);\n            if (this.handleResize_ !== undefined) {\n                removeEventListener(EventType.RESIZE, this.handleResize_, false);\n                this.handleResize_ = undefined;\n            }\n            this.mapBrowserEventHandler_.dispose();\n            this.mapBrowserEventHandler_ = null;\n            removeNode(this.viewport_);\n        }\n        if (!targetElement) {\n            if (this.renderer_) {\n                clearTimeout(this.postRenderTimeoutHandle_);\n                this.postRenderTimeoutHandle_ = undefined;\n                this.postRenderFunctions_.length = 0;\n                this.renderer_.dispose();\n                this.renderer_ = null;\n            }\n            if (this.animationDelayKey_) {\n                cancelAnimationFrame(this.animationDelayKey_);\n                this.animationDelayKey_ = undefined;\n            }\n        }\n        else {\n            targetElement.appendChild(this.viewport_);\n            if (!this.renderer_) {\n                this.renderer_ = this.createRenderer();\n            }\n            this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);\n            for (var key in MapBrowserEventType) {\n                this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));\n            }\n            this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);\n            this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);\n            var keyboardEventTarget = !this.keyboardEventTarget_\n                ? targetElement\n                : this.keyboardEventTarget_;\n            this.keyHandlerKeys_ = [\n                listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),\n                listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this),\n            ];\n            if (!this.handleResize_) {\n                this.handleResize_ = this.updateSize.bind(this);\n                window.addEventListener(EventType.RESIZE, this.handleResize_, false);\n            }\n        }\n        this.updateSize();\n        // updateSize calls setSize, so no need to call this.render\n        // ourselves here.\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleTileChange_ = function () {\n        this.render();\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleViewPropertyChanged_ = function () {\n        this.render();\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleViewChanged_ = function () {\n        if (this.viewPropertyListenerKey_) {\n            unlistenByKey(this.viewPropertyListenerKey_);\n            this.viewPropertyListenerKey_ = null;\n        }\n        if (this.viewChangeListenerKey_) {\n            unlistenByKey(this.viewChangeListenerKey_);\n            this.viewChangeListenerKey_ = null;\n        }\n        var view = this.getView();\n        if (view) {\n            this.updateViewportSize_();\n            this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n            this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n            view.resolveConstraints(0);\n        }\n        this.render();\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleLayerGroupChanged_ = function () {\n        if (this.layerGroupPropertyListenerKeys_) {\n            this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n            this.layerGroupPropertyListenerKeys_ = null;\n        }\n        var layerGroup = this.getLayerGroup();\n        if (layerGroup) {\n            this.layerGroupPropertyListenerKeys_ = [\n                listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),\n                listen(layerGroup, EventType.CHANGE, this.render, this),\n            ];\n        }\n        this.render();\n    };\n    /**\n     * @return {boolean} Is rendered.\n     */\n    PluggableMap.prototype.isRendered = function () {\n        return !!this.frameState_;\n    };\n    /**\n     * Requests an immediate render in a synchronous manner.\n     * @api\n     */\n    PluggableMap.prototype.renderSync = function () {\n        if (this.animationDelayKey_) {\n            cancelAnimationFrame(this.animationDelayKey_);\n        }\n        this.animationDelay_();\n    };\n    /**\n     * Redraws all text after new fonts have loaded\n     */\n    PluggableMap.prototype.redrawText = function () {\n        var layerStates = this.getLayerGroup().getLayerStatesArray();\n        for (var i = 0, ii = layerStates.length; i < ii; ++i) {\n            var layer = layerStates[i].layer;\n            if (layer.hasRenderer()) {\n                layer.getRenderer().handleFontsChanged();\n            }\n        }\n    };\n    /**\n     * Request a map rendering (at the next animation frame).\n     * @api\n     */\n    PluggableMap.prototype.render = function () {\n        if (this.renderer_ && this.animationDelayKey_ === undefined) {\n            this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n        }\n    };\n    /**\n     * Remove the given control from the map.\n     * @param {import(\"./control/Control.js\").default} control Control.\n     * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\n     *     if the control was not found).\n     * @api\n     */\n    PluggableMap.prototype.removeControl = function (control) {\n        return this.getControls().remove(control);\n    };\n    /**\n     * Remove the given interaction from the map.\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\n     * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\n     *     undefined if the interaction was not found).\n     * @api\n     */\n    PluggableMap.prototype.removeInteraction = function (interaction) {\n        return this.getInteractions().remove(interaction);\n    };\n    /**\n     * Removes the given layer from the map.\n     * @param {import(\"./layer/Base.js\").default} layer Layer.\n     * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\n     *     layer was not found).\n     * @api\n     */\n    PluggableMap.prototype.removeLayer = function (layer) {\n        var layers = this.getLayerGroup().getLayers();\n        return layers.remove(layer);\n    };\n    /**\n     * Remove the given overlay from the map.\n     * @param {import(\"./Overlay.js\").default} overlay Overlay.\n     * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\n     *     if the overlay was not found).\n     * @api\n     */\n    PluggableMap.prototype.removeOverlay = function (overlay) {\n        return this.getOverlays().remove(overlay);\n    };\n    /**\n     * @param {number} time Time.\n     * @private\n     */\n    PluggableMap.prototype.renderFrame_ = function (time) {\n        var _this = this;\n        var size = this.getSize();\n        var view = this.getView();\n        var previousFrameState = this.frameState_;\n        /** @type {?FrameState} */\n        var frameState = null;\n        if (size !== undefined && hasArea(size) && view && view.isDef()) {\n            var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n            var viewState = view.getState();\n            frameState = {\n                animate: false,\n                coordinateToPixelTransform: this.coordinateToPixelTransform_,\n                declutterTree: null,\n                extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),\n                index: this.frameIndex_++,\n                layerIndex: 0,\n                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),\n                pixelRatio: this.pixelRatio_,\n                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n                postRenderFunctions: [],\n                size: size,\n                tileQueue: this.tileQueue_,\n                time: time,\n                usedTiles: {},\n                viewState: viewState,\n                viewHints: viewHints,\n                wantedTiles: {},\n            };\n            if (viewState.nextCenter && viewState.nextResolution) {\n                var rotation = isNaN(viewState.nextRotation)\n                    ? viewState.rotation\n                    : viewState.nextRotation;\n                frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);\n            }\n        }\n        this.frameState_ = frameState;\n        this.renderer_.renderFrame(frameState);\n        if (frameState) {\n            if (frameState.animate) {\n                this.render();\n            }\n            Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n            if (previousFrameState) {\n                var moveStart = !this.previousExtent_ ||\n                    (!isEmpty(this.previousExtent_) &&\n                        !equals(frameState.extent, this.previousExtent_));\n                if (moveStart) {\n                    this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n                    this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n                }\n            }\n            var idle = this.previousExtent_ &&\n                !frameState.viewHints[ViewHint.ANIMATING] &&\n                !frameState.viewHints[ViewHint.INTERACTING] &&\n                !equals(frameState.extent, this.previousExtent_);\n            if (idle) {\n                this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n                clone(frameState.extent, this.previousExtent_);\n            }\n        }\n        this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n        if (!this.postRenderTimeoutHandle_) {\n            this.postRenderTimeoutHandle_ = setTimeout(function () {\n                _this.postRenderTimeoutHandle_ = undefined;\n                _this.handlePostRender();\n            }, 0);\n        }\n    };\n    /**\n     * Sets the layergroup of this map.\n     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.setLayerGroup = function (layerGroup) {\n        this.set(MapProperty.LAYERGROUP, layerGroup);\n    };\n    /**\n     * Set the size of this map.\n     * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.setSize = function (size) {\n        this.set(MapProperty.SIZE, size);\n    };\n    /**\n     * Set the target element to render this map into.\n     * @param {HTMLElement|string} [target] The Element or id of the Element\n     *     that the map is rendered in.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.setTarget = function (target) {\n        this.set(MapProperty.TARGET, target);\n    };\n    /**\n     * Set the view for this map.\n     * @param {View|Promise<import(\"./View.js\").ViewOptions>} view The view that controls this map.\n     * It is also possible to pass a promise that resolves to options for constructing a view.  This\n     * alternative allows view properties to be resolved by sources or other components that load\n     * view-related metadata.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.setView = function (view) {\n        if (!view || view instanceof View) {\n            this.set(MapProperty.VIEW, view);\n            return;\n        }\n        this.set(MapProperty.VIEW, new View());\n        var map = this;\n        view.then(function (viewOptions) {\n            map.setView(new View(viewOptions));\n        });\n    };\n    /**\n     * Force a recalculation of the map viewport size.  This should be called when\n     * third-party code changes the size of the map viewport.\n     * @api\n     */\n    PluggableMap.prototype.updateSize = function () {\n        var targetElement = this.getTargetElement();\n        var size = undefined;\n        if (targetElement) {\n            var computedStyle = getComputedStyle(targetElement);\n            var width = targetElement.offsetWidth -\n                parseFloat(computedStyle['borderLeftWidth']) -\n                parseFloat(computedStyle['paddingLeft']) -\n                parseFloat(computedStyle['paddingRight']) -\n                parseFloat(computedStyle['borderRightWidth']);\n            var height = targetElement.offsetHeight -\n                parseFloat(computedStyle['borderTopWidth']) -\n                parseFloat(computedStyle['paddingTop']) -\n                parseFloat(computedStyle['paddingBottom']) -\n                parseFloat(computedStyle['borderBottomWidth']);\n            if (!isNaN(width) && !isNaN(height)) {\n                size = [width, height];\n                if (!hasArea(size) &&\n                    !!(targetElement.offsetWidth ||\n                        targetElement.offsetHeight ||\n                        targetElement.getClientRects().length)) {\n                    // eslint-disable-next-line\n                    console.warn(\"No map visible because the map container's width or height are 0.\");\n                }\n            }\n        }\n        this.setSize(size);\n        this.updateViewportSize_();\n    };\n    /**\n     * Recomputes the viewport size and save it on the view object (if any)\n     * @private\n     */\n    PluggableMap.prototype.updateViewportSize_ = function () {\n        var view = this.getView();\n        if (view) {\n            var size = undefined;\n            var computedStyle = getComputedStyle(this.viewport_);\n            if (computedStyle.width && computedStyle.height) {\n                size = [\n                    parseInt(computedStyle.width, 10),\n                    parseInt(computedStyle.height, 10),\n                ];\n            }\n            view.setViewportSize(size);\n        }\n    };\n    return PluggableMap;\n}(BaseObject));\n/**\n * @param {MapOptions} options Map options.\n * @return {MapOptionsInternal} Internal map options.\n */\nfunction createOptionsInternal(options) {\n    /**\n     * @type {HTMLElement|Document}\n     */\n    var keyboardEventTarget = null;\n    if (options.keyboardEventTarget !== undefined) {\n        keyboardEventTarget =\n            typeof options.keyboardEventTarget === 'string'\n                ? document.getElementById(options.keyboardEventTarget)\n                : options.keyboardEventTarget;\n    }\n    /**\n     * @type {Object<string, *>}\n     */\n    var values = {};\n    var layerGroup = options.layers &&\n        typeof ( /** @type {?} */(options.layers).getLayers) === 'function'\n        ? /** @type {LayerGroup} */ (options.layers)\n        : new LayerGroup({ layers: /** @type {Collection} */ (options.layers) });\n    values[MapProperty.LAYERGROUP] = layerGroup;\n    values[MapProperty.TARGET] = options.target;\n    values[MapProperty.VIEW] =\n        options.view instanceof View ? options.view : new View();\n    var controls;\n    if (options.controls !== undefined) {\n        if (Array.isArray(options.controls)) {\n            controls = new Collection(options.controls.slice());\n        }\n        else {\n            assert(typeof ( /** @type {?} */(options.controls).getArray) === 'function', 47); // Expected `controls` to be an array or an `import(\"./Collection.js\").Collection`\n            controls = /** @type {Collection} */ (options.controls);\n        }\n    }\n    var interactions;\n    if (options.interactions !== undefined) {\n        if (Array.isArray(options.interactions)) {\n            interactions = new Collection(options.interactions.slice());\n        }\n        else {\n            assert(typeof ( /** @type {?} */(options.interactions).getArray) ===\n                'function', 48); // Expected `interactions` to be an array or an `import(\"./Collection.js\").Collection`\n            interactions = /** @type {Collection} */ (options.interactions);\n        }\n    }\n    var overlays;\n    if (options.overlays !== undefined) {\n        if (Array.isArray(options.overlays)) {\n            overlays = new Collection(options.overlays.slice());\n        }\n        else {\n            assert(typeof ( /** @type {?} */(options.overlays).getArray) === 'function', 49); // Expected `overlays` to be an array or an `import(\"./Collection.js\").Collection`\n            overlays = options.overlays;\n        }\n    }\n    else {\n        overlays = new Collection();\n    }\n    return {\n        controls: controls,\n        interactions: interactions,\n        keyboardEventTarget: keyboardEventTarget,\n        overlays: overlays,\n        values: values,\n    };\n}\nexport default PluggableMap;\n"]},"metadata":{},"sourceType":"module"}