{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\n\n\nimport Feature from '../Feature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport XMLFeature from './XMLFeature.js';\nimport { assign } from '../obj.js';\nimport { extend } from '../array.js';\nimport { getAllTextContent, getAttributeNS, makeArrayPusher, makeReplacer, parseNode, pushParseAndPop } from '../xml.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformExtentWithOptions, transformGeometryWithOptions } from './Feature.js';\n/**\n * @const\n * @type {string}\n */\n\nexport var GMLNS = 'http://www.opengis.net/gml';\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc. The non-breaking\n * space (0xa0) is explicitly included as IE doesn't include it in its\n * definition of `\\s`.\n *\n * Information from `goog.string.isEmptyOrWhitespace`: https://github.com/google/closure-library/blob/e877b1e/closure/goog/string/string.js#L156-L160\n *\n * @const\n * @type {RegExp}\n */\n\nvar ONLY_WHITESPACE_RE = /^[\\s\\xa0]*$/;\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} srsName srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\n\nvar GMLBase = function (_super) {\n  __extends(GMLBase, _super);\n  /**\n   * @param {Options} [opt_options] Optional configuration object.\n   */\n\n\n  function GMLBase(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n\n    _this.featureType = options.featureType;\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n\n    _this.featureNS = options.featureNS;\n    /**\n     * @protected\n     * @type {string}\n     */\n\n    _this.srsName = options.srsName;\n    /**\n     * @protected\n     * @type {string}\n     */\n\n    _this.schemaLocation = '';\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n\n    _this.FEATURE_COLLECTION_PARSERS = {};\n    _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {\n      'featureMember': makeArrayPusher(_this.readFeaturesInternal),\n      'featureMembers': makeReplacer(_this.readFeaturesInternal)\n    };\n    _this.supportedMediaTypes = ['application/gml+xml'];\n    return _this;\n  }\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n\n\n  GMLBase.prototype.readFeaturesInternal = function (node, objectStack) {\n    var localName = node.localName;\n    var features = null;\n\n    if (localName == 'FeatureCollection') {\n      features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);\n    } else if (localName == 'featureMembers' || localName == 'featureMember' || localName == 'member') {\n      var context = objectStack[0];\n      var featureType = context['featureType'];\n      var featureNS = context['featureNS'];\n      var prefix = 'p';\n      var defaultPrefix = 'p0';\n\n      if (!featureType && node.childNodes) {\n        featureType = [], featureNS = {};\n\n        for (var i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          var child = node.childNodes[i];\n\n          if (child.nodeType === 1) {\n            var ft = child.nodeName.split(':').pop();\n\n            if (featureType.indexOf(ft) === -1) {\n              var key = '';\n              var count = 0;\n              var uri = child.namespaceURI;\n\n              for (var candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n\n                ++count;\n              }\n\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n\n      if (typeof featureNS === 'string') {\n        var ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n\n\n      var parsersNS = {};\n      var featureTypes = Array.isArray(featureType) ? featureType : [featureType];\n\n      for (var p in featureNS) {\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        var parsers = {};\n\n        for (var i = 0, ii = featureTypes.length; i < ii; ++i) {\n          var featurePrefix = featureTypes[i].indexOf(':') === -1 ? defaultPrefix : featureTypes[i].split(':')[0];\n\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] = localName == 'featureMembers' ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n\n        parsersNS[featureNS[p]] = parsers;\n      }\n\n      if (localName == 'featureMember' || localName == 'member') {\n        features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n\n    if (features === null) {\n      features = [];\n    }\n\n    return features;\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n\n\n  GMLBase.prototype.readGeometryElement = function (node, objectStack) {\n    var context = objectStack[0];\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');\n    var geometry = pushParseAndPop(null, this.GEOMETRY_PARSERS, node, objectStack, this);\n\n    if (geometry) {\n      if (Array.isArray(geometry)) {\n        return transformExtentWithOptions(geometry, context);\n      } else {\n        return transformGeometryWithOptions(geometry, false, context);\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {boolean} asFeature whether result should be wrapped as a feature.\n   * @return {Feature|Object} Feature\n   */\n\n\n  GMLBase.prototype.readFeatureElementInternal = function (node, objectStack, asFeature) {\n    var geometryName;\n    var values = {};\n\n    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {\n      var value = void 0;\n      var localName = n.localName; // first, check if it is simple attribute\n\n      if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {\n        value = getAllTextContent(n, false);\n\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = undefined;\n        }\n      } else {\n        if (asFeature) {\n          //if feature, try it as a geometry\n          value = this.readGeometryElement(n, objectStack);\n        }\n\n        if (!value) {\n          //if not a geometry or not a feature, treat it as a complex attribute\n          value = this.readFeatureElementInternal(n, objectStack, false);\n        } else if (localName !== 'boundedBy') {\n          // boundedBy is an extent and must not be considered as a geometry\n          geometryName = localName;\n        }\n      }\n\n      if (values[localName]) {\n        if (!(values[localName] instanceof Array)) {\n          values[localName] = [values[localName]];\n        }\n\n        values[localName].push(value);\n      } else {\n        values[localName] = value;\n      }\n\n      var len = n.attributes.length;\n\n      if (len > 0) {\n        values[localName] = {\n          _content_: values[localName]\n        };\n\n        for (var i = 0; i < len; i++) {\n          var attName = n.attributes[i].name;\n          values[localName][attName] = n.attributes[i].value;\n        }\n      }\n    }\n\n    if (!asFeature) {\n      return values;\n    } else {\n      var feature = new Feature(values);\n\n      if (geometryName) {\n        feature.setGeometryName(geometryName);\n      }\n\n      var fid = node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n\n      if (fid) {\n        feature.setId(fid);\n      }\n\n      return feature;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Feature} Feature.\n   */\n\n\n  GMLBase.prototype.readFeatureElement = function (node, objectStack) {\n    return this.readFeatureElementInternal(node, objectStack, true);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Point|undefined} Point.\n   */\n\n\n  GMLBase.prototype.readPoint = function (node, objectStack) {\n    var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n\n    if (flatCoordinates) {\n      return new Point(flatCoordinates, GeometryLayout.XYZ);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPoint|undefined} MultiPoint.\n   */\n\n\n  GMLBase.prototype.readMultiPoint = function (node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    var coordinates = pushParseAndPop([], this.MULTIPOINT_PARSERS, node, objectStack, this);\n\n    if (coordinates) {\n      return new MultiPoint(coordinates);\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n\n\n  GMLBase.prototype.readMultiLineString = function (node, objectStack) {\n    /** @type {Array<LineString>} */\n    var lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS, node, objectStack, this);\n\n    if (lineStrings) {\n      return new MultiLineString(lineStrings);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n\n\n  GMLBase.prototype.readMultiPolygon = function (node, objectStack) {\n    /** @type {Array<Polygon>} */\n    var polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS, node, objectStack, this);\n\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n\n\n  GMLBase.prototype.pointMemberParser = function (node, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n\n\n  GMLBase.prototype.lineStringMemberParser = function (node, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n\n\n  GMLBase.prototype.polygonMemberParser = function (node, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n\n\n  GMLBase.prototype.readLineString = function (node, objectStack) {\n    var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n\n    if (flatCoordinates) {\n      var lineString = new LineString(flatCoordinates, GeometryLayout.XYZ);\n      return lineString;\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} LinearRing flat coordinates.\n   */\n\n\n  GMLBase.prototype.readFlatLinearRing = function (node, objectStack) {\n    var ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n\n    if (ring) {\n      return ring;\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LinearRing|undefined} LinearRing.\n   */\n\n\n  GMLBase.prototype.readLinearRing = function (node, objectStack) {\n    var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n\n    if (flatCoordinates) {\n      return new LinearRing(flatCoordinates, GeometryLayout.XYZ);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n\n\n  GMLBase.prototype.readPolygon = function (node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    var flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);\n\n    if (flatLinearRings && flatLinearRings[0]) {\n      var flatCoordinates = flatLinearRings[0];\n      var ends = [flatCoordinates.length];\n      var i = void 0,\n          ii = void 0;\n\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n\n      return new Polygon(flatCoordinates, GeometryLayout.XYZ, ends);\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>} Flat coordinates.\n   */\n\n\n  GMLBase.prototype.readFlatCoordinatesFromNode = function (node, objectStack) {\n    return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} Geometry.\n   */\n  //@ts-ignore\n\n\n  GMLBase.prototype.readGeometryFromNode = function (node, opt_options) {\n    var geometry = this.readGeometryElement(node, [this.getReadOptions(node, opt_options ? opt_options : {})]);\n    return geometry ? geometry : null;\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n\n\n  GMLBase.prototype.readFeaturesFromNode = function (node, opt_options) {\n    var options = {\n      featureType: this.featureType,\n      featureNS: this.featureNS\n    };\n\n    if (opt_options) {\n      assign(options, this.getReadOptions(node, opt_options));\n    }\n\n    var features = this.readFeaturesInternal(node, [options]);\n    return features || [];\n  };\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n\n\n  GMLBase.prototype.readProjectionFromNode = function (node) {\n    return getProjection(this.srsName ? this.srsName : node.firstElementChild.getAttribute('srsName'));\n  };\n\n  return GMLBase;\n}(XMLFeature);\n\nGMLBase.prototype.namespace = GMLNS;\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(GMLBase.prototype.lineStringMemberParser),\n    'lineStringMembers': makeArrayPusher(GMLBase.prototype.lineStringMemberParser)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing)\n  }\n};\nexport default GMLBase;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/format/GMLBase.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","Feature","GeometryLayout","LineString","LinearRing","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","XMLFeature","assign","extend","getAllTextContent","getAttributeNS","makeArrayPusher","makeReplacer","parseNode","pushParseAndPop","get","getProjection","transformExtentWithOptions","transformGeometryWithOptions","GMLNS","ONLY_WHITESPACE_RE","GMLBase","_super","opt_options","_this","options","featureType","featureNS","srsName","schemaLocation","FEATURE_COLLECTION_PARSERS","namespace","readFeaturesInternal","supportedMediaTypes","node","objectStack","localName","features","context","prefix","defaultPrefix","childNodes","i","ii","length","child","nodeType","ft","nodeName","split","pop","indexOf","key","count","uri","namespaceURI","candidate","push","ns","parsersNS","featureTypes","isArray","parsers","featurePrefix","readFeatureElement","undefined","readGeometryElement","firstElementChild","getAttribute","geometry","GEOMETRY_PARSERS","readFeatureElementInternal","asFeature","geometryName","values","n","nextElementSibling","value","firstChild","test","len","attributes","_content_","attName","name","feature","setGeometryName","fid","setId","readPoint","flatCoordinates","readFlatCoordinatesFromNode","XYZ","readMultiPoint","coordinates","MULTIPOINT_PARSERS","readMultiLineString","lineStrings","MULTILINESTRING_PARSERS","readMultiPolygon","polygons","MULTIPOLYGON_PARSERS","pointMemberParser","POINTMEMBER_PARSERS","lineStringMemberParser","LINESTRINGMEMBER_PARSERS","polygonMemberParser","POLYGONMEMBER_PARSERS","readLineString","lineString","readFlatLinearRing","ring","GEOMETRY_FLAT_COORDINATES_PARSERS","readLinearRing","readPolygon","flatLinearRings","FLAT_LINEAR_RINGS_PARSERS","ends","readGeometryFromNode","getReadOptions","readFeaturesFromNode","readProjectionFromNode","RING_PARSERS"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport Feature from '../Feature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport XMLFeature from './XMLFeature.js';\nimport { assign } from '../obj.js';\nimport { extend } from '../array.js';\nimport { getAllTextContent, getAttributeNS, makeArrayPusher, makeReplacer, parseNode, pushParseAndPop, } from '../xml.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformExtentWithOptions, transformGeometryWithOptions, } from './Feature.js';\n/**\n * @const\n * @type {string}\n */\nexport var GMLNS = 'http://www.opengis.net/gml';\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc. The non-breaking\n * space (0xa0) is explicitly included as IE doesn't include it in its\n * definition of `\\s`.\n *\n * Information from `goog.string.isEmptyOrWhitespace`: https://github.com/google/closure-library/blob/e877b1e/closure/goog/string/string.js#L156-L160\n *\n * @const\n * @type {RegExp}\n */\nvar ONLY_WHITESPACE_RE = /^[\\s\\xa0]*$/;\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} srsName srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\nvar GMLBase = /** @class */ (function (_super) {\n    __extends(GMLBase, _super);\n    /**\n     * @param {Options} [opt_options] Optional configuration object.\n     */\n    function GMLBase(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = /** @type {Options} */ (opt_options ? opt_options : {});\n        /**\n         * @protected\n         * @type {Array<string>|string|undefined}\n         */\n        _this.featureType = options.featureType;\n        /**\n         * @protected\n         * @type {Object<string, string>|string|undefined}\n         */\n        _this.featureNS = options.featureNS;\n        /**\n         * @protected\n         * @type {string}\n         */\n        _this.srsName = options.srsName;\n        /**\n         * @protected\n         * @type {string}\n         */\n        _this.schemaLocation = '';\n        /**\n         * @type {Object<string, Object<string, Object>>}\n         */\n        _this.FEATURE_COLLECTION_PARSERS = {};\n        _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {\n            'featureMember': makeArrayPusher(_this.readFeaturesInternal),\n            'featureMembers': makeReplacer(_this.readFeaturesInternal),\n        };\n        _this.supportedMediaTypes = ['application/gml+xml'];\n        return _this;\n    }\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<Feature> | undefined} Features.\n     */\n    GMLBase.prototype.readFeaturesInternal = function (node, objectStack) {\n        var localName = node.localName;\n        var features = null;\n        if (localName == 'FeatureCollection') {\n            features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);\n        }\n        else if (localName == 'featureMembers' ||\n            localName == 'featureMember' ||\n            localName == 'member') {\n            var context = objectStack[0];\n            var featureType = context['featureType'];\n            var featureNS = context['featureNS'];\n            var prefix = 'p';\n            var defaultPrefix = 'p0';\n            if (!featureType && node.childNodes) {\n                (featureType = []), (featureNS = {});\n                for (var i = 0, ii = node.childNodes.length; i < ii; ++i) {\n                    var child = node.childNodes[i];\n                    if (child.nodeType === 1) {\n                        var ft = child.nodeName.split(':').pop();\n                        if (featureType.indexOf(ft) === -1) {\n                            var key = '';\n                            var count = 0;\n                            var uri = child.namespaceURI;\n                            for (var candidate in featureNS) {\n                                if (featureNS[candidate] === uri) {\n                                    key = candidate;\n                                    break;\n                                }\n                                ++count;\n                            }\n                            if (!key) {\n                                key = prefix + count;\n                                featureNS[key] = uri;\n                            }\n                            featureType.push(key + ':' + ft);\n                        }\n                    }\n                }\n                if (localName != 'featureMember') {\n                    // recheck featureType for each featureMember\n                    context['featureType'] = featureType;\n                    context['featureNS'] = featureNS;\n                }\n            }\n            if (typeof featureNS === 'string') {\n                var ns = featureNS;\n                featureNS = {};\n                featureNS[defaultPrefix] = ns;\n            }\n            /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n            var parsersNS = {};\n            var featureTypes = Array.isArray(featureType)\n                ? featureType\n                : [featureType];\n            for (var p in featureNS) {\n                /** @type {Object<string, import(\"../xml.js\").Parser>} */\n                var parsers = {};\n                for (var i = 0, ii = featureTypes.length; i < ii; ++i) {\n                    var featurePrefix = featureTypes[i].indexOf(':') === -1\n                        ? defaultPrefix\n                        : featureTypes[i].split(':')[0];\n                    if (featurePrefix === p) {\n                        parsers[featureTypes[i].split(':').pop()] =\n                            localName == 'featureMembers'\n                                ? makeArrayPusher(this.readFeatureElement, this)\n                                : makeReplacer(this.readFeatureElement, this);\n                    }\n                }\n                parsersNS[featureNS[p]] = parsers;\n            }\n            if (localName == 'featureMember' || localName == 'member') {\n                features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n            }\n            else {\n                features = pushParseAndPop([], parsersNS, node, objectStack);\n            }\n        }\n        if (features === null) {\n            features = [];\n        }\n        return features;\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n     */\n    GMLBase.prototype.readGeometryElement = function (node, objectStack) {\n        var context = /** @type {Object} */ (objectStack[0]);\n        context['srsName'] = node.firstElementChild.getAttribute('srsName');\n        context['srsDimension'] =\n            node.firstElementChild.getAttribute('srsDimension');\n        var geometry = pushParseAndPop(null, this.GEOMETRY_PARSERS, node, objectStack, this);\n        if (geometry) {\n            if (Array.isArray(geometry)) {\n                return transformExtentWithOptions(\n                /** @type {import(\"../extent.js\").Extent} */ (geometry), context);\n            }\n            else {\n                return transformGeometryWithOptions(\n                /** @type {import(\"../geom/Geometry.js\").default} */ (geometry), false, context);\n            }\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {boolean} asFeature whether result should be wrapped as a feature.\n     * @return {Feature|Object} Feature\n     */\n    GMLBase.prototype.readFeatureElementInternal = function (node, objectStack, asFeature) {\n        var geometryName;\n        var values = {};\n        for (var n = node.firstElementChild; n; n = n.nextElementSibling) {\n            var value = void 0;\n            var localName = n.localName;\n            // first, check if it is simple attribute\n            if (n.childNodes.length === 0 ||\n                (n.childNodes.length === 1 &&\n                    (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))) {\n                value = getAllTextContent(n, false);\n                if (ONLY_WHITESPACE_RE.test(value)) {\n                    value = undefined;\n                }\n            }\n            else {\n                if (asFeature) {\n                    //if feature, try it as a geometry\n                    value = this.readGeometryElement(n, objectStack);\n                }\n                if (!value) {\n                    //if not a geometry or not a feature, treat it as a complex attribute\n                    value = this.readFeatureElementInternal(n, objectStack, false);\n                }\n                else if (localName !== 'boundedBy') {\n                    // boundedBy is an extent and must not be considered as a geometry\n                    geometryName = localName;\n                }\n            }\n            if (values[localName]) {\n                if (!(values[localName] instanceof Array)) {\n                    values[localName] = [values[localName]];\n                }\n                values[localName].push(value);\n            }\n            else {\n                values[localName] = value;\n            }\n            var len = n.attributes.length;\n            if (len > 0) {\n                values[localName] = { _content_: values[localName] };\n                for (var i = 0; i < len; i++) {\n                    var attName = n.attributes[i].name;\n                    values[localName][attName] = n.attributes[i].value;\n                }\n            }\n        }\n        if (!asFeature) {\n            return values;\n        }\n        else {\n            var feature = new Feature(values);\n            if (geometryName) {\n                feature.setGeometryName(geometryName);\n            }\n            var fid = node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n            if (fid) {\n                feature.setId(fid);\n            }\n            return feature;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Feature} Feature.\n     */\n    GMLBase.prototype.readFeatureElement = function (node, objectStack) {\n        return this.readFeatureElementInternal(node, objectStack, true);\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Point|undefined} Point.\n     */\n    GMLBase.prototype.readPoint = function (node, objectStack) {\n        var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n        if (flatCoordinates) {\n            return new Point(flatCoordinates, GeometryLayout.XYZ);\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {MultiPoint|undefined} MultiPoint.\n     */\n    GMLBase.prototype.readMultiPoint = function (node, objectStack) {\n        /** @type {Array<Array<number>>} */\n        var coordinates = pushParseAndPop([], this.MULTIPOINT_PARSERS, node, objectStack, this);\n        if (coordinates) {\n            return new MultiPoint(coordinates);\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {MultiLineString|undefined} MultiLineString.\n     */\n    GMLBase.prototype.readMultiLineString = function (node, objectStack) {\n        /** @type {Array<LineString>} */\n        var lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS, node, objectStack, this);\n        if (lineStrings) {\n            return new MultiLineString(lineStrings);\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {MultiPolygon|undefined} MultiPolygon.\n     */\n    GMLBase.prototype.readMultiPolygon = function (node, objectStack) {\n        /** @type {Array<Polygon>} */\n        var polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS, node, objectStack, this);\n        if (polygons) {\n            return new MultiPolygon(polygons);\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    GMLBase.prototype.pointMemberParser = function (node, objectStack) {\n        parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    GMLBase.prototype.lineStringMemberParser = function (node, objectStack) {\n        parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    GMLBase.prototype.polygonMemberParser = function (node, objectStack) {\n        parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {LineString|undefined} LineString.\n     */\n    GMLBase.prototype.readLineString = function (node, objectStack) {\n        var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n        if (flatCoordinates) {\n            var lineString = new LineString(flatCoordinates, GeometryLayout.XYZ);\n            return lineString;\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<number>|undefined} LinearRing flat coordinates.\n     */\n    GMLBase.prototype.readFlatLinearRing = function (node, objectStack) {\n        var ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n        if (ring) {\n            return ring;\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {LinearRing|undefined} LinearRing.\n     */\n    GMLBase.prototype.readLinearRing = function (node, objectStack) {\n        var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n        if (flatCoordinates) {\n            return new LinearRing(flatCoordinates, GeometryLayout.XYZ);\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Polygon|undefined} Polygon.\n     */\n    GMLBase.prototype.readPolygon = function (node, objectStack) {\n        /** @type {Array<Array<number>>} */\n        var flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);\n        if (flatLinearRings && flatLinearRings[0]) {\n            var flatCoordinates = flatLinearRings[0];\n            var ends = [flatCoordinates.length];\n            var i = void 0, ii = void 0;\n            for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n                extend(flatCoordinates, flatLinearRings[i]);\n                ends.push(flatCoordinates.length);\n            }\n            return new Polygon(flatCoordinates, GeometryLayout.XYZ, ends);\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<number>} Flat coordinates.\n     */\n    GMLBase.prototype.readFlatCoordinatesFromNode = function (node, objectStack) {\n        return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @protected\n     * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} Geometry.\n     */\n    //@ts-ignore\n    GMLBase.prototype.readGeometryFromNode = function (node, opt_options) {\n        var geometry = this.readGeometryElement(node, [\n            this.getReadOptions(node, opt_options ? opt_options : {}),\n        ]);\n        return geometry ? geometry : null;\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     */\n    GMLBase.prototype.readFeaturesFromNode = function (node, opt_options) {\n        var options = {\n            featureType: this.featureType,\n            featureNS: this.featureNS,\n        };\n        if (opt_options) {\n            assign(options, this.getReadOptions(node, opt_options));\n        }\n        var features = this.readFeaturesInternal(node, [options]);\n        return features || [];\n    };\n    /**\n     * @param {Element} node Node.\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     */\n    GMLBase.prototype.readProjectionFromNode = function (node) {\n        return getProjection(this.srsName\n            ? this.srsName\n            : node.firstElementChild.getAttribute('srsName'));\n    };\n    return GMLBase;\n}(XMLFeature));\nGMLBase.prototype.namespace = GMLNS;\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n    'http://www.opengis.net/gml': {},\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n    'http://www.opengis.net/gml': {},\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n    'http://www.opengis.net/gml': {},\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n    'http://www.opengis.net/gml': {\n        'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n        'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    },\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n    'http://www.opengis.net/gml': {\n        'lineStringMember': makeArrayPusher(GMLBase.prototype.lineStringMemberParser),\n        'lineStringMembers': makeArrayPusher(GMLBase.prototype.lineStringMemberParser),\n    },\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n    'http://www.opengis.net/gml': {\n        'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n        'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    },\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n    'http://www.opengis.net/gml': {\n        'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n    },\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n    'http://www.opengis.net/gml': {\n        'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    },\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n    'http://www.opengis.net/gml': {\n        'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    },\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n    'http://www.opengis.net/gml': {\n        'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    },\n};\nexport default GMLBase;\n"]},"metadata":{},"sourceType":"module"}