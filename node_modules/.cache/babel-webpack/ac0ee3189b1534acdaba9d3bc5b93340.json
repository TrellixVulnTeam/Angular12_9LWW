{"ast":null,"code":"/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [opt_dest] Destination.\n * @param {number} [opt_dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\n\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {\n  var o, t;\n  var n = (end - offset) / stride;\n\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length_1 = 0;\n    var cumulativeLengths = [0];\n\n    for (var i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length_1);\n      x1 = x2;\n      y1 = y2;\n    }\n\n    var target = fraction * length_1;\n    var index = binarySearch(cumulativeLengths, target);\n\n    if (index < 0) {\n      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n\n  var dimension = opt_dimension > 1 ? opt_dimension : 2;\n  var dest = opt_dest ? opt_dest : new Array(dimension);\n\n  for (var i = 0; i < dimension; ++i) {\n    dest[i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n\n  return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\n\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n\n  var coordinate;\n\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } // FIXME use O(1) search\n\n\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n\n  var lo = offset / stride;\n  var hi = end / stride;\n\n  while (lo < hi) {\n    var mid = lo + hi >> 1;\n\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n\n  var m0 = flatCoordinates[lo * stride - 1];\n\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n\n  for (var i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n  }\n\n  coordinate.push(m);\n  return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\n\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n\n  var coordinate;\n\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n\n    if (offset == end) {\n      continue;\n    }\n\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n    }\n\n    offset = end;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/geom/flat/interpolate.js"],"names":["binarySearch","lerp","interpolatePoint","flatCoordinates","offset","end","stride","fraction","opt_dest","opt_dimension","o","t","n","x1","y1","length_1","cumulativeLengths","i","x2","y2","Math","sqrt","push","target","index","dimension","dest","Array","undefined","NaN","lineStringCoordinateAtM","m","extrapolate","coordinate","slice","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","ends","interpolate","length","ii"],"mappings":"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","sourcesContent":["/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [opt_dest] Destination.\n * @param {number} [opt_dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {\n    var o, t;\n    var n = (end - offset) / stride;\n    if (n === 1) {\n        o = offset;\n    }\n    else if (n === 2) {\n        o = offset;\n        t = fraction;\n    }\n    else if (n !== 0) {\n        var x1 = flatCoordinates[offset];\n        var y1 = flatCoordinates[offset + 1];\n        var length_1 = 0;\n        var cumulativeLengths = [0];\n        for (var i = offset + stride; i < end; i += stride) {\n            var x2 = flatCoordinates[i];\n            var y2 = flatCoordinates[i + 1];\n            length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n            cumulativeLengths.push(length_1);\n            x1 = x2;\n            y1 = y2;\n        }\n        var target = fraction * length_1;\n        var index = binarySearch(cumulativeLengths, target);\n        if (index < 0) {\n            t =\n                (target - cumulativeLengths[-index - 2]) /\n                    (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n            o = offset + (-index - 2) * stride;\n        }\n        else {\n            o = offset + index * stride;\n        }\n    }\n    var dimension = opt_dimension > 1 ? opt_dimension : 2;\n    var dest = opt_dest ? opt_dest : new Array(dimension);\n    for (var i = 0; i < dimension; ++i) {\n        dest[i] =\n            o === undefined\n                ? NaN\n                : t === undefined\n                    ? flatCoordinates[o + i]\n                    : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n    if (end == offset) {\n        return null;\n    }\n    var coordinate;\n    if (m < flatCoordinates[offset + stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(offset, offset + stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    else if (flatCoordinates[end - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(end - stride, end);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    // FIXME use O(1) search\n    if (m == flatCoordinates[offset + stride - 1]) {\n        return flatCoordinates.slice(offset, offset + stride);\n    }\n    var lo = offset / stride;\n    var hi = end / stride;\n    while (lo < hi) {\n        var mid = (lo + hi) >> 1;\n        if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    var m0 = flatCoordinates[lo * stride - 1];\n    if (m == m0) {\n        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n    }\n    var m1 = flatCoordinates[(lo + 1) * stride - 1];\n    var t = (m - m0) / (m1 - m0);\n    coordinate = [];\n    for (var i = 0; i < stride - 1; ++i) {\n        coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n    }\n    coordinate.push(m);\n    return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n    if (interpolate) {\n        return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n    }\n    var coordinate;\n    if (m < flatCoordinates[stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(0, stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    if (flatCoordinates[flatCoordinates.length - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        if (offset == end) {\n            continue;\n        }\n        if (m < flatCoordinates[offset + stride - 1]) {\n            return null;\n        }\n        else if (m <= flatCoordinates[end - 1]) {\n            return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n        }\n        offset = end;\n    }\n    return null;\n}\n"]},"metadata":{},"sourceType":"module"}