{"ast":null,"code":"/*! @azure/msal-common v4.5.1 2021-08-02 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { AuthorityType } from '../authority/AuthorityType.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Class that handles response parsing.\r\n */\n\nvar ResponseHandler = function () {\n  function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n  }\n  /**\r\n   * Function which validates server authorization code response.\r\n   * @param serverResponseHash\r\n   * @param cachedState\r\n   * @param cryptoObj\r\n   */\n\n\n  ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\n    if (!serverResponseHash.state || !cachedState) {\n      throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\n    }\n\n    if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\n      throw ClientAuthError.createStateMismatchError();\n    } // Check for error\n\n\n    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n      }\n\n      throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n    }\n\n    if (serverResponseHash.client_info) {\n      buildClientInfo(serverResponseHash.client_info, cryptoObj);\n    }\n  };\n  /**\r\n   * Function which validates server authorization token response.\r\n   * @param serverResponse\r\n   */\n\n\n  ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);\n      }\n\n      var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\n      throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\n    }\n  };\n  /**\r\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n   * @param serverTokenResponse\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, oboAssertion, handlingRefreshTokenResponse) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, requestStateObj, cacheRecord, cacheContext, key, account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (serverTokenResponse.id_token) {\n              idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj); // token nonce check (TODO: Add a warning if no nonce is given?)\n\n              if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\n                  throw ClientAuthError.createNonceMismatchError();\n                }\n              }\n            } // generate homeAccountId\n\n\n            this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\n\n            if (!!authCodePayload && !!authCodePayload.state) {\n              requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n            }\n\n            cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, idTokenObj, request.scopes, oboAssertion, authCodePayload);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1,, 4, 7]);\n\n            if (!(this.persistencePlugin && this.serializableCache)) return [3\n            /*break*/\n            , 3];\n            this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n            cacheContext = new TokenCacheContext(this.serializableCache, true);\n            return [4\n            /*yield*/\n            , this.persistencePlugin.beforeCacheAccess(cacheContext)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal.\r\n             */\n            if (handlingRefreshTokenResponse && cacheRecord.account) {\n              key = cacheRecord.account.generateAccountKey();\n              account = this.cacheStorage.getAccount(key);\n\n              if (!account) {\n                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n                return [2\n                /*return*/\n                , ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj)];\n              }\n            }\n\n            this.cacheStorage.saveCacheRecord(cacheRecord);\n            return [3\n            /*break*/\n            , 7];\n\n          case 4:\n            if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3\n            /*break*/\n            , 6];\n            this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n            return [4\n            /*yield*/\n            , this.persistencePlugin.afterCacheAccess(cacheContext)];\n\n          case 5:\n            _a.sent();\n\n            _a.label = 6;\n\n          case 6:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 7:\n            return [2\n            /*return*/\n            , ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates CacheRecord\r\n   * @param serverTokenResponse\r\n   * @param idTokenObj\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, idTokenObj, requestScopes, oboAssertion, authCodePayload) {\n    var env = authority.getPreferredCache();\n\n    if (StringUtils.isEmpty(env)) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    } // IdToken: non AAD scenarios can have empty realm\n\n\n    var cachedIdToken;\n    var cachedAccount;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\n      cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING, oboAssertion);\n      cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, oboAssertion, authCodePayload);\n    } // AccessToken\n\n\n    var cachedAccessToken = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\n      // If scopes not returned in server response, use request scopes\n      var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(requestScopes || []);\n      /*\r\n       * Use timestamp calculated before request\r\n       * Server may return timestamps as strings, parse to numbers if so.\r\n       */\n\n      var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      var tokenExpirationSeconds = reqTimestamp + expiresIn;\n      var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined; // non AAD scenarios can have empty realm\n\n      cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, oboAssertion);\n    } // refreshToken\n\n\n    var cachedRefreshToken = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\n      cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, oboAssertion);\n    } // appMetadata\n\n\n    var cachedAppMetadata = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\n      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  };\n  /**\r\n   * Generate Account\r\n   * @param serverTokenResponse\r\n   * @param idToken\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, oboAssertion, authCodePayload) {\n    var authorityType = authority.authorityType;\n    var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : \"\";\n    var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : \"\"; // ADFS does not require client_info in the response\n\n    if (authorityType === AuthorityType.Adfs) {\n      this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\n      return AccountEntity.createGenericAccount(authority, this.homeAccountIdentifier, idToken, oboAssertion, cloudGraphHostName, msGraphhost);\n    } // This fallback applies to B2C as well as they fall under an AAD account type.\n\n\n    if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\n      throw ClientAuthError.createClientInfoEmptyError();\n    }\n\n    return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, authority, idToken, oboAssertion, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(authority, this.homeAccountIdentifier, idToken, oboAssertion, cloudGraphHostName, msGraphhost);\n  };\n  /**\r\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n   *\r\n   * Optionally takes a state string that is set as-is in the response.\r\n   *\r\n   * @param cacheRecord\r\n   * @param idTokenObj\r\n   * @param fromTokenCache\r\n   * @param stateString\r\n   */\n\n\n  ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, uid, tid;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            accessToken = \"\";\n            responseScopes = [];\n            expiresOn = null;\n            familyId = Constants.EMPTY_STRING;\n            if (!cacheRecord.accessToken) return [3\n            /*break*/\n            , 4];\n            if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator(cryptoObj);\n            return [4\n            /*yield*/\n            , popTokenGenerator.signPopToken(cacheRecord.accessToken.secret, request)];\n\n          case 1:\n            accessToken = _d.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            accessToken = cacheRecord.accessToken.secret;\n            _d.label = 3;\n\n          case 3:\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n            _d.label = 4;\n\n          case 4:\n            if (cacheRecord.appMetadata) {\n              familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\n            }\n\n            uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\n            tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;\n            return [2\n            /*return*/\n            , {\n              authority: authority.canonicalAuthority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes,\n              account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n              idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\n              idTokenClaims: idTokenObj ? idTokenObj.claims : {},\n              accessToken: accessToken,\n              fromCache: fromTokenCache,\n              expiresOn: expiresOn,\n              extExpiresOn: extExpiresOn,\n              familyId: familyId,\n              tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\n              state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n              cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\n              msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING\n            }];\n        }\n      });\n    });\n  };\n\n  return ResponseHandler;\n}();\n\nexport { ResponseHandler };","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/@azure/msal-common/dist/response/ResponseHandler.js"],"names":["__awaiter","__generator","buildClientInfo","ClientAuthError","StringUtils","ServerError","AuthToken","ScopeSet","AccountEntity","AuthorityType","IdTokenEntity","AccessTokenEntity","RefreshTokenEntity","InteractionRequiredAuthError","CacheRecord","ProtocolUtils","Constants","AuthenticationScheme","THE_FAMILY_ID","PopTokenGenerator","AppMetadataEntity","TokenCacheContext","ResponseHandler","clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","prototype","validateServerAuthorizationCodeResponse","serverResponseHash","cachedState","state","createStateNotFoundError","decodeURIComponent","createStateMismatchError","error","error_description","suberror","isInteractionRequiredError","EMPTY_STRING","client_info","validateTokenResponse","serverResponse","errString","error_codes","timestamp","correlation_id","trace_id","handleServerTokenResponse","serverTokenResponse","authority","reqTimestamp","request","authCodePayload","oboAssertion","handlingRefreshTokenResponse","idTokenObj","requestStateObj","cacheRecord","cacheContext","key","account","_a","label","id_token","isEmpty","nonce","claims","createNonceMismatchError","homeAccountIdentifier","generateHomeAccountId","authorityType","parseRequestState","generateCacheRecord","scopes","trys","push","verbose","beforeCacheAccess","sent","generateAccountKey","getAccount","warning","generateAuthenticationResult","saveCacheRecord","afterCacheAccess","requestScopes","env","getPreferredCache","createInvalidCacheEnvironmentError","cachedIdToken","cachedAccount","createIdTokenEntity","tid","generateAccountEntity","cachedAccessToken","access_token","responseScopes","scope","fromString","expiresIn","expires_in","parseInt","extExpiresIn","ext_expires_in","refreshIn","refresh_in","undefined","tokenExpirationSeconds","extendedTokenExpirationSeconds","refreshOnSeconds","createAccessTokenEntity","tenant","printScopes","token_type","cachedRefreshToken","refresh_token","createRefreshTokenEntity","foci","cachedAppMetadata","createAppMetadataEntity","idToken","cloudGraphHostName","cloud_graph_host_name","msGraphhost","msgraph_host","Adfs","createGenericAccount","protocolMode","createClientInfoEmptyError","createAccount","fromTokenCache","requestState","_b","_c","accessToken","expiresOn","extExpiresOn","familyId","popTokenGenerator","uid","_d","tokenType","POP","signPopToken","secret","target","asArray","Date","Number","extendedExpiresOn","appMetadata","oid","sub","canonicalAuthority","uniqueId","tenantId","getAccountInfo","rawToken","idTokenClaims","fromCache","userRequestState","msGraphHost"],"mappings":"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","sourcesContent":["/*! @azure/msal-common v4.5.1 2021-08-02 */\n'use strict';\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { AuthorityType } from '../authority/AuthorityType.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Class that handles response parsing.\r\n */\r\nvar ResponseHandler = /** @class */ (function () {\r\n    function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin) {\r\n        this.clientId = clientId;\r\n        this.cacheStorage = cacheStorage;\r\n        this.cryptoObj = cryptoObj;\r\n        this.logger = logger;\r\n        this.serializableCache = serializableCache;\r\n        this.persistencePlugin = persistencePlugin;\r\n    }\r\n    /**\r\n     * Function which validates server authorization code response.\r\n     * @param serverResponseHash\r\n     * @param cachedState\r\n     * @param cryptoObj\r\n     */\r\n    ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\r\n        if (!serverResponseHash.state || !cachedState) {\r\n            throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\r\n        }\r\n        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\r\n            throw ClientAuthError.createStateMismatchError();\r\n        }\r\n        // Check for error\r\n        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\r\n            }\r\n            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\r\n        }\r\n        if (serverResponseHash.client_info) {\r\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\r\n        }\r\n    };\r\n    /**\r\n     * Function which validates server authorization token response.\r\n     * @param serverResponse\r\n     */\r\n    ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\r\n        // Check for error\r\n        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);\r\n            }\r\n            var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\r\n            throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\r\n        }\r\n    };\r\n    /**\r\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n     * @param serverTokenResponse\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, oboAssertion, handlingRefreshTokenResponse) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var idTokenObj, requestStateObj, cacheRecord, cacheContext, key, account;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (serverTokenResponse.id_token) {\r\n                            idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\r\n                            // token nonce check (TODO: Add a warning if no nonce is given?)\r\n                            if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\r\n                                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\r\n                                    throw ClientAuthError.createNonceMismatchError();\r\n                                }\r\n                            }\r\n                        }\r\n                        // generate homeAccountId\r\n                        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\r\n                        if (!!authCodePayload && !!authCodePayload.state) {\r\n                            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\r\n                        }\r\n                        cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, idTokenObj, request.scopes, oboAssertion, authCodePayload);\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, , 4, 7]);\r\n                        if (!(this.persistencePlugin && this.serializableCache)) return [3 /*break*/, 3];\r\n                        this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\r\n                        cacheContext = new TokenCacheContext(this.serializableCache, true);\r\n                        return [4 /*yield*/, this.persistencePlugin.beforeCacheAccess(cacheContext)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        /*\r\n                         * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n                         * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n                         * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal.\r\n                         */\r\n                        if (handlingRefreshTokenResponse && cacheRecord.account) {\r\n                            key = cacheRecord.account.generateAccountKey();\r\n                            account = this.cacheStorage.getAccount(key);\r\n                            if (!account) {\r\n                                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\r\n                                return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj)];\r\n                            }\r\n                        }\r\n                        this.cacheStorage.saveCacheRecord(cacheRecord);\r\n                        return [3 /*break*/, 7];\r\n                    case 4:\r\n                        if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3 /*break*/, 6];\r\n                        this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\r\n                        return [4 /*yield*/, this.persistencePlugin.afterCacheAccess(cacheContext)];\r\n                    case 5:\r\n                        _a.sent();\r\n                        _a.label = 6;\r\n                    case 6: return [7 /*endfinally*/];\r\n                    case 7: return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Generates CacheRecord\r\n     * @param serverTokenResponse\r\n     * @param idTokenObj\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, idTokenObj, requestScopes, oboAssertion, authCodePayload) {\r\n        var env = authority.getPreferredCache();\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n        // IdToken: non AAD scenarios can have empty realm\r\n        var cachedIdToken;\r\n        var cachedAccount;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\r\n            cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING, oboAssertion);\r\n            cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, oboAssertion, authCodePayload);\r\n        }\r\n        // AccessToken\r\n        var cachedAccessToken = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\r\n            // If scopes not returned in server response, use request scopes\r\n            var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(requestScopes || []);\r\n            /*\r\n             * Use timestamp calculated before request\r\n             * Server may return timestamps as strings, parse to numbers if so.\r\n             */\r\n            var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\r\n            var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\r\n            var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\r\n            var tokenExpirationSeconds = reqTimestamp + expiresIn;\r\n            var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\r\n            var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\r\n            // non AAD scenarios can have empty realm\r\n            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, oboAssertion);\r\n        }\r\n        // refreshToken\r\n        var cachedRefreshToken = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\r\n            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, oboAssertion);\r\n        }\r\n        // appMetadata\r\n        var cachedAppMetadata = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\r\n            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\r\n        }\r\n        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\r\n    };\r\n    /**\r\n     * Generate Account\r\n     * @param serverTokenResponse\r\n     * @param idToken\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, oboAssertion, authCodePayload) {\r\n        var authorityType = authority.authorityType;\r\n        var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : \"\";\r\n        var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : \"\";\r\n        // ADFS does not require client_info in the response\r\n        if (authorityType === AuthorityType.Adfs) {\r\n            this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\r\n            return AccountEntity.createGenericAccount(authority, this.homeAccountIdentifier, idToken, oboAssertion, cloudGraphHostName, msGraphhost);\r\n        }\r\n        // This fallback applies to B2C as well as they fall under an AAD account type.\r\n        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\r\n            throw ClientAuthError.createClientInfoEmptyError();\r\n        }\r\n        return serverTokenResponse.client_info ?\r\n            AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, authority, idToken, oboAssertion, cloudGraphHostName, msGraphhost) :\r\n            AccountEntity.createGenericAccount(authority, this.homeAccountIdentifier, idToken, oboAssertion, cloudGraphHostName, msGraphhost);\r\n    };\r\n    /**\r\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n     *\r\n     * Optionally takes a state string that is set as-is in the response.\r\n     *\r\n     * @param cacheRecord\r\n     * @param idTokenObj\r\n     * @param fromTokenCache\r\n     * @param stateString\r\n     */\r\n    ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState) {\r\n        var _a, _b, _c;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, uid, tid;\r\n            return __generator(this, function (_d) {\r\n                switch (_d.label) {\r\n                    case 0:\r\n                        accessToken = \"\";\r\n                        responseScopes = [];\r\n                        expiresOn = null;\r\n                        familyId = Constants.EMPTY_STRING;\r\n                        if (!cacheRecord.accessToken) return [3 /*break*/, 4];\r\n                        if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 2];\r\n                        popTokenGenerator = new PopTokenGenerator(cryptoObj);\r\n                        return [4 /*yield*/, popTokenGenerator.signPopToken(cacheRecord.accessToken.secret, request)];\r\n                    case 1:\r\n                        accessToken = _d.sent();\r\n                        return [3 /*break*/, 3];\r\n                    case 2:\r\n                        accessToken = cacheRecord.accessToken.secret;\r\n                        _d.label = 3;\r\n                    case 3:\r\n                        responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\r\n                        expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\r\n                        extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\r\n                        _d.label = 4;\r\n                    case 4:\r\n                        if (cacheRecord.appMetadata) {\r\n                            familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\r\n                        }\r\n                        uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\r\n                        tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;\r\n                        return [2 /*return*/, {\r\n                                authority: authority.canonicalAuthority,\r\n                                uniqueId: uid,\r\n                                tenantId: tid,\r\n                                scopes: responseScopes,\r\n                                account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\r\n                                idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\r\n                                idTokenClaims: idTokenObj ? idTokenObj.claims : {},\r\n                                accessToken: accessToken,\r\n                                fromCache: fromTokenCache,\r\n                                expiresOn: expiresOn,\r\n                                extExpiresOn: extExpiresOn,\r\n                                familyId: familyId,\r\n                                tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\r\n                                state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\r\n                                cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\r\n                                msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING\r\n                            }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return ResponseHandler;\r\n}());\n\nexport { ResponseHandler };\n"]},"metadata":{},"sourceType":"module"}