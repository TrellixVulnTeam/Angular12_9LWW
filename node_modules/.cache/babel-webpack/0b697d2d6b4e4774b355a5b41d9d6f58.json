{"ast":null,"code":"/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\n\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var x1 = 0;\n  var y1 = 0;\n  var segmentLength = 0;\n  var segmentM = 0;\n\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n\n  var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  var beginX = lerp(x1, x2, interpolate);\n  var beginY = lerp(y1, y2, interpolate);\n  var startOffset = offset - stride;\n  var startLength = segmentM;\n  var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  var endX = lerp(x1, x2, interpolate);\n  var endY = lerp(y1, y2, interpolate); // Keep text upright\n\n  var reverse;\n\n  if (rotation) {\n    var flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n\n  var PI = Math.PI;\n  var result = [];\n  var singleSegment = startOffset + stride === offset;\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n  var previousAngle; // All on the same segment\n\n  if (singleSegment) {\n    advance();\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n\n    var x = (endX + beginX) / 2;\n    var y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  }\n\n  for (var i = 0, ii = text.length; i < ii;) {\n    advance();\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n\n    previousAngle = angle;\n    var iStart = i;\n    var charLength = 0;\n\n    for (; i < ii; ++i) {\n      var index = reverse ? ii - i - 1 : i;\n      var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n\n      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {\n        break;\n      }\n\n      charLength += len;\n    }\n\n    if (i === iStart) {\n      continue;\n    }\n\n    var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);\n    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;\n    var x = lerp(x1, x2, interpolate);\n    var y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/geom/flat/textpath.js"],"names":["lerp","rotate","drawTextOnPath","flatCoordinates","offset","end","stride","text","startM","maxAngle","scale","measureAndCacheTextWidth","font","cache","rotation","x2","y2","x1","y1","segmentLength","segmentM","advance","Math","sqrt","interpolate","beginX","beginY","startOffset","startLength","endM","endX","endY","reverse","flat","PI","result","singleSegment","previousAngle","atan2","x","y","i","ii","length","angle","undefined","delta","abs","iStart","charLength","index","len","chars","substring","push"],"mappings":"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","sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var x1 = 0;\n    var y1 = 0;\n    var segmentLength = 0;\n    var segmentM = 0;\n    function advance() {\n        x1 = x2;\n        y1 = y2;\n        offset += stride;\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        segmentM += segmentLength;\n        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    do {\n        advance();\n    } while (offset < end - stride && segmentM + segmentLength < startM);\n    var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n    var beginX = lerp(x1, x2, interpolate);\n    var beginY = lerp(y1, y2, interpolate);\n    var startOffset = offset - stride;\n    var startLength = segmentM;\n    var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n    while (offset < end - stride && segmentM + segmentLength < endM) {\n        advance();\n    }\n    interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n    var endX = lerp(x1, x2, interpolate);\n    var endY = lerp(y1, y2, interpolate);\n    // Keep text upright\n    var reverse;\n    if (rotation) {\n        var flat = [beginX, beginY, endX, endY];\n        rotate(flat, 0, 4, 2, rotation, flat, flat);\n        reverse = flat[0] > flat[2];\n    }\n    else {\n        reverse = beginX > endX;\n    }\n    var PI = Math.PI;\n    var result = [];\n    var singleSegment = startOffset + stride === offset;\n    offset = startOffset;\n    segmentLength = 0;\n    segmentM = startLength;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    var previousAngle;\n    // All on the same segment\n    if (singleSegment) {\n        advance();\n        previousAngle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            previousAngle += previousAngle > 0 ? -PI : PI;\n        }\n        var x = (endX + beginX) / 2;\n        var y = (endY + beginY) / 2;\n        result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n        return result;\n    }\n    for (var i = 0, ii = text.length; i < ii;) {\n        advance();\n        var angle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            angle += angle > 0 ? -PI : PI;\n        }\n        if (previousAngle !== undefined) {\n            var delta = angle - previousAngle;\n            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n            if (Math.abs(delta) > maxAngle) {\n                return null;\n            }\n        }\n        previousAngle = angle;\n        var iStart = i;\n        var charLength = 0;\n        for (; i < ii; ++i) {\n            var index = reverse ? ii - i - 1 : i;\n            var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n            if (offset + stride < end &&\n                segmentM + segmentLength < startM + charLength + len / 2) {\n                break;\n            }\n            charLength += len;\n        }\n        if (i === iStart) {\n            continue;\n        }\n        var chars = reverse\n            ? text.substring(ii - iStart, ii - i)\n            : text.substring(iStart, i);\n        interpolate =\n            segmentLength === 0\n                ? 0\n                : (startM + charLength / 2 - segmentM) / segmentLength;\n        var x = lerp(x1, x2, interpolate);\n        var y = lerp(y1, y2, interpolate);\n        result.push([x, y, charLength / 2, angle, chars]);\n        startM += charLength;\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}