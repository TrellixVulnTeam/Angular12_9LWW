{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/TileLayer\n */\n\n\nimport CanvasLayerRenderer from './Layer.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse } from '../../transform.js';\nimport { assign } from '../../obj.js';\nimport { createEmpty, equals, getIntersection, getTopLeft } from '../../extent.js';\nimport { cssOpacity } from '../../css.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toString as toTransformString } from '../../transform.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\n\nvar CanvasTileLayerRenderer = function (_super) {\n  __extends(CanvasTileLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} tileLayer Tile layer.\n   */\n\n\n  function CanvasTileLayerRenderer(tileLayer) {\n    var _this = _super.call(this, tileLayer) || this;\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n\n\n    _this.extentChanged = true;\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n\n    _this.renderedExtent_ = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.renderedPixelRatio;\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n\n    _this.renderedProjection = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.renderedRevision;\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n\n    _this.renderedTiles = [];\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.newTiles_ = false;\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    _this.tmpExtent = createEmpty();\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n\n    _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    var tileLayer = this.getLayer();\n    var tileState = tile.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var projection = frameState.viewState.projection;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n\n    return tile;\n  };\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);\n    }\n\n    return false;\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    return !!this.getLayer().getSource();\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var rotation = viewState.rotation;\n    var pixelRatio = frameState.pixelRatio;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var extent = frameState.extent;\n    var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n\n    if (layerExtent) {\n      extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n    }\n\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio); // desired dimensions of the canvas in pixels\n\n    var width = Math.round(frameState.size[0] * tilePixelRatio);\n    var height = Math.round(frameState.size[1] * tilePixelRatio);\n\n    if (rotation) {\n      var size = Math.round(Math.sqrt(width * width + height * height));\n      width = size;\n      height = size;\n    }\n\n    var dx = tileResolution * width / 2 / tilePixelRatio;\n    var dy = tileResolution * height / 2 / tilePixelRatio;\n    var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        var tile = this.getTile(z, x, y, frameState);\n\n        if (this.isDrawableTile(tile)) {\n          var uid = getUid(this);\n\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n\n    var canvasScale = tileResolution / viewResolution; // set forward and inverse pixel transforms\n\n    composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);\n    var canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, layerState.opacity);\n    var context = this.context;\n    var canvas = context.canvas;\n    makeInverse(this.inversePixelTransform, this.pixelTransform); // set scale transform for calculating tile positions on the canvas\n\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    assign(context, tileSource.getContextOptions());\n    this.preRender(context, frameState);\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n\n    var zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var clips, clipZs, currentClip;\n\n    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n\n    for (var i = zs.length - 1; i >= 0; --i) {\n      var currentZ = zs[i];\n      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      var currentResolution = tileGrid.getResolution(currentZ);\n      var currentScale = currentResolution / tileResolution;\n      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;\n      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;\n      var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      var origin_1 = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      var tilesToDraw = tilesToDrawByZ[currentZ];\n\n      for (var tileCoordKey in tilesToDraw) {\n        var tile = tilesToDraw[tileCoordKey];\n        var tileCoord = tile.tileCoord; // Calculate integer positions and sizes so that tiles align\n\n        var xIndex = originTileCoord[1] - tileCoord[1];\n        var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);\n        var yIndex = originTileCoord[2] - tileCoord[2];\n        var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);\n        var x = Math.round(origin_1[0] - xIndex * dx_1);\n        var y = Math.round(origin_1[1] - yIndex * dy_1);\n        var w = nextX - x;\n        var h = nextY - y;\n        var transition = z === currentZ;\n        var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            context.save();\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n\n            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {\n              if (z !== currentZ && currentZ < clipZs[i_1]) {\n                var clip = clips[i_1];\n                context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n                context.moveTo(currentClip[0], currentClip[1]);\n                context.lineTo(currentClip[2], currentClip[3]);\n                context.lineTo(currentClip[4], currentClip[5]);\n                context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile\n\n                context.moveTo(clip[6], clip[7]);\n                context.lineTo(clip[4], clip[5]);\n                context.lineTo(clip[2], clip[3]);\n                context.lineTo(clip[0], clip[1]);\n                context.clip();\n              }\n            }\n\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n\n        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);\n\n        if (clips && !inTransition) {\n          context.restore();\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    var opacity = cssOpacity(layerState.opacity);\n    var container = this.container;\n\n    if (opacity !== container.style.opacity) {\n      container.style.opacity = opacity;\n    }\n\n    return this.container;\n  };\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition) {\n    var image = this.getTileImage(tile);\n\n    if (!image) {\n      return;\n    }\n\n    var uid = getUid(this);\n    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    var alphaChanged = alpha !== this.context.globalAlpha;\n\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getImage = function () {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage();\n  };\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function (tileSource, map, frameState) {\n        var tileSourceKey = getUid(tileSource);\n\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n  };\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    var tileSourceKey = getUid(tileSource);\n\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  };\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {\n    var tileSourceKey = getUid(tileSource);\n\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var tileCount = 0;\n    var tile, tileRange, tileResolution, x, y, z;\n\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n\n    tileSource.updateCacheSize(tileCount, projection);\n  };\n\n  return CanvasTileLayerRenderer;\n}(CanvasLayerRenderer);\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\n\n\nCanvasTileLayerRenderer.prototype.getLayer;\nexport default CanvasTileLayerRenderer;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/renderer/canvas/TileLayer.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","CanvasLayerRenderer","TileRange","TileState","apply","applyTransform","compose","composeTransform","makeInverse","assign","createEmpty","equals","getIntersection","getTopLeft","cssOpacity","fromUserExtent","getUid","numberSafeCompareFunction","toString","toTransformString","CanvasTileLayerRenderer","_super","tileLayer","_this","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","isDrawableTile","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","getTile","z","x","y","frameState","pixelRatio","projection","viewState","tileSource","getSource","setState","getPreload","getInterimTile","loadedTileCallback","tiles","zoom","prepareFrame","renderFrame","target","layerState","layerStatesArray","layerIndex","viewResolution","resolution","viewCenter","center","rotation","sourceRevision","getRevision","tileGrid","getTileGridForProjection","getZForResolution","zDirection","tileResolution","getResolution","extent","layerExtent","tilePixelRatio","getTilePixelRatio","width","Math","round","size","height","sqrt","dx","dy","canvasExtent","tileRange","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","minX","maxX","minY","maxY","uid","tileCoord","inTransition","indexOf","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","pixelTransform","canvasTransform","useContainer","opacity","context","canvas","inversePixelTransform","tempTransform","containerReused","clearRect","clipUnrotated","getContextOptions","preRender","length","zs","keys","map","Number","sort","clips","clipZs","currentClip","getOpaque","reverse","i","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","dx_1","dy_1","originTileCoord","getTileCoordForCoordAndZ","originTileExtent","getTileCoordExtent","origin_1","tileGutter","getGutterForProjection","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","save","i_1","ii","clip","beginPath","moveTo","lineTo","push","drawTileImage","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","manageTilePyramid","scheduleExpireCache","postRender","style","transform","container","gutter","image","getTileImage","alpha","alphaChanged","globalAlpha","drawImage","animate","endTransition","getImage","canExpireCache","postRenderFunction","tileSourceKey","expireCache","bind","postRenderFunctions","getKey","preload","opt_tileCallback","wantedTiles","tileQueue","minZoom","getMinZoom","tileCount","IDLE","isKeyQueued","enqueue","getTileCoordCenter","undefined","useTile","updateCacheSize"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse, } from '../../transform.js';\nimport { assign } from '../../obj.js';\nimport { createEmpty, equals, getIntersection, getTopLeft, } from '../../extent.js';\nimport { cssOpacity } from '../../css.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toString as toTransformString } from '../../transform.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nvar CanvasTileLayerRenderer = /** @class */ (function (_super) {\n    __extends(CanvasTileLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} tileLayer Tile layer.\n     */\n    function CanvasTileLayerRenderer(tileLayer) {\n        var _this = _super.call(this, tileLayer) || this;\n        /**\n         * Rendered extent has changed since the previous `renderFrame()` call\n         * @type {boolean}\n         */\n        _this.extentChanged = true;\n        /**\n         * @private\n         * @type {?import(\"../../extent.js\").Extent}\n         */\n        _this.renderedExtent_ = null;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.renderedPixelRatio;\n        /**\n         * @protected\n         * @type {import(\"../../proj/Projection.js\").default}\n         */\n        _this.renderedProjection = null;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.renderedRevision;\n        /**\n         * @protected\n         * @type {!Array<import(\"../../Tile.js\").default>}\n         */\n        _this.renderedTiles = [];\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.newTiles_ = false;\n        /**\n         * @protected\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.tmpExtent = createEmpty();\n        /**\n         * @private\n         * @type {import(\"../../TileRange.js\").default}\n         */\n        _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n        return _this;\n    }\n    /**\n     * @protected\n     * @param {import(\"../../Tile.js\").default} tile Tile.\n     * @return {boolean} Tile is drawable.\n     */\n    CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n        var tileLayer = this.getLayer();\n        var tileState = tile.getState();\n        var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n        return (tileState == TileState.LOADED ||\n            tileState == TileState.EMPTY ||\n            (tileState == TileState.ERROR && !useInterimTilesOnError));\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {!import(\"../../Tile.js\").default} Tile.\n     */\n    CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n        var pixelRatio = frameState.pixelRatio;\n        var projection = frameState.viewState.projection;\n        var tileLayer = this.getLayer();\n        var tileSource = tileLayer.getSource();\n        var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n        if (tile.getState() == TileState.ERROR) {\n            if (!tileLayer.getUseInterimTilesOnError()) {\n                // When useInterimTilesOnError is false, we consider the error tile as loaded.\n                tile.setState(TileState.LOADED);\n            }\n            else if (tileLayer.getPreload() > 0) {\n                // Preloaded tiles for lower resolutions might have finished loading.\n                this.newTiles_ = true;\n            }\n        }\n        if (!this.isDrawableTile(tile)) {\n            tile = tile.getInterimTile();\n        }\n        return tile;\n    };\n    /**\n     * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n     * @param {number} zoom Zoom level.\n     * @param {import(\"../../Tile.js\").default} tile Tile.\n     * @return {boolean|void} If `false`, the tile will not be considered loaded.\n     */\n    CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n        if (this.isDrawableTile(tile)) {\n            return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);\n        }\n        return false;\n    };\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n        return !!this.getLayer().getSource();\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {HTMLElement} target Target that may be used to render content to.\n     * @return {HTMLElement} The rendered element.\n     */\n    CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var viewState = frameState.viewState;\n        var projection = viewState.projection;\n        var viewResolution = viewState.resolution;\n        var viewCenter = viewState.center;\n        var rotation = viewState.rotation;\n        var pixelRatio = frameState.pixelRatio;\n        var tileLayer = this.getLayer();\n        var tileSource = tileLayer.getSource();\n        var sourceRevision = tileSource.getRevision();\n        var tileGrid = tileSource.getTileGridForProjection(projection);\n        var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n        var tileResolution = tileGrid.getResolution(z);\n        var extent = frameState.extent;\n        var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n        if (layerExtent) {\n            extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n        }\n        var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n        // desired dimensions of the canvas in pixels\n        var width = Math.round(frameState.size[0] * tilePixelRatio);\n        var height = Math.round(frameState.size[1] * tilePixelRatio);\n        if (rotation) {\n            var size = Math.round(Math.sqrt(width * width + height * height));\n            width = size;\n            height = size;\n        }\n        var dx = (tileResolution * width) / 2 / tilePixelRatio;\n        var dy = (tileResolution * height) / 2 / tilePixelRatio;\n        var canvasExtent = [\n            viewCenter[0] - dx,\n            viewCenter[1] - dy,\n            viewCenter[0] + dx,\n            viewCenter[1] + dy,\n        ];\n        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n        /**\n         * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n         */\n        var tilesToDrawByZ = {};\n        tilesToDrawByZ[z] = {};\n        var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n        var tmpExtent = this.tmpExtent;\n        var tmpTileRange = this.tmpTileRange_;\n        this.newTiles_ = false;\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                var tile = this.getTile(z, x, y, frameState);\n                if (this.isDrawableTile(tile)) {\n                    var uid = getUid(this);\n                    if (tile.getState() == TileState.LOADED) {\n                        tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n                        var inTransition = tile.inTransition(uid);\n                        if (!this.newTiles_ &&\n                            (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n                            this.newTiles_ = true;\n                        }\n                    }\n                    if (tile.getAlpha(uid, frameState.time) === 1) {\n                        // don't look for alt tiles if alpha is 1\n                        continue;\n                    }\n                }\n                var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n                var covered = false;\n                if (childTileRange) {\n                    covered = findLoadedTiles(z + 1, childTileRange);\n                }\n                if (!covered) {\n                    tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n                }\n            }\n        }\n        var canvasScale = tileResolution / viewResolution;\n        // set forward and inverse pixel transforms\n        composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);\n        var canvasTransform = toTransformString(this.pixelTransform);\n        this.useContainer(target, canvasTransform, layerState.opacity);\n        var context = this.context;\n        var canvas = context.canvas;\n        makeInverse(this.inversePixelTransform, this.pixelTransform);\n        // set scale transform for calculating tile positions on the canvas\n        composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n        if (canvas.width != width || canvas.height != height) {\n            canvas.width = width;\n            canvas.height = height;\n        }\n        else if (!this.containerReused) {\n            context.clearRect(0, 0, width, height);\n        }\n        if (layerExtent) {\n            this.clipUnrotated(context, frameState, layerExtent);\n        }\n        assign(context, tileSource.getContextOptions());\n        this.preRender(context, frameState);\n        this.renderedTiles.length = 0;\n        /** @type {Array<number>} */\n        var zs = Object.keys(tilesToDrawByZ).map(Number);\n        zs.sort(numberSafeCompareFunction);\n        var clips, clipZs, currentClip;\n        if (layerState.opacity === 1 &&\n            (!this.containerReused ||\n                tileSource.getOpaque(frameState.viewState.projection))) {\n            zs = zs.reverse();\n        }\n        else {\n            clips = [];\n            clipZs = [];\n        }\n        for (var i = zs.length - 1; i >= 0; --i) {\n            var currentZ = zs[i];\n            var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n            var currentResolution = tileGrid.getResolution(currentZ);\n            var currentScale = currentResolution / tileResolution;\n            var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;\n            var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;\n            var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n            var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n            var origin_1 = applyTransform(this.tempTransform, [\n                (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n                    tileResolution,\n                (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n                    tileResolution,\n            ]);\n            var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n            var tilesToDraw = tilesToDrawByZ[currentZ];\n            for (var tileCoordKey in tilesToDraw) {\n                var tile = /** @type {import(\"../../ImageTile.js\").default} */ (tilesToDraw[tileCoordKey]);\n                var tileCoord = tile.tileCoord;\n                // Calculate integer positions and sizes so that tiles align\n                var xIndex = originTileCoord[1] - tileCoord[1];\n                var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);\n                var yIndex = originTileCoord[2] - tileCoord[2];\n                var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);\n                var x = Math.round(origin_1[0] - xIndex * dx_1);\n                var y = Math.round(origin_1[1] - yIndex * dy_1);\n                var w = nextX - x;\n                var h = nextY - y;\n                var transition = z === currentZ;\n                var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n                if (!inTransition) {\n                    if (clips) {\n                        // Clip mask for regions in this tile that already filled by a higher z tile\n                        context.save();\n                        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n                        for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {\n                            if (z !== currentZ && currentZ < clipZs[i_1]) {\n                                var clip = clips[i_1];\n                                context.beginPath();\n                                // counter-clockwise (outer ring) for current tile\n                                context.moveTo(currentClip[0], currentClip[1]);\n                                context.lineTo(currentClip[2], currentClip[3]);\n                                context.lineTo(currentClip[4], currentClip[5]);\n                                context.lineTo(currentClip[6], currentClip[7]);\n                                // clockwise (inner ring) for higher z tile\n                                context.moveTo(clip[6], clip[7]);\n                                context.lineTo(clip[4], clip[5]);\n                                context.lineTo(clip[2], clip[3]);\n                                context.lineTo(clip[0], clip[1]);\n                                context.clip();\n                            }\n                        }\n                        clips.push(currentClip);\n                        clipZs.push(currentZ);\n                    }\n                    else {\n                        context.clearRect(x, y, w, h);\n                    }\n                }\n                this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);\n                if (clips && !inTransition) {\n                    context.restore();\n                    this.renderedTiles.unshift(tile);\n                }\n                else {\n                    this.renderedTiles.push(tile);\n                }\n                this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n            }\n        }\n        this.renderedRevision = sourceRevision;\n        this.renderedResolution = tileResolution;\n        this.extentChanged =\n            !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n        this.renderedExtent_ = canvasExtent;\n        this.renderedPixelRatio = pixelRatio;\n        this.renderedProjection = projection;\n        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n        this.scheduleExpireCache(frameState, tileSource);\n        this.postRender(context, frameState);\n        if (layerState.extent) {\n            context.restore();\n        }\n        if (canvasTransform !== canvas.style.transform) {\n            canvas.style.transform = canvasTransform;\n        }\n        var opacity = cssOpacity(layerState.opacity);\n        var container = this.container;\n        if (opacity !== container.style.opacity) {\n            container.style.opacity = opacity;\n        }\n        return this.container;\n    };\n    /**\n     * @param {import(\"../../ImageTile.js\").default} tile Tile.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} x Left of the tile.\n     * @param {number} y Top of the tile.\n     * @param {number} w Width of the tile.\n     * @param {number} h Height of the tile.\n     * @param {number} gutter Tile gutter.\n     * @param {boolean} transition Apply an alpha transition.\n     */\n    CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition) {\n        var image = this.getTileImage(tile);\n        if (!image) {\n            return;\n        }\n        var uid = getUid(this);\n        var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n        var alphaChanged = alpha !== this.context.globalAlpha;\n        if (alphaChanged) {\n            this.context.save();\n            this.context.globalAlpha = alpha;\n        }\n        this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n        if (alphaChanged) {\n            this.context.restore();\n        }\n        if (alpha !== 1) {\n            frameState.animate = true;\n        }\n        else if (transition) {\n            tile.endTransition(uid);\n        }\n    };\n    /**\n     * @return {HTMLCanvasElement} Image\n     */\n    CanvasTileLayerRenderer.prototype.getImage = function () {\n        var context = this.context;\n        return context ? context.canvas : null;\n    };\n    /**\n     * Get the image from a tile.\n     * @param {import(\"../../ImageTile.js\").default} tile Tile.\n     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {\n        return tile.getImage();\n    };\n    /**\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {\n        if (tileSource.canExpireCache()) {\n            /**\n             * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n             * @param {import(\"../../PluggableMap.js\").default} map Map.\n             * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n             */\n            var postRenderFunction = function (tileSource, map, frameState) {\n                var tileSourceKey = getUid(tileSource);\n                if (tileSourceKey in frameState.usedTiles) {\n                    tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n                }\n            }.bind(null, tileSource);\n            frameState.postRenderFunctions.push(\n            /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */ (postRenderFunction));\n        }\n    };\n    /**\n     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @param {import('../../Tile.js').default} tile Tile.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {\n        // FIXME should we use tilesToDrawByZ instead?\n        var tileSourceKey = getUid(tileSource);\n        if (!(tileSourceKey in usedTiles)) {\n            usedTiles[tileSourceKey] = {};\n        }\n        usedTiles[tileSourceKey][tile.getKey()] = true;\n    };\n    /**\n     * Manage tile pyramid.\n     * This function performs a number of functions related to the tiles at the\n     * current zoom and lower zoom levels:\n     * - registers idle tiles in frameState.wantedTiles so that they are not\n     *   discarded by the tile queue\n     * - enqueues missing tiles\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @param {number} currentZ Current Z.\n     * @param {number} preload Load low resolution tiles up to 'preload' levels.\n     * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {\n        var tileSourceKey = getUid(tileSource);\n        if (!(tileSourceKey in frameState.wantedTiles)) {\n            frameState.wantedTiles[tileSourceKey] = {};\n        }\n        var wantedTiles = frameState.wantedTiles[tileSourceKey];\n        var tileQueue = frameState.tileQueue;\n        var minZoom = tileGrid.getMinZoom();\n        var tileCount = 0;\n        var tile, tileRange, tileResolution, x, y, z;\n        for (z = minZoom; z <= currentZ; ++z) {\n            tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n            tileResolution = tileGrid.getResolution(z);\n            for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n                for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                    if (currentZ - z <= preload) {\n                        ++tileCount;\n                        tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n                        if (tile.getState() == TileState.IDLE) {\n                            wantedTiles[tile.getKey()] = true;\n                            if (!tileQueue.isKeyQueued(tile.getKey())) {\n                                tileQueue.enqueue([\n                                    tile,\n                                    tileSourceKey,\n                                    tileGrid.getTileCoordCenter(tile.tileCoord),\n                                    tileResolution,\n                                ]);\n                            }\n                        }\n                        if (opt_tileCallback !== undefined) {\n                            opt_tileCallback(tile);\n                        }\n                    }\n                    else {\n                        tileSource.useTile(z, x, y, projection);\n                    }\n                }\n            }\n        }\n        tileSource.updateCacheSize(tileCount, projection);\n    };\n    return CanvasTileLayerRenderer;\n}(CanvasLayerRenderer));\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\nexport default CanvasTileLayerRenderer;\n"]},"metadata":{},"sourceType":"module"}