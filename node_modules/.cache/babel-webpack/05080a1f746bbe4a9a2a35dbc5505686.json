{"ast":null,"code":"/**\n * @module ol/render/canvas/ExecutorGroup\n */\nimport BuilderType from './BuilderType.js';\nimport Executor from './Executor.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { isEmpty } from '../../obj.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @const\n * @type {Array<import(\"./BuilderType.js\").default>}\n */\n\nvar ORDER = [BuilderType.POLYGON, BuilderType.CIRCLE, BuilderType.LINE_STRING, BuilderType.IMAGE, BuilderType.TEXT, BuilderType.DEFAULT];\n\nvar ExecutorGroup = function () {\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceed that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number} [opt_renderBuffer] Optional rendering buffer.\n   */\n  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.overlaps_ = overlaps;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.resolution_ = resolution;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.renderBuffer_ = opt_renderBuffer;\n    /**\n     * @private\n     * @type {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Executor\").default>>}\n     */\n\n    this.executorsByZIndex_ = {};\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.hitDetectionContext_ = null;\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    this.hitDetectionTransform_ = createTransform();\n    this.createExecutors_(allInstructions);\n  }\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n\n\n  ExecutorGroup.prototype.clip = function (context, transform) {\n    var flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n  /**\n   * Create executors and populate them using the provided instructions.\n   * @private\n   * @param {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\n   */\n\n\n  ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {\n    for (var zIndex in allInstructions) {\n      var executors = this.executorsByZIndex_[zIndex];\n\n      if (executors === undefined) {\n        executors = {};\n        this.executorsByZIndex_[zIndex] = executors;\n      }\n\n      var instructionByZindex = allInstructions[zIndex];\n\n      for (var builderType in instructionByZindex) {\n        var instructions = instructionByZindex[builderType];\n        executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);\n      }\n    }\n  };\n  /**\n   * @param {Array<import(\"./BuilderType.js\").default>} executors Executors.\n   * @return {boolean} Has executors of the provided types.\n   */\n\n\n  ExecutorGroup.prototype.hasExecutors = function (executors) {\n    for (var zIndex in this.executorsByZIndex_) {\n      var candidates = this.executorsByZIndex_[zIndex];\n\n      for (var i = 0, ii = executors.length; i < ii; ++i) {\n        if (executors[i] in candidates) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    var newContext = !this.hitDetectionContext_;\n\n    if (newContext) {\n      this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);\n    }\n\n    var context = this.hitDetectionContext_;\n\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else if (!newContext) {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n\n    var hitExtent;\n\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n\n    var indexes = getPixelIndexArray(hitTolerance);\n    var builderType;\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n\n    function featureCallback(feature, geometry) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n\n      for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {\n        if (imageData[indexes[i_1]] > 0) {\n          if (!declutteredFeatures || builderType !== BuilderType.IMAGE && builderType !== BuilderType.TEXT || declutteredFeatures.indexOf(feature) !== -1) {\n            var idx = (indexes[i_1] - 3) / 4;\n            var x = hitTolerance - idx % contextSize;\n            var y = hitTolerance - (idx / contextSize | 0);\n            var result_1 = callback(feature, geometry, x * x + y * y);\n\n            if (result_1) {\n              return result_1;\n            }\n          }\n\n          context.clearRect(0, 0, contextSize, contextSize);\n          break;\n        }\n      }\n\n      return undefined;\n    }\n    /** @type {Array<number>} */\n\n\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var i, j, executors, executor, result;\n\n    for (i = zs.length - 1; i >= 0; --i) {\n      var zIndexKey = zs[i].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        builderType = ORDER[j];\n        executor = executors[builderType];\n\n        if (executor !== undefined) {\n          result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n\n\n  ExecutorGroup.prototype.getClipCoords = function (transform) {\n    var maxExtent = this.maxExtent_;\n\n    if (!maxExtent) {\n      return null;\n    }\n\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  };\n  /**\n   * @return {boolean} Is empty.\n   */\n\n\n  ExecutorGroup.prototype.isEmpty = function () {\n    return isEmpty(this.executorsByZIndex_);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<import(\"./BuilderType.js\").default>} [opt_builderTypes] Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n   */\n\n\n  ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction); // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n\n    if (this.maxExtent_) {\n      context.save();\n      this.clip(context, transform);\n    }\n\n    var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;\n    var i, ii, j, jj, replays, replay;\n\n    if (opt_declutterTree) {\n      zs.reverse();\n    }\n\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n        var builderType = builderTypes[j];\n        replay = replays[builderType];\n\n        if (replay !== undefined) {\n          replay.execute(context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree);\n        }\n      }\n    }\n\n    if (this.maxExtent_) {\n      context.restore();\n    }\n  };\n\n  return ExecutorGroup;\n}();\n/**\n * This cache is used to store arrays of indexes for calculated pixel circles\n * to increase performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<number>>}\n */\n\n\nvar circlePixelIndexArrayCache = {};\n/**\n * This methods creates an array with indexes of all pixels within a circle,\n * ordered by how close they are to the center.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @return {Array<number>} An array with indexes within a circle.\n */\n\nexport function getPixelIndexArray(radius) {\n  if (circlePixelIndexArrayCache[radius] !== undefined) {\n    return circlePixelIndexArrayCache[radius];\n  }\n\n  var size = radius * 2 + 1;\n  var maxDistanceSq = radius * radius;\n  var distances = new Array(maxDistanceSq + 1);\n\n  for (var i = 0; i <= radius; ++i) {\n    for (var j = 0; j <= radius; ++j) {\n      var distanceSq = i * i + j * j;\n\n      if (distanceSq > maxDistanceSq) {\n        break;\n      }\n\n      var distance = distances[distanceSq];\n\n      if (!distance) {\n        distance = [];\n        distances[distanceSq] = distance;\n      }\n\n      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\n\n      if (i > 0) {\n        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\n      }\n\n      if (j > 0) {\n        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\n\n        if (i > 0) {\n          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\n        }\n      }\n    }\n  }\n\n  var pixelIndex = [];\n\n  for (var i = 0, ii = distances.length; i < ii; ++i) {\n    if (distances[i]) {\n      pixelIndex.push.apply(pixelIndex, distances[i]);\n    }\n  }\n\n  circlePixelIndexArrayCache[radius] = pixelIndex;\n  return pixelIndex;\n}\nexport default ExecutorGroup;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/render/canvas/ExecutorGroup.js"],"names":["BuilderType","Executor","buffer","createEmpty","extendCoordinate","compose","composeTransform","create","createTransform","createCanvasContext2D","isEmpty","numberSafeCompareFunction","transform2D","ORDER","POLYGON","CIRCLE","LINE_STRING","IMAGE","TEXT","DEFAULT","ExecutorGroup","maxExtent","resolution","pixelRatio","overlaps","allInstructions","opt_renderBuffer","maxExtent_","overlaps_","pixelRatio_","resolution_","renderBuffer_","executorsByZIndex_","hitDetectionContext_","hitDetectionTransform_","createExecutors_","prototype","clip","context","transform","flatClipCoords","getClipCoords","beginPath","moveTo","lineTo","zIndex","executors","undefined","instructionByZindex","builderType","instructions","hasExecutors","candidates","i","ii","length","forEachFeatureAtCoordinate","coordinate","rotation","hitTolerance","callback","declutteredFeatures","Math","round","contextSize","newContext","canvas","width","height","clearRect","hitExtent","indexes","getPixelIndexArray","featureCallback","feature","geometry","imageData","getImageData","data","i_1","indexOf","idx","x","y","result_1","zs","Object","keys","map","Number","sort","j","executor","result","zIndexKey","toString","executeHitDetection","minX","minY","maxX","maxY","execute","contextScale","viewRotation","snapToPixel","opt_builderTypes","opt_declutterTree","save","builderTypes","jj","replays","replay","reverse","restore","circlePixelIndexArrayCache","radius","size","maxDistanceSq","distances","Array","distanceSq","distance","push","pixelIndex","apply"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,WAAP,MAAwB,kBAAxB;AACA,OAAOC,QAAP,MAAqB,eAArB;AACA,SAASC,MAAT,EAAiBC,WAAjB,EAA8BC,gBAA9B,QAAsD,iBAAtD;AACA,SAASC,OAAO,IAAIC,gBAApB,EAAsCC,MAAM,IAAIC,eAAhD,QAAwE,oBAAxE;AACA,SAASC,qBAAT,QAAsC,cAAtC;AACA,SAASC,OAAT,QAAwB,cAAxB;AACA,SAASC,yBAAT,QAA0C,gBAA1C;AACA,SAASC,WAAT,QAA4B,8BAA5B;AACA;AACA;AACA;AACA;;AACA,IAAIC,KAAK,GAAG,CACRb,WAAW,CAACc,OADJ,EAERd,WAAW,CAACe,MAFJ,EAGRf,WAAW,CAACgB,WAHJ,EAIRhB,WAAW,CAACiB,KAJJ,EAKRjB,WAAW,CAACkB,IALJ,EAMRlB,WAAW,CAACmB,OANJ,CAAZ;;AAQA,IAAIC,aAAa,GAAkB,YAAY;AAC3C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,WAASA,aAAT,CAAuBC,SAAvB,EAAkCC,UAAlC,EAA8CC,UAA9C,EAA0DC,QAA1D,EAAoEC,eAApE,EAAqFC,gBAArF,EAAuG;AACnG;AACR;AACA;AACA;AACQ,SAAKC,UAAL,GAAkBN,SAAlB;AACA;AACR;AACA;AACA;;AACQ,SAAKO,SAAL,GAAiBJ,QAAjB;AACA;AACR;AACA;AACA;;AACQ,SAAKK,WAAL,GAAmBN,UAAnB;AACA;AACR;AACA;AACA;;AACQ,SAAKO,WAAL,GAAmBR,UAAnB;AACA;AACR;AACA;AACA;;AACQ,SAAKS,aAAL,GAAqBL,gBAArB;AACA;AACR;AACA;AACA;;AACQ,SAAKM,kBAAL,GAA0B,EAA1B;AACA;AACR;AACA;AACA;;AACQ,SAAKC,oBAAL,GAA4B,IAA5B;AACA;AACR;AACA;AACA;;AACQ,SAAKC,sBAAL,GAA8B1B,eAAe,EAA7C;AACA,SAAK2B,gBAAL,CAAsBV,eAAtB;AACH;AACD;AACJ;AACA;AACA;;;AACIL,EAAAA,aAAa,CAACgB,SAAd,CAAwBC,IAAxB,GAA+B,UAAUC,OAAV,EAAmBC,SAAnB,EAA8B;AACzD,QAAIC,cAAc,GAAG,KAAKC,aAAL,CAAmBF,SAAnB,CAArB;AACAD,IAAAA,OAAO,CAACI,SAAR;AACAJ,IAAAA,OAAO,CAACK,MAAR,CAAeH,cAAc,CAAC,CAAD,CAA7B,EAAkCA,cAAc,CAAC,CAAD,CAAhD;AACAF,IAAAA,OAAO,CAACM,MAAR,CAAeJ,cAAc,CAAC,CAAD,CAA7B,EAAkCA,cAAc,CAAC,CAAD,CAAhD;AACAF,IAAAA,OAAO,CAACM,MAAR,CAAeJ,cAAc,CAAC,CAAD,CAA7B,EAAkCA,cAAc,CAAC,CAAD,CAAhD;AACAF,IAAAA,OAAO,CAACM,MAAR,CAAeJ,cAAc,CAAC,CAAD,CAA7B,EAAkCA,cAAc,CAAC,CAAD,CAAhD;AACAF,IAAAA,OAAO,CAACD,IAAR;AACH,GARD;AASA;AACJ;AACA;AACA;AACA;;;AACIjB,EAAAA,aAAa,CAACgB,SAAd,CAAwBD,gBAAxB,GAA2C,UAAUV,eAAV,EAA2B;AAClE,SAAK,IAAIoB,MAAT,IAAmBpB,eAAnB,EAAoC;AAChC,UAAIqB,SAAS,GAAG,KAAKd,kBAAL,CAAwBa,MAAxB,CAAhB;;AACA,UAAIC,SAAS,KAAKC,SAAlB,EAA6B;AACzBD,QAAAA,SAAS,GAAG,EAAZ;AACA,aAAKd,kBAAL,CAAwBa,MAAxB,IAAkCC,SAAlC;AACH;;AACD,UAAIE,mBAAmB,GAAGvB,eAAe,CAACoB,MAAD,CAAzC;;AACA,WAAK,IAAII,WAAT,IAAwBD,mBAAxB,EAA6C;AACzC,YAAIE,YAAY,GAAGF,mBAAmB,CAACC,WAAD,CAAtC;AACAH,QAAAA,SAAS,CAACG,WAAD,CAAT,GAAyB,IAAIhD,QAAJ,CAAa,KAAK6B,WAAlB,EAA+B,KAAKD,WAApC,EAAiD,KAAKD,SAAtD,EAAiEsB,YAAjE,CAAzB;AACH;AACJ;AACJ,GAbD;AAcA;AACJ;AACA;AACA;;;AACI9B,EAAAA,aAAa,CAACgB,SAAd,CAAwBe,YAAxB,GAAuC,UAAUL,SAAV,EAAqB;AACxD,SAAK,IAAID,MAAT,IAAmB,KAAKb,kBAAxB,EAA4C;AACxC,UAAIoB,UAAU,GAAG,KAAKpB,kBAAL,CAAwBa,MAAxB,CAAjB;;AACA,WAAK,IAAIQ,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGR,SAAS,CAACS,MAA/B,EAAuCF,CAAC,GAAGC,EAA3C,EAA+C,EAAED,CAAjD,EAAoD;AAChD,YAAIP,SAAS,CAACO,CAAD,CAAT,IAAgBD,UAApB,EAAgC;AAC5B,iBAAO,IAAP;AACH;AACJ;AACJ;;AACD,WAAO,KAAP;AACH,GAVD;AAWA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIhC,EAAAA,aAAa,CAACgB,SAAd,CAAwBoB,0BAAxB,GAAqD,UAAUC,UAAV,EAAsBnC,UAAtB,EAAkCoC,QAAlC,EAA4CC,YAA5C,EAA0DC,QAA1D,EAAoEC,mBAApE,EAAyF;AAC1IF,IAAAA,YAAY,GAAGG,IAAI,CAACC,KAAL,CAAWJ,YAAX,CAAf;AACA,QAAIK,WAAW,GAAGL,YAAY,GAAG,CAAf,GAAmB,CAArC;AACA,QAAIpB,SAAS,GAAGjC,gBAAgB,CAAC,KAAK4B,sBAAN,EAA8ByB,YAAY,GAAG,GAA7C,EAAkDA,YAAY,GAAG,GAAjE,EAAsE,IAAIrC,UAA1E,EAAsF,CAAC,CAAD,GAAKA,UAA3F,EAAuG,CAACoC,QAAxG,EAAkH,CAACD,UAAU,CAAC,CAAD,CAA7H,EAAkI,CAACA,UAAU,CAAC,CAAD,CAA7I,CAAhC;AACA,QAAIQ,UAAU,GAAG,CAAC,KAAKhC,oBAAvB;;AACA,QAAIgC,UAAJ,EAAgB;AACZ,WAAKhC,oBAAL,GAA4BxB,qBAAqB,CAACuD,WAAD,EAAcA,WAAd,CAAjD;AACH;;AACD,QAAI1B,OAAO,GAAG,KAAKL,oBAAnB;;AACA,QAAIK,OAAO,CAAC4B,MAAR,CAAeC,KAAf,KAAyBH,WAAzB,IACA1B,OAAO,CAAC4B,MAAR,CAAeE,MAAf,KAA0BJ,WAD9B,EAC2C;AACvC1B,MAAAA,OAAO,CAAC4B,MAAR,CAAeC,KAAf,GAAuBH,WAAvB;AACA1B,MAAAA,OAAO,CAAC4B,MAAR,CAAeE,MAAf,GAAwBJ,WAAxB;AACH,KAJD,MAKK,IAAI,CAACC,UAAL,EAAiB;AAClB3B,MAAAA,OAAO,CAAC+B,SAAR,CAAkB,CAAlB,EAAqB,CAArB,EAAwBL,WAAxB,EAAqCA,WAArC;AACH;AACD;AACR;AACA;;;AACQ,QAAIM,SAAJ;;AACA,QAAI,KAAKvC,aAAL,KAAuBgB,SAA3B,EAAsC;AAClCuB,MAAAA,SAAS,GAAGnE,WAAW,EAAvB;AACAC,MAAAA,gBAAgB,CAACkE,SAAD,EAAYb,UAAZ,CAAhB;AACAvD,MAAAA,MAAM,CAACoE,SAAD,EAAYhD,UAAU,IAAI,KAAKS,aAAL,GAAqB4B,YAAzB,CAAtB,EAA8DW,SAA9D,CAAN;AACH;;AACD,QAAIC,OAAO,GAAGC,kBAAkB,CAACb,YAAD,CAAhC;AACA,QAAIV,WAAJ;AACA;AACR;AACA;AACA;AACA;;AACQ,aAASwB,eAAT,CAAyBC,OAAzB,EAAkCC,QAAlC,EAA4C;AACxC,UAAIC,SAAS,GAAGtC,OAAO,CAACuC,YAAR,CAAqB,CAArB,EAAwB,CAAxB,EAA2Bb,WAA3B,EAAwCA,WAAxC,EAAqDc,IAArE;;AACA,WAAK,IAAIC,GAAG,GAAG,CAAV,EAAazB,EAAE,GAAGiB,OAAO,CAAChB,MAA/B,EAAuCwB,GAAG,GAAGzB,EAA7C,EAAiDyB,GAAG,EAApD,EAAwD;AACpD,YAAIH,SAAS,CAACL,OAAO,CAACQ,GAAD,CAAR,CAAT,GAA0B,CAA9B,EAAiC;AAC7B,cAAI,CAAClB,mBAAD,IACCZ,WAAW,KAAKjD,WAAW,CAACiB,KAA5B,IACGgC,WAAW,KAAKjD,WAAW,CAACkB,IAFhC,IAGA2C,mBAAmB,CAACmB,OAApB,CAA4BN,OAA5B,MAAyC,CAAC,CAH9C,EAGiD;AAC7C,gBAAIO,GAAG,GAAG,CAACV,OAAO,CAACQ,GAAD,CAAP,GAAe,CAAhB,IAAqB,CAA/B;AACA,gBAAIG,CAAC,GAAGvB,YAAY,GAAIsB,GAAG,GAAGjB,WAA9B;AACA,gBAAImB,CAAC,GAAGxB,YAAY,IAAKsB,GAAG,GAAGjB,WAAP,GAAsB,CAA1B,CAApB;AACA,gBAAIoB,QAAQ,GAAGxB,QAAQ,CAACc,OAAD,EAAUC,QAAV,EAAoBO,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAhC,CAAvB;;AACA,gBAAIC,QAAJ,EAAc;AACV,qBAAOA,QAAP;AACH;AACJ;;AACD9C,UAAAA,OAAO,CAAC+B,SAAR,CAAkB,CAAlB,EAAqB,CAArB,EAAwBL,WAAxB,EAAqCA,WAArC;AACA;AACH;AACJ;;AACD,aAAOjB,SAAP;AACH;AACD;;;AACA,QAAIsC,EAAE,GAAGC,MAAM,CAACC,IAAP,CAAY,KAAKvD,kBAAjB,EAAqCwD,GAArC,CAAyCC,MAAzC,CAAT;AACAJ,IAAAA,EAAE,CAACK,IAAH,CAAQ/E,yBAAR;AACA,QAAI0C,CAAJ,EAAOsC,CAAP,EAAU7C,SAAV,EAAqB8C,QAArB,EAA+BC,MAA/B;;AACA,SAAKxC,CAAC,GAAGgC,EAAE,CAAC9B,MAAH,GAAY,CAArB,EAAwBF,CAAC,IAAI,CAA7B,EAAgC,EAAEA,CAAlC,EAAqC;AACjC,UAAIyC,SAAS,GAAGT,EAAE,CAAChC,CAAD,CAAF,CAAM0C,QAAN,EAAhB;AACAjD,MAAAA,SAAS,GAAG,KAAKd,kBAAL,CAAwB8D,SAAxB,CAAZ;;AACA,WAAKH,CAAC,GAAG9E,KAAK,CAAC0C,MAAN,GAAe,CAAxB,EAA2BoC,CAAC,IAAI,CAAhC,EAAmC,EAAEA,CAArC,EAAwC;AACpC1C,QAAAA,WAAW,GAAGpC,KAAK,CAAC8E,CAAD,CAAnB;AACAC,QAAAA,QAAQ,GAAG9C,SAAS,CAACG,WAAD,CAApB;;AACA,YAAI2C,QAAQ,KAAK7C,SAAjB,EAA4B;AACxB8C,UAAAA,MAAM,GAAGD,QAAQ,CAACI,mBAAT,CAA6B1D,OAA7B,EAAsCC,SAAtC,EAAiDmB,QAAjD,EAA2De,eAA3D,EAA4EH,SAA5E,CAAT;;AACA,cAAIuB,MAAJ,EAAY;AACR,mBAAOA,MAAP;AACH;AACJ;AACJ;AACJ;;AACD,WAAO9C,SAAP;AACH,GA1ED;AA2EA;AACJ;AACA;AACA;;;AACI3B,EAAAA,aAAa,CAACgB,SAAd,CAAwBK,aAAxB,GAAwC,UAAUF,SAAV,EAAqB;AACzD,QAAIlB,SAAS,GAAG,KAAKM,UAArB;;AACA,QAAI,CAACN,SAAL,EAAgB;AACZ,aAAO,IAAP;AACH;;AACD,QAAI4E,IAAI,GAAG5E,SAAS,CAAC,CAAD,CAApB;AACA,QAAI6E,IAAI,GAAG7E,SAAS,CAAC,CAAD,CAApB;AACA,QAAI8E,IAAI,GAAG9E,SAAS,CAAC,CAAD,CAApB;AACA,QAAI+E,IAAI,GAAG/E,SAAS,CAAC,CAAD,CAApB;AACA,QAAImB,cAAc,GAAG,CAACyD,IAAD,EAAOC,IAAP,EAAaD,IAAb,EAAmBG,IAAnB,EAAyBD,IAAzB,EAA+BC,IAA/B,EAAqCD,IAArC,EAA2CD,IAA3C,CAArB;AACAtF,IAAAA,WAAW,CAAC4B,cAAD,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0BD,SAA1B,EAAqCC,cAArC,CAAX;AACA,WAAOA,cAAP;AACH,GAZD;AAaA;AACJ;AACA;;;AACIpB,EAAAA,aAAa,CAACgB,SAAd,CAAwB1B,OAAxB,GAAkC,YAAY;AAC1C,WAAOA,OAAO,CAAC,KAAKsB,kBAAN,CAAd;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIZ,EAAAA,aAAa,CAACgB,SAAd,CAAwBiE,OAAxB,GAAkC,UAAU/D,OAAV,EAAmBgE,YAAnB,EAAiC/D,SAAjC,EAA4CgE,YAA5C,EAA0DC,WAA1D,EAAuEC,gBAAvE,EAAyFC,iBAAzF,EAA4G;AAC1I;AACA,QAAIrB,EAAE,GAAGC,MAAM,CAACC,IAAP,CAAY,KAAKvD,kBAAjB,EAAqCwD,GAArC,CAAyCC,MAAzC,CAAT;AACAJ,IAAAA,EAAE,CAACK,IAAH,CAAQ/E,yBAAR,EAH0I,CAI1I;AACA;;AACA,QAAI,KAAKgB,UAAT,EAAqB;AACjBW,MAAAA,OAAO,CAACqE,IAAR;AACA,WAAKtE,IAAL,CAAUC,OAAV,EAAmBC,SAAnB;AACH;;AACD,QAAIqE,YAAY,GAAGH,gBAAgB,GAAGA,gBAAH,GAAsB5F,KAAzD;AACA,QAAIwC,CAAJ,EAAOC,EAAP,EAAWqC,CAAX,EAAckB,EAAd,EAAkBC,OAAlB,EAA2BC,MAA3B;;AACA,QAAIL,iBAAJ,EAAuB;AACnBrB,MAAAA,EAAE,CAAC2B,OAAH;AACH;;AACD,SAAK3D,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAG+B,EAAE,CAAC9B,MAApB,EAA4BF,CAAC,GAAGC,EAAhC,EAAoC,EAAED,CAAtC,EAAyC;AACrC,UAAIyC,SAAS,GAAGT,EAAE,CAAChC,CAAD,CAAF,CAAM0C,QAAN,EAAhB;AACAe,MAAAA,OAAO,GAAG,KAAK9E,kBAAL,CAAwB8D,SAAxB,CAAV;;AACA,WAAKH,CAAC,GAAG,CAAJ,EAAOkB,EAAE,GAAGD,YAAY,CAACrD,MAA9B,EAAsCoC,CAAC,GAAGkB,EAA1C,EAA8C,EAAElB,CAAhD,EAAmD;AAC/C,YAAI1C,WAAW,GAAG2D,YAAY,CAACjB,CAAD,CAA9B;AACAoB,QAAAA,MAAM,GAAGD,OAAO,CAAC7D,WAAD,CAAhB;;AACA,YAAI8D,MAAM,KAAKhE,SAAf,EAA0B;AACtBgE,UAAAA,MAAM,CAACV,OAAP,CAAe/D,OAAf,EAAwBgE,YAAxB,EAAsC/D,SAAtC,EAAiDgE,YAAjD,EAA+DC,WAA/D,EAA4EE,iBAA5E;AACH;AACJ;AACJ;;AACD,QAAI,KAAK/E,UAAT,EAAqB;AACjBW,MAAAA,OAAO,CAAC2E,OAAR;AACH;AACJ,GA7BD;;AA8BA,SAAO7F,aAAP;AACH,CA5PkC,EAAnC;AA6PA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAI8F,0BAA0B,GAAG,EAAjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS1C,kBAAT,CAA4B2C,MAA5B,EAAoC;AACvC,MAAID,0BAA0B,CAACC,MAAD,CAA1B,KAAuCpE,SAA3C,EAAsD;AAClD,WAAOmE,0BAA0B,CAACC,MAAD,CAAjC;AACH;;AACD,MAAIC,IAAI,GAAGD,MAAM,GAAG,CAAT,GAAa,CAAxB;AACA,MAAIE,aAAa,GAAGF,MAAM,GAAGA,MAA7B;AACA,MAAIG,SAAS,GAAG,IAAIC,KAAJ,CAAUF,aAAa,GAAG,CAA1B,CAAhB;;AACA,OAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI8D,MAArB,EAA6B,EAAE9D,CAA/B,EAAkC;AAC9B,SAAK,IAAIsC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIwB,MAArB,EAA6B,EAAExB,CAA/B,EAAkC;AAC9B,UAAI6B,UAAU,GAAGnE,CAAC,GAAGA,CAAJ,GAAQsC,CAAC,GAAGA,CAA7B;;AACA,UAAI6B,UAAU,GAAGH,aAAjB,EAAgC;AAC5B;AACH;;AACD,UAAII,QAAQ,GAAGH,SAAS,CAACE,UAAD,CAAxB;;AACA,UAAI,CAACC,QAAL,EAAe;AACXA,QAAAA,QAAQ,GAAG,EAAX;AACAH,QAAAA,SAAS,CAACE,UAAD,CAAT,GAAwBC,QAAxB;AACH;;AACDA,MAAAA,QAAQ,CAACC,IAAT,CAAc,CAAC,CAACP,MAAM,GAAG9D,CAAV,IAAe+D,IAAf,IAAuBD,MAAM,GAAGxB,CAAhC,CAAD,IAAuC,CAAvC,GAA2C,CAAzD;;AACA,UAAItC,CAAC,GAAG,CAAR,EAAW;AACPoE,QAAAA,QAAQ,CAACC,IAAT,CAAc,CAAC,CAACP,MAAM,GAAG9D,CAAV,IAAe+D,IAAf,IAAuBD,MAAM,GAAGxB,CAAhC,CAAD,IAAuC,CAAvC,GAA2C,CAAzD;AACH;;AACD,UAAIA,CAAC,GAAG,CAAR,EAAW;AACP8B,QAAAA,QAAQ,CAACC,IAAT,CAAc,CAAC,CAACP,MAAM,GAAG9D,CAAV,IAAe+D,IAAf,IAAuBD,MAAM,GAAGxB,CAAhC,CAAD,IAAuC,CAAvC,GAA2C,CAAzD;;AACA,YAAItC,CAAC,GAAG,CAAR,EAAW;AACPoE,UAAAA,QAAQ,CAACC,IAAT,CAAc,CAAC,CAACP,MAAM,GAAG9D,CAAV,IAAe+D,IAAf,IAAuBD,MAAM,GAAGxB,CAAhC,CAAD,IAAuC,CAAvC,GAA2C,CAAzD;AACH;AACJ;AACJ;AACJ;;AACD,MAAIgC,UAAU,GAAG,EAAjB;;AACA,OAAK,IAAItE,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGgE,SAAS,CAAC/D,MAA/B,EAAuCF,CAAC,GAAGC,EAA3C,EAA+C,EAAED,CAAjD,EAAoD;AAChD,QAAIiE,SAAS,CAACjE,CAAD,CAAb,EAAkB;AACdsE,MAAAA,UAAU,CAACD,IAAX,CAAgBE,KAAhB,CAAsBD,UAAtB,EAAkCL,SAAS,CAACjE,CAAD,CAA3C;AACH;AACJ;;AACD6D,EAAAA,0BAA0B,CAACC,MAAD,CAA1B,GAAqCQ,UAArC;AACA,SAAOA,UAAP;AACH;AACD,eAAevG,aAAf","sourcesContent":["/**\n * @module ol/render/canvas/ExecutorGroup\n */\nimport BuilderType from './BuilderType.js';\nimport Executor from './Executor.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { compose as composeTransform, create as createTransform, } from '../../transform.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { isEmpty } from '../../obj.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @const\n * @type {Array<import(\"./BuilderType.js\").default>}\n */\nvar ORDER = [\n    BuilderType.POLYGON,\n    BuilderType.CIRCLE,\n    BuilderType.LINE_STRING,\n    BuilderType.IMAGE,\n    BuilderType.TEXT,\n    BuilderType.DEFAULT,\n];\nvar ExecutorGroup = /** @class */ (function () {\n    /**\n     * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n     * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\n     * should be set here, unless the target context does not exceed that extent (which\n     * can be the case when rendering to tiles).\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {boolean} overlaps The executor group can have overlapping geometries.\n     * @param {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\n     * The serializable instructions.\n     * @param {number} [opt_renderBuffer] Optional rendering buffer.\n     */\n    function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        this.maxExtent_ = maxExtent;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this.overlaps_ = overlaps;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.resolution_ = resolution;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        this.renderBuffer_ = opt_renderBuffer;\n        /**\n         * @private\n         * @type {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Executor\").default>>}\n         */\n        this.executorsByZIndex_ = {};\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n        this.hitDetectionContext_ = null;\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n        this.hitDetectionTransform_ = createTransform();\n        this.createExecutors_(allInstructions);\n    }\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     */\n    ExecutorGroup.prototype.clip = function (context, transform) {\n        var flatClipCoords = this.getClipCoords(transform);\n        context.beginPath();\n        context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n        context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n        context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n        context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n        context.clip();\n    };\n    /**\n     * Create executors and populate them using the provided instructions.\n     * @private\n     * @param {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\n     */\n    ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {\n        for (var zIndex in allInstructions) {\n            var executors = this.executorsByZIndex_[zIndex];\n            if (executors === undefined) {\n                executors = {};\n                this.executorsByZIndex_[zIndex] = executors;\n            }\n            var instructionByZindex = allInstructions[zIndex];\n            for (var builderType in instructionByZindex) {\n                var instructions = instructionByZindex[builderType];\n                executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);\n            }\n        }\n    };\n    /**\n     * @param {Array<import(\"./BuilderType.js\").default>} executors Executors.\n     * @return {boolean} Has executors of the provided types.\n     */\n    ExecutorGroup.prototype.hasExecutors = function (executors) {\n        for (var zIndex in this.executorsByZIndex_) {\n            var candidates = this.executorsByZIndex_[zIndex];\n            for (var i = 0, ii = executors.length; i < ii; ++i) {\n                if (executors[i] in candidates) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {number} rotation Rotation.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\n     * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n        hitTolerance = Math.round(hitTolerance);\n        var contextSize = hitTolerance * 2 + 1;\n        var transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n        var newContext = !this.hitDetectionContext_;\n        if (newContext) {\n            this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);\n        }\n        var context = this.hitDetectionContext_;\n        if (context.canvas.width !== contextSize ||\n            context.canvas.height !== contextSize) {\n            context.canvas.width = contextSize;\n            context.canvas.height = contextSize;\n        }\n        else if (!newContext) {\n            context.clearRect(0, 0, contextSize, contextSize);\n        }\n        /**\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        var hitExtent;\n        if (this.renderBuffer_ !== undefined) {\n            hitExtent = createEmpty();\n            extendCoordinate(hitExtent, coordinate);\n            buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n        }\n        var indexes = getPixelIndexArray(hitTolerance);\n        var builderType;\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n         * @return {T|undefined} Callback result.\n         */\n        function featureCallback(feature, geometry) {\n            var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n            for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {\n                if (imageData[indexes[i_1]] > 0) {\n                    if (!declutteredFeatures ||\n                        (builderType !== BuilderType.IMAGE &&\n                            builderType !== BuilderType.TEXT) ||\n                        declutteredFeatures.indexOf(feature) !== -1) {\n                        var idx = (indexes[i_1] - 3) / 4;\n                        var x = hitTolerance - (idx % contextSize);\n                        var y = hitTolerance - ((idx / contextSize) | 0);\n                        var result_1 = callback(feature, geometry, x * x + y * y);\n                        if (result_1) {\n                            return result_1;\n                        }\n                    }\n                    context.clearRect(0, 0, contextSize, contextSize);\n                    break;\n                }\n            }\n            return undefined;\n        }\n        /** @type {Array<number>} */\n        var zs = Object.keys(this.executorsByZIndex_).map(Number);\n        zs.sort(numberSafeCompareFunction);\n        var i, j, executors, executor, result;\n        for (i = zs.length - 1; i >= 0; --i) {\n            var zIndexKey = zs[i].toString();\n            executors = this.executorsByZIndex_[zIndexKey];\n            for (j = ORDER.length - 1; j >= 0; --j) {\n                builderType = ORDER[j];\n                executor = executors[builderType];\n                if (executor !== undefined) {\n                    result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n        }\n        return undefined;\n    };\n    /**\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @return {Array<number>} Clip coordinates.\n     */\n    ExecutorGroup.prototype.getClipCoords = function (transform) {\n        var maxExtent = this.maxExtent_;\n        if (!maxExtent) {\n            return null;\n        }\n        var minX = maxExtent[0];\n        var minY = maxExtent[1];\n        var maxX = maxExtent[2];\n        var maxY = maxExtent[3];\n        var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n        transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n        return flatClipCoords;\n    };\n    /**\n     * @return {boolean} Is empty.\n     */\n    ExecutorGroup.prototype.isEmpty = function () {\n        return isEmpty(this.executorsByZIndex_);\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n     * @param {Array<import(\"./BuilderType.js\").default>} [opt_builderTypes] Ordered replay types to replay.\n     *     Default is {@link module:ol/render/replay~ORDER}\n     * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n     */\n    ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {\n        /** @type {Array<number>} */\n        var zs = Object.keys(this.executorsByZIndex_).map(Number);\n        zs.sort(numberSafeCompareFunction);\n        // setup clipping so that the parts of over-simplified geometries are not\n        // visible outside the current extent when panning\n        if (this.maxExtent_) {\n            context.save();\n            this.clip(context, transform);\n        }\n        var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;\n        var i, ii, j, jj, replays, replay;\n        if (opt_declutterTree) {\n            zs.reverse();\n        }\n        for (i = 0, ii = zs.length; i < ii; ++i) {\n            var zIndexKey = zs[i].toString();\n            replays = this.executorsByZIndex_[zIndexKey];\n            for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n                var builderType = builderTypes[j];\n                replay = replays[builderType];\n                if (replay !== undefined) {\n                    replay.execute(context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree);\n                }\n            }\n        }\n        if (this.maxExtent_) {\n            context.restore();\n        }\n    };\n    return ExecutorGroup;\n}());\n/**\n * This cache is used to store arrays of indexes for calculated pixel circles\n * to increase performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<number>>}\n */\nvar circlePixelIndexArrayCache = {};\n/**\n * This methods creates an array with indexes of all pixels within a circle,\n * ordered by how close they are to the center.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @return {Array<number>} An array with indexes within a circle.\n */\nexport function getPixelIndexArray(radius) {\n    if (circlePixelIndexArrayCache[radius] !== undefined) {\n        return circlePixelIndexArrayCache[radius];\n    }\n    var size = radius * 2 + 1;\n    var maxDistanceSq = radius * radius;\n    var distances = new Array(maxDistanceSq + 1);\n    for (var i = 0; i <= radius; ++i) {\n        for (var j = 0; j <= radius; ++j) {\n            var distanceSq = i * i + j * j;\n            if (distanceSq > maxDistanceSq) {\n                break;\n            }\n            var distance = distances[distanceSq];\n            if (!distance) {\n                distance = [];\n                distances[distanceSq] = distance;\n            }\n            distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\n            if (i > 0) {\n                distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\n            }\n            if (j > 0) {\n                distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\n                if (i > 0) {\n                    distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\n                }\n            }\n        }\n    }\n    var pixelIndex = [];\n    for (var i = 0, ii = distances.length; i < ii; ++i) {\n        if (distances[i]) {\n            pixelIndex.push.apply(pixelIndex, distances[i]);\n        }\n    }\n    circlePixelIndexArrayCache[radius] = pixelIndex;\n    return pixelIndex;\n}\nexport default ExecutorGroup;\n"]},"metadata":{},"sourceType":"module"}