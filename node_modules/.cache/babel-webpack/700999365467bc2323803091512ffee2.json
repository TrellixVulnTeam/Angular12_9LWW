{"ast":null,"code":"/**\n * @module ol/source/Cluster\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\nimport { add as addCoordinate, scale as scaleCoordinate } from '../coordinate.js';\nimport { assert } from '../asserts.js';\nimport { buffer, createEmpty, createOrUpdateFromCoordinate, getCenter } from '../extent.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Distance in pixels within which features will\n * be clustered together.\n * @property {number} [minDistance=0] Minimum distance in pixels between clusters.\n * Will be capped at the configured distance.\n * By default no minimum distance is guaranteed. This config can be used to avoid\n * overlapping icons. As a tradoff, the cluster feature's position will no longer be\n * the center of all its features.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underlying source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {function(Point, Array<Feature>):Feature} [createCluster]\n * Function that takes the cluster's center {@link module:ol/geom/Point} and an array\n * of {@link module:ol/Feature} included in this cluster. Must return a\n * {@link module:ol/Feature} that will be used to render. Default implementation is:\n * ```js\n * function(point, features) {\n *   return new Feature({\n *     geometry: point,\n *     features: features\n *   });\n * }\n * ```\n * @property {VectorSource} [source] Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n *\n * If the instance is disposed without also disposing the underlying\n * source `setSource(null)` has to be called to remove the listener reference\n * from the wrapped source.\n * @api\n */\n\nvar Cluster = function (_super) {\n  __extends(Cluster, _super);\n  /**\n   * @param {Options} options Cluster options.\n   */\n\n\n  function Cluster(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      wrapX: options.wrapX\n    }) || this;\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n\n\n    _this.resolution = undefined;\n    /**\n     * @type {number}\n     * @protected\n     */\n\n    _this.distance = options.distance !== undefined ? options.distance : 20;\n    /**\n     * @type {number}\n     * @protected\n     */\n\n    _this.minDistance = options.minDistance || 0;\n    /**\n     * @type {number}\n     * @protected\n     */\n\n    _this.interpolationRatio = 0;\n    /**\n     * @type {Array<Feature>}\n     * @protected\n     */\n\n    _this.features = [];\n    /**\n     * @param {Feature} feature Feature.\n     * @return {Point} Cluster calculation point.\n     * @protected\n     */\n\n    _this.geometryFunction = options.geometryFunction || function (feature) {\n      var geometry = feature.getGeometry();\n      assert(geometry.getType() == GeometryType.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries\n\n      return geometry;\n    };\n    /**\n     * @type {function(Point, Array<Feature>):Feature}\n     * @private\n     */\n\n\n    _this.createCustomCluster_ = options.createCluster;\n    /**\n     * @type {VectorSource}\n     * @protected\n     */\n\n    _this.source = null;\n    _this.boundRefresh_ = _this.refresh.bind(_this);\n\n    _this.updateDistance(_this.distance, _this.minDistance);\n\n    _this.setSource(options.source || null);\n\n    return _this;\n  }\n  /**\n   * Remove all features from the source.\n   * @param {boolean} [opt_fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.\n   * @api\n   */\n\n\n  Cluster.prototype.clear = function (opt_fast) {\n    this.features.length = 0;\n\n    _super.prototype.clear.call(this, opt_fast);\n  };\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n\n\n  Cluster.prototype.getDistance = function () {\n    return this.distance;\n  };\n  /**\n   * Get a reference to the wrapped source.\n   * @return {VectorSource} Source.\n   * @api\n   */\n\n\n  Cluster.prototype.getSource = function () {\n    return this.source;\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n\n\n  Cluster.prototype.loadFeatures = function (extent, resolution, projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n\n    if (resolution !== this.resolution) {\n      this.resolution = resolution;\n      this.refresh();\n    }\n  };\n  /**\n   * Set the distance within which features will be clusterd together.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n\n\n  Cluster.prototype.setDistance = function (distance) {\n    this.updateDistance(distance, this.minDistance);\n  };\n  /**\n   * Set the minimum distance between clusters. Will be capped at the\n   * configured distance.\n   * @param {number} minDistance The minimum distance in pixels.\n   * @api\n   */\n\n\n  Cluster.prototype.setMinDistance = function (minDistance) {\n    this.updateDistance(this.distance, minDistance);\n  };\n  /**\n   * The configured minimum distance between clusters.\n   * @return {number} The minimum distance in pixels.\n   * @api\n   */\n\n\n  Cluster.prototype.getMinDistance = function () {\n    return this.minDistance;\n  };\n  /**\n   * Replace the wrapped source.\n   * @param {VectorSource} source The new source for this instance.\n   * @api\n   */\n\n\n  Cluster.prototype.setSource = function (source) {\n    if (this.source) {\n      this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n\n    this.source = source;\n\n    if (source) {\n      source.addEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n\n    this.refresh();\n  };\n  /**\n   * Handle the source changing.\n   */\n\n\n  Cluster.prototype.refresh = function () {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  };\n  /**\n   * Update the distances and refresh the source if necessary.\n   * @param {number} distance The new distance.\n   * @param {number} minDistance The new minimum distance.\n   */\n\n\n  Cluster.prototype.updateDistance = function (distance, minDistance) {\n    var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;\n    var changed = distance !== this.distance || this.interpolationRatio !== ratio;\n    this.distance = distance;\n    this.minDistance = minDistance;\n    this.interpolationRatio = ratio;\n\n    if (changed) {\n      this.refresh();\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  Cluster.prototype.cluster = function () {\n    if (this.resolution === undefined || !this.source) {\n      return;\n    }\n\n    var extent = createEmpty();\n    var mapDistance = this.distance * this.resolution;\n    var features = this.source.getFeatures();\n    /** @type {Object<string, true>} */\n\n    var clustered = {};\n\n    for (var i = 0, ii = features.length; i < ii; i++) {\n      var feature = features[i];\n\n      if (!(getUid(feature) in clustered)) {\n        var geometry = this.geometryFunction(feature);\n\n        if (geometry) {\n          var coordinates = geometry.getCoordinates();\n          createOrUpdateFromCoordinate(coordinates, extent);\n          buffer(extent, mapDistance, extent);\n          var neighbors = this.source.getFeaturesInExtent(extent).filter(function (neighbor) {\n            var uid = getUid(neighbor);\n\n            if (uid in clustered) {\n              return false;\n            }\n\n            clustered[uid] = true;\n            return true;\n          });\n          this.features.push(this.createCluster(neighbors, extent));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Feature>} features Features\n   * @param {import(\"../extent.js\").Extent} extent The searched extent for these features.\n   * @return {Feature} The cluster feature.\n   * @protected\n   */\n\n\n  Cluster.prototype.createCluster = function (features, extent) {\n    var centroid = [0, 0];\n\n    for (var i = features.length - 1; i >= 0; --i) {\n      var geometry_1 = this.geometryFunction(features[i]);\n\n      if (geometry_1) {\n        addCoordinate(centroid, geometry_1.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n\n    scaleCoordinate(centroid, 1 / features.length);\n    var searchCenter = getCenter(extent);\n    var ratio = this.interpolationRatio;\n    var geometry = new Point([centroid[0] * (1 - ratio) + searchCenter[0] * ratio, centroid[1] * (1 - ratio) + searchCenter[1] * ratio]);\n\n    if (this.createCustomCluster_) {\n      return this.createCustomCluster_(geometry, features);\n    } else {\n      return new Feature({\n        geometry: geometry,\n        features: features\n      });\n    }\n  };\n\n  return Cluster;\n}(VectorSource);\n\nexport default Cluster;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/source/Cluster.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","EventType","Feature","GeometryType","Point","VectorSource","add","addCoordinate","scale","scaleCoordinate","assert","buffer","createEmpty","createOrUpdateFromCoordinate","getCenter","getUid","Cluster","_super","options","_this","attributions","wrapX","resolution","undefined","distance","minDistance","interpolationRatio","features","geometryFunction","feature","geometry","getGeometry","getType","POINT","createCustomCluster_","createCluster","source","boundRefresh_","refresh","bind","updateDistance","setSource","clear","opt_fast","length","getDistance","getSource","loadFeatures","extent","projection","setDistance","setMinDistance","getMinDistance","removeEventListener","CHANGE","addEventListener","cluster","addFeatures","ratio","Math","min","changed","mapDistance","getFeatures","clustered","i","ii","coordinates","getCoordinates","neighbors","getFeaturesInExtent","filter","neighbor","uid","push","centroid","geometry_1","splice","searchCenter"],"mappings":"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","sourcesContent":["/**\n * @module ol/source/Cluster\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\nimport { add as addCoordinate, scale as scaleCoordinate } from '../coordinate.js';\nimport { assert } from '../asserts.js';\nimport { buffer, createEmpty, createOrUpdateFromCoordinate, getCenter, } from '../extent.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Distance in pixels within which features will\n * be clustered together.\n * @property {number} [minDistance=0] Minimum distance in pixels between clusters.\n * Will be capped at the configured distance.\n * By default no minimum distance is guaranteed. This config can be used to avoid\n * overlapping icons. As a tradoff, the cluster feature's position will no longer be\n * the center of all its features.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underlying source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {function(Point, Array<Feature>):Feature} [createCluster]\n * Function that takes the cluster's center {@link module:ol/geom/Point} and an array\n * of {@link module:ol/Feature} included in this cluster. Must return a\n * {@link module:ol/Feature} that will be used to render. Default implementation is:\n * ```js\n * function(point, features) {\n *   return new Feature({\n *     geometry: point,\n *     features: features\n *   });\n * }\n * ```\n * @property {VectorSource} [source] Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n *\n * If the instance is disposed without also disposing the underlying\n * source `setSource(null)` has to be called to remove the listener reference\n * from the wrapped source.\n * @api\n */\nvar Cluster = /** @class */ (function (_super) {\n    __extends(Cluster, _super);\n    /**\n     * @param {Options} options Cluster options.\n     */\n    function Cluster(options) {\n        var _this = _super.call(this, {\n            attributions: options.attributions,\n            wrapX: options.wrapX,\n        }) || this;\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n        _this.resolution = undefined;\n        /**\n         * @type {number}\n         * @protected\n         */\n        _this.distance = options.distance !== undefined ? options.distance : 20;\n        /**\n         * @type {number}\n         * @protected\n         */\n        _this.minDistance = options.minDistance || 0;\n        /**\n         * @type {number}\n         * @protected\n         */\n        _this.interpolationRatio = 0;\n        /**\n         * @type {Array<Feature>}\n         * @protected\n         */\n        _this.features = [];\n        /**\n         * @param {Feature} feature Feature.\n         * @return {Point} Cluster calculation point.\n         * @protected\n         */\n        _this.geometryFunction =\n            options.geometryFunction ||\n                function (feature) {\n                    var geometry = feature.getGeometry();\n                    assert(geometry.getType() == GeometryType.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries\n                    return geometry;\n                };\n        /**\n         * @type {function(Point, Array<Feature>):Feature}\n         * @private\n         */\n        _this.createCustomCluster_ = options.createCluster;\n        /**\n         * @type {VectorSource}\n         * @protected\n         */\n        _this.source = null;\n        _this.boundRefresh_ = _this.refresh.bind(_this);\n        _this.updateDistance(_this.distance, _this.minDistance);\n        _this.setSource(options.source || null);\n        return _this;\n    }\n    /**\n     * Remove all features from the source.\n     * @param {boolean} [opt_fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.\n     * @api\n     */\n    Cluster.prototype.clear = function (opt_fast) {\n        this.features.length = 0;\n        _super.prototype.clear.call(this, opt_fast);\n    };\n    /**\n     * Get the distance in pixels between clusters.\n     * @return {number} Distance.\n     * @api\n     */\n    Cluster.prototype.getDistance = function () {\n        return this.distance;\n    };\n    /**\n     * Get a reference to the wrapped source.\n     * @return {VectorSource} Source.\n     * @api\n     */\n    Cluster.prototype.getSource = function () {\n        return this.source;\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    Cluster.prototype.loadFeatures = function (extent, resolution, projection) {\n        this.source.loadFeatures(extent, resolution, projection);\n        if (resolution !== this.resolution) {\n            this.resolution = resolution;\n            this.refresh();\n        }\n    };\n    /**\n     * Set the distance within which features will be clusterd together.\n     * @param {number} distance The distance in pixels.\n     * @api\n     */\n    Cluster.prototype.setDistance = function (distance) {\n        this.updateDistance(distance, this.minDistance);\n    };\n    /**\n     * Set the minimum distance between clusters. Will be capped at the\n     * configured distance.\n     * @param {number} minDistance The minimum distance in pixels.\n     * @api\n     */\n    Cluster.prototype.setMinDistance = function (minDistance) {\n        this.updateDistance(this.distance, minDistance);\n    };\n    /**\n     * The configured minimum distance between clusters.\n     * @return {number} The minimum distance in pixels.\n     * @api\n     */\n    Cluster.prototype.getMinDistance = function () {\n        return this.minDistance;\n    };\n    /**\n     * Replace the wrapped source.\n     * @param {VectorSource} source The new source for this instance.\n     * @api\n     */\n    Cluster.prototype.setSource = function (source) {\n        if (this.source) {\n            this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);\n        }\n        this.source = source;\n        if (source) {\n            source.addEventListener(EventType.CHANGE, this.boundRefresh_);\n        }\n        this.refresh();\n    };\n    /**\n     * Handle the source changing.\n     */\n    Cluster.prototype.refresh = function () {\n        this.clear();\n        this.cluster();\n        this.addFeatures(this.features);\n    };\n    /**\n     * Update the distances and refresh the source if necessary.\n     * @param {number} distance The new distance.\n     * @param {number} minDistance The new minimum distance.\n     */\n    Cluster.prototype.updateDistance = function (distance, minDistance) {\n        var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;\n        var changed = distance !== this.distance || this.interpolationRatio !== ratio;\n        this.distance = distance;\n        this.minDistance = minDistance;\n        this.interpolationRatio = ratio;\n        if (changed) {\n            this.refresh();\n        }\n    };\n    /**\n     * @protected\n     */\n    Cluster.prototype.cluster = function () {\n        if (this.resolution === undefined || !this.source) {\n            return;\n        }\n        var extent = createEmpty();\n        var mapDistance = this.distance * this.resolution;\n        var features = this.source.getFeatures();\n        /** @type {Object<string, true>} */\n        var clustered = {};\n        for (var i = 0, ii = features.length; i < ii; i++) {\n            var feature = features[i];\n            if (!(getUid(feature) in clustered)) {\n                var geometry = this.geometryFunction(feature);\n                if (geometry) {\n                    var coordinates = geometry.getCoordinates();\n                    createOrUpdateFromCoordinate(coordinates, extent);\n                    buffer(extent, mapDistance, extent);\n                    var neighbors = this.source\n                        .getFeaturesInExtent(extent)\n                        .filter(function (neighbor) {\n                        var uid = getUid(neighbor);\n                        if (uid in clustered) {\n                            return false;\n                        }\n                        clustered[uid] = true;\n                        return true;\n                    });\n                    this.features.push(this.createCluster(neighbors, extent));\n                }\n            }\n        }\n    };\n    /**\n     * @param {Array<Feature>} features Features\n     * @param {import(\"../extent.js\").Extent} extent The searched extent for these features.\n     * @return {Feature} The cluster feature.\n     * @protected\n     */\n    Cluster.prototype.createCluster = function (features, extent) {\n        var centroid = [0, 0];\n        for (var i = features.length - 1; i >= 0; --i) {\n            var geometry_1 = this.geometryFunction(features[i]);\n            if (geometry_1) {\n                addCoordinate(centroid, geometry_1.getCoordinates());\n            }\n            else {\n                features.splice(i, 1);\n            }\n        }\n        scaleCoordinate(centroid, 1 / features.length);\n        var searchCenter = getCenter(extent);\n        var ratio = this.interpolationRatio;\n        var geometry = new Point([\n            centroid[0] * (1 - ratio) + searchCenter[0] * ratio,\n            centroid[1] * (1 - ratio) + searchCenter[1] * ratio,\n        ]);\n        if (this.createCustomCluster_) {\n            return this.createCustomCluster_(geometry, features);\n        }\n        else {\n            return new Feature({\n                geometry: geometry,\n                features: features,\n            });\n        }\n    };\n    return Cluster;\n}(VectorSource));\nexport default Cluster;\n"]},"metadata":{},"sourceType":"module"}