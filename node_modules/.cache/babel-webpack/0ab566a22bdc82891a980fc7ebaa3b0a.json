{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Draw\n */\n\n\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, { fromCircle, makeRegular } from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { always, noModifierKeys, shiftKeyOnly } from '../events/condition.js';\nimport { boundingExtent, getBottomLeft, getBottomRight, getTopLeft, getTopRight } from '../extent.js';\nimport { createEditingStyle } from '../style/Style.js';\nimport { fromUserCoordinate, getUserProjection } from '../proj.js';\nimport { squaredDistance as squaredCoordinateDistance } from '../coordinate.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/GeometryType.js\").default} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n */\n\nvar Mode = {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  POLYGON: 'Polygon',\n  CIRCLE: 'Circle'\n};\n/**\n * @enum {string}\n */\n\nvar DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\n\nvar DrawEvent = function (_super) {\n  __extends(DrawEvent, _super);\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n\n\n  function DrawEvent(type, feature) {\n    var _this = _super.call(this, type) || this;\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n\n\n    _this.feature = feature;\n    return _this;\n  }\n\n  return DrawEvent;\n}(Event);\n\nexport { DrawEvent };\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\n\nvar Draw = function (_super) {\n  __extends(Draw, _super);\n  /**\n   * @param {Options} options Options.\n   */\n\n\n  function Draw(options) {\n    var _this = this;\n\n    var pointerOptions = options;\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    _this = _super.call(this, pointerOptions) || this;\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n\n    _this.on;\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n\n    _this.once;\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n\n    _this.un;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.shouldHandle_ = false;\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n\n    _this.downPx_ = null;\n    /**\n     * @type {?}\n     * @private\n     */\n\n    _this.downTimeout_;\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n\n    _this.lastDragTime_;\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n\n    _this.pointerType_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.freehand_ = false;\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource}\n     * @private\n     */\n\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>}\n     * @private\n     */\n\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n\n    _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/GeometryType.js\").default}\n     * @private\n     */\n\n    _this.type_ = options.type;\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n\n    _this.mode_ = getMode(_this.type_);\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n\n    _this.stopClick_ = !!options.stopClick;\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n\n    _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Mode.POLYGON ? 3 : 2;\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n\n    _this.maxPoints_ = _this.mode_ === Mode.CIRCLE ? 2 : options.maxPoints ? options.maxPoints : Infinity;\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n\n    _this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;\n    var geometryFunction = options.geometryFunction;\n\n    if (!geometryFunction) {\n      var mode_1 = _this.mode_;\n\n      if (mode_1 === Mode.CIRCLE) {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          var circle = geometry ? geometry : new Circle([NaN, NaN]);\n          var center = fromUserCoordinate(coordinates[0], projection);\n          var squaredLength = squaredCoordinateDistance(center, fromUserCoordinate(coordinates[coordinates.length - 1], projection));\n          circle.setCenterAndRadius(center, Math.sqrt(squaredLength));\n          var userProjection = getUserProjection();\n\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n\n          return circle;\n        };\n      } else {\n        var Constructor_1;\n\n        if (mode_1 === Mode.POINT) {\n          Constructor_1 = Point;\n        } else if (mode_1 === Mode.LINE_STRING) {\n          Constructor_1 = LineString;\n        } else if (mode_1 === Mode.POLYGON) {\n          Constructor_1 = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n\n\n        geometryFunction = function (coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode_1 === Mode.POLYGON) {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);\n              } else {\n                geometry.setCoordinates([]);\n              }\n            } else {\n              geometry.setCoordinates(coordinates);\n            }\n          } else {\n            geometry = new Constructor_1(coordinates);\n          }\n\n          return geometry;\n        };\n      }\n    }\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n\n\n    _this.geometryFunction_ = geometryFunction;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    _this.finishCoordinate_ = null;\n    /**\n     * Sketch feature.\n     * @type {Feature}\n     * @private\n     */\n\n    _this.sketchFeature_ = null;\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n\n    _this.sketchPoint_ = null;\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n\n    _this.sketchCoords_ = null;\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n\n    _this.sketchLine_ = null;\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n\n    _this.sketchLineCoords_ = null;\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n\n    _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n\n    _this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true\n    });\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n\n    _this.geometryName_ = options.geometryName;\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n\n    _this.condition_ = options.condition ? options.condition : noModifierKeys;\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n\n    _this.freehandCondition_;\n\n    if (options.freehand) {\n      _this.freehandCondition_ = always;\n    } else {\n      _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;\n    }\n\n    _this.addChangeListener(InteractionProperty.ACTIVE, _this.updateState_);\n\n    return _this;\n  }\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n\n\n  Draw.prototype.setMap = function (map) {\n    _super.prototype.setMap.call(this, map);\n\n    this.updateState_();\n  };\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n\n\n  Draw.prototype.getOverlay = function () {\n    return this.overlay_;\n  };\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n\n\n  Draw.prototype.handleEvent = function (event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n\n    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n    var move = event.type === MapBrowserEventType.POINTERMOVE;\n    var pass = true;\n\n    if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {\n      var now = Date.now();\n\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n\n    if (this.freehand_ && event.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (this.freehand_ && event.type === MapBrowserEventType.POINTERDOWN) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (event.originalEvent.pointerType === 'mouse' || event.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === undefined) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return _super.prototype.handleEvent.call(this, event) && pass;\n  };\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  Draw.prototype.handleDownEvent = function (event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n\n      return true;\n    } else if (this.condition_(event)) {\n      this.lastDragTime_ = Date.now();\n      this.downTimeout_ = setTimeout(function () {\n        this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));\n      }.bind(this), this.dragVertexDelay_);\n      this.downPx_ = event.pixel;\n      return true;\n    } else {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  Draw.prototype.handleUpEvent = function (event) {\n    var pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n\n      if (this.shouldHandle_) {\n        var startingToDraw = !this.finishCoordinate_;\n\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (!this.freehand_ && (!startingToDraw || this.mode_ === Mode.POINT)) {\n          if (this.atFinish_(event.pixel)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n\n    return pass;\n  };\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n\n\n  Draw.prototype.handlePointerMove_ = function (event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n\n    if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {\n      var downPx = this.downPx_;\n      var clickPx = event.pixel;\n      var dx = downPx[0] - clickPx[0];\n      var dy = downPx[1] - clickPx[1];\n      var squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;\n\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (this.finishCoordinate_) {\n      this.modifyDrawing_(event.coordinate);\n    } else {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n    }\n  };\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n\n\n  Draw.prototype.atFinish_ = function (pixel) {\n    var at = false;\n\n    if (this.sketchFeature_) {\n      var potentiallyDone = false;\n      var potentiallyFinishCoordinates = [this.finishCoordinate_];\n      var mode = this.mode_;\n\n      if (mode === Mode.POINT) {\n        at = true;\n      } else if (mode === Mode.CIRCLE) {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === Mode.LINE_STRING) {\n        potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === Mode.POLYGON) {\n        var sketchCoords = this.sketchCoords_;\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];\n      }\n\n      if (potentiallyDone) {\n        var map = this.getMap();\n\n        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          var finishCoordinate = potentiallyFinishCoordinates[i];\n          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          var dx = pixel[0] - finishPixel[0];\n          var dy = pixel[1] - finishPixel[1];\n          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n\n    return at;\n  };\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n\n\n  Draw.prototype.createOrUpdateSketchPoint_ = function (coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      var sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  };\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n\n\n  Draw.prototype.createOrUpdateCustomSketchLine_ = function (geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n\n    var ring = geometry.getLinearRing(0);\n    var sketchLineGeom = this.sketchLine_.getGeometry();\n\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n      sketchLineGeom.changed();\n    }\n  };\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n\n\n  Draw.prototype.startDrawing_ = function (start) {\n    var projection = this.getMap().getView().getProjection();\n    this.finishCoordinate_ = start;\n\n    if (this.mode_ === Mode.POINT) {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === Mode.POLYGON) {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n\n    var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);\n    this.sketchFeature_ = new Feature();\n\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n\n\n  Draw.prototype.modifyDrawing_ = function (coordinate) {\n    var map = this.getMap();\n    var geometry = this.sketchFeature_.getGeometry();\n    var projection = map.getView().getProjection();\n    var coordinates, last;\n\n    if (this.mode_ === Mode.POINT) {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates =\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0];\n      last = coordinates[coordinates.length - 1];\n\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(this.sketchCoords_, geometry, projection);\n\n    if (this.sketchPoint_) {\n      var sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n\n    if (geometry.getType() === GeometryType.POLYGON && this.mode_ !== Mode.POLYGON) {\n      this.createOrUpdateCustomSketchLine_(geometry);\n    } else if (this.sketchLineCoords_) {\n      var sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n\n    this.updateSketchFeatures_();\n  };\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @private\n   */\n\n\n  Draw.prototype.addToDrawing_ = function (coordinate) {\n    var geometry = this.sketchFeature_.getGeometry();\n    var projection = this.getMap().getView().getProjection();\n    var done;\n    var coordinates;\n    var mode = this.mode_;\n\n    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = this.sketchCoords_;\n\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === Mode.POLYGON) {\n      coordinates =\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0];\n\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n\n      coordinates.push(coordinate.slice());\n\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n\n    if (done) {\n      this.finishDrawing();\n    }\n  };\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n\n\n  Draw.prototype.removeLastPoint = function () {\n    if (!this.sketchFeature_) {\n      return;\n    }\n\n    var geometry = this.sketchFeature_.getGeometry();\n    var projection = this.getMap().getView().getProjection();\n    var coordinates;\n    var mode = this.mode_;\n\n    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n      coordinates = this.sketchCoords_;\n      coordinates.splice(-2, 1);\n\n      if (coordinates.length >= 2) {\n        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n        var finishCoordinate = this.finishCoordinate_.slice();\n        coordinates[coordinates.length - 1] = finishCoordinate;\n        this.createOrUpdateSketchPoint_(finishCoordinate);\n      }\n\n      this.geometryFunction_(coordinates, geometry, projection);\n\n      if (geometry.getType() === GeometryType.POLYGON && this.sketchLine_) {\n        this.createOrUpdateCustomSketchLine_(geometry);\n      }\n    } else if (mode === Mode.POLYGON) {\n      coordinates =\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0];\n      coordinates.splice(-2, 1);\n      var sketchLineGeom = this.sketchLine_.getGeometry();\n\n      if (coordinates.length >= 2) {\n        var finishCoordinate = coordinates[coordinates.length - 2].slice();\n        coordinates[coordinates.length - 1] = finishCoordinate;\n        this.createOrUpdateSketchPoint_(finishCoordinate);\n      }\n\n      sketchLineGeom.setCoordinates(coordinates);\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n\n    if (coordinates.length === 1) {\n      this.abortDrawing();\n    }\n\n    this.updateSketchFeatures_();\n  };\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @api\n   */\n\n\n  Draw.prototype.finishDrawing = function () {\n    var sketchFeature = this.abortDrawing_();\n\n    if (!sketchFeature) {\n      return;\n    }\n\n    var coordinates = this.sketchCoords_;\n    var geometry = sketchFeature.getGeometry();\n    var projection = this.getMap().getView().getProjection();\n\n    if (this.mode_ === Mode.LINE_STRING) {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === Mode.POLYGON) {\n      // remove the redundant last point in ring\n\n      /** @type {PolyCoordType} */\n      coordinates[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    } // cast multi-part geometries\n\n\n    if (this.type_ === GeometryType.MULTI_POINT) {\n      sketchFeature.setGeometry(new MultiPoint([\n        /** @type {PointCoordType} */\n      coordinates]));\n    } else if (this.type_ === GeometryType.MULTI_LINE_STRING) {\n      sketchFeature.setGeometry(new MultiLineString([\n        /** @type {LineCoordType} */\n      coordinates]));\n    } else if (this.type_ === GeometryType.MULTI_POLYGON) {\n      sketchFeature.setGeometry(new MultiPolygon([\n        /** @type {PolyCoordType} */\n      coordinates]));\n    } // First dispatch event to allow full set up of feature\n\n\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature)); // Then insert feature\n\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  };\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature} The sketch feature (or null if none).\n   * @private\n   */\n\n\n  Draw.prototype.abortDrawing_ = function () {\n    this.finishCoordinate_ = null;\n    var sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    return sketchFeature;\n  };\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n\n\n  Draw.prototype.abortDrawing = function () {\n    var sketchFeature = this.abortDrawing_();\n\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  };\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n\n\n  Draw.prototype.appendCoordinates = function (coordinates) {\n    var mode = this.mode_;\n    var newDrawing = !this.sketchFeature_;\n\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n\n\n    var sketchCoords;\n\n    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n      sketchCoords = this.sketchCoords_;\n    } else if (mode === Mode.POLYGON) {\n      sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ?\n      /** @type {PolyCoordType} */\n      this.sketchCoords_[0] : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    } // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n\n\n    sketchCoords.pop(); // Append coordinate list\n\n    for (var i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    var ending = coordinates[coordinates.length - 1]; // Duplicate last coordinate for sketch drawing (cursor position)\n\n    this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  };\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n\n\n  Draw.prototype.extend = function (feature) {\n    var geometry = feature.getGeometry();\n    var lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n\n\n  Draw.prototype.updateSketchFeatures_ = function () {\n    var sketchFeatures = [];\n\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n\n    var overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  };\n  /**\n   * @private\n   */\n\n\n  Draw.prototype.updateState_ = function () {\n    var map = this.getMap();\n    var active = this.getActive();\n\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n\n    this.overlay_.setMap(active ? map : null);\n  };\n\n  return Draw;\n}(PointerInteraction);\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\n\n\nfunction getDefaultStyleFunction() {\n  var styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * `import(\"../geom/Circle.js\").Circle` geometry.\n * @param {number} [opt_sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [opt_angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\n\n\nexport function createRegularPolygon(opt_sides, opt_angle) {\n  return function (coordinates, opt_geometry, projection) {\n    var center = fromUserCoordinate(\n    /** @type {LineCoordType} */\n    coordinates[0], projection);\n    var end = fromUserCoordinate(\n    /** @type {LineCoordType} */\n    coordinates[coordinates.length - 1], projection);\n    var radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    var geometry = opt_geometry ? opt_geometry : fromCircle(new Circle(center), opt_sides);\n    var angle = opt_angle;\n\n    if (!opt_angle && opt_angle !== 0) {\n      var x = end[0] - center[0];\n      var y = end[1] - center[1];\n      angle = Math.atan2(y, x);\n    }\n\n    makeRegular(geometry, center, radius, angle);\n    var userProjection = getUserProjection();\n\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n\n    return geometry;\n  };\n}\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\n\nexport function createBox() {\n  return function (coordinates, opt_geometry, projection) {\n    var extent = boundingExtent(\n    /** @type {LineCoordType} */\n    [coordinates[0], coordinates[coordinates.length - 1]].map(function (coordinate) {\n      return fromUserCoordinate(coordinate, projection);\n    }));\n    var boxCoordinates = [[getBottomLeft(extent), getBottomRight(extent), getTopRight(extent), getTopLeft(extent), getBottomLeft(extent)]];\n    var geometry = opt_geometry;\n\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n\n    var userProjection = getUserProjection();\n\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n\n    return geometry;\n  };\n}\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/GeometryType.js\").default} type Geometry type.\n * @return {Mode} Drawing mode.\n */\n\nfunction getMode(type) {\n  switch (type) {\n    case GeometryType.POINT:\n    case GeometryType.MULTI_POINT:\n      return Mode.POINT;\n\n    case GeometryType.LINE_STRING:\n    case GeometryType.MULTI_LINE_STRING:\n      return Mode.LINE_STRING;\n\n    case GeometryType.POLYGON:\n    case GeometryType.MULTI_POLYGON:\n      return Mode.POLYGON;\n\n    case GeometryType.CIRCLE:\n      return Mode.CIRCLE;\n\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/interaction/Draw.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","Circle","Event","EventType","Feature","GeometryType","InteractionProperty","LineString","MapBrowserEvent","MapBrowserEventType","MultiLineString","MultiPoint","MultiPolygon","Point","PointerInteraction","Polygon","fromCircle","makeRegular","VectorLayer","VectorSource","FALSE","TRUE","always","noModifierKeys","shiftKeyOnly","boundingExtent","getBottomLeft","getBottomRight","getTopLeft","getTopRight","createEditingStyle","fromUserCoordinate","getUserProjection","squaredDistance","squaredCoordinateDistance","Mode","POINT","LINE_STRING","POLYGON","CIRCLE","DrawEventType","DRAWSTART","DRAWEND","DRAWABORT","DrawEvent","_super","type","feature","_this","Draw","options","pointerOptions","stopDown","on","once","un","shouldHandle_","downPx_","downTimeout_","lastDragTime_","pointerType_","freehand_","source_","source","features_","features","snapTolerance_","snapTolerance","type_","mode_","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","Infinity","finishCondition_","finishCondition","geometryFunction","mode_1","coordinates","geometry","projection","circle","NaN","center","squaredLength","length","setCenterAndRadius","Math","sqrt","userProjection","transform","Constructor_1","setCoordinates","concat","geometryFunction_","dragVertexDelay_","dragVertexDelay","undefined","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","squaredClickTolerance_","clickTolerance","overlay_","useSpatialIndex","wrapX","style","getDefaultStyleFunction","updateWhileInteracting","geometryName_","geometryName","condition_","condition","freehandCondition_","freehand","freehandCondition","addChangeListener","ACTIVE","updateState_","setMap","map","getOverlay","handleEvent","event","originalEvent","CONTEXTMENU","preventDefault","move","POINTERMOVE","pass","POINTERDRAG","now","Date","pixel","clearTimeout","addToDrawing_","coordinate","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","handleDownEvent","startDrawing_","setTimeout","frameState","bind","handleUpEvent","startingToDraw","finishDrawing","atFinish_","abortDrawing","downPx","clickPx","dx","dy","modifyDrawing_","createOrUpdateSketchPoint_","slice","at","potentiallyDone","potentiallyFinishCoordinates","mode","sketchCoords","getMap","i","ii","finishCoordinate","finishPixel","getPixelFromCoordinate","updateSketchFeatures_","sketchPointGeom","getGeometry","createOrUpdateCustomSketchLine_","ring","getLinearRing","sketchLineGeom","getFlatCoordinates","getLayout","setGeometry","setFlatCoordinates","changed","start","getView","getProjection","setGeometryName","dispatchEvent","last","getType","done","pop","push","removeLastPoint","splice","sketchFeature","abortDrawing_","getCoordinates","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","addFeature","getSource","clear","appendCoordinates","newDrawing","shift","ending","extend","lineString","sketchFeatures","overlaySource","addFeatures","active","getActive","styles","resolution","createRegularPolygon","opt_sides","opt_angle","opt_geometry","end","radius","angle","x","y","atan2","createBox","extent","boxCoordinates","Error"],"mappings":"AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIC,MAAM,CAACK,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCR,CAArC,EAAwCK,CAAxC,CAAJ,EAAgDN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAFrG;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnB,QAAI,OAAOA,CAAP,KAAa,UAAb,IAA2BA,CAAC,KAAK,IAArC,EACI,MAAM,IAAIS,SAAJ,CAAc,yBAAyBC,MAAM,CAACV,CAAD,CAA/B,GAAqC,+BAAnD,CAAN;AACJF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASW,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBb,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACO,SAAF,GAAcN,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACY,MAAP,CAAcb,CAAd,CAAb,IAAiCW,EAAE,CAACL,SAAH,GAAeN,CAAC,CAACM,SAAjB,EAA4B,IAAIK,EAAJ,EAA7D,CAAd;AACH,GAND;AAOH,CAd2C,EAA5C;AAeA;AACA;AACA;;;AACA,OAAOG,MAAP,MAAmB,mBAAnB;AACA,OAAOC,KAAP,MAAkB,oBAAlB;AACA,OAAOC,SAAP,MAAsB,wBAAtB;AACA,OAAOC,OAAP,MAAoB,eAApB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,mBAAP,MAAgC,eAAhC;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,eAAP,MAA4B,uBAA5B;AACA,OAAOC,mBAAP,MAAgC,2BAAhC;AACA,OAAOC,eAAP,MAA4B,4BAA5B;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,kBAAP,MAA+B,cAA/B;AACA,OAAOC,OAAP,IAAkBC,UAAlB,EAA8BC,WAA9B,QAAiD,oBAAjD;AACA,OAAOC,WAAP,MAAwB,oBAAxB;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AACA,SAASC,KAAT,EAAgBC,IAAhB,QAA4B,iBAA5B;AACA,SAASC,MAAT,EAAiBC,cAAjB,EAAiCC,YAAjC,QAAqD,wBAArD;AACA,SAASC,cAAT,EAAyBC,aAAzB,EAAwCC,cAAxC,EAAwDC,UAAxD,EAAoEC,WAApE,QAAwF,cAAxF;AACA,SAASC,kBAAT,QAAmC,mBAAnC;AACA,SAASC,kBAAT,EAA6BC,iBAA7B,QAAsD,YAAtD;AACA,SAASC,eAAe,IAAIC,yBAA5B,QAA6D,kBAA7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,IAAI,GAAG;AACPC,EAAAA,KAAK,EAAE,OADA;AAEPC,EAAAA,WAAW,EAAE,YAFN;AAGPC,EAAAA,OAAO,EAAE,SAHF;AAIPC,EAAAA,MAAM,EAAE;AAJD,CAAX;AAMA;AACA;AACA;;AACA,I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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, { fromCircle, makeRegular } from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { always, noModifierKeys, shiftKeyOnly } from '../events/condition.js';\nimport { boundingExtent, getBottomLeft, getBottomRight, getTopLeft, getTopRight, } from '../extent.js';\nimport { createEditingStyle } from '../style/Style.js';\nimport { fromUserCoordinate, getUserProjection } from '../proj.js';\nimport { squaredDistance as squaredCoordinateDistance } from '../coordinate.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/GeometryType.js\").default} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n */\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n */\nvar Mode = {\n    POINT: 'Point',\n    LINE_STRING: 'LineString',\n    POLYGON: 'Polygon',\n    CIRCLE: 'Circle',\n};\n/**\n * @enum {string}\n */\nvar DrawEventType = {\n    /**\n     * Triggered upon feature draw start\n     * @event DrawEvent#drawstart\n     * @api\n     */\n    DRAWSTART: 'drawstart',\n    /**\n     * Triggered upon feature draw end\n     * @event DrawEvent#drawend\n     * @api\n     */\n    DRAWEND: 'drawend',\n    /**\n     * Triggered upon feature draw abortion\n     * @event DrawEvent#drawabort\n     * @api\n     */\n    DRAWABORT: 'drawabort',\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nvar DrawEvent = /** @class */ (function (_super) {\n    __extends(DrawEvent, _super);\n    /**\n     * @param {DrawEventType} type Type.\n     * @param {Feature} feature The feature drawn.\n     */\n    function DrawEvent(type, feature) {\n        var _this = _super.call(this, type) || this;\n        /**\n         * The feature being drawn.\n         * @type {Feature}\n         * @api\n         */\n        _this.feature = feature;\n        return _this;\n    }\n    return DrawEvent;\n}(Event));\nexport { DrawEvent };\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nvar Draw = /** @class */ (function (_super) {\n    __extends(Draw, _super);\n    /**\n     * @param {Options} options Options.\n     */\n    function Draw(options) {\n        var _this = this;\n        var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n        if (!pointerOptions.stopDown) {\n            pointerOptions.stopDown = FALSE;\n        }\n        _this = _super.call(this, pointerOptions) || this;\n        /***\n         * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.on;\n        /***\n         * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.once;\n        /***\n         * @type {DrawOnSignature<void>}\n         */\n        _this.un;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.shouldHandle_ = false;\n        /**\n         * @type {import(\"../pixel.js\").Pixel}\n         * @private\n         */\n        _this.downPx_ = null;\n        /**\n         * @type {?}\n         * @private\n         */\n        _this.downTimeout_;\n        /**\n         * @type {number|undefined}\n         * @private\n         */\n        _this.lastDragTime_;\n        /**\n         * Pointer type of the last pointermove event\n         * @type {string}\n         * @private\n         */\n        _this.pointerType_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.freehand_ = false;\n        /**\n         * Target source for drawn features.\n         * @type {VectorSource}\n         * @private\n         */\n        _this.source_ = options.source ? options.source : null;\n        /**\n         * Target collection for drawn features.\n         * @type {import(\"../Collection.js\").default<Feature>}\n         * @private\n         */\n        _this.features_ = options.features ? options.features : null;\n        /**\n         * Pixel distance for snapping.\n         * @type {number}\n         * @private\n         */\n        _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n        /**\n         * Geometry type.\n         * @type {import(\"../geom/GeometryType.js\").default}\n         * @private\n         */\n        _this.type_ = /** @type {import(\"../geom/GeometryType.js\").default} */ (options.type);\n        /**\n         * Drawing mode (derived from geometry type.\n         * @type {Mode}\n         * @private\n         */\n        _this.mode_ = getMode(_this.type_);\n        /**\n         * Stop click, singleclick, and doubleclick events from firing during drawing.\n         * Default is `false`.\n         * @type {boolean}\n         * @private\n         */\n        _this.stopClick_ = !!options.stopClick;\n        /**\n         * The number of points that must be drawn before a polygon ring or line\n         * string can be finished.  The default is 3 for polygon rings and 2 for\n         * line strings.\n         * @type {number}\n         * @private\n         */\n        _this.minPoints_ = options.minPoints\n            ? options.minPoints\n            : _this.mode_ === Mode.POLYGON\n                ? 3\n                : 2;\n        /**\n         * The number of points that can be drawn before a polygon ring or line string\n         * is finished. The default is no restriction.\n         * @type {number}\n         * @private\n         */\n        _this.maxPoints_ =\n            _this.mode_ === Mode.CIRCLE\n                ? 2\n                : options.maxPoints\n                    ? options.maxPoints\n                    : Infinity;\n        /**\n         * A function to decide if a potential finish coordinate is permissible\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.finishCondition_ = options.finishCondition\n            ? options.finishCondition\n            : TRUE;\n        var geometryFunction = options.geometryFunction;\n        if (!geometryFunction) {\n            var mode_1 = _this.mode_;\n            if (mode_1 === Mode.CIRCLE) {\n                /**\n                 * @param {!LineCoordType} coordinates The coordinates.\n                 * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n                 * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n                 * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n                 */\n                geometryFunction = function (coordinates, geometry, projection) {\n                    var circle = geometry\n                        ? /** @type {Circle} */ (geometry)\n                        : new Circle([NaN, NaN]);\n                    var center = fromUserCoordinate(coordinates[0], projection);\n                    var squaredLength = squaredCoordinateDistance(center, fromUserCoordinate(coordinates[coordinates.length - 1], projection));\n                    circle.setCenterAndRadius(center, Math.sqrt(squaredLength));\n                    var userProjection = getUserProjection();\n                    if (userProjection) {\n                        circle.transform(projection, userProjection);\n                    }\n                    return circle;\n                };\n            }\n            else {\n                var Constructor_1;\n                if (mode_1 === Mode.POINT) {\n                    Constructor_1 = Point;\n                }\n                else if (mode_1 === Mode.LINE_STRING) {\n                    Constructor_1 = LineString;\n                }\n                else if (mode_1 === Mode.POLYGON) {\n                    Constructor_1 = Polygon;\n                }\n                /**\n                 * @param {!LineCoordType} coordinates The coordinates.\n                 * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n                 * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n                 * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n                 */\n                geometryFunction = function (coordinates, geometry, projection) {\n                    if (geometry) {\n                        if (mode_1 === Mode.POLYGON) {\n                            if (coordinates[0].length) {\n                                // Add a closing coordinate to match the first\n                                geometry.setCoordinates([\n                                    coordinates[0].concat([coordinates[0][0]]),\n                                ]);\n                            }\n                            else {\n                                geometry.setCoordinates([]);\n                            }\n                        }\n                        else {\n                            geometry.setCoordinates(coordinates);\n                        }\n                    }\n                    else {\n                        geometry = new Constructor_1(coordinates);\n                    }\n                    return geometry;\n                };\n            }\n        }\n        /**\n         * @type {GeometryFunction}\n         * @private\n         */\n        _this.geometryFunction_ = geometryFunction;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.dragVertexDelay_ =\n            options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n        /**\n         * Finish coordinate for the feature (first point for polygons, last point for\n         * linestrings).\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.finishCoordinate_ = null;\n        /**\n         * Sketch feature.\n         * @type {Feature}\n         * @private\n         */\n        _this.sketchFeature_ = null;\n        /**\n         * Sketch point.\n         * @type {Feature<Point>}\n         * @private\n         */\n        _this.sketchPoint_ = null;\n        /**\n         * Sketch coordinates. Used when drawing a line or polygon.\n         * @type {SketchCoordType}\n         * @private\n         */\n        _this.sketchCoords_ = null;\n        /**\n         * Sketch line. Used when drawing polygon.\n         * @type {Feature<LineString>}\n         * @private\n         */\n        _this.sketchLine_ = null;\n        /**\n         * Sketch line coordinates. Used when drawing a polygon or circle.\n         * @type {LineCoordType}\n         * @private\n         */\n        _this.sketchLineCoords_ = null;\n        /**\n         * Squared tolerance for handling up events.  If the squared distance\n         * between a down and up event is greater than this tolerance, up events\n         * will not be handled.\n         * @type {number}\n         * @private\n         */\n        _this.squaredClickTolerance_ = options.clickTolerance\n            ? options.clickTolerance * options.clickTolerance\n            : 36;\n        /**\n         * Draw overlay where our sketch features are drawn.\n         * @type {VectorLayer}\n         * @private\n         */\n        _this.overlay_ = new VectorLayer({\n            source: new VectorSource({\n                useSpatialIndex: false,\n                wrapX: options.wrapX ? options.wrapX : false,\n            }),\n            style: options.style ? options.style : getDefaultStyleFunction(),\n            updateWhileInteracting: true,\n        });\n        /**\n         * Name of the geometry attribute for newly created features.\n         * @type {string|undefined}\n         * @private\n         */\n        _this.geometryName_ = options.geometryName;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.condition_ = options.condition ? options.condition : noModifierKeys;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.freehandCondition_;\n        if (options.freehand) {\n            _this.freehandCondition_ = always;\n        }\n        else {\n            _this.freehandCondition_ = options.freehandCondition\n                ? options.freehandCondition\n                : shiftKeyOnly;\n        }\n        _this.addChangeListener(InteractionProperty.ACTIVE, _this.updateState_);\n        return _this;\n    }\n    /**\n     * Remove the interaction from its current map and attach it to the new map.\n     * Subclasses may set up event handlers to get notified about changes to\n     * the map here.\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     */\n    Draw.prototype.setMap = function (map) {\n        _super.prototype.setMap.call(this, map);\n        this.updateState_();\n    };\n    /**\n     * Get the overlay layer that this interaction renders sketch features to.\n     * @return {VectorLayer} Overlay layer.\n     * @api\n     */\n    Draw.prototype.getOverlay = function () {\n        return this.overlay_;\n    };\n    /**\n     * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @api\n     */\n    Draw.prototype.handleEvent = function (event) {\n        if (event.originalEvent.type === EventType.CONTEXTMENU) {\n            // Avoid context menu for long taps when drawing on mobile\n            event.originalEvent.preventDefault();\n        }\n        this.freehand_ =\n            this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n        var move = event.type === MapBrowserEventType.POINTERMOVE;\n        var pass = true;\n        if (!this.freehand_ &&\n            this.lastDragTime_ &&\n            event.type === MapBrowserEventType.POINTERDRAG) {\n            var now = Date.now();\n            if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n                this.downPx_ = event.pixel;\n                this.shouldHandle_ = !this.freehand_;\n                move = true;\n            }\n            else {\n                this.lastDragTime_ = undefined;\n            }\n            if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n                clearTimeout(this.downTimeout_);\n                this.downTimeout_ = undefined;\n            }\n        }\n        if (this.freehand_ &&\n            event.type === MapBrowserEventType.POINTERDRAG &&\n            this.sketchFeature_ !== null) {\n            this.addToDrawing_(event.coordinate);\n            pass = false;\n        }\n        else if (this.freehand_ &&\n            event.type === MapBrowserEventType.POINTERDOWN) {\n            pass = false;\n        }\n        else if (move && this.getPointerCount() < 2) {\n            pass = event.type === MapBrowserEventType.POINTERMOVE;\n            if (pass && this.freehand_) {\n                this.handlePointerMove_(event);\n                if (this.shouldHandle_) {\n                    // Avoid page scrolling when freehand drawing on mobile\n                    event.originalEvent.preventDefault();\n                }\n            }\n            else if (event.originalEvent.pointerType === 'mouse' ||\n                (event.type === MapBrowserEventType.POINTERDRAG &&\n                    this.downTimeout_ === undefined)) {\n                this.handlePointerMove_(event);\n            }\n        }\n        else if (event.type === MapBrowserEventType.DBLCLICK) {\n            pass = false;\n        }\n        return _super.prototype.handleEvent.call(this, event) && pass;\n    };\n    /**\n     * Handle pointer down events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Draw.prototype.handleDownEvent = function (event) {\n        this.shouldHandle_ = !this.freehand_;\n        if (this.freehand_) {\n            this.downPx_ = event.pixel;\n            if (!this.finishCoordinate_) {\n                this.startDrawing_(event.coordinate);\n            }\n            return true;\n        }\n        else if (this.condition_(event)) {\n            this.lastDragTime_ = Date.now();\n            this.downTimeout_ = setTimeout(function () {\n                this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));\n            }.bind(this), this.dragVertexDelay_);\n            this.downPx_ = event.pixel;\n            return true;\n        }\n        else {\n            this.lastDragTime_ = undefined;\n            return false;\n        }\n    };\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Draw.prototype.handleUpEvent = function (event) {\n        var pass = true;\n        if (this.getPointerCount() === 0) {\n            if (this.downTimeout_) {\n                clearTimeout(this.downTimeout_);\n                this.downTimeout_ = undefined;\n            }\n            this.handlePointerMove_(event);\n            if (this.shouldHandle_) {\n                var startingToDraw = !this.finishCoordinate_;\n                if (startingToDraw) {\n                    this.startDrawing_(event.coordinate);\n                }\n                if (!startingToDraw && this.freehand_) {\n                    this.finishDrawing();\n                }\n                else if (!this.freehand_ &&\n                    (!startingToDraw || this.mode_ === Mode.POINT)) {\n                    if (this.atFinish_(event.pixel)) {\n                        if (this.finishCondition_(event)) {\n                            this.finishDrawing();\n                        }\n                    }\n                    else {\n                        this.addToDrawing_(event.coordinate);\n                    }\n                }\n                pass = false;\n            }\n            else if (this.freehand_) {\n                this.abortDrawing();\n            }\n        }\n        if (!pass && this.stopClick_) {\n            event.preventDefault();\n        }\n        return pass;\n    };\n    /**\n     * Handle move events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n     * @private\n     */\n    Draw.prototype.handlePointerMove_ = function (event) {\n        this.pointerType_ = event.originalEvent.pointerType;\n        if (this.downPx_ &&\n            ((!this.freehand_ && this.shouldHandle_) ||\n                (this.freehand_ && !this.shouldHandle_))) {\n            var downPx = this.downPx_;\n            var clickPx = event.pixel;\n            var dx = downPx[0] - clickPx[0];\n            var dy = downPx[1] - clickPx[1];\n            var squaredDistance = dx * dx + dy * dy;\n            this.shouldHandle_ = this.freehand_\n                ? squaredDistance > this.squaredClickTolerance_\n                : squaredDistance <= this.squaredClickTolerance_;\n            if (!this.shouldHandle_) {\n                return;\n            }\n        }\n        if (this.finishCoordinate_) {\n            this.modifyDrawing_(event.coordinate);\n        }\n        else {\n            this.createOrUpdateSketchPoint_(event.coordinate.slice());\n        }\n    };\n    /**\n     * Determine if an event is within the snapping tolerance of the start coord.\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n     * @return {boolean} The event is within the snapping tolerance of the start.\n     * @private\n     */\n    Draw.prototype.atFinish_ = function (pixel) {\n        var at = false;\n        if (this.sketchFeature_) {\n            var potentiallyDone = false;\n            var potentiallyFinishCoordinates = [this.finishCoordinate_];\n            var mode = this.mode_;\n            if (mode === Mode.POINT) {\n                at = true;\n            }\n            else if (mode === Mode.CIRCLE) {\n                at = this.sketchCoords_.length === 2;\n            }\n            else if (mode === Mode.LINE_STRING) {\n                potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n            }\n            else if (mode === Mode.POLYGON) {\n                var sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n                potentiallyDone = sketchCoords[0].length > this.minPoints_;\n                potentiallyFinishCoordinates = [\n                    sketchCoords[0][0],\n                    sketchCoords[0][sketchCoords[0].length - 2],\n                ];\n            }\n            if (potentiallyDone) {\n                var map = this.getMap();\n                for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n                    var finishCoordinate = potentiallyFinishCoordinates[i];\n                    var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n                    var dx = pixel[0] - finishPixel[0];\n                    var dy = pixel[1] - finishPixel[1];\n                    var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n                    at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n                    if (at) {\n                        this.finishCoordinate_ = finishCoordinate;\n                        break;\n                    }\n                }\n            }\n        }\n        return at;\n    };\n    /**\n     * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n     * @private\n     */\n    Draw.prototype.createOrUpdateSketchPoint_ = function (coordinates) {\n        if (!this.sketchPoint_) {\n            this.sketchPoint_ = new Feature(new Point(coordinates));\n            this.updateSketchFeatures_();\n        }\n        else {\n            var sketchPointGeom = this.sketchPoint_.getGeometry();\n            sketchPointGeom.setCoordinates(coordinates);\n        }\n    };\n    /**\n     * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n     * @private\n     */\n    Draw.prototype.createOrUpdateCustomSketchLine_ = function (geometry) {\n        if (!this.sketchLine_) {\n            this.sketchLine_ = new Feature();\n        }\n        var ring = geometry.getLinearRing(0);\n        var sketchLineGeom = this.sketchLine_.getGeometry();\n        if (!sketchLineGeom) {\n            sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());\n            this.sketchLine_.setGeometry(sketchLineGeom);\n        }\n        else {\n            sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n            sketchLineGeom.changed();\n        }\n    };\n    /**\n     * Start the drawing.\n     * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n     * @private\n     */\n    Draw.prototype.startDrawing_ = function (start) {\n        var projection = this.getMap().getView().getProjection();\n        this.finishCoordinate_ = start;\n        if (this.mode_ === Mode.POINT) {\n            this.sketchCoords_ = start.slice();\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            this.sketchCoords_ = [[start.slice(), start.slice()]];\n            this.sketchLineCoords_ = this.sketchCoords_[0];\n        }\n        else {\n            this.sketchCoords_ = [start.slice(), start.slice()];\n        }\n        if (this.sketchLineCoords_) {\n            this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n        }\n        var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);\n        this.sketchFeature_ = new Feature();\n        if (this.geometryName_) {\n            this.sketchFeature_.setGeometryName(this.geometryName_);\n        }\n        this.sketchFeature_.setGeometry(geometry);\n        this.updateSketchFeatures_();\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n    };\n    /**\n     * Modify the drawing.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @private\n     */\n    Draw.prototype.modifyDrawing_ = function (coordinate) {\n        var map = this.getMap();\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = map.getView().getProjection();\n        var coordinates, last;\n        if (this.mode_ === Mode.POINT) {\n            last = this.sketchCoords_;\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            last = coordinates[coordinates.length - 1];\n            if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n                // snap to finish\n                coordinate = this.finishCoordinate_.slice();\n            }\n        }\n        else {\n            coordinates = this.sketchCoords_;\n            last = coordinates[coordinates.length - 1];\n        }\n        last[0] = coordinate[0];\n        last[1] = coordinate[1];\n        this.geometryFunction_(\n        /** @type {!LineCoordType} */ (this.sketchCoords_), geometry, projection);\n        if (this.sketchPoint_) {\n            var sketchPointGeom = this.sketchPoint_.getGeometry();\n            sketchPointGeom.setCoordinates(coordinate);\n        }\n        if (geometry.getType() === GeometryType.POLYGON &&\n            this.mode_ !== Mode.POLYGON) {\n            this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n        }\n        else if (this.sketchLineCoords_) {\n            var sketchLineGeom = this.sketchLine_.getGeometry();\n            sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n        }\n        this.updateSketchFeatures_();\n    };\n    /**\n     * Add a new coordinate to the drawing.\n     * @param {!PointCoordType} coordinate Coordinate\n     * @private\n     */\n    Draw.prototype.addToDrawing_ = function (coordinate) {\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        var done;\n        var coordinates;\n        var mode = this.mode_;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            this.finishCoordinate_ = coordinate.slice();\n            coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n            if (coordinates.length >= this.maxPoints_) {\n                if (this.freehand_) {\n                    coordinates.pop();\n                }\n                else {\n                    done = true;\n                }\n            }\n            coordinates.push(coordinate.slice());\n            this.geometryFunction_(coordinates, geometry, projection);\n        }\n        else if (mode === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            if (coordinates.length >= this.maxPoints_) {\n                if (this.freehand_) {\n                    coordinates.pop();\n                }\n                else {\n                    done = true;\n                }\n            }\n            coordinates.push(coordinate.slice());\n            if (done) {\n                this.finishCoordinate_ = coordinates[0];\n            }\n            this.geometryFunction_(this.sketchCoords_, geometry, projection);\n        }\n        this.createOrUpdateSketchPoint_(coordinate.slice());\n        this.updateSketchFeatures_();\n        if (done) {\n            this.finishDrawing();\n        }\n    };\n    /**\n     * Remove last point of the feature currently being drawn. Does not do anything when\n     * drawing POINT or MULTI_POINT geometries.\n     * @api\n     */\n    Draw.prototype.removeLastPoint = function () {\n        if (!this.sketchFeature_) {\n            return;\n        }\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        var coordinates;\n        var mode = this.mode_;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n            coordinates.splice(-2, 1);\n            if (coordinates.length >= 2) {\n                this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n                var finishCoordinate = this.finishCoordinate_.slice();\n                coordinates[coordinates.length - 1] = finishCoordinate;\n                this.createOrUpdateSketchPoint_(finishCoordinate);\n            }\n            this.geometryFunction_(coordinates, geometry, projection);\n            if (geometry.getType() === GeometryType.POLYGON && this.sketchLine_) {\n                this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n            }\n        }\n        else if (mode === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            coordinates.splice(-2, 1);\n            var sketchLineGeom = this.sketchLine_.getGeometry();\n            if (coordinates.length >= 2) {\n                var finishCoordinate = coordinates[coordinates.length - 2].slice();\n                coordinates[coordinates.length - 1] = finishCoordinate;\n                this.createOrUpdateSketchPoint_(finishCoordinate);\n            }\n            sketchLineGeom.setCoordinates(coordinates);\n            this.geometryFunction_(this.sketchCoords_, geometry, projection);\n        }\n        if (coordinates.length === 1) {\n            this.abortDrawing();\n        }\n        this.updateSketchFeatures_();\n    };\n    /**\n     * Stop drawing and add the sketch feature to the target layer.\n     * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n     * dispatched before inserting the feature.\n     * @api\n     */\n    Draw.prototype.finishDrawing = function () {\n        var sketchFeature = this.abortDrawing_();\n        if (!sketchFeature) {\n            return;\n        }\n        var coordinates = this.sketchCoords_;\n        var geometry = sketchFeature.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        if (this.mode_ === Mode.LINE_STRING) {\n            // remove the redundant last point\n            coordinates.pop();\n            this.geometryFunction_(coordinates, geometry, projection);\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            // remove the redundant last point in ring\n            /** @type {PolyCoordType} */ (coordinates)[0].pop();\n            this.geometryFunction_(coordinates, geometry, projection);\n            coordinates = geometry.getCoordinates();\n        }\n        // cast multi-part geometries\n        if (this.type_ === GeometryType.MULTI_POINT) {\n            sketchFeature.setGeometry(new MultiPoint([/** @type {PointCoordType} */ (coordinates)]));\n        }\n        else if (this.type_ === GeometryType.MULTI_LINE_STRING) {\n            sketchFeature.setGeometry(new MultiLineString([/** @type {LineCoordType} */ (coordinates)]));\n        }\n        else if (this.type_ === GeometryType.MULTI_POLYGON) {\n            sketchFeature.setGeometry(new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]));\n        }\n        // First dispatch event to allow full set up of feature\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n        // Then insert feature\n        if (this.features_) {\n            this.features_.push(sketchFeature);\n        }\n        if (this.source_) {\n            this.source_.addFeature(sketchFeature);\n        }\n    };\n    /**\n     * Stop drawing without adding the sketch feature to the target layer.\n     * @return {Feature} The sketch feature (or null if none).\n     * @private\n     */\n    Draw.prototype.abortDrawing_ = function () {\n        this.finishCoordinate_ = null;\n        var sketchFeature = this.sketchFeature_;\n        this.sketchFeature_ = null;\n        this.sketchPoint_ = null;\n        this.sketchLine_ = null;\n        this.overlay_.getSource().clear(true);\n        return sketchFeature;\n    };\n    /**\n     * Stop drawing without adding the sketch feature to the target layer.\n     * @api\n     */\n    Draw.prototype.abortDrawing = function () {\n        var sketchFeature = this.abortDrawing_();\n        if (sketchFeature) {\n            this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n        }\n    };\n    /**\n     * Append coordinates to the end of the geometry that is currently being drawn.\n     * This can be used when drawing LineStrings or Polygons. Coordinates will\n     * either be appended to the current LineString or the outer ring of the current\n     * Polygon. If no geometry is being drawn, a new one will be created.\n     * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n     * the coordinate array.\n     * @api\n     */\n    Draw.prototype.appendCoordinates = function (coordinates) {\n        var mode = this.mode_;\n        var newDrawing = !this.sketchFeature_;\n        if (newDrawing) {\n            this.startDrawing_(coordinates[0]);\n        }\n        /** @type {LineCoordType} */\n        var sketchCoords;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n        }\n        else if (mode === Mode.POLYGON) {\n            sketchCoords =\n                this.sketchCoords_ && this.sketchCoords_.length\n                    ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n                    : [];\n        }\n        else {\n            return;\n        }\n        if (newDrawing) {\n            sketchCoords.shift();\n        }\n        // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n        sketchCoords.pop();\n        // Append coordinate list\n        for (var i = 0; i < coordinates.length; i++) {\n            this.addToDrawing_(coordinates[i]);\n        }\n        var ending = coordinates[coordinates.length - 1];\n        // Duplicate last coordinate for sketch drawing (cursor position)\n        this.addToDrawing_(ending);\n        this.modifyDrawing_(ending);\n    };\n    /**\n     * Initiate draw mode by starting from an existing geometry which will\n     * receive new additional points. This only works on features with\n     * `LineString` geometries, where the interaction will extend lines by adding\n     * points to the end of the coordinates array.\n     * This will change the original feature, instead of drawing a copy.\n     *\n     * The function will dispatch a `drawstart` event.\n     *\n     * @param {!Feature<LineString>} feature Feature to be extended.\n     * @api\n     */\n    Draw.prototype.extend = function (feature) {\n        var geometry = feature.getGeometry();\n        var lineString = geometry;\n        this.sketchFeature_ = feature;\n        this.sketchCoords_ = lineString.getCoordinates();\n        var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n        this.finishCoordinate_ = last.slice();\n        this.sketchCoords_.push(last.slice());\n        this.sketchPoint_ = new Feature(new Point(last));\n        this.updateSketchFeatures_();\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n    };\n    /**\n     * Redraw the sketch features.\n     * @private\n     */\n    Draw.prototype.updateSketchFeatures_ = function () {\n        var sketchFeatures = [];\n        if (this.sketchFeature_) {\n            sketchFeatures.push(this.sketchFeature_);\n        }\n        if (this.sketchLine_) {\n            sketchFeatures.push(this.sketchLine_);\n        }\n        if (this.sketchPoint_) {\n            sketchFeatures.push(this.sketchPoint_);\n        }\n        var overlaySource = this.overlay_.getSource();\n        overlaySource.clear(true);\n        overlaySource.addFeatures(sketchFeatures);\n    };\n    /**\n     * @private\n     */\n    Draw.prototype.updateState_ = function () {\n        var map = this.getMap();\n        var active = this.getActive();\n        if (!map || !active) {\n            this.abortDrawing();\n        }\n        this.overlay_.setMap(active ? map : null);\n    };\n    return Draw;\n}(PointerInteraction));\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n    var styles = createEditingStyle();\n    return function (feature, resolution) {\n        return styles[feature.getGeometry().getType()];\n    };\n}\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * `import(\"../geom/Circle.js\").Circle` geometry.\n * @param {number} [opt_sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [opt_angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(opt_sides, opt_angle) {\n    return function (coordinates, opt_geometry, projection) {\n        var center = fromUserCoordinate(\n        /** @type {LineCoordType} */ (coordinates)[0], projection);\n        var end = fromUserCoordinate(\n        /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1], projection);\n        var radius = Math.sqrt(squaredCoordinateDistance(center, end));\n        var geometry = opt_geometry\n            ? /** @type {Polygon} */ (opt_geometry)\n            : fromCircle(new Circle(center), opt_sides);\n        var angle = opt_angle;\n        if (!opt_angle && opt_angle !== 0) {\n            var x = end[0] - center[0];\n            var y = end[1] - center[1];\n            angle = Math.atan2(y, x);\n        }\n        makeRegular(geometry, center, radius, angle);\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            geometry.transform(projection, userProjection);\n        }\n        return geometry;\n    };\n}\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n    return function (coordinates, opt_geometry, projection) {\n        var extent = boundingExtent(\n        /** @type {LineCoordType} */ ([\n            coordinates[0],\n            coordinates[coordinates.length - 1],\n        ]).map(function (coordinate) {\n            return fromUserCoordinate(coordinate, projection);\n        }));\n        var boxCoordinates = [\n            [\n                getBottomLeft(extent),\n                getBottomRight(extent),\n                getTopRight(extent),\n                getTopLeft(extent),\n                getBottomLeft(extent),\n            ],\n        ];\n        var geometry = opt_geometry;\n        if (geometry) {\n            geometry.setCoordinates(boxCoordinates);\n        }\n        else {\n            geometry = new Polygon(boxCoordinates);\n        }\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            geometry.transform(projection, userProjection);\n        }\n        return geometry;\n    };\n}\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/GeometryType.js\").default} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n    switch (type) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT:\n            return Mode.POINT;\n        case GeometryType.LINE_STRING:\n        case GeometryType.MULTI_LINE_STRING:\n            return Mode.LINE_STRING;\n        case GeometryType.POLYGON:\n        case GeometryType.MULTI_POLYGON:\n            return Mode.POLYGON;\n        case GeometryType.CIRCLE:\n            return Mode.CIRCLE;\n        default:\n            throw new Error('Invalid type: ' + type);\n    }\n}\nexport default Draw;\n"]},"metadata":{},"sourceType":"module"}