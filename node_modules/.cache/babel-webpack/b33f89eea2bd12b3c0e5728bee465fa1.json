{"ast":null,"code":"/**\n * @module ol/xml\n */\nimport { extend } from './array.js';\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Node} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\n\nexport var XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\n\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\n\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\n\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    var n = void 0;\n\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n\n  return accumulator;\n}\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\n\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\n\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\n\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\n\nexport function makeArrayExtender(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n\n      if (value !== undefined) {\n        var array = objectStack[objectStack.length - 1];\n        extend(array, value);\n      }\n    }\n  );\n}\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\n\nexport function makeArrayPusher(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n\n      if (value !== undefined) {\n        var array = objectStack[objectStack.length - 1];\n        array.push(value);\n      }\n    }\n  );\n}\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\n\nexport function makeReplacer(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [opt_property] Property.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\n\nexport function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n\n      if (value !== undefined) {\n        var object = objectStack[objectStack.length - 1];\n        var property = opt_property !== undefined ? opt_property : node.localName;\n        var array = void 0;\n\n        if (property in object) {\n          array = object[property];\n        } else {\n          array = [];\n          object[property] = array;\n        }\n\n        array.push(value);\n      }\n    }\n  );\n}\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [opt_property] Property.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\n\nexport function makeObjectPropertySetter(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n\n      if (value !== undefined) {\n        var object = objectStack[objectStack.length - 1];\n        var property = opt_property !== undefined ? opt_property : node.localName;\n        object[property] = value;\n      }\n    }\n  );\n}\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\n\nexport function makeChildAppender(nodeWriter, opt_this) {\n  return function (node, value, objectStack) {\n    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);\n    var parent = objectStack[objectStack.length - 1];\n    var parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * 'nodeWriter' called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\n\nexport function makeArraySerializer(nodeWriter, opt_this) {\n  var serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      var serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n/**\n * Create a node factory which can use the `opt_keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [opt_nodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [opt_namespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\n\nexport function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {\n  var fixedNodeName = opt_nodeName;\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [opt_nodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, opt_nodeName) {\n      var context = objectStack[objectStack.length - 1];\n      var node = context.node;\n      var nodeName = fixedNodeName;\n\n      if (nodeName === undefined) {\n        nodeName = opt_nodeName;\n      }\n\n      var namespaceURI = opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, nodeName);\n    }\n  );\n}\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\n\nexport var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `opt_key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\n\nexport function makeSequence(object, orderedKeys) {\n  var length = orderedKeys.length;\n  var sequence = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n\n  return sequence;\n}\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [opt_structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\n\nexport function makeStructureNS(namespaceURIs, structure, opt_structureNS) {\n  /**\n   * @type {Object<string, T>}\n   */\n  var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};\n  var i, ii;\n\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n\n  return structureNS;\n}\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [opt_this] The object to use as `this`.\n */\n\nexport function parseNode(parsersNS, node, objectStack, opt_this) {\n  var n;\n\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    var parsers = parsersNS[n.namespaceURI];\n\n    if (parsers !== undefined) {\n      var parser = parsers[n.localName];\n\n      if (parser !== undefined) {\n        parser.call(opt_this, n, objectStack);\n      }\n    }\n  }\n}\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [opt_this] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\n\nexport function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, opt_this);\n  return objectStack.pop();\n}\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T} [opt_this] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\n\nexport function serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n  var length = (opt_keys !== undefined ? opt_keys : values).length;\n  var value, node;\n\n  for (var i = 0; i < length; ++i) {\n    value = values[i];\n\n    if (value !== undefined) {\n      node = nodeFactory.call(opt_this !== undefined ? opt_this : this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);\n\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);\n      }\n    }\n  }\n}\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T} [opt_this] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\n\nexport function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);\n  return objectStack.pop();\n}\nvar xmlSerializer_ = undefined;\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\n\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\n\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n\n  return xmlSerializer_;\n}\nvar document_ = undefined;\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\n\nexport function registerDocument(document) {\n  document_ = document;\n}\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\n\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n\n  return document_;\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/xml.js"],"names":["extend","XML_SCHEMA_INSTANCE_URI","createElementNS","namespaceURI","qualifiedName","getDocument","getAllTextContent","node","normalizeWhitespace","getAllTextContent_","join","accumulator","nodeType","Node","CDATA_SECTION_NODE","TEXT_NODE","push","String","nodeValue","replace","n","firstChild","nextSibling","isDocument","object","getAttributeNS","name","parse","xml","DOMParser","parseFromString","makeArrayExtender","valueReader","opt_this","objectStack","value","call","undefined","array","length","makeArrayPusher","makeReplacer","makeObjectPropertyPusher","opt_property","property","localName","makeObjectPropertySetter","makeChildAppender","nodeWriter","parent","parentNode","appendChild","makeArraySerializer","serializersNS","nodeFactory","serializers","makeSimpleNodeFactory","serialize","opt_nodeName","opt_namespaceURI","fixedNodeName","context","nodeName","OBJECT_PROPERTY_NODE_FACTORY","makeSequence","orderedKeys","sequence","Array","i","makeStructureNS","namespaceURIs","structure","opt_structureNS","structureNS","ii","parseNode","parsersNS","firstElementChild","nextElementSibling","parsers","parser","pushParseAndPop","pop","values","opt_keys","pushSerializeAndPop","xmlSerializer_","registerXMLSerializer","xmlSerializer","getXMLSerializer","XMLSerializer","document_","registerDocument","document","implementation","createDocument"],"mappings":"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","sourcesContent":["/**\n * @module ol/xml\n */\nimport { extend } from './array.js';\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Node} node Node.\n */\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n/**\n * @type {string}\n */\nexport var XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n    return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n    return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n    if (node.nodeType == Node.CDATA_SECTION_NODE ||\n        node.nodeType == Node.TEXT_NODE) {\n        if (normalizeWhitespace) {\n            accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n        }\n        else {\n            accumulator.push(node.nodeValue);\n        }\n    }\n    else {\n        var n = void 0;\n        for (n = node.firstChild; n; n = n.nextSibling) {\n            getAllTextContent_(n, normalizeWhitespace, accumulator);\n        }\n    }\n    return accumulator;\n}\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n    return 'documentElement' in object;\n}\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n    return node.getAttributeNS(namespaceURI, name) || '';\n}\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n    return new DOMParser().parseFromString(xml, 'application/xml');\n}\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, opt_this) {\n    return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n        if (value !== undefined) {\n            var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);\n            extend(array, value);\n        }\n    });\n}\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, opt_this) {\n    return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n        if (value !== undefined) {\n            var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);\n            array.push(value);\n        }\n    });\n}\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, opt_this) {\n    return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n        if (value !== undefined) {\n            objectStack[objectStack.length - 1] = value;\n        }\n    });\n}\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [opt_property] Property.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {\n    return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n        if (value !== undefined) {\n            var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n            var property = opt_property !== undefined ? opt_property : node.localName;\n            var array = void 0;\n            if (property in object) {\n                array = object[property];\n            }\n            else {\n                array = [];\n                object[property] = array;\n            }\n            array.push(value);\n        }\n    });\n}\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [opt_property] Property.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, opt_property, opt_this) {\n    return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n        if (value !== undefined) {\n            var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n            var property = opt_property !== undefined ? opt_property : node.localName;\n            object[property] = value;\n        }\n    });\n}\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, opt_this) {\n    return function (node, value, objectStack) {\n        nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);\n        var parent = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);\n        var parentNode = parent.node;\n        parentNode.appendChild(node);\n    };\n}\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * 'nodeWriter' called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, opt_this) {\n    var serializersNS, nodeFactory;\n    return function (node, value, objectStack) {\n        if (serializersNS === undefined) {\n            serializersNS = {};\n            var serializers = {};\n            serializers[node.localName] = nodeWriter;\n            serializersNS[node.namespaceURI] = serializers;\n            nodeFactory = makeSimpleNodeFactory(node.localName);\n        }\n        serialize(serializersNS, nodeFactory, value, objectStack);\n    };\n}\n/**\n * Create a node factory which can use the `opt_keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [opt_nodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [opt_namespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {\n    var fixedNodeName = opt_nodeName;\n    return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [opt_nodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, opt_nodeName) {\n        var context = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);\n        var node = context.node;\n        var nodeName = fixedNodeName;\n        if (nodeName === undefined) {\n            nodeName = opt_nodeName;\n        }\n        var namespaceURI = opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;\n        return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    });\n}\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `opt_key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n    var length = orderedKeys.length;\n    var sequence = new Array(length);\n    for (var i = 0; i < length; ++i) {\n        sequence[i] = object[orderedKeys[i]];\n    }\n    return sequence;\n}\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [opt_structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, opt_structureNS) {\n    /**\n     * @type {Object<string, T>}\n     */\n    var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};\n    var i, ii;\n    for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n        structureNS[namespaceURIs[i]] = structure;\n    }\n    return structureNS;\n}\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [opt_this] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, opt_this) {\n    var n;\n    for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n        var parsers = parsersNS[n.namespaceURI];\n        if (parsers !== undefined) {\n            var parser = parsers[n.localName];\n            if (parser !== undefined) {\n                parser.call(opt_this, n, objectStack);\n            }\n        }\n    }\n}\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [opt_this] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {\n    objectStack.push(object);\n    parseNode(parsersNS, node, objectStack, opt_this);\n    return /** @type {T} */ (objectStack.pop());\n}\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T} [opt_this] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n    var length = (opt_keys !== undefined ? opt_keys : values).length;\n    var value, node;\n    for (var i = 0; i < length; ++i) {\n        value = values[i];\n        if (value !== undefined) {\n            node = nodeFactory.call(opt_this !== undefined ? opt_this : this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);\n            if (node !== undefined) {\n                serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);\n            }\n        }\n    }\n}\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T} [opt_this] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n    objectStack.push(object);\n    serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);\n    return /** @type {O|undefined} */ (objectStack.pop());\n}\nvar xmlSerializer_ = undefined;\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n    xmlSerializer_ = xmlSerializer;\n}\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n    if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n        xmlSerializer_ = new XMLSerializer();\n    }\n    return xmlSerializer_;\n}\nvar document_ = undefined;\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n    document_ = document;\n}\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n    if (document_ === undefined && typeof document !== 'undefined') {\n        document_ = document.implementation.createDocument('', '', null);\n    }\n    return document_;\n}\n"]},"metadata":{},"sourceType":"module"}