{"ast":null,"code":"/**\n * @module ol/centerconstraint\n */\nimport { clamp } from './math.js';\n/**\n * @typedef {function((import(\"./coordinate.js\").Coordinate|undefined), number, import(\"./size.js\").Size, boolean=, Array<number>=): (import(\"./coordinate.js\").Coordinate|undefined)} Type\n */\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.\n * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent\n * (only during interaction and animation).\n * @return {Type} The constraint.\n */\n\nexport function createExtent(extent, onlyCenter, smooth) {\n  return (\n    /**\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} center Center.\n     * @param {number} resolution Resolution.\n     * @param {import(\"./size.js\").Size} size Viewport size; unused if `onlyCenter` was specified.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @param {Array<number>} [opt_centerShift] Shift between map center and viewport center.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n     */\n    function (center, resolution, size, opt_isMoving, opt_centerShift) {\n      if (center) {\n        var viewWidth = onlyCenter ? 0 : size[0] * resolution;\n        var viewHeight = onlyCenter ? 0 : size[1] * resolution;\n        var shiftX = opt_centerShift ? opt_centerShift[0] : 0;\n        var shiftY = opt_centerShift ? opt_centerShift[1] : 0;\n        var minX = extent[0] + viewWidth / 2 + shiftX;\n        var maxX = extent[2] - viewWidth / 2 + shiftX;\n        var minY = extent[1] + viewHeight / 2 + shiftY;\n        var maxY = extent[3] - viewHeight / 2 + shiftY; // note: when zooming out of bounds, min and max values for x and y may\n        // end up inverted (min > max); this has to be accounted for\n\n        if (minX > maxX) {\n          minX = (maxX + minX) / 2;\n          maxX = minX;\n        }\n\n        if (minY > maxY) {\n          minY = (maxY + minY) / 2;\n          maxY = minY;\n        }\n\n        var x = clamp(center[0], minX, maxX);\n        var y = clamp(center[1], minY, maxY);\n        var ratio = 30 * resolution; // during an interaction, allow some overscroll\n\n        if (opt_isMoving && smooth) {\n          x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);\n          y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);\n        }\n\n        return [x, y];\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} [center] Center.\n * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n */\n\nexport function none(center) {\n  return center;\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/centerconstraint.js"],"names":["clamp","createExtent","extent","onlyCenter","smooth","center","resolution","size","opt_isMoving","opt_centerShift","viewWidth","viewHeight","shiftX","shiftY","minX","maxX","minY","maxY","x","y","ratio","Math","log","max","undefined","none"],"mappings":"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","sourcesContent":["/**\n * @module ol/centerconstraint\n */\nimport { clamp } from './math.js';\n/**\n * @typedef {function((import(\"./coordinate.js\").Coordinate|undefined), number, import(\"./size.js\").Size, boolean=, Array<number>=): (import(\"./coordinate.js\").Coordinate|undefined)} Type\n */\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.\n * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent\n * (only during interaction and animation).\n * @return {Type} The constraint.\n */\nexport function createExtent(extent, onlyCenter, smooth) {\n    return (\n    /**\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} center Center.\n     * @param {number} resolution Resolution.\n     * @param {import(\"./size.js\").Size} size Viewport size; unused if `onlyCenter` was specified.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @param {Array<number>} [opt_centerShift] Shift between map center and viewport center.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n     */\n    function (center, resolution, size, opt_isMoving, opt_centerShift) {\n        if (center) {\n            var viewWidth = onlyCenter ? 0 : size[0] * resolution;\n            var viewHeight = onlyCenter ? 0 : size[1] * resolution;\n            var shiftX = opt_centerShift ? opt_centerShift[0] : 0;\n            var shiftY = opt_centerShift ? opt_centerShift[1] : 0;\n            var minX = extent[0] + viewWidth / 2 + shiftX;\n            var maxX = extent[2] - viewWidth / 2 + shiftX;\n            var minY = extent[1] + viewHeight / 2 + shiftY;\n            var maxY = extent[3] - viewHeight / 2 + shiftY;\n            // note: when zooming out of bounds, min and max values for x and y may\n            // end up inverted (min > max); this has to be accounted for\n            if (minX > maxX) {\n                minX = (maxX + minX) / 2;\n                maxX = minX;\n            }\n            if (minY > maxY) {\n                minY = (maxY + minY) / 2;\n                maxY = minY;\n            }\n            var x = clamp(center[0], minX, maxX);\n            var y = clamp(center[1], minY, maxY);\n            var ratio = 30 * resolution;\n            // during an interaction, allow some overscroll\n            if (opt_isMoving && smooth) {\n                x +=\n                    -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +\n                        ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);\n                y +=\n                    -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +\n                        ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);\n            }\n            return [x, y];\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} [center] Center.\n * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n */\nexport function none(center) {\n    return center;\n}\n"]},"metadata":{},"sourceType":"module"}