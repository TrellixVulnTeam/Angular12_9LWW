{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Snap\n */\n\n\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, squaredDistanceToSegment } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { getValues } from '../obj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped Snapped.\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\n\nfunction getFeatureFromEvent(evt) {\n  if (\n  /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n  evt.feature) {\n    return (\n      /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n      evt.feature\n    );\n  } else if (\n  /** @type {import(\"../Collection.js\").CollectionEvent} */\n  evt.element) {\n    return (\n      /** @type {import(\"../Collection.js\").CollectionEvent} */\n      evt.element\n    );\n  }\n}\n\nvar tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\n\nvar Snap = function (_super) {\n  __extends(Snap, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n\n\n  function Snap(opt_options) {\n    var _this = this;\n\n    var options = opt_options ? opt_options : {};\n    var pointerOptions = options;\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    _this = _super.call(this, pointerOptions) || this;\n    /**\n     * @type {import(\"../source/Vector.js\").default}\n     * @private\n     */\n\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.edge_ = options.edge !== undefined ? options.edge : true;\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n     * @private\n     */\n\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    _this.featuresListenerKeys_ = [];\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    _this.featureChangeListenerKeys_ = {};\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n\n    _this.indexedFeaturesExtents_ = {};\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n\n    _this.pendingFeatures_ = {};\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n\n    _this.rBush_ = new RBush();\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default): void>}\n     */\n\n    _this.SEGMENT_WRITERS_ = {\n      'Point': _this.writePointGeometry_.bind(_this),\n      'LineString': _this.writeLineStringGeometry_.bind(_this),\n      'LinearRing': _this.writeLineStringGeometry_.bind(_this),\n      'Polygon': _this.writePolygonGeometry_.bind(_this),\n      'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),\n      'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),\n      'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),\n      'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this),\n      'Circle': _this.writeCircleGeometry_.bind(_this)\n    };\n    return _this;\n  }\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n\n\n  Snap.prototype.addFeature = function (feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        segmentWriter(feature, geometry);\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureAdd_ = function (feature) {\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureRemove_ = function (feature) {\n    this.removeFeature(feature);\n  };\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n\n\n  Snap.prototype.getFeatures_ = function () {\n    var features;\n\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n\n    return features;\n  };\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n\n\n  Snap.prototype.handleEvent = function (evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n\n    if (result.snapped) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n\n    return _super.prototype.handleEvent.call(this, evt);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureAdd_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureRemove_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  };\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureChange_ = function (evt) {\n    var feature = evt.target;\n\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  Snap.prototype.handleUpEvent = function (evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n\n    return false;\n  };\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n\n\n  Snap.prototype.removeFeature = function (feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove_1 = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove_1.push(node);\n        }\n      });\n\n      for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove_1[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n\n\n  Snap.prototype.setMap = function (map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features = this.getFeatures_();\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n\n    _super.prototype.setMap.call(this, map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result} Snap result\n   */\n\n\n  Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box); // If snapping on vertices only, don't consider circles\n\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function (segment) {\n        return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;\n      });\n    }\n\n    var snapped = false;\n    var vertex = null;\n    var vertexPixel = null;\n\n    if (segments.length === 0) {\n      return {\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel\n      };\n    }\n\n    var projection = map.getView().getProjection();\n    var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n    var closestSegmentData;\n    var minSquaredDistance = Infinity;\n\n    for (var i = 0; i < segments.length; ++i) {\n      var segmentData = segments[i];\n      tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n      tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n      var delta = squaredDistanceToSegment(projectedCoordinate, tempSegment);\n\n      if (delta < minSquaredDistance) {\n        closestSegmentData = segmentData;\n        minSquaredDistance = delta;\n      }\n    }\n\n    var closestSegment = closestSegmentData.segment;\n\n    if (this.vertex_ && !this.edge_) {\n      var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n      var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n      var squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n      var squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n      var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n\n      if (dist <= this.pixelTolerance_) {\n        snapped = true;\n        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n      }\n    } else if (this.edge_) {\n      var isCircle = closestSegmentData.feature.getGeometry().getType() === GeometryType.CIRCLE;\n\n      if (isCircle) {\n        var circleGeometry = closestSegmentData.feature.getGeometry();\n        var userProjection = getUserProjection();\n\n        if (userProjection) {\n          circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n        }\n\n        vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, circleGeometry), projection);\n      } else {\n        tempSegment[0] = fromUserCoordinate(closestSegment[0], projection);\n        tempSegment[1] = fromUserCoordinate(closestSegment[1], projection);\n        vertex = toUserCoordinate(closestOnSegment(projectedCoordinate, tempSegment), projection);\n      }\n\n      vertexPixel = map.getPixelFromCoordinate(vertex);\n\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n        snapped = true;\n\n        if (this.vertex_ && !isCircle) {\n          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n          var squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n          var squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n          var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n\n          if (dist <= this.pixelTolerance_) {\n            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n            vertexPixel = map.getPixelFromCoordinate(vertex);\n          }\n        }\n      }\n    }\n\n    if (snapped) {\n      vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n    }\n\n    return {\n      snapped: snapped,\n      vertex: vertex,\n      vertexPixel: vertexPixel\n    };\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n\n\n  Snap.prototype.updateFeature_ = function (feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeCircleGeometry_ = function (feature, geometry) {\n    var projection = this.getMap().getView().getProjection();\n    var circleGeometry = geometry;\n    var userProjection = getUserProjection();\n\n    if (userProjection) {\n      circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n    }\n\n    var polygon = fromCircle(circleGeometry);\n\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n\n    var coordinates = polygon.getCoordinates()[0];\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData = {\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {\n    var geometries = geometry.getGeometriesArray();\n\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n\n      if (segmentWriter) {\n        segmentWriter(feature, geometries[i]);\n      }\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeLineStringGeometry_ = function (feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData = {\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {\n    var lines = geometry.getCoordinates();\n\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData = {\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeMultiPointGeometry_ = function (feature, geometry) {\n    var points = geometry.getCoordinates();\n\n    for (var i = 0, ii = points.length; i < ii; ++i) {\n      var coordinates = points[i];\n      var segmentData = {\n        feature: feature,\n        segment: [coordinates, coordinates]\n      };\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {\n    var polygons = geometry.getCoordinates();\n\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          var segment = coordinates.slice(i, i + 2);\n          var segmentData = {\n            feature: feature,\n            segment: segment\n          };\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writePointGeometry_ = function (feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var segmentData = {\n      feature: feature,\n      segment: [coordinates, coordinates]\n    };\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writePolygonGeometry_ = function (feature, geometry) {\n    var rings = geometry.getCoordinates();\n\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData = {\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n\n  return Snap;\n}(PointerInteraction);\n\nexport default Snap;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/interaction/Snap.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","CollectionEventType","EventType","GeometryType","PointerInteraction","RBush","VectorEventType","FALSE","TRUE","boundingExtent","createEmpty","closestOnCircle","closestOnSegment","distance","coordinateDistance","squaredDistance","squaredCoordinateDistance","squaredDistanceToSegment","fromCircle","fromUserCoordinate","getUserProjection","toUserCoordinate","getUid","getValues","listen","unlistenByKey","getFeatureFromEvent","evt","feature","element","tempSegment","Snap","_super","opt_options","_this","options","pointerOptions","handleDownEvent","stopDown","source_","source","vertex_","vertex","undefined","edge_","edge","features_","features","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","pixelTolerance_","pixelTolerance","rBush_","SEGMENT_WRITERS_","writePointGeometry_","bind","writeLineStringGeometry_","writePolygonGeometry_","writeMultiPointGeometry_","writeMultiLineStringGeometry_","writeMultiPolygonGeometry_","writeGeometryCollectionGeometry_","writeCircleGeometry_","addFeature","opt_listen","register","feature_uid","geometry","getGeometry","segmentWriter","getType","getExtent","CHANGE","handleFeatureChange_","forEachFeatureAdd_","forEachFeatureRemove_","removeFeature","getFeatures_","getFeatures","handleEvent","result","snapTo","pixel","coordinate","map","snapped","slice","vertexPixel","handleFeatureAdd_","handleFeatureRemove_","target","handlingDownUpSequence","uid","updateFeature_","handleUpEvent","featuresToUpdate","length","forEach","opt_unlisten","unregister","extent","rBush","nodesToRemove_1","forEachInExtent","node","push","i","remove","setMap","currentMap","getMap","keys","ADD","REMOVE","ADDFEATURE","REMOVEFEATURE","pixelCoordinate","lowerLeft","getCoordinateFromPixel","upperRight","box","segments","getInExtent","filter","segment","CIRCLE","projection","getView","getProjection","projectedCoordinate","closestSegmentData","minSquaredDistance","Infinity","segmentData","delta","closestSegment","pixel1","getPixelFromCoordinate","pixel2","squaredDist1","squaredDist2","dist","Math","sqrt","min","isCircle","circleGeometry","userProjection","clone","transform","round","polygon","coordinates","getCoordinates","ii","insert","geometries","getGeometriesArray","lines","j","jj","points","polygons","k","kk","rings"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, squaredDistanceToSegment, } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate, } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { getValues } from '../obj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped Snapped.\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n    if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature) {\n        return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n            .feature;\n    }\n    else if (\n    /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element) {\n        return /** @type {import(\"../Feature.js\").default} */ (\n        /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element);\n    }\n}\nvar tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nvar Snap = /** @class */ (function (_super) {\n    __extends(Snap, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function Snap(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n        if (!pointerOptions.handleDownEvent) {\n            pointerOptions.handleDownEvent = TRUE;\n        }\n        if (!pointerOptions.stopDown) {\n            pointerOptions.stopDown = FALSE;\n        }\n        _this = _super.call(this, pointerOptions) || this;\n        /**\n         * @type {import(\"../source/Vector.js\").default}\n         * @private\n         */\n        _this.source_ = options.source ? options.source : null;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.edge_ = options.edge !== undefined ? options.edge : true;\n        /**\n         * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n         * @private\n         */\n        _this.features_ = options.features ? options.features : null;\n        /**\n         * @type {Array<import(\"../events.js\").EventsKey>}\n         * @private\n         */\n        _this.featuresListenerKeys_ = [];\n        /**\n         * @type {Object<string, import(\"../events.js\").EventsKey>}\n         * @private\n         */\n        _this.featureChangeListenerKeys_ = {};\n        /**\n         * Extents are preserved so indexed segment can be quickly removed\n         * when its feature geometry changes\n         * @type {Object<string, import(\"../extent.js\").Extent>}\n         * @private\n         */\n        _this.indexedFeaturesExtents_ = {};\n        /**\n         * If a feature geometry changes while a pointer drag|move event occurs, the\n         * feature doesn't get updated right away.  It will be at the next 'pointerup'\n         * event fired.\n         * @type {!Object<string, import(\"../Feature.js\").default>}\n         * @private\n         */\n        _this.pendingFeatures_ = {};\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.pixelTolerance_ =\n            options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n        /**\n         * Segment RTree for each layer\n         * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n         * @private\n         */\n        _this.rBush_ = new RBush();\n        /**\n         * @const\n         * @private\n         * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default): void>}\n         */\n        _this.SEGMENT_WRITERS_ = {\n            'Point': _this.writePointGeometry_.bind(_this),\n            'LineString': _this.writeLineStringGeometry_.bind(_this),\n            'LinearRing': _this.writeLineStringGeometry_.bind(_this),\n            'Polygon': _this.writePolygonGeometry_.bind(_this),\n            'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),\n            'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),\n            'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),\n            'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this),\n            'Circle': _this.writeCircleGeometry_.bind(_this),\n        };\n        return _this;\n    }\n    /**\n     * Add a feature to the collection of features that we may snap to.\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n     *     Defaults to `true`.\n     * @api\n     */\n    Snap.prototype.addFeature = function (feature, opt_listen) {\n        var register = opt_listen !== undefined ? opt_listen : true;\n        var feature_uid = getUid(feature);\n        var geometry = feature.getGeometry();\n        if (geometry) {\n            var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n            if (segmentWriter) {\n                this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n                segmentWriter(feature, geometry);\n            }\n        }\n        if (register) {\n            this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n        }\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @private\n     */\n    Snap.prototype.forEachFeatureAdd_ = function (feature) {\n        this.addFeature(feature);\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @private\n     */\n    Snap.prototype.forEachFeatureRemove_ = function (feature) {\n        this.removeFeature(feature);\n    };\n    /**\n     * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n     * @private\n     */\n    Snap.prototype.getFeatures_ = function () {\n        var features;\n        if (this.features_) {\n            features = this.features_;\n        }\n        else if (this.source_) {\n            features = this.source_.getFeatures();\n        }\n        return features;\n    };\n    /**\n     * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     */\n    Snap.prototype.handleEvent = function (evt) {\n        var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n        if (result.snapped) {\n            evt.coordinate = result.vertex.slice(0, 2);\n            evt.pixel = result.vertexPixel;\n        }\n        return _super.prototype.handleEvent.call(this, evt);\n    };\n    /**\n     * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n     * @private\n     */\n    Snap.prototype.handleFeatureAdd_ = function (evt) {\n        var feature = getFeatureFromEvent(evt);\n        this.addFeature(feature);\n    };\n    /**\n     * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n     * @private\n     */\n    Snap.prototype.handleFeatureRemove_ = function (evt) {\n        var feature = getFeatureFromEvent(evt);\n        this.removeFeature(feature);\n    };\n    /**\n     * @param {import(\"../events/Event.js\").default} evt Event.\n     * @private\n     */\n    Snap.prototype.handleFeatureChange_ = function (evt) {\n        var feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n        if (this.handlingDownUpSequence) {\n            var uid = getUid(feature);\n            if (!(uid in this.pendingFeatures_)) {\n                this.pendingFeatures_[uid] = feature;\n            }\n        }\n        else {\n            this.updateFeature_(feature);\n        }\n    };\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Snap.prototype.handleUpEvent = function (evt) {\n        var featuresToUpdate = getValues(this.pendingFeatures_);\n        if (featuresToUpdate.length) {\n            featuresToUpdate.forEach(this.updateFeature_.bind(this));\n            this.pendingFeatures_ = {};\n        }\n        return false;\n    };\n    /**\n     * Remove a feature from the collection of features that we may snap to.\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n     *     or not. Defaults to `true`.\n     * @api\n     */\n    Snap.prototype.removeFeature = function (feature, opt_unlisten) {\n        var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n        var feature_uid = getUid(feature);\n        var extent = this.indexedFeaturesExtents_[feature_uid];\n        if (extent) {\n            var rBush = this.rBush_;\n            var nodesToRemove_1 = [];\n            rBush.forEachInExtent(extent, function (node) {\n                if (feature === node.feature) {\n                    nodesToRemove_1.push(node);\n                }\n            });\n            for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {\n                rBush.remove(nodesToRemove_1[i]);\n            }\n        }\n        if (unregister) {\n            unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n            delete this.featureChangeListenerKeys_[feature_uid];\n        }\n    };\n    /**\n     * Remove the interaction from its current map and attach it to the new map.\n     * Subclasses may set up event handlers to get notified about changes to\n     * the map here.\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     */\n    Snap.prototype.setMap = function (map) {\n        var currentMap = this.getMap();\n        var keys = this.featuresListenerKeys_;\n        var features = /** @type {Array<import(\"../Feature.js\").default>} */ (this.getFeatures_());\n        if (currentMap) {\n            keys.forEach(unlistenByKey);\n            keys.length = 0;\n            features.forEach(this.forEachFeatureRemove_.bind(this));\n        }\n        _super.prototype.setMap.call(this, map);\n        if (map) {\n            if (this.features_) {\n                keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n            }\n            else if (this.source_) {\n                keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n            }\n            features.forEach(this.forEachFeatureAdd_.bind(this));\n        }\n    };\n    /**\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n     * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     * @return {Result} Snap result\n     */\n    Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n        var lowerLeft = map.getCoordinateFromPixel([\n            pixel[0] - this.pixelTolerance_,\n            pixel[1] + this.pixelTolerance_,\n        ]);\n        var upperRight = map.getCoordinateFromPixel([\n            pixel[0] + this.pixelTolerance_,\n            pixel[1] - this.pixelTolerance_,\n        ]);\n        var box = boundingExtent([lowerLeft, upperRight]);\n        var segments = this.rBush_.getInExtent(box);\n        // If snapping on vertices only, don't consider circles\n        if (this.vertex_ && !this.edge_) {\n            segments = segments.filter(function (segment) {\n                return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;\n            });\n        }\n        var snapped = false;\n        var vertex = null;\n        var vertexPixel = null;\n        if (segments.length === 0) {\n            return {\n                snapped: snapped,\n                vertex: vertex,\n                vertexPixel: vertexPixel,\n            };\n        }\n        var projection = map.getView().getProjection();\n        var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n        var closestSegmentData;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < segments.length; ++i) {\n            var segmentData = segments[i];\n            tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n            tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n            var delta = squaredDistanceToSegment(projectedCoordinate, tempSegment);\n            if (delta < minSquaredDistance) {\n                closestSegmentData = segmentData;\n                minSquaredDistance = delta;\n            }\n        }\n        var closestSegment = closestSegmentData.segment;\n        if (this.vertex_ && !this.edge_) {\n            var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            var squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n            var squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n            var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            if (dist <= this.pixelTolerance_) {\n                snapped = true;\n                vertex =\n                    squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n                vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n        }\n        else if (this.edge_) {\n            var isCircle = closestSegmentData.feature.getGeometry().getType() ===\n                GeometryType.CIRCLE;\n            if (isCircle) {\n                var circleGeometry = closestSegmentData.feature.getGeometry();\n                var userProjection = getUserProjection();\n                if (userProjection) {\n                    circleGeometry = circleGeometry\n                        .clone()\n                        .transform(userProjection, projection);\n                }\n                vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, \n                /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)), projection);\n            }\n            else {\n                tempSegment[0] = fromUserCoordinate(closestSegment[0], projection);\n                tempSegment[1] = fromUserCoordinate(closestSegment[1], projection);\n                vertex = toUserCoordinate(closestOnSegment(projectedCoordinate, tempSegment), projection);\n            }\n            vertexPixel = map.getPixelFromCoordinate(vertex);\n            if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n                snapped = true;\n                if (this.vertex_ && !isCircle) {\n                    var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n                    var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n                    var squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n                    var squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n                    var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n                    if (dist <= this.pixelTolerance_) {\n                        vertex =\n                            squaredDist1 > squaredDist2\n                                ? closestSegment[1]\n                                : closestSegment[0];\n                        vertexPixel = map.getPixelFromCoordinate(vertex);\n                    }\n                }\n            }\n        }\n        if (snapped) {\n            vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n        }\n        return {\n            snapped: snapped,\n            vertex: vertex,\n            vertexPixel: vertexPixel,\n        };\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @private\n     */\n    Snap.prototype.updateFeature_ = function (feature) {\n        this.removeFeature(feature, false);\n        this.addFeature(feature, false);\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.writeCircleGeometry_ = function (feature, geometry) {\n        var projection = this.getMap().getView().getProjection();\n        var circleGeometry = geometry;\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry.clone().transform(userProjection, projection));\n        }\n        var polygon = fromCircle(circleGeometry);\n        if (userProjection) {\n            polygon.transform(projection, userProjection);\n        }\n        var coordinates = polygon.getCoordinates()[0];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            var segment = coordinates.slice(i, i + 2);\n            var segmentData = {\n                feature: feature,\n                segment: segment,\n            };\n            this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {\n        var geometries = geometry.getGeometriesArray();\n        for (var i = 0; i < geometries.length; ++i) {\n            var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n            if (segmentWriter) {\n                segmentWriter(feature, geometries[i]);\n            }\n        }\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.writeLineStringGeometry_ = function (feature, geometry) {\n        var coordinates = geometry.getCoordinates();\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            var segment = coordinates.slice(i, i + 2);\n            var segmentData = {\n                feature: feature,\n                segment: segment,\n            };\n            this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {\n        var lines = geometry.getCoordinates();\n        for (var j = 0, jj = lines.length; j < jj; ++j) {\n            var coordinates = lines[j];\n            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n                var segment = coordinates.slice(i, i + 2);\n                var segmentData = {\n                    feature: feature,\n                    segment: segment,\n                };\n                this.rBush_.insert(boundingExtent(segment), segmentData);\n            }\n        }\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.writeMultiPointGeometry_ = function (feature, geometry) {\n        var points = geometry.getCoordinates();\n        for (var i = 0, ii = points.length; i < ii; ++i) {\n            var coordinates = points[i];\n            var segmentData = {\n                feature: feature,\n                segment: [coordinates, coordinates],\n            };\n            this.rBush_.insert(geometry.getExtent(), segmentData);\n        }\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {\n        var polygons = geometry.getCoordinates();\n        for (var k = 0, kk = polygons.length; k < kk; ++k) {\n            var rings = polygons[k];\n            for (var j = 0, jj = rings.length; j < jj; ++j) {\n                var coordinates = rings[j];\n                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n                    var segment = coordinates.slice(i, i + 2);\n                    var segmentData = {\n                        feature: feature,\n                        segment: segment,\n                    };\n                    this.rBush_.insert(boundingExtent(segment), segmentData);\n                }\n            }\n        }\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.writePointGeometry_ = function (feature, geometry) {\n        var coordinates = geometry.getCoordinates();\n        var segmentData = {\n            feature: feature,\n            segment: [coordinates, coordinates],\n        };\n        this.rBush_.insert(geometry.getExtent(), segmentData);\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n     * @private\n     */\n    Snap.prototype.writePolygonGeometry_ = function (feature, geometry) {\n        var rings = geometry.getCoordinates();\n        for (var j = 0, jj = rings.length; j < jj; ++j) {\n            var coordinates = rings[j];\n            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n                var segment = coordinates.slice(i, i + 2);\n                var segmentData = {\n                    feature: feature,\n                    segment: segment,\n                };\n                this.rBush_.insert(boundingExtent(segment), segmentData);\n            }\n        }\n    };\n    return Snap;\n}(PointerInteraction));\nexport default Snap;\n"]},"metadata":{},"sourceType":"module"}