{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/TopoJSON\n */\n\n\nimport Feature from '../Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n/**\n * @typedef {import(\"topojson-specification\").Topology} TopoJSONTopology\n * @typedef {import(\"topojson-specification\").GeometryCollection} TopoJSONGeometryCollection\n * @typedef {import(\"topojson-specification\").GeometryObject} TopoJSONGeometry\n * @typedef {import(\"topojson-specification\").Point} TopoJSONPoint\n * @typedef {import(\"topojson-specification\").MultiPoint} TopoJSONMultiPoint\n * @typedef {import(\"topojson-specification\").LineString} TopoJSONLineString\n * @typedef {import(\"topojson-specification\").MultiLineString} TopoJSONMultiLineString\n * @typedef {import(\"topojson-specification\").Polygon} TopoJSONPolygon\n * @typedef {import(\"topojson-specification\").MultiPolygon} TopoJSONMultiPolygon\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {string} [layerName] Set the name of the TopoJSON topology\n * `objects`'s children as feature property with the specified name. This means\n * that when set to `'layer'`, a topology like\n * ```\n * {\n *   \"type\": \"Topology\",\n *   \"objects\": {\n *     \"example\": {\n *       \"type\": \"GeometryCollection\",\n *       \"geometries\": []\n *     }\n *   }\n * }\n * ```\n * will result in features that have a property `'layer'` set to `'example'`.\n * When not set, no property will be added to features.\n * @property {Array<string>} [layers] Names of the TopoJSON topology's\n * `objects`'s children to read features from.  If not provided, features will\n * be read from all children.\n */\n\n/**\n * @classdesc\n * Feature format for reading data in the TopoJSON format.\n *\n * @api\n */\n\nvar TopoJSON = function (_super) {\n  __extends(TopoJSON, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n\n\n  function TopoJSON(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n\n    _this.layerName_ = options.layerName;\n    /**\n     * @private\n     * @type {?Array<string>}\n     */\n\n    _this.layers_ = options.layers ? options.layers : null;\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n\n    _this.dataProjection = getProjection(options.dataProjection ? options.dataProjection : 'EPSG:4326');\n    return _this;\n  }\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n\n\n  TopoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {\n    if (object.type == 'Topology') {\n      var topoJSONTopology = object;\n      var transform = void 0,\n          scale = null,\n          translate = null;\n\n      if (topoJSONTopology['transform']) {\n        transform = topoJSONTopology['transform'];\n        scale = transform['scale'];\n        translate = transform['translate'];\n      }\n\n      var arcs = topoJSONTopology['arcs'];\n\n      if (transform) {\n        transformArcs(arcs, scale, translate);\n      }\n      /** @type {Array<Feature>} */\n\n\n      var features = [];\n      var topoJSONFeatures = topoJSONTopology['objects'];\n      var property = this.layerName_;\n      var feature = void 0;\n\n      for (var objectName in topoJSONFeatures) {\n        if (this.layers_ && this.layers_.indexOf(objectName) == -1) {\n          continue;\n        }\n\n        if (topoJSONFeatures[objectName].type === 'GeometryCollection') {\n          feature = topoJSONFeatures[objectName];\n          features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, opt_options));\n        } else {\n          feature = topoJSONFeatures[objectName];\n          features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, opt_options));\n        }\n      }\n\n      return features;\n    } else {\n      return [];\n    }\n  };\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n\n\n  TopoJSON.prototype.readProjectionFromObject = function (object) {\n    return this.dataProjection;\n  };\n\n  return TopoJSON;\n}(JSONFeature);\n/**\n * @const\n * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import(\"../geom/Geometry.js\").default>}\n */\n\n\nvar GEOMETRY_READERS = {\n  'Point': readPointGeometry,\n  'LineString': readLineStringGeometry,\n  'Polygon': readPolygonGeometry,\n  'MultiPoint': readMultiPointGeometry,\n  'MultiLineString': readMultiLineStringGeometry,\n  'MultiPolygon': readMultiPolygonGeometry\n};\n/**\n * Concatenate arcs into a coordinate array.\n * @param {Array<number>} indices Indices of arcs to concatenate.  Negative\n *     values indicate arcs need to be reversed.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs (already\n *     transformed).\n * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates array.\n */\n\nfunction concatenateArcs(indices, arcs) {\n  /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n  var coordinates = [];\n  var index, arc;\n\n  for (var i = 0, ii = indices.length; i < ii; ++i) {\n    index = indices[i];\n\n    if (i > 0) {\n      // splicing together arcs, discard last point\n      coordinates.pop();\n    }\n\n    if (index >= 0) {\n      // forward arc\n      arc = arcs[index];\n    } else {\n      // reverse arc\n      arc = arcs[~index].slice().reverse();\n    }\n\n    coordinates.push.apply(coordinates, arc);\n  } // provide fresh copies of coordinate arrays\n\n\n  for (var j = 0, jj = coordinates.length; j < jj; ++j) {\n    coordinates[j] = coordinates[j].slice();\n  }\n\n  return coordinates;\n}\n/**\n * Create a point from a TopoJSON geometry object.\n *\n * @param {TopoJSONPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {Point} Geometry.\n */\n\n\nfunction readPointGeometry(object, scale, translate) {\n  var coordinates = object['coordinates'];\n\n  if (scale && translate) {\n    transformVertex(coordinates, scale, translate);\n  }\n\n  return new Point(coordinates);\n}\n/**\n * Create a multi-point from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {MultiPoint} Geometry.\n */\n\n\nfunction readMultiPointGeometry(object, scale, translate) {\n  var coordinates = object['coordinates'];\n\n  if (scale && translate) {\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n      transformVertex(coordinates[i], scale, translate);\n    }\n  }\n\n  return new MultiPoint(coordinates);\n}\n/**\n * Create a linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {LineString} Geometry.\n */\n\n\nfunction readLineStringGeometry(object, arcs) {\n  var coordinates = concatenateArcs(object['arcs'], arcs);\n  return new LineString(coordinates);\n}\n/**\n * Create a multi-linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiLineString} Geometry.\n */\n\n\nfunction readMultiLineStringGeometry(object, arcs) {\n  var coordinates = [];\n\n  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n\n  return new MultiLineString(coordinates);\n}\n/**\n * Create a polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {Polygon} Geometry.\n */\n\n\nfunction readPolygonGeometry(object, arcs) {\n  var coordinates = [];\n\n  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n\n  return new Polygon(coordinates);\n}\n/**\n * Create a multi-polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiPolygon} Geometry.\n */\n\n\nfunction readMultiPolygonGeometry(object, arcs) {\n  var coordinates = [];\n\n  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    // for each polygon\n    var polyArray = object['arcs'][i];\n    var ringCoords = [];\n\n    for (var j = 0, jj = polyArray.length; j < jj; ++j) {\n      // for each ring\n      ringCoords[j] = concatenateArcs(polyArray[j], arcs);\n    }\n\n    coordinates[i] = ringCoords;\n  }\n\n  return new MultiPolygon(coordinates);\n}\n/**\n * Create features from a TopoJSON GeometryCollection object.\n *\n * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry\n *     object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n * @return {Array<Feature>} Array of features.\n */\n\n\nfunction readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, opt_options) {\n  var geometries = collection['geometries'];\n  var features = [];\n\n  for (var i = 0, ii = geometries.length; i < ii; ++i) {\n    features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, opt_options);\n  }\n\n  return features;\n}\n/**\n * Create a feature from a TopoJSON geometry object.\n *\n * @param {TopoJSONGeometry} object TopoJSON geometry object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n * @return {Feature} Feature.\n */\n\n\nfunction readFeatureFromGeometry(object, arcs, scale, translate, property, name, opt_options) {\n  var geometry = null;\n  var type = object.type;\n\n  if (type) {\n    var geometryReader = GEOMETRY_READERS[type];\n\n    if (type === 'Point' || type === 'MultiPoint') {\n      geometry = geometryReader(object, scale, translate);\n    } else {\n      geometry = geometryReader(object, arcs);\n    }\n\n    geometry = transformGeometryWithOptions(geometry, false, opt_options);\n  }\n\n  var feature = new Feature({\n    geometry: geometry\n  });\n\n  if (object.id !== undefined) {\n    feature.setId(object.id);\n  }\n\n  var properties = object.properties;\n\n  if (property) {\n    if (!properties) {\n      properties = {};\n    }\n\n    properties[property] = name;\n  }\n\n  if (properties) {\n    feature.setProperties(properties, true);\n  }\n\n  return feature;\n}\n/**\n * Apply a linear transform to array of arcs.  The provided array of arcs is\n * modified in place.\n *\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\n\n\nfunction transformArcs(arcs, scale, translate) {\n  for (var i = 0, ii = arcs.length; i < ii; ++i) {\n    transformArc(arcs[i], scale, translate);\n  }\n}\n/**\n * Apply a linear transform to an arc.  The provided arc is modified in place.\n *\n * @param {Array<import(\"../coordinate.js\").Coordinate>} arc Arc.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\n\n\nfunction transformArc(arc, scale, translate) {\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0, ii = arc.length; i < ii; ++i) {\n    var vertex = arc[i];\n    x += vertex[0];\n    y += vertex[1];\n    vertex[0] = x;\n    vertex[1] = y;\n    transformVertex(vertex, scale, translate);\n  }\n}\n/**\n * Apply a linear transform to a vertex.  The provided vertex is modified in\n * place.\n *\n * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\n\n\nfunction transformVertex(vertex, scale, translate) {\n  vertex[0] = vertex[0] * scale[0] + translate[0];\n  vertex[1] = vertex[1] * scale[1] + translate[1];\n}\n\nexport default TopoJSON;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/format/TopoJSON.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","Feature","JSONFeature","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","get","getProjection","transformGeometryWithOptions","TopoJSON","_super","opt_options","_this","options","layerName_","layerName","layers_","layers","dataProjection","readFeaturesFromObject","object","type","topoJSONTopology","transform","scale","translate","arcs","transformArcs","features","topoJSONFeatures","property","feature","objectName","indexOf","push","apply","readFeaturesFromGeometryCollection","readFeatureFromGeometry","readProjectionFromObject","GEOMETRY_READERS","readPointGeometry","readLineStringGeometry","readPolygonGeometry","readMultiPointGeometry","readMultiLineStringGeometry","readMultiPolygonGeometry","concatenateArcs","indices","coordinates","index","arc","i","ii","length","pop","slice","reverse","j","jj","transformVertex","polyArray","ringCoords","collection","name","geometries","geometry","geometryReader","id","undefined","setId","properties","setProperties","transformArc","x","y","vertex"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/TopoJSON\n */\nimport Feature from '../Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n/**\n * @typedef {import(\"topojson-specification\").Topology} TopoJSONTopology\n * @typedef {import(\"topojson-specification\").GeometryCollection} TopoJSONGeometryCollection\n * @typedef {import(\"topojson-specification\").GeometryObject} TopoJSONGeometry\n * @typedef {import(\"topojson-specification\").Point} TopoJSONPoint\n * @typedef {import(\"topojson-specification\").MultiPoint} TopoJSONMultiPoint\n * @typedef {import(\"topojson-specification\").LineString} TopoJSONLineString\n * @typedef {import(\"topojson-specification\").MultiLineString} TopoJSONMultiLineString\n * @typedef {import(\"topojson-specification\").Polygon} TopoJSONPolygon\n * @typedef {import(\"topojson-specification\").MultiPolygon} TopoJSONMultiPolygon\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {string} [layerName] Set the name of the TopoJSON topology\n * `objects`'s children as feature property with the specified name. This means\n * that when set to `'layer'`, a topology like\n * ```\n * {\n *   \"type\": \"Topology\",\n *   \"objects\": {\n *     \"example\": {\n *       \"type\": \"GeometryCollection\",\n *       \"geometries\": []\n *     }\n *   }\n * }\n * ```\n * will result in features that have a property `'layer'` set to `'example'`.\n * When not set, no property will be added to features.\n * @property {Array<string>} [layers] Names of the TopoJSON topology's\n * `objects`'s children to read features from.  If not provided, features will\n * be read from all children.\n */\n/**\n * @classdesc\n * Feature format for reading data in the TopoJSON format.\n *\n * @api\n */\nvar TopoJSON = /** @class */ (function (_super) {\n    __extends(TopoJSON, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function TopoJSON(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @private\n         * @type {string|undefined}\n         */\n        _this.layerName_ = options.layerName;\n        /**\n         * @private\n         * @type {?Array<string>}\n         */\n        _this.layers_ = options.layers ? options.layers : null;\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n        _this.dataProjection = getProjection(options.dataProjection ? options.dataProjection : 'EPSG:4326');\n        return _this;\n    }\n    /**\n     * @param {Object} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {Array<Feature>} Features.\n     */\n    TopoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {\n        if (object.type == 'Topology') {\n            var topoJSONTopology = /** @type {TopoJSONTopology} */ (object);\n            var transform = void 0, scale = null, translate = null;\n            if (topoJSONTopology['transform']) {\n                transform = topoJSONTopology['transform'];\n                scale = transform['scale'];\n                translate = transform['translate'];\n            }\n            var arcs = topoJSONTopology['arcs'];\n            if (transform) {\n                transformArcs(arcs, scale, translate);\n            }\n            /** @type {Array<Feature>} */\n            var features = [];\n            var topoJSONFeatures = topoJSONTopology['objects'];\n            var property = this.layerName_;\n            var feature = void 0;\n            for (var objectName in topoJSONFeatures) {\n                if (this.layers_ && this.layers_.indexOf(objectName) == -1) {\n                    continue;\n                }\n                if (topoJSONFeatures[objectName].type === 'GeometryCollection') {\n                    feature = /** @type {TopoJSONGeometryCollection} */ (topoJSONFeatures[objectName]);\n                    features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, opt_options));\n                }\n                else {\n                    feature = /** @type {TopoJSONGeometry} */ (topoJSONFeatures[objectName]);\n                    features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, opt_options));\n                }\n            }\n            return features;\n        }\n        else {\n            return [];\n        }\n    };\n    /**\n     * @param {Object} object Object.\n     * @protected\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     */\n    TopoJSON.prototype.readProjectionFromObject = function (object) {\n        return this.dataProjection;\n    };\n    return TopoJSON;\n}(JSONFeature));\n/**\n * @const\n * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import(\"../geom/Geometry.js\").default>}\n */\nvar GEOMETRY_READERS = {\n    'Point': readPointGeometry,\n    'LineString': readLineStringGeometry,\n    'Polygon': readPolygonGeometry,\n    'MultiPoint': readMultiPointGeometry,\n    'MultiLineString': readMultiLineStringGeometry,\n    'MultiPolygon': readMultiPolygonGeometry,\n};\n/**\n * Concatenate arcs into a coordinate array.\n * @param {Array<number>} indices Indices of arcs to concatenate.  Negative\n *     values indicate arcs need to be reversed.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs (already\n *     transformed).\n * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates array.\n */\nfunction concatenateArcs(indices, arcs) {\n    /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n    var coordinates = [];\n    var index, arc;\n    for (var i = 0, ii = indices.length; i < ii; ++i) {\n        index = indices[i];\n        if (i > 0) {\n            // splicing together arcs, discard last point\n            coordinates.pop();\n        }\n        if (index >= 0) {\n            // forward arc\n            arc = arcs[index];\n        }\n        else {\n            // reverse arc\n            arc = arcs[~index].slice().reverse();\n        }\n        coordinates.push.apply(coordinates, arc);\n    }\n    // provide fresh copies of coordinate arrays\n    for (var j = 0, jj = coordinates.length; j < jj; ++j) {\n        coordinates[j] = coordinates[j].slice();\n    }\n    return coordinates;\n}\n/**\n * Create a point from a TopoJSON geometry object.\n *\n * @param {TopoJSONPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {Point} Geometry.\n */\nfunction readPointGeometry(object, scale, translate) {\n    var coordinates = object['coordinates'];\n    if (scale && translate) {\n        transformVertex(coordinates, scale, translate);\n    }\n    return new Point(coordinates);\n}\n/**\n * Create a multi-point from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {MultiPoint} Geometry.\n */\nfunction readMultiPointGeometry(object, scale, translate) {\n    var coordinates = object['coordinates'];\n    if (scale && translate) {\n        for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n            transformVertex(coordinates[i], scale, translate);\n        }\n    }\n    return new MultiPoint(coordinates);\n}\n/**\n * Create a linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {LineString} Geometry.\n */\nfunction readLineStringGeometry(object, arcs) {\n    var coordinates = concatenateArcs(object['arcs'], arcs);\n    return new LineString(coordinates);\n}\n/**\n * Create a multi-linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiLineString} Geometry.\n */\nfunction readMultiLineStringGeometry(object, arcs) {\n    var coordinates = [];\n    for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n        coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n    }\n    return new MultiLineString(coordinates);\n}\n/**\n * Create a polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {Polygon} Geometry.\n */\nfunction readPolygonGeometry(object, arcs) {\n    var coordinates = [];\n    for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n        coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n    }\n    return new Polygon(coordinates);\n}\n/**\n * Create a multi-polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiPolygon} Geometry.\n */\nfunction readMultiPolygonGeometry(object, arcs) {\n    var coordinates = [];\n    for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n        // for each polygon\n        var polyArray = object['arcs'][i];\n        var ringCoords = [];\n        for (var j = 0, jj = polyArray.length; j < jj; ++j) {\n            // for each ring\n            ringCoords[j] = concatenateArcs(polyArray[j], arcs);\n        }\n        coordinates[i] = ringCoords;\n    }\n    return new MultiPolygon(coordinates);\n}\n/**\n * Create features from a TopoJSON GeometryCollection object.\n *\n * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry\n *     object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n * @return {Array<Feature>} Array of features.\n */\nfunction readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, opt_options) {\n    var geometries = collection['geometries'];\n    var features = [];\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n        features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, opt_options);\n    }\n    return features;\n}\n/**\n * Create a feature from a TopoJSON geometry object.\n *\n * @param {TopoJSONGeometry} object TopoJSON geometry object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n * @return {Feature} Feature.\n */\nfunction readFeatureFromGeometry(object, arcs, scale, translate, property, name, opt_options) {\n    var geometry = null;\n    var type = object.type;\n    if (type) {\n        var geometryReader = GEOMETRY_READERS[type];\n        if (type === 'Point' || type === 'MultiPoint') {\n            geometry = geometryReader(object, scale, translate);\n        }\n        else {\n            geometry = geometryReader(object, arcs);\n        }\n        geometry = transformGeometryWithOptions(geometry, false, opt_options);\n    }\n    var feature = new Feature({ geometry: geometry });\n    if (object.id !== undefined) {\n        feature.setId(object.id);\n    }\n    var properties = object.properties;\n    if (property) {\n        if (!properties) {\n            properties = {};\n        }\n        properties[property] = name;\n    }\n    if (properties) {\n        feature.setProperties(properties, true);\n    }\n    return feature;\n}\n/**\n * Apply a linear transform to array of arcs.  The provided array of arcs is\n * modified in place.\n *\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArcs(arcs, scale, translate) {\n    for (var i = 0, ii = arcs.length; i < ii; ++i) {\n        transformArc(arcs[i], scale, translate);\n    }\n}\n/**\n * Apply a linear transform to an arc.  The provided arc is modified in place.\n *\n * @param {Array<import(\"../coordinate.js\").Coordinate>} arc Arc.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArc(arc, scale, translate) {\n    var x = 0;\n    var y = 0;\n    for (var i = 0, ii = arc.length; i < ii; ++i) {\n        var vertex = arc[i];\n        x += vertex[0];\n        y += vertex[1];\n        vertex[0] = x;\n        vertex[1] = y;\n        transformVertex(vertex, scale, translate);\n    }\n}\n/**\n * Apply a linear transform to a vertex.  The provided vertex is modified in\n * place.\n *\n * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformVertex(vertex, scale, translate) {\n    vertex[0] = vertex[0] * scale[0] + translate[0];\n    vertex[1] = vertex[1] * scale[1] + translate[1];\n}\nexport default TopoJSON;\n"]},"metadata":{},"sourceType":"module"}