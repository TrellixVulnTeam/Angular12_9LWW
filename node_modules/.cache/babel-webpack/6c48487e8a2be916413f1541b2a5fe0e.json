{"ast":null,"code":"import explode from '@turf/explode';\nimport centroid from '@turf/center';\nimport nearestPoint from '@turf/nearest-point';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { featureCollection, point, feature } from '@turf/helpers';\n/**\n * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @name pointOnFeature\n * @param {GeoJSON} geojson any Feature or FeatureCollection\n * @returns {Feature<Point>} a point on the surface of `input`\n * @example\n * var polygon = turf.polygon([[\n *   [116, -36],\n *   [131, -32],\n *   [146, -43],\n *   [155, -25],\n *   [133, -9],\n *   [111, -22],\n *   [116, -36]\n * ]]);\n *\n * var pointOnPolygon = turf.pointOnFeature(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, pointOnPolygon];\n */\n\nfunction pointOnFeature(geojson) {\n  // normalize\n  var fc = normalize(geojson); // get centroid\n\n  var cent = centroid(fc); // check to see if centroid is on surface\n\n  var onSurface = false;\n  var i = 0;\n\n  while (!onSurface && i < fc.features.length) {\n    var geom = fc.features[i].geometry;\n    var x, y, x1, y1, x2, y2, k;\n    var onLine = false;\n\n    if (geom.type === \"Point\") {\n      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {\n        onSurface = true;\n      }\n    } else if (geom.type === \"MultiPoint\") {\n      var onMultiPoint = false;\n      k = 0;\n\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n\n        k++;\n      }\n    } else if (geom.type === \"LineString\") {\n      k = 0;\n\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n\n        k++;\n      }\n    } else if (geom.type === \"MultiLineString\") {\n      var j = 0;\n\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        k = 0;\n        var line = geom.coordinates[j];\n\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n\n          k++;\n        }\n\n        j++;\n      }\n    } else if (geom.type === \"Polygon\" || geom.type === \"MultiPolygon\") {\n      if (booleanPointInPolygon(cent, geom)) {\n        onSurface = true;\n      }\n    }\n\n    i++;\n  }\n\n  if (onSurface) {\n    return cent;\n  } else {\n    var vertices = featureCollection([]);\n\n    for (i = 0; i < fc.features.length; i++) {\n      vertices.features = vertices.features.concat(explode(fc.features[i]).features);\n    } // Remove distanceToPoint properties from nearestPoint()\n\n\n    return point(nearestPoint(cent, vertices).geometry.coordinates);\n  }\n}\n/**\n * Normalizes any GeoJSON to a FeatureCollection\n *\n * @private\n * @name normalize\n * @param {GeoJSON} geojson Any GeoJSON\n * @returns {FeatureCollection} FeatureCollection\n */\n\n\nfunction normalize(geojson) {\n  if (geojson.type !== \"FeatureCollection\") {\n    if (geojson.type !== \"Feature\") {\n      return featureCollection([feature(geojson)]);\n    }\n\n    return featureCollection([geojson]);\n  }\n\n  return geojson;\n}\n\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n  var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n  return ab === ap + pb;\n}\n\nexport default pointOnFeature;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/@turf/point-on-feature/dist/es/index.js"],"names":["explode","centroid","nearestPoint","booleanPointInPolygon","featureCollection","point","feature","pointOnFeature","geojson","fc","normalize","cent","onSurface","i","features","length","geom","geometry","x","y","x1","y1","x2","y2","k","onLine","type","coordinates","onMultiPoint","pointOnSegment","j","line","vertices","concat","ab","Math","sqrt","ap","pb"],"mappings":"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","sourcesContent":["import explode from '@turf/explode';\nimport centroid from '@turf/center';\nimport nearestPoint from '@turf/nearest-point';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { featureCollection, point, feature } from '@turf/helpers';\n\n/**\n * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @name pointOnFeature\n * @param {GeoJSON} geojson any Feature or FeatureCollection\n * @returns {Feature<Point>} a point on the surface of `input`\n * @example\n * var polygon = turf.polygon([[\n *   [116, -36],\n *   [131, -32],\n *   [146, -43],\n *   [155, -25],\n *   [133, -9],\n *   [111, -22],\n *   [116, -36]\n * ]]);\n *\n * var pointOnPolygon = turf.pointOnFeature(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, pointOnPolygon];\n */\nfunction pointOnFeature(geojson) {\n  // normalize\n  var fc = normalize(geojson);\n\n  // get centroid\n  var cent = centroid(fc);\n\n  // check to see if centroid is on surface\n  var onSurface = false;\n  var i = 0;\n  while (!onSurface && i < fc.features.length) {\n    var geom = fc.features[i].geometry;\n    var x, y, x1, y1, x2, y2, k;\n    var onLine = false;\n    if (geom.type === \"Point\") {\n      if (\n        cent.geometry.coordinates[0] === geom.coordinates[0] &&\n        cent.geometry.coordinates[1] === geom.coordinates[1]\n      ) {\n        onSurface = true;\n      }\n    } else if (geom.type === \"MultiPoint\") {\n      var onMultiPoint = false;\n      k = 0;\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (\n          cent.geometry.coordinates[0] === geom.coordinates[k][0] &&\n          cent.geometry.coordinates[1] === geom.coordinates[k][1]\n        ) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"LineString\") {\n      k = 0;\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"MultiLineString\") {\n      var j = 0;\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        k = 0;\n        var line = geom.coordinates[j];\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n          k++;\n        }\n        j++;\n      }\n    } else if (geom.type === \"Polygon\" || geom.type === \"MultiPolygon\") {\n      if (booleanPointInPolygon(cent, geom)) {\n        onSurface = true;\n      }\n    }\n    i++;\n  }\n  if (onSurface) {\n    return cent;\n  } else {\n    var vertices = featureCollection([]);\n    for (i = 0; i < fc.features.length; i++) {\n      vertices.features = vertices.features.concat(\n        explode(fc.features[i]).features\n      );\n    }\n    // Remove distanceToPoint properties from nearestPoint()\n    return point(nearestPoint(cent, vertices).geometry.coordinates);\n  }\n}\n\n/**\n * Normalizes any GeoJSON to a FeatureCollection\n *\n * @private\n * @name normalize\n * @param {GeoJSON} geojson Any GeoJSON\n * @returns {FeatureCollection} FeatureCollection\n */\nfunction normalize(geojson) {\n  if (geojson.type !== \"FeatureCollection\") {\n    if (geojson.type !== \"Feature\") {\n      return featureCollection([feature(geojson)]);\n    }\n    return featureCollection([geojson]);\n  }\n  return geojson;\n}\n\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n  var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n  return ab === ap + pb;\n}\n\nexport default pointOnFeature;\n"]},"metadata":{},"sourceType":"module"}