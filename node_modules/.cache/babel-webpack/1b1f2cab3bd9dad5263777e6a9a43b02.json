{"ast":null,"code":"/**\n * @module ol/format/MVT\n */\n//FIXME Implement projection handling\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport FeatureFormat, { transformGeometryWithOptions } from './Feature.js';\nimport FormatType from './FormatType.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport PBF from 'pbf';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport Projection from '../proj/Projection.js';\nimport RenderFeature from '../render/Feature.js';\nimport Units from '../proj/Units.js';\nimport { assert } from '../asserts.js';\nimport { get } from '../proj.js';\nimport { linearRingIsClockwise } from '../geom/flat/orient.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../Feature.js\").FeatureClass} [featureClass] Class for features returned by\n * {@link module:ol/format/MVT~MVT#readFeatures}. Set to {@link module:ol/Feature~Feature} to get full editing and geometry\n * support at the cost of decreased rendering performance. The default is\n * {@link module:ol/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.\n * @property {string} [geometryName='geometry'] Geometry name to use when creating features.\n * @property {string} [layerName='layer'] Name of the feature attribute that holds the layer name.\n * @property {Array<string>} [layers] Layers to read features from. If not provided, features will be read from all\n * @property {string} [idProperty] Optional property that will be assigned as the feature id and removed from the properties.\n * layers.\n */\n\n/**\n * @classdesc\n * Feature format for reading data in the Mapbox MVT format.\n *\n * @param {Options} [opt_options] Options.\n * @api\n */\n\nvar MVT = function (_super) {\n  __extends(MVT, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n\n\n  function MVT(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    /**\n     * @type {Projection}\n     */\n\n    _this.dataProjection = new Projection({\n      code: '',\n      units: Units.TILE_PIXELS\n    });\n    /**\n     * @private\n     * @type {import(\"../Feature.js\").FeatureClass}\n     */\n\n    _this.featureClass_ = options.featureClass ? options.featureClass : RenderFeature;\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n\n    _this.geometryName_ = options.geometryName;\n    /**\n     * @private\n     * @type {string}\n     */\n\n    _this.layerName_ = options.layerName ? options.layerName : 'layer';\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n\n    _this.layers_ = options.layers ? options.layers : null;\n    /**\n     * @private\n     * @type {string}\n     */\n\n    _this.idProperty_ = options.idProperty;\n    _this.supportedMediaTypes = ['application/vnd.mapbox-vector-tile', 'application/x-protobuf'];\n    return _this;\n  }\n  /**\n   * Read the raw geometry from the pbf offset stored in a raw feature's geometry\n   * property.\n   * @param {PBF} pbf PBF.\n   * @param {Object} feature Raw feature.\n   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.\n   * @param {Array<number>} ends Array to store ends in.\n   * @private\n   */\n\n\n  MVT.prototype.readRawGeometry_ = function (pbf, feature, flatCoordinates, ends) {\n    pbf.pos = feature.geometry;\n    var end = pbf.readVarint() + pbf.pos;\n    var cmd = 1;\n    var length = 0;\n    var x = 0;\n    var y = 0;\n    var coordsLen = 0;\n    var currentEnd = 0;\n\n    while (pbf.pos < end) {\n      if (!length) {\n        var cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          // moveTo\n          if (coordsLen > currentEnd) {\n            ends.push(coordsLen);\n            currentEnd = coordsLen;\n          }\n        }\n\n        flatCoordinates.push(x, y);\n        coordsLen += 2;\n      } else if (cmd === 7) {\n        if (coordsLen > currentEnd) {\n          // close polygon\n          flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);\n          coordsLen += 2;\n        }\n      } else {\n        assert(false, 59); // Invalid command found in the PBF\n      }\n    }\n\n    if (coordsLen > currentEnd) {\n      ends.push(coordsLen);\n      currentEnd = coordsLen;\n    }\n  };\n  /**\n   * @private\n   * @param {PBF} pbf PBF\n   * @param {Object} rawFeature Raw Mapbox feature.\n   * @param {import(\"./Feature.js\").ReadOptions} options Read options.\n   * @return {import(\"../Feature.js\").FeatureLike} Feature.\n   */\n\n\n  MVT.prototype.createFeature_ = function (pbf, rawFeature, options) {\n    var type = rawFeature.type;\n\n    if (type === 0) {\n      return null;\n    }\n\n    var feature;\n    var values = rawFeature.properties;\n    var id;\n\n    if (!this.idProperty_) {\n      id = rawFeature.id;\n    } else {\n      id = values[this.idProperty_];\n      delete values[this.idProperty_];\n    }\n\n    values[this.layerName_] = rawFeature.layer.name;\n    var flatCoordinates = [];\n    var ends = [];\n    this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);\n    var geometryType = getGeometryType(type, ends.length);\n\n    if (this.featureClass_ === RenderFeature) {\n      feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);\n      feature.transform(options.dataProjection);\n    } else {\n      var geom = void 0;\n\n      if (geometryType == GeometryType.POLYGON) {\n        var endss = [];\n        var offset = 0;\n        var prevEndIndex = 0;\n\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          var end = ends[i]; // classifies an array of rings into polygons with outer rings and holes\n\n          if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n            endss.push(ends.slice(prevEndIndex, i + 1));\n          } else {\n            if (endss.length === 0) {\n              continue;\n            }\n\n            endss[endss.length - 1].push(ends[prevEndIndex]);\n          }\n\n          prevEndIndex = i + 1;\n          offset = end;\n        }\n\n        if (endss.length > 1) {\n          geom = new MultiPolygon(flatCoordinates, GeometryLayout.XY, endss);\n        } else {\n          geom = new Polygon(flatCoordinates, GeometryLayout.XY, ends);\n        }\n      } else {\n        geom = geometryType === GeometryType.POINT ? new Point(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.LINE_STRING ? new LineString(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.POLYGON ? new Polygon(flatCoordinates, GeometryLayout.XY, ends) : geometryType === GeometryType.MULTI_POINT ? new MultiPoint(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.MULTI_LINE_STRING ? new MultiLineString(flatCoordinates, GeometryLayout.XY, ends) : null;\n      }\n\n      var ctor = this.featureClass_;\n      feature = new ctor();\n\n      if (this.geometryName_) {\n        feature.setGeometryName(this.geometryName_);\n      }\n\n      var geometry = transformGeometryWithOptions(geom, false, options);\n      feature.setGeometry(geometry);\n      feature.setId(id);\n      feature.setProperties(values, true);\n    }\n\n    return feature;\n  };\n  /**\n   * @return {import(\"./FormatType.js\").default} Format.\n   */\n\n\n  MVT.prototype.getType = function () {\n    return FormatType.ARRAY_BUFFER;\n  };\n  /**\n   * Read all features.\n   *\n   * @param {ArrayBuffer} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n\n\n  MVT.prototype.readFeatures = function (source, opt_options) {\n    var layers = this.layers_;\n    var options = this.adaptOptions(opt_options);\n    var dataProjection = get(options.dataProjection);\n    dataProjection.setWorldExtent(options.extent);\n    options.dataProjection = dataProjection;\n    var pbf = new PBF(source);\n    var pbfLayers = pbf.readFields(layersPBFReader, {});\n    var features = [];\n\n    for (var name_1 in pbfLayers) {\n      if (layers && layers.indexOf(name_1) == -1) {\n        continue;\n      }\n\n      var pbfLayer = pbfLayers[name_1];\n      var extent = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\n      dataProjection.setExtent(extent);\n\n      for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {\n        var rawFeature = readRawFeature(pbf, pbfLayer, i);\n        features.push(this.createFeature_(pbf, rawFeature, options));\n      }\n    }\n\n    return features;\n  };\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n\n\n  MVT.prototype.readProjection = function (source) {\n    return this.dataProjection;\n  };\n  /**\n   * Sets the layers that features will be read from.\n   * @param {Array<string>} layers Layers.\n   * @api\n   */\n\n\n  MVT.prototype.setLayers = function (layers) {\n    this.layers_ = layers;\n  };\n\n  return MVT;\n}(FeatureFormat);\n/**\n * Reader callback for parsing layers.\n * @param {number} tag The tag.\n * @param {Object} layers The layers object.\n * @param {PBF} pbf The PBF.\n */\n\n\nfunction layersPBFReader(tag, layers, pbf) {\n  if (tag === 3) {\n    var layer = {\n      keys: [],\n      values: [],\n      features: []\n    };\n    var end = pbf.readVarint() + pbf.pos;\n    pbf.readFields(layerPBFReader, layer, end);\n    layer.length = layer.features.length;\n\n    if (layer.length) {\n      layers[layer.name] = layer;\n    }\n  }\n}\n/**\n * Reader callback for parsing layer.\n * @param {number} tag The tag.\n * @param {Object} layer The layer object.\n * @param {PBF} pbf The PBF.\n */\n\n\nfunction layerPBFReader(tag, layer, pbf) {\n  if (tag === 15) {\n    layer.version = pbf.readVarint();\n  } else if (tag === 1) {\n    layer.name = pbf.readString();\n  } else if (tag === 5) {\n    layer.extent = pbf.readVarint();\n  } else if (tag === 2) {\n    layer.features.push(pbf.pos);\n  } else if (tag === 3) {\n    layer.keys.push(pbf.readString());\n  } else if (tag === 4) {\n    var value = null;\n    var end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n      tag = pbf.readVarint() >> 3;\n      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;\n    }\n\n    layer.values.push(value);\n  }\n}\n/**\n * Reader callback for parsing feature.\n * @param {number} tag The tag.\n * @param {Object} feature The feature object.\n * @param {PBF} pbf The PBF.\n */\n\n\nfunction featurePBFReader(tag, feature, pbf) {\n  if (tag == 1) {\n    feature.id = pbf.readVarint();\n  } else if (tag == 2) {\n    var end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n      var key = feature.layer.keys[pbf.readVarint()];\n      var value = feature.layer.values[pbf.readVarint()];\n      feature.properties[key] = value;\n    }\n  } else if (tag == 3) {\n    feature.type = pbf.readVarint();\n  } else if (tag == 4) {\n    feature.geometry = pbf.pos;\n  }\n}\n/**\n * Read a raw feature from the pbf offset stored at index `i` in the raw layer.\n * @param {PBF} pbf PBF.\n * @param {Object} layer Raw layer.\n * @param {number} i Index of the feature in the raw layer's `features` array.\n * @return {Object} Raw feature.\n */\n\n\nfunction readRawFeature(pbf, layer, i) {\n  pbf.pos = layer.features[i];\n  var end = pbf.readVarint() + pbf.pos;\n  var feature = {\n    layer: layer,\n    type: 0,\n    properties: {}\n  };\n  pbf.readFields(featurePBFReader, feature, end);\n  return feature;\n}\n/**\n * @param {number} type The raw feature's geometry type\n * @param {number} numEnds Number of ends of the flat coordinates of the\n * geometry.\n * @return {import(\"../geom/GeometryType.js\").default} The geometry type.\n */\n\n\nfunction getGeometryType(type, numEnds) {\n  /** @type {import(\"../geom/GeometryType.js\").default} */\n  var geometryType;\n\n  if (type === 1) {\n    geometryType = numEnds === 1 ? GeometryType.POINT : GeometryType.MULTI_POINT;\n  } else if (type === 2) {\n    geometryType = numEnds === 1 ? GeometryType.LINE_STRING : GeometryType.MULTI_LINE_STRING;\n  } else if (type === 3) {\n    geometryType = GeometryType.POLYGON; // MultiPolygon not relevant for rendering - winding order determines\n    // outer rings of polygons.\n  }\n\n  return geometryType;\n}\n\nexport default MVT;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/format/MVT.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","FeatureFormat","transformGeometryWithOptions","FormatType","GeometryLayout","GeometryType","LineString","MultiLineString","MultiPoint","MultiPolygon","PBF","Point","Polygon","Projection","RenderFeature","Units","assert","get","linearRingIsClockwise","MVT","_super","opt_options","_this","options","dataProjection","code","units","TILE_PIXELS","featureClass_","featureClass","geometryName_","geometryName","layerName_","layerName","layers_","layers","idProperty_","idProperty","supportedMediaTypes","readRawGeometry_","pbf","feature","flatCoordinates","ends","pos","geometry","end","readVarint","cmd","length","x","y","coordsLen","currentEnd","cmdLen","readSVarint","push","createFeature_","rawFeature","type","values","properties","id","layer","name","geometryType","getGeometryType","transform","geom","POLYGON","endss","offset","prevEndIndex","i","ii","slice","XY","POINT","LINE_STRING","MULTI_POINT","MULTI_LINE_STRING","ctor","setGeometryName","setGeometry","setId","setProperties","getType","ARRAY_BUFFER","readFeatures","source","adaptOptions","setWorldExtent","extent","pbfLayers","readFields","layersPBFReader","features","name_1","indexOf","pbfLayer","setExtent","readRawFeature","readProjection","setLayers","tag","keys","layerPBFReader","version","readString","value","readFloat","readDouble","readVarint64","readBoolean","featurePBFReader","key","numEnds"],"mappings":"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","sourcesContent":["/**\n * @module ol/format/MVT\n */\n//FIXME Implement projection handling\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport FeatureFormat, { transformGeometryWithOptions } from './Feature.js';\nimport FormatType from './FormatType.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport PBF from 'pbf';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport Projection from '../proj/Projection.js';\nimport RenderFeature from '../render/Feature.js';\nimport Units from '../proj/Units.js';\nimport { assert } from '../asserts.js';\nimport { get } from '../proj.js';\nimport { linearRingIsClockwise } from '../geom/flat/orient.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../Feature.js\").FeatureClass} [featureClass] Class for features returned by\n * {@link module:ol/format/MVT~MVT#readFeatures}. Set to {@link module:ol/Feature~Feature} to get full editing and geometry\n * support at the cost of decreased rendering performance. The default is\n * {@link module:ol/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.\n * @property {string} [geometryName='geometry'] Geometry name to use when creating features.\n * @property {string} [layerName='layer'] Name of the feature attribute that holds the layer name.\n * @property {Array<string>} [layers] Layers to read features from. If not provided, features will be read from all\n * @property {string} [idProperty] Optional property that will be assigned as the feature id and removed from the properties.\n * layers.\n */\n/**\n * @classdesc\n * Feature format for reading data in the Mapbox MVT format.\n *\n * @param {Options} [opt_options] Options.\n * @api\n */\nvar MVT = /** @class */ (function (_super) {\n    __extends(MVT, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function MVT(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @type {Projection}\n         */\n        _this.dataProjection = new Projection({\n            code: '',\n            units: Units.TILE_PIXELS,\n        });\n        /**\n         * @private\n         * @type {import(\"../Feature.js\").FeatureClass}\n         */\n        _this.featureClass_ = options.featureClass\n            ? options.featureClass\n            : RenderFeature;\n        /**\n         * @private\n         * @type {string|undefined}\n         */\n        _this.geometryName_ = options.geometryName;\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.layerName_ = options.layerName ? options.layerName : 'layer';\n        /**\n         * @private\n         * @type {Array<string>}\n         */\n        _this.layers_ = options.layers ? options.layers : null;\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.idProperty_ = options.idProperty;\n        _this.supportedMediaTypes = [\n            'application/vnd.mapbox-vector-tile',\n            'application/x-protobuf',\n        ];\n        return _this;\n    }\n    /**\n     * Read the raw geometry from the pbf offset stored in a raw feature's geometry\n     * property.\n     * @param {PBF} pbf PBF.\n     * @param {Object} feature Raw feature.\n     * @param {Array<number>} flatCoordinates Array to store flat coordinates in.\n     * @param {Array<number>} ends Array to store ends in.\n     * @private\n     */\n    MVT.prototype.readRawGeometry_ = function (pbf, feature, flatCoordinates, ends) {\n        pbf.pos = feature.geometry;\n        var end = pbf.readVarint() + pbf.pos;\n        var cmd = 1;\n        var length = 0;\n        var x = 0;\n        var y = 0;\n        var coordsLen = 0;\n        var currentEnd = 0;\n        while (pbf.pos < end) {\n            if (!length) {\n                var cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (cmd === 1) {\n                    // moveTo\n                    if (coordsLen > currentEnd) {\n                        ends.push(coordsLen);\n                        currentEnd = coordsLen;\n                    }\n                }\n                flatCoordinates.push(x, y);\n                coordsLen += 2;\n            }\n            else if (cmd === 7) {\n                if (coordsLen > currentEnd) {\n                    // close polygon\n                    flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);\n                    coordsLen += 2;\n                }\n            }\n            else {\n                assert(false, 59); // Invalid command found in the PBF\n            }\n        }\n        if (coordsLen > currentEnd) {\n            ends.push(coordsLen);\n            currentEnd = coordsLen;\n        }\n    };\n    /**\n     * @private\n     * @param {PBF} pbf PBF\n     * @param {Object} rawFeature Raw Mapbox feature.\n     * @param {import(\"./Feature.js\").ReadOptions} options Read options.\n     * @return {import(\"../Feature.js\").FeatureLike} Feature.\n     */\n    MVT.prototype.createFeature_ = function (pbf, rawFeature, options) {\n        var type = rawFeature.type;\n        if (type === 0) {\n            return null;\n        }\n        var feature;\n        var values = rawFeature.properties;\n        var id;\n        if (!this.idProperty_) {\n            id = rawFeature.id;\n        }\n        else {\n            id = values[this.idProperty_];\n            delete values[this.idProperty_];\n        }\n        values[this.layerName_] = rawFeature.layer.name;\n        var flatCoordinates = [];\n        var ends = [];\n        this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);\n        var geometryType = getGeometryType(type, ends.length);\n        if (this.featureClass_ === RenderFeature) {\n            feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);\n            feature.transform(options.dataProjection);\n        }\n        else {\n            var geom = void 0;\n            if (geometryType == GeometryType.POLYGON) {\n                var endss = [];\n                var offset = 0;\n                var prevEndIndex = 0;\n                for (var i = 0, ii = ends.length; i < ii; ++i) {\n                    var end = ends[i];\n                    // classifies an array of rings into polygons with outer rings and holes\n                    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n                        endss.push(ends.slice(prevEndIndex, i + 1));\n                    }\n                    else {\n                        if (endss.length === 0) {\n                            continue;\n                        }\n                        endss[endss.length - 1].push(ends[prevEndIndex]);\n                    }\n                    prevEndIndex = i + 1;\n                    offset = end;\n                }\n                if (endss.length > 1) {\n                    geom = new MultiPolygon(flatCoordinates, GeometryLayout.XY, endss);\n                }\n                else {\n                    geom = new Polygon(flatCoordinates, GeometryLayout.XY, ends);\n                }\n            }\n            else {\n                geom =\n                    geometryType === GeometryType.POINT\n                        ? new Point(flatCoordinates, GeometryLayout.XY)\n                        : geometryType === GeometryType.LINE_STRING\n                            ? new LineString(flatCoordinates, GeometryLayout.XY)\n                            : geometryType === GeometryType.POLYGON\n                                ? new Polygon(flatCoordinates, GeometryLayout.XY, ends)\n                                : geometryType === GeometryType.MULTI_POINT\n                                    ? new MultiPoint(flatCoordinates, GeometryLayout.XY)\n                                    : geometryType === GeometryType.MULTI_LINE_STRING\n                                        ? new MultiLineString(flatCoordinates, GeometryLayout.XY, ends)\n                                        : null;\n            }\n            var ctor = /** @type {typeof import(\"../Feature.js\").default} */ (this.featureClass_);\n            feature = new ctor();\n            if (this.geometryName_) {\n                feature.setGeometryName(this.geometryName_);\n            }\n            var geometry = transformGeometryWithOptions(geom, false, options);\n            feature.setGeometry(geometry);\n            feature.setId(id);\n            feature.setProperties(values, true);\n        }\n        return feature;\n    };\n    /**\n     * @return {import(\"./FormatType.js\").default} Format.\n     */\n    MVT.prototype.getType = function () {\n        return FormatType.ARRAY_BUFFER;\n    };\n    /**\n     * Read all features.\n     *\n     * @param {ArrayBuffer} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n     * @api\n     */\n    MVT.prototype.readFeatures = function (source, opt_options) {\n        var layers = this.layers_;\n        var options = /** @type {import(\"./Feature.js\").ReadOptions} */ (this.adaptOptions(opt_options));\n        var dataProjection = get(options.dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n        options.dataProjection = dataProjection;\n        var pbf = new PBF(/** @type {ArrayBuffer} */ (source));\n        var pbfLayers = pbf.readFields(layersPBFReader, {});\n        var features = [];\n        for (var name_1 in pbfLayers) {\n            if (layers && layers.indexOf(name_1) == -1) {\n                continue;\n            }\n            var pbfLayer = pbfLayers[name_1];\n            var extent = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\n            dataProjection.setExtent(extent);\n            for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {\n                var rawFeature = readRawFeature(pbf, pbfLayer, i);\n                features.push(this.createFeature_(pbf, rawFeature, options));\n            }\n        }\n        return features;\n    };\n    /**\n     * Read the projection from the source.\n     *\n     * @param {Document|Element|Object|string} source Source.\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     * @api\n     */\n    MVT.prototype.readProjection = function (source) {\n        return this.dataProjection;\n    };\n    /**\n     * Sets the layers that features will be read from.\n     * @param {Array<string>} layers Layers.\n     * @api\n     */\n    MVT.prototype.setLayers = function (layers) {\n        this.layers_ = layers;\n    };\n    return MVT;\n}(FeatureFormat));\n/**\n * Reader callback for parsing layers.\n * @param {number} tag The tag.\n * @param {Object} layers The layers object.\n * @param {PBF} pbf The PBF.\n */\nfunction layersPBFReader(tag, layers, pbf) {\n    if (tag === 3) {\n        var layer = {\n            keys: [],\n            values: [],\n            features: [],\n        };\n        var end = pbf.readVarint() + pbf.pos;\n        pbf.readFields(layerPBFReader, layer, end);\n        layer.length = layer.features.length;\n        if (layer.length) {\n            layers[layer.name] = layer;\n        }\n    }\n}\n/**\n * Reader callback for parsing layer.\n * @param {number} tag The tag.\n * @param {Object} layer The layer object.\n * @param {PBF} pbf The PBF.\n */\nfunction layerPBFReader(tag, layer, pbf) {\n    if (tag === 15) {\n        layer.version = pbf.readVarint();\n    }\n    else if (tag === 1) {\n        layer.name = pbf.readString();\n    }\n    else if (tag === 5) {\n        layer.extent = pbf.readVarint();\n    }\n    else if (tag === 2) {\n        layer.features.push(pbf.pos);\n    }\n    else if (tag === 3) {\n        layer.keys.push(pbf.readString());\n    }\n    else if (tag === 4) {\n        var value = null;\n        var end = pbf.readVarint() + pbf.pos;\n        while (pbf.pos < end) {\n            tag = pbf.readVarint() >> 3;\n            value =\n                tag === 1\n                    ? pbf.readString()\n                    : tag === 2\n                        ? pbf.readFloat()\n                        : tag === 3\n                            ? pbf.readDouble()\n                            : tag === 4\n                                ? pbf.readVarint64()\n                                : tag === 5\n                                    ? pbf.readVarint()\n                                    : tag === 6\n                                        ? pbf.readSVarint()\n                                        : tag === 7\n                                            ? pbf.readBoolean()\n                                            : null;\n        }\n        layer.values.push(value);\n    }\n}\n/**\n * Reader callback for parsing feature.\n * @param {number} tag The tag.\n * @param {Object} feature The feature object.\n * @param {PBF} pbf The PBF.\n */\nfunction featurePBFReader(tag, feature, pbf) {\n    if (tag == 1) {\n        feature.id = pbf.readVarint();\n    }\n    else if (tag == 2) {\n        var end = pbf.readVarint() + pbf.pos;\n        while (pbf.pos < end) {\n            var key = feature.layer.keys[pbf.readVarint()];\n            var value = feature.layer.values[pbf.readVarint()];\n            feature.properties[key] = value;\n        }\n    }\n    else if (tag == 3) {\n        feature.type = pbf.readVarint();\n    }\n    else if (tag == 4) {\n        feature.geometry = pbf.pos;\n    }\n}\n/**\n * Read a raw feature from the pbf offset stored at index `i` in the raw layer.\n * @param {PBF} pbf PBF.\n * @param {Object} layer Raw layer.\n * @param {number} i Index of the feature in the raw layer's `features` array.\n * @return {Object} Raw feature.\n */\nfunction readRawFeature(pbf, layer, i) {\n    pbf.pos = layer.features[i];\n    var end = pbf.readVarint() + pbf.pos;\n    var feature = {\n        layer: layer,\n        type: 0,\n        properties: {},\n    };\n    pbf.readFields(featurePBFReader, feature, end);\n    return feature;\n}\n/**\n * @param {number} type The raw feature's geometry type\n * @param {number} numEnds Number of ends of the flat coordinates of the\n * geometry.\n * @return {import(\"../geom/GeometryType.js\").default} The geometry type.\n */\nfunction getGeometryType(type, numEnds) {\n    /** @type {import(\"../geom/GeometryType.js\").default} */\n    var geometryType;\n    if (type === 1) {\n        geometryType =\n            numEnds === 1 ? GeometryType.POINT : GeometryType.MULTI_POINT;\n    }\n    else if (type === 2) {\n        geometryType =\n            numEnds === 1 ? GeometryType.LINE_STRING : GeometryType.MULTI_LINE_STRING;\n    }\n    else if (type === 3) {\n        geometryType = GeometryType.POLYGON;\n        // MultiPolygon not relevant for rendering - winding order determines\n        // outer rings of polygons.\n    }\n    return geometryType;\n}\nexport default MVT;\n"]},"metadata":{},"sourceType":"module"}