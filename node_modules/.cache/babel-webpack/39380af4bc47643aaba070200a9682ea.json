{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/reproj/Tile\n */\n\n\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\n\nvar ReprojTile = function (_super) {\n  __extends(ReprojTile, _super);\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [opt_renderEdges] Render reprojection edges.\n   * @param {object} [opt_contextOptions] Properties to set on the canvas context.\n   */\n\n\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {\n    var _this = _super.call(this, tileCoord, TileState.IDLE) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n\n    _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n    /**\n     * @private\n     * @type {object}\n     */\n\n    _this.contextOptions_ = opt_contextOptions;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.gutter_ = gutter;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    _this.canvas_ = null;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n\n    _this.sourceTileGrid_ = sourceTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n\n    _this.targetTileGrid_ = targetTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n\n    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n\n    _this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n\n    _this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n\n    var sourceProjExtent = sourceProj.getExtent();\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n\n    _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n\n    if (_this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n\n    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      _this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n\n          if (tile) {\n            _this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = TileState.EMPTY;\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n\n\n  ReprojTile.prototype.getImage = function () {\n    return this.canvas_;\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojTile.prototype.reproject_ = function () {\n    var sources = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);\n      this.state = TileState.LOADED;\n    }\n\n    this.changed();\n  };\n  /**\n   * Load not yet loaded URI.\n   */\n\n\n  ReprojTile.prototype.load = function () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      var leftToLoad_1 = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad_1++;\n          var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n            var state = tile.getState();\n\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey_1);\n              leftToLoad_1--;\n\n              if (leftToLoad_1 === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey_1);\n        }\n      }.bind(this));\n\n      if (leftToLoad_1 === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          var state = tile.getState();\n\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojTile.prototype.unlistenSources_ = function () {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n\n  return ReprojTile;\n}(Tile);\n\nexport default ReprojTile;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/reproj/Tile.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","ERROR_THRESHOLD","EventType","Tile","TileState","Triangulation","calculateSourceExtentResolution","render","renderReprojected","clamp","getArea","getIntersection","listen","unlistenByKey","ReprojTile","_super","sourceProj","sourceTileGrid","targetProj","targetTileGrid","tileCoord","wrappedTileCoord","pixelRatio","gutter","getTileFunction","opt_errorThreshold","opt_renderEdges","opt_contextOptions","_this","IDLE","renderEdges_","undefined","contextOptions_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","getTileCoordExtent","maxTargetExtent","getExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","sourceProjExtent","targetResolution","getResolution","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","canWrapX","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","push","getImage","reproject_","sources","forEach","i","arr","getState","LOADED","extent","image","bind","ERROR","z","size","getTileSize","width","height","changed","load","LOADING","leftToLoad_1","sourceListenKey_1","CHANGE","e","unlistenSources_","setTimeout"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, render as renderReprojected, } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */ (function (_super) {\n    __extends(ReprojTile, _super);\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n     * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {number} gutter Gutter of the source tiles.\n     * @param {FunctionType} getTileFunction\n     *     Function returning source tiles (z, x, y, pixelRatio).\n     * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n     * @param {boolean} [opt_renderEdges] Render reprojection edges.\n     * @param {object} [opt_contextOptions] Properties to set on the canvas context.\n     */\n    function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {\n        var _this = _super.call(this, tileCoord, TileState.IDLE) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n        /**\n         * @private\n         * @type {object}\n         */\n        _this.contextOptions_ = opt_contextOptions;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.gutter_ = gutter;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.canvas_ = null;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.sourceTileGrid_ = sourceTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.targetTileGrid_ = targetTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilecoord.js\").TileCoord}\n         */\n        _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n        /**\n         * @private\n         * @type {!Array<import(\"../Tile.js\").default>}\n         */\n        _this.sourceTiles_ = [];\n        /**\n         * @private\n         * @type {?Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.sourcesListenerKeys_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.sourceZ_ = 0;\n        var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n        var maxTargetExtent = _this.targetTileGrid_.getExtent();\n        var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n        var limitedTargetExtent = maxTargetExtent\n            ? getIntersection(targetExtent, maxTargetExtent)\n            : targetExtent;\n        if (getArea(limitedTargetExtent) === 0) {\n            // Tile is completely outside range -> EMPTY\n            // TODO: is it actually correct that the source even creates the tile ?\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var sourceProjExtent = sourceProj.getExtent();\n        if (sourceProjExtent) {\n            if (!maxSourceExtent) {\n                maxSourceExtent = sourceProjExtent;\n            }\n            else {\n                maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n            }\n        }\n        var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n        var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n        if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n            // invalid sourceResolution -> EMPTY\n            // probably edges of the projections when no extent is defined\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n        /**\n         * @private\n         * @type {!import(\"./Triangulation.js\").default}\n         */\n        _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n        if (_this.triangulation_.getTriangles().length === 0) {\n            // no valid triangles -> EMPTY\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n        var sourceExtent = _this.triangulation_.calculateSourceExtent();\n        if (maxSourceExtent) {\n            if (sourceProj.canWrapX()) {\n                sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n                sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n            }\n            else {\n                sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n            }\n        }\n        if (!getArea(sourceExtent)) {\n            _this.state = TileState.EMPTY;\n        }\n        else {\n            var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n            for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n                for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n                    var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n                    if (tile) {\n                        _this.sourceTiles_.push(tile);\n                    }\n                }\n            }\n            if (_this.sourceTiles_.length === 0) {\n                _this.state = TileState.EMPTY;\n            }\n        }\n        return _this;\n    }\n    /**\n     * Get the HTML Canvas element for this tile.\n     * @return {HTMLCanvasElement} Canvas.\n     */\n    ReprojTile.prototype.getImage = function () {\n        return this.canvas_;\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.reproject_ = function () {\n        var sources = [];\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n            if (tile && tile.getState() == TileState.LOADED) {\n                sources.push({\n                    extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n                    image: tile.getImage(),\n                });\n            }\n        }.bind(this));\n        this.sourceTiles_.length = 0;\n        if (sources.length === 0) {\n            this.state = TileState.ERROR;\n        }\n        else {\n            var z = this.wrappedTileCoord_[0];\n            var size = this.targetTileGrid_.getTileSize(z);\n            var width = typeof size === 'number' ? size : size[0];\n            var height = typeof size === 'number' ? size : size[1];\n            var targetResolution = this.targetTileGrid_.getResolution(z);\n            var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n            var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n            this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);\n            this.state = TileState.LOADED;\n        }\n        this.changed();\n    };\n    /**\n     * Load not yet loaded URI.\n     */\n    ReprojTile.prototype.load = function () {\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            this.changed();\n            var leftToLoad_1 = 0;\n            this.sourcesListenerKeys_ = [];\n            this.sourceTiles_.forEach(function (tile, i, arr) {\n                var state = tile.getState();\n                if (state == TileState.IDLE || state == TileState.LOADING) {\n                    leftToLoad_1++;\n                    var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n                        var state = tile.getState();\n                        if (state == TileState.LOADED ||\n                            state == TileState.ERROR ||\n                            state == TileState.EMPTY) {\n                            unlistenByKey(sourceListenKey_1);\n                            leftToLoad_1--;\n                            if (leftToLoad_1 === 0) {\n                                this.unlistenSources_();\n                                this.reproject_();\n                            }\n                        }\n                    }, this);\n                    this.sourcesListenerKeys_.push(sourceListenKey_1);\n                }\n            }.bind(this));\n            if (leftToLoad_1 === 0) {\n                setTimeout(this.reproject_.bind(this), 0);\n            }\n            else {\n                this.sourceTiles_.forEach(function (tile, i, arr) {\n                    var state = tile.getState();\n                    if (state == TileState.IDLE) {\n                        tile.load();\n                    }\n                });\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.unlistenSources_ = function () {\n        this.sourcesListenerKeys_.forEach(unlistenByKey);\n        this.sourcesListenerKeys_ = null;\n    };\n    return ReprojTile;\n}(Tile));\nexport default ReprojTile;\n"]},"metadata":{},"sourceType":"module"}