{"ast":null,"code":"import { WORKER_OFFSCREEN_CANVAS } from './has.js';\n/**\n * @module ol/dom\n */\n//FIXME Move this function to the canvas module\n\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number} [opt_width] Canvas width.\n * @param {number} [opt_height] Canvas height.\n * @param {Array<HTMLCanvasElement>} [opt_canvasPool] Canvas pool to take existing canvas from.\n * @param {CanvasRenderingContext2DSettings} [opt_Context2DSettings] CanvasRenderingContext2DSettings\n * @return {CanvasRenderingContext2D} The context.\n */\n\nexport function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  var canvas;\n\n  if (opt_canvasPool && opt_canvasPool.length) {\n    canvas = opt_canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n    canvas.style.all = 'unset';\n  }\n\n  if (opt_width) {\n    canvas.width = opt_width;\n  }\n\n  if (opt_height) {\n    canvas.height = opt_height;\n  } //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n\n\n  return canvas.getContext('2d', opt_Context2DSettings);\n}\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\n\nexport function outerWidth(element) {\n  var width = element.offsetWidth;\n  var style = getComputedStyle(element);\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n  return width;\n}\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\n\nexport function outerHeight(element) {\n  var height = element.offsetHeight;\n  var style = getComputedStyle(element);\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n  return height;\n}\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\n\nexport function replaceNode(newNode, oldNode) {\n  var parent = oldNode.parentNode;\n\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n}\n/**\n * @param {Node} node The node to remove.\n * @return {Node} The node that was removed or null.\n */\n\nexport function removeNode(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n/**\n * @param {Node} node The node to remove the children from.\n */\n\nexport function removeChildren(node) {\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n}\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\n\nexport function replaceChildren(node, children) {\n  var oldChildren = node.childNodes;\n\n  for (var i = 0; true; ++i) {\n    var oldChild = oldChildren[i];\n    var newChild = children[i]; // check if our work is done\n\n    if (!oldChild && !newChild) {\n      break;\n    } // check if children match\n\n\n    if (oldChild === newChild) {\n      continue;\n    } // check if a new child needs to be added\n\n\n    if (!oldChild) {\n      node.appendChild(newChild);\n      continue;\n    } // check if an old child needs to be removed\n\n\n    if (!newChild) {\n      node.removeChild(oldChild);\n      --i;\n      continue;\n    } // reorder\n\n\n    node.insertBefore(newChild, oldChild);\n  }\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/dom.js"],"names":["WORKER_OFFSCREEN_CANVAS","createCanvasContext2D","opt_width","opt_height","opt_canvasPool","opt_Context2DSettings","canvas","length","shift","OffscreenCanvas","document","createElement","style","all","width","height","getContext","outerWidth","element","offsetWidth","getComputedStyle","parseInt","marginLeft","marginRight","outerHeight","offsetHeight","marginTop","marginBottom","replaceNode","newNode","oldNode","parent","parentNode","replaceChild","removeNode","node","removeChild","removeChildren","lastChild","replaceChildren","children","oldChildren","childNodes","i","oldChild","newChild","appendChild","insertBefore"],"mappings":"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","sourcesContent":["import { WORKER_OFFSCREEN_CANVAS } from './has.js';\n/**\n * @module ol/dom\n */\n//FIXME Move this function to the canvas module\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number} [opt_width] Canvas width.\n * @param {number} [opt_height] Canvas height.\n * @param {Array<HTMLCanvasElement>} [opt_canvasPool] Canvas pool to take existing canvas from.\n * @param {CanvasRenderingContext2DSettings} [opt_Context2DSettings] CanvasRenderingContext2DSettings\n * @return {CanvasRenderingContext2D} The context.\n */\nexport function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {\n    /** @type {HTMLCanvasElement|OffscreenCanvas} */\n    var canvas;\n    if (opt_canvasPool && opt_canvasPool.length) {\n        canvas = opt_canvasPool.shift();\n    }\n    else if (WORKER_OFFSCREEN_CANVAS) {\n        canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);\n    }\n    else {\n        canvas = document.createElement('canvas');\n        canvas.style.all = 'unset';\n    }\n    if (opt_width) {\n        canvas.width = opt_width;\n    }\n    if (opt_height) {\n        canvas.height = opt_height;\n    }\n    //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n    return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d', opt_Context2DSettings));\n}\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\nexport function outerWidth(element) {\n    var width = element.offsetWidth;\n    var style = getComputedStyle(element);\n    width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n    return width;\n}\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\nexport function outerHeight(element) {\n    var height = element.offsetHeight;\n    var style = getComputedStyle(element);\n    height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n    return height;\n}\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\nexport function replaceNode(newNode, oldNode) {\n    var parent = oldNode.parentNode;\n    if (parent) {\n        parent.replaceChild(newNode, oldNode);\n    }\n}\n/**\n * @param {Node} node The node to remove.\n * @return {Node} The node that was removed or null.\n */\nexport function removeNode(node) {\n    return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n/**\n * @param {Node} node The node to remove the children from.\n */\nexport function removeChildren(node) {\n    while (node.lastChild) {\n        node.removeChild(node.lastChild);\n    }\n}\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\nexport function replaceChildren(node, children) {\n    var oldChildren = node.childNodes;\n    for (var i = 0; true; ++i) {\n        var oldChild = oldChildren[i];\n        var newChild = children[i];\n        // check if our work is done\n        if (!oldChild && !newChild) {\n            break;\n        }\n        // check if children match\n        if (oldChild === newChild) {\n            continue;\n        }\n        // check if a new child needs to be added\n        if (!oldChild) {\n            node.appendChild(newChild);\n            continue;\n        }\n        // check if an old child needs to be removed\n        if (!newChild) {\n            node.removeChild(oldChild);\n            --i;\n            continue;\n        }\n        // reorder\n        node.insertBefore(newChild, oldChild);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}