{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/render/canvas/PolygonBuilder\n */\n\n\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, { beginPathInstruction, closePathInstruction, fillInstruction, strokeInstruction } from './Instruction.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport { snap } from '../../geom/flat/simplify.js';\n\nvar CanvasPolygonBuilder = function (_super) {\n  __extends(CanvasPolygonBuilder, _super);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n\n\n  function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n\n\n  CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {\n    var state = this.state;\n    var fill = state.fillStyle !== undefined;\n    var stroke = state.strokeStyle !== undefined;\n    var numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n\n    for (var i = 0; i < numEnds; ++i) {\n      var end = ends[i];\n      var myBegin = this.coordinates.length;\n      var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      var moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n\n      offset = end;\n    }\n\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n\n    return offset;\n  };\n  /**\n   * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   */\n\n\n  CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n\n    this.endGeometry(feature);\n  };\n  /**\n   * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(feature);\n  };\n  /**\n   * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset = 0;\n\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n\n    this.endGeometry(feature);\n  };\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n\n\n  CanvasPolygonBuilder.prototype.finish = function () {\n    this.reverseHitDetectionInstructions();\n    this.state = null; // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n\n    var tolerance = this.tolerance;\n\n    if (tolerance !== 0) {\n      var coordinates = this.coordinates;\n\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n\n    return _super.prototype.finish.call(this);\n  };\n  /**\n   * @private\n   */\n\n\n  CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n\n  return CanvasPolygonBuilder;\n}(CanvasBuilder);\n\nexport default CanvasPolygonBuilder;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/render/canvas/PolygonBuilder.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","CanvasBuilder","CanvasInstruction","beginPathInstruction","closePathInstruction","fillInstruction","strokeInstruction","defaultFillStyle","snap","CanvasPolygonBuilder","_super","tolerance","maxExtent","resolution","pixelRatio","drawFlatCoordinatess_","flatCoordinates","offset","ends","stride","state","fill","fillStyle","undefined","stroke","strokeStyle","numEnds","length","instructions","push","hitDetectionInstructions","i","end","myBegin","coordinates","myEnd","appendFlatLineCoordinates","moveToLineToInstruction","MOVE_TO_LINE_TO","drawCircle","circleGeometry","feature","setFillStrokeStyles_","beginGeometry","SET_FILL_STYLE","SET_STROKE_STYLE","lineWidth","lineCap","lineJoin","miterLimit","lineDash","lineDashOffset","getFlatCoordinates","getStride","circleInstruction","CIRCLE","endGeometry","drawPolygon","polygonGeometry","getEnds","getOrientedFlatCoordinates","drawMultiPolygon","multiPolygonGeometry","endss","getEndss","ii","finish","reverseHitDetectionInstructions","updateFillStyle","createFill","updateStrokeStyle","applyStroke"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/render/canvas/PolygonBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, { beginPathInstruction, closePathInstruction, fillInstruction, strokeInstruction, } from './Instruction.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport { snap } from '../../geom/flat/simplify.js';\nvar CanvasPolygonBuilder = /** @class */ (function (_super) {\n    __extends(CanvasPolygonBuilder, _super);\n    /**\n     * @param {number} tolerance Tolerance.\n     * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     */\n    function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n        return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @private\n     * @return {number} End.\n     */\n    CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {\n        var state = this.state;\n        var fill = state.fillStyle !== undefined;\n        var stroke = state.strokeStyle !== undefined;\n        var numEnds = ends.length;\n        this.instructions.push(beginPathInstruction);\n        this.hitDetectionInstructions.push(beginPathInstruction);\n        for (var i = 0; i < numEnds; ++i) {\n            var end = ends[i];\n            var myBegin = this.coordinates.length;\n            var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n            var moveToLineToInstruction = [\n                CanvasInstruction.MOVE_TO_LINE_TO,\n                myBegin,\n                myEnd,\n            ];\n            this.instructions.push(moveToLineToInstruction);\n            this.hitDetectionInstructions.push(moveToLineToInstruction);\n            if (stroke) {\n                // Performance optimization: only call closePath() when we have a stroke.\n                // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n                this.instructions.push(closePathInstruction);\n                this.hitDetectionInstructions.push(closePathInstruction);\n            }\n            offset = end;\n        }\n        if (fill) {\n            this.instructions.push(fillInstruction);\n            this.hitDetectionInstructions.push(fillInstruction);\n        }\n        if (stroke) {\n            this.instructions.push(strokeInstruction);\n            this.hitDetectionInstructions.push(strokeInstruction);\n        }\n        return offset;\n    };\n    /**\n     * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n     * @param {import(\"../../Feature.js\").default} feature Feature.\n     */\n    CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        var strokeStyle = state.strokeStyle;\n        if (fillStyle === undefined && strokeStyle === undefined) {\n            return;\n        }\n        this.setFillStrokeStyles_();\n        this.beginGeometry(circleGeometry, feature);\n        if (state.fillStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_FILL_STYLE,\n                defaultFillStyle,\n            ]);\n        }\n        if (state.strokeStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_STROKE_STYLE,\n                state.strokeStyle,\n                state.lineWidth,\n                state.lineCap,\n                state.lineJoin,\n                state.miterLimit,\n                state.lineDash,\n                state.lineDashOffset,\n            ]);\n        }\n        var flatCoordinates = circleGeometry.getFlatCoordinates();\n        var stride = circleGeometry.getStride();\n        var myBegin = this.coordinates.length;\n        this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n        var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n        this.instructions.push(beginPathInstruction, circleInstruction);\n        this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n        if (state.fillStyle !== undefined) {\n            this.instructions.push(fillInstruction);\n            this.hitDetectionInstructions.push(fillInstruction);\n        }\n        if (state.strokeStyle !== undefined) {\n            this.instructions.push(strokeInstruction);\n            this.hitDetectionInstructions.push(strokeInstruction);\n        }\n        this.endGeometry(feature);\n    };\n    /**\n     * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        var strokeStyle = state.strokeStyle;\n        if (fillStyle === undefined && strokeStyle === undefined) {\n            return;\n        }\n        this.setFillStrokeStyles_();\n        this.beginGeometry(polygonGeometry, feature);\n        if (state.fillStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_FILL_STYLE,\n                defaultFillStyle,\n            ]);\n        }\n        if (state.strokeStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_STROKE_STYLE,\n                state.strokeStyle,\n                state.lineWidth,\n                state.lineCap,\n                state.lineJoin,\n                state.miterLimit,\n                state.lineDash,\n                state.lineDashOffset,\n            ]);\n        }\n        var ends = polygonGeometry.getEnds();\n        var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n        var stride = polygonGeometry.getStride();\n        this.drawFlatCoordinatess_(flatCoordinates, 0, \n        /** @type {Array<number>} */ (ends), stride);\n        this.endGeometry(feature);\n    };\n    /**\n     * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        var strokeStyle = state.strokeStyle;\n        if (fillStyle === undefined && strokeStyle === undefined) {\n            return;\n        }\n        this.setFillStrokeStyles_();\n        this.beginGeometry(multiPolygonGeometry, feature);\n        if (state.fillStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_FILL_STYLE,\n                defaultFillStyle,\n            ]);\n        }\n        if (state.strokeStyle !== undefined) {\n            this.hitDetectionInstructions.push([\n                CanvasInstruction.SET_STROKE_STYLE,\n                state.strokeStyle,\n                state.lineWidth,\n                state.lineCap,\n                state.lineJoin,\n                state.miterLimit,\n                state.lineDash,\n                state.lineDashOffset,\n            ]);\n        }\n        var endss = multiPolygonGeometry.getEndss();\n        var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n        var stride = multiPolygonGeometry.getStride();\n        var offset = 0;\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n            offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n        }\n        this.endGeometry(feature);\n    };\n    /**\n     * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n     */\n    CanvasPolygonBuilder.prototype.finish = function () {\n        this.reverseHitDetectionInstructions();\n        this.state = null;\n        // We want to preserve topology when drawing polygons.  Polygons are\n        // simplified using quantization and point elimination. However, we might\n        // have received a mix of quantized and non-quantized geometries, so ensure\n        // that all are quantized by quantizing all coordinates in the batch.\n        var tolerance = this.tolerance;\n        if (tolerance !== 0) {\n            var coordinates = this.coordinates;\n            for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n                coordinates[i] = snap(coordinates[i], tolerance);\n            }\n        }\n        return _super.prototype.finish.call(this);\n    };\n    /**\n     * @private\n     */\n    CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {\n        var state = this.state;\n        var fillStyle = state.fillStyle;\n        if (fillStyle !== undefined) {\n            this.updateFillStyle(state, this.createFill);\n        }\n        if (state.strokeStyle !== undefined) {\n            this.updateStrokeStyle(state, this.applyStroke);\n        }\n    };\n    return CanvasPolygonBuilder;\n}(CanvasBuilder));\nexport default CanvasPolygonBuilder;\n"]},"metadata":{},"sourceType":"module"}