{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/render/canvas/Builder\n */\n\n\nimport CanvasInstruction from './Instruction.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, containsCoordinate, coordinateRelationship } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\n\nvar CanvasBuilder = function (_super) {\n  __extends(CanvasBuilder, _super);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n\n\n  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this = _super.call(this) || this;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n\n    _this.tolerance = tolerance;\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    _this.maxExtent = maxExtent;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.maxLineWidth = 0;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    _this.resolution = resolution;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    _this.beginGeometryInstruction1_ = null;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    _this.beginGeometryInstruction2_ = null;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    _this.bufferedMaxExtent_ = null;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    _this.instructions = [];\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    _this.coordinates = [];\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n\n    _this.tmpCoordinate_ = [];\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    _this.hitDetectionInstructions = [];\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n\n    _this.state = {};\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n\n\n  CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n      return dash * pixelRatio;\n    });\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} stride Stride.\n   * @protected\n   * @return {number} My end\n   */\n\n\n  CanvasBuilder.prototype.appendFlatPointCoordinates = function (flatCoordinates, stride) {\n    var extent = this.getBufferedMaxExtent();\n    var tmpCoord = this.tmpCoordinate_;\n    var coordinates = this.coordinates;\n    var myEnd = coordinates.length;\n\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      tmpCoord[0] = flatCoordinates[i];\n      tmpCoord[1] = flatCoordinates[i + 1];\n\n      if (containsCoordinate(extent, tmpCoord)) {\n        coordinates[myEnd++] = tmpCoord[0];\n        coordinates[myEnd++] = tmpCoord[1];\n      }\n    }\n\n    return myEnd;\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n\n\n  CanvasBuilder.prototype.appendFlatLineCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {\n    var coordinates = this.coordinates;\n    var myEnd = coordinates.length;\n    var extent = this.getBufferedMaxExtent();\n\n    if (skipFirst) {\n      offset += stride;\n    }\n\n    var lastXCoord = flatCoordinates[offset];\n    var lastYCoord = flatCoordinates[offset + 1];\n    var nextCoord = this.tmpCoordinate_;\n    var skipped = true;\n    var i, lastRel, nextRel;\n\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          coordinates[myEnd++] = lastXCoord;\n          coordinates[myEnd++] = lastYCoord;\n          skipped = false;\n        }\n\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n      } else if (nextRel === Relationship.INTERSECTING) {\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    } // Last coordinate equals first or only one point to append:\n\n\n    if (closed && skipped || i === offset + stride) {\n      coordinates[myEnd++] = lastXCoord;\n      coordinates[myEnd++] = lastYCoord;\n    }\n\n    return myEnd;\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n\n\n  CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n\n    return offset;\n  };\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {Function} renderer Renderer.\n   * @param {Function} hitDetectionRenderer Renderer.\n   */\n\n\n  CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer, hitDetectionRenderer) {\n    this.beginGeometry(geometry, feature);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var builderBegin = this.coordinates.length;\n    var flatCoordinates, builderEnd, builderEnds, builderEndss;\n    var offset;\n\n    switch (type) {\n      case GeometryType.MULTI_POLYGON:\n        flatCoordinates =\n        /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.getOrientedFlatCoordinates();\n        builderEndss = [];\n        var endss =\n        /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.getEndss();\n        offset = 0;\n\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n          var myEnds = [];\n          offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n          builderEndss.push(myEnds);\n        }\n\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, hitDetectionRenderer || renderer, inflateMultiCoordinatesArray]);\n        break;\n\n      case GeometryType.POLYGON:\n      case GeometryType.MULTI_LINE_STRING:\n        builderEnds = [];\n        flatCoordinates = type == GeometryType.POLYGON ?\n        /** @type {import(\"../../geom/Polygon.js\").default} */\n        geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n        offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n        /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */\n        geometry.getEnds(), stride, builderEnds);\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, inflateCoordinatesArray]);\n        break;\n\n      case GeometryType.LINE_STRING:\n      case GeometryType.CIRCLE:\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n        break;\n\n      case GeometryType.MULTI_POINT:\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n\n        if (builderEnd > builderBegin) {\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n        }\n\n        break;\n\n      case GeometryType.POINT:\n        flatCoordinates = geometry.getFlatCoordinates();\n        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n        builderEnd = this.coordinates.length;\n        this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer]);\n        this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer]);\n        break;\n\n      default:\n    }\n\n    this.endGeometry(feature);\n  };\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n\n\n  CanvasBuilder.prototype.finish = function () {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates\n    };\n  };\n  /**\n   * Reverse the hit detection instructions.\n   */\n\n\n  CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {\n    var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array\n\n    hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks\n\n    var i;\n    var n = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = instruction[0];\n\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  };\n  /**\n   * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n   * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n   */\n\n\n  CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {\n    var state = this.state;\n\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache\n\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n\n\n  CanvasBuilder.prototype.createFill = function (state) {\n    var fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n\n    var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n\n    return fillInstruction;\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n\n\n  CanvasBuilder.prototype.applyStroke = function (state) {\n    this.instructions.push(this.createStroke(state));\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n\n\n  CanvasBuilder.prototype.createStroke = function (state) {\n    return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n\n\n  CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {\n    var fillStyle = state.fillStyle;\n\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n\n      state.currentFillStyle = fillStyle;\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n\n\n  CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n\n\n  CanvasBuilder.prototype.endGeometry = function (feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n\n\n  CanvasBuilder.prototype.getBufferedMaxExtent = function () {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n\n    return this.bufferedMaxExtent_;\n  };\n\n  return CanvasBuilder;\n}(VectorContext);\n\nexport default CanvasBuilder;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/render/canvas/Builder.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","CanvasInstruction","GeometryType","Relationship","VectorContext","asColorLike","buffer","clone","containsCoordinate","coordinateRelationship","defaultFillStyle","defaultLineCap","defaultLineDash","defaultLineDashOffset","defaultLineJoin","defaultLineWidth","defaultMiterLimit","defaultStrokeStyle","equals","reverseSubArray","inflateCoordinates","inflateCoordinatesArray","inflateMultiCoordinatesArray","CanvasBuilder","_super","tolerance","maxExtent","resolution","pixelRatio","_this","maxLineWidth","beginGeometryInstruction1_","beginGeometryInstruction2_","bufferedMaxExtent_","instructions","coordinates","tmpCoordinate_","hitDetectionInstructions","state","applyPixelRatio","dashArray","map","dash","appendFlatPointCoordinates","flatCoordinates","stride","extent","getBufferedMaxExtent","tmpCoord","myEnd","length","i","ii","appendFlatLineCoordinates","offset","end","closed","skipFirst","lastXCoord","lastYCoord","nextCoord","skipped","lastRel","nextRel","INTERSECTING","drawCustomCoordinates_","ends","builderEnds","builderEnd","push","drawCustom","geometry","feature","renderer","hitDetectionRenderer","beginGeometry","type","getType","getStride","builderBegin","builderEndss","MULTI_POLYGON","getOrientedFlatCoordinates","endss","getEndss","myEnds","CUSTOM","POLYGON","MULTI_LINE_STRING","getFlatCoordinates","getEnds","LINE_STRING","CIRCLE","MULTI_POINT","POINT","endGeometry","BEGIN_GEOMETRY","finish","reverseHitDetectionInstructions","reverse","n","instruction","begin","END_GEOMETRY","setFillStrokeStyle","fillStyle","strokeStyle","fillStyleColor","getColor","undefined","strokeStyleColor","strokeStyleLineCap","getLineCap","lineCap","strokeStyleLineDash","getLineDash","lineDash","slice","strokeStyleLineDashOffset","getLineDashOffset","lineDashOffset","strokeStyleLineJoin","getLineJoin","lineJoin","strokeStyleWidth","getWidth","lineWidth","strokeStyleMiterLimit","getMiterLimit","miterLimit","createFill","fillInstruction","SET_FILL_STYLE","applyStroke","createStroke","SET_STROKE_STYLE","updateFillStyle","currentFillStyle","updateStrokeStyle","currentStrokeStyle","currentLineCap","currentLineDash","currentLineDashOffset","currentLineJoin","currentLineWidth","currentMiterLimit","endGeometryInstruction","width"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, containsCoordinate, coordinateRelationship, } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle, } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray, } from '../../geom/flat/inflate.js';\nvar CanvasBuilder = /** @class */ (function (_super) {\n    __extends(CanvasBuilder, _super);\n    /**\n     * @param {number} tolerance Tolerance.\n     * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     */\n    function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n        var _this = _super.call(this) || this;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.tolerance = tolerance;\n        /**\n         * @protected\n         * @const\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.maxExtent = maxExtent;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.pixelRatio = pixelRatio;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.maxLineWidth = 0;\n        /**\n         * @protected\n         * @const\n         * @type {number}\n         */\n        _this.resolution = resolution;\n        /**\n         * @private\n         * @type {Array<*>}\n         */\n        _this.beginGeometryInstruction1_ = null;\n        /**\n         * @private\n         * @type {Array<*>}\n         */\n        _this.beginGeometryInstruction2_ = null;\n        /**\n         * @private\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.bufferedMaxExtent_ = null;\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        _this.instructions = [];\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        _this.coordinates = [];\n        /**\n         * @private\n         * @type {import(\"../../coordinate.js\").Coordinate}\n         */\n        _this.tmpCoordinate_ = [];\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        _this.hitDetectionInstructions = [];\n        /**\n         * @protected\n         * @type {import(\"../canvas.js\").FillStrokeState}\n         */\n        _this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */ ({});\n        return _this;\n    }\n    /**\n     * @protected\n     * @param {Array<number>} dashArray Dash array.\n     * @return {Array<number>} Dash array with pixel ratio applied\n     */\n    CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {\n        var pixelRatio = this.pixelRatio;\n        return pixelRatio == 1\n            ? dashArray\n            : dashArray.map(function (dash) {\n                return dash * pixelRatio;\n            });\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} stride Stride.\n     * @protected\n     * @return {number} My end\n     */\n    CanvasBuilder.prototype.appendFlatPointCoordinates = function (flatCoordinates, stride) {\n        var extent = this.getBufferedMaxExtent();\n        var tmpCoord = this.tmpCoordinate_;\n        var coordinates = this.coordinates;\n        var myEnd = coordinates.length;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            tmpCoord[0] = flatCoordinates[i];\n            tmpCoord[1] = flatCoordinates[i + 1];\n            if (containsCoordinate(extent, tmpCoord)) {\n                coordinates[myEnd++] = tmpCoord[0];\n                coordinates[myEnd++] = tmpCoord[1];\n            }\n        }\n        return myEnd;\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {boolean} closed Last input coordinate equals first.\n     * @param {boolean} skipFirst Skip first coordinate.\n     * @protected\n     * @return {number} My end.\n     */\n    CanvasBuilder.prototype.appendFlatLineCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {\n        var coordinates = this.coordinates;\n        var myEnd = coordinates.length;\n        var extent = this.getBufferedMaxExtent();\n        if (skipFirst) {\n            offset += stride;\n        }\n        var lastXCoord = flatCoordinates[offset];\n        var lastYCoord = flatCoordinates[offset + 1];\n        var nextCoord = this.tmpCoordinate_;\n        var skipped = true;\n        var i, lastRel, nextRel;\n        for (i = offset + stride; i < end; i += stride) {\n            nextCoord[0] = flatCoordinates[i];\n            nextCoord[1] = flatCoordinates[i + 1];\n            nextRel = coordinateRelationship(extent, nextCoord);\n            if (nextRel !== lastRel) {\n                if (skipped) {\n                    coordinates[myEnd++] = lastXCoord;\n                    coordinates[myEnd++] = lastYCoord;\n                    skipped = false;\n                }\n                coordinates[myEnd++] = nextCoord[0];\n                coordinates[myEnd++] = nextCoord[1];\n            }\n            else if (nextRel === Relationship.INTERSECTING) {\n                coordinates[myEnd++] = nextCoord[0];\n                coordinates[myEnd++] = nextCoord[1];\n                skipped = false;\n            }\n            else {\n                skipped = true;\n            }\n            lastXCoord = nextCoord[0];\n            lastYCoord = nextCoord[1];\n            lastRel = nextRel;\n        }\n        // Last coordinate equals first or only one point to append:\n        if ((closed && skipped) || i === offset + stride) {\n            coordinates[myEnd++] = lastXCoord;\n            coordinates[myEnd++] = lastYCoord;\n        }\n        return myEnd;\n    };\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {Array<number>} builderEnds Builder ends.\n     * @return {number} Offset.\n     */\n    CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n            builderEnds.push(builderEnd);\n            offset = end;\n        }\n        return offset;\n    };\n    /**\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {Function} renderer Renderer.\n     * @param {Function} hitDetectionRenderer Renderer.\n     */\n    CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer, hitDetectionRenderer) {\n        this.beginGeometry(geometry, feature);\n        var type = geometry.getType();\n        var stride = geometry.getStride();\n        var builderBegin = this.coordinates.length;\n        var flatCoordinates, builderEnd, builderEnds, builderEndss;\n        var offset;\n        switch (type) {\n            case GeometryType.MULTI_POLYGON:\n                flatCoordinates =\n                    /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry).getOrientedFlatCoordinates();\n                builderEndss = [];\n                var endss = \n                /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry).getEndss();\n                offset = 0;\n                for (var i = 0, ii = endss.length; i < ii; ++i) {\n                    var myEnds = [];\n                    offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n                    builderEndss.push(myEnds);\n                }\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEndss,\n                    geometry,\n                    renderer,\n                    inflateMultiCoordinatesArray,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEndss,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                    inflateMultiCoordinatesArray,\n                ]);\n                break;\n            case GeometryType.POLYGON:\n            case GeometryType.MULTI_LINE_STRING:\n                builderEnds = [];\n                flatCoordinates =\n                    type == GeometryType.POLYGON\n                        ? /** @type {import(\"../../geom/Polygon.js\").default} */ (geometry).getOrientedFlatCoordinates()\n                        : geometry.getFlatCoordinates();\n                offset = this.drawCustomCoordinates_(flatCoordinates, 0, \n                /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */ (geometry).getEnds(), stride, builderEnds);\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnds,\n                    geometry,\n                    renderer,\n                    inflateCoordinatesArray,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnds,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                    inflateCoordinatesArray,\n                ]);\n                break;\n            case GeometryType.LINE_STRING:\n            case GeometryType.CIRCLE:\n                flatCoordinates = geometry.getFlatCoordinates();\n                builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    renderer,\n                    inflateCoordinates,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                    inflateCoordinates,\n                ]);\n                break;\n            case GeometryType.MULTI_POINT:\n                flatCoordinates = geometry.getFlatCoordinates();\n                builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n                if (builderEnd > builderBegin) {\n                    this.instructions.push([\n                        CanvasInstruction.CUSTOM,\n                        builderBegin,\n                        builderEnd,\n                        geometry,\n                        renderer,\n                        inflateCoordinates,\n                    ]);\n                    this.hitDetectionInstructions.push([\n                        CanvasInstruction.CUSTOM,\n                        builderBegin,\n                        builderEnd,\n                        geometry,\n                        hitDetectionRenderer || renderer,\n                        inflateCoordinates,\n                    ]);\n                }\n                break;\n            case GeometryType.POINT:\n                flatCoordinates = geometry.getFlatCoordinates();\n                this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n                builderEnd = this.coordinates.length;\n                this.instructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    renderer,\n                ]);\n                this.hitDetectionInstructions.push([\n                    CanvasInstruction.CUSTOM,\n                    builderBegin,\n                    builderEnd,\n                    geometry,\n                    hitDetectionRenderer || renderer,\n                ]);\n                break;\n            default:\n        }\n        this.endGeometry(feature);\n    };\n    /**\n     * @protected\n     * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {\n        this.beginGeometryInstruction1_ = [\n            CanvasInstruction.BEGIN_GEOMETRY,\n            feature,\n            0,\n            geometry,\n        ];\n        this.instructions.push(this.beginGeometryInstruction1_);\n        this.beginGeometryInstruction2_ = [\n            CanvasInstruction.BEGIN_GEOMETRY,\n            feature,\n            0,\n            geometry,\n        ];\n        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n    };\n    /**\n     * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n     */\n    CanvasBuilder.prototype.finish = function () {\n        return {\n            instructions: this.instructions,\n            hitDetectionInstructions: this.hitDetectionInstructions,\n            coordinates: this.coordinates,\n        };\n    };\n    /**\n     * Reverse the hit detection instructions.\n     */\n    CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {\n        var hitDetectionInstructions = this.hitDetectionInstructions;\n        // step 1 - reverse array\n        hitDetectionInstructions.reverse();\n        // step 2 - reverse instructions within geometry blocks\n        var i;\n        var n = hitDetectionInstructions.length;\n        var instruction;\n        var type;\n        var begin = -1;\n        for (i = 0; i < n; ++i) {\n            instruction = hitDetectionInstructions[i];\n            type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n            if (type == CanvasInstruction.END_GEOMETRY) {\n                begin = i;\n            }\n            else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n                instruction[2] = i;\n                reverseSubArray(this.hitDetectionInstructions, begin, i);\n                begin = -1;\n            }\n        }\n    };\n    /**\n     * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n     * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n     */\n    CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {\n        var state = this.state;\n        if (fillStyle) {\n            var fillStyleColor = fillStyle.getColor();\n            state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n        }\n        else {\n            state.fillStyle = undefined;\n        }\n        if (strokeStyle) {\n            var strokeStyleColor = strokeStyle.getColor();\n            state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n            var strokeStyleLineCap = strokeStyle.getLineCap();\n            state.lineCap =\n                strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n            var strokeStyleLineDash = strokeStyle.getLineDash();\n            state.lineDash = strokeStyleLineDash\n                ? strokeStyleLineDash.slice()\n                : defaultLineDash;\n            var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n            state.lineDashOffset = strokeStyleLineDashOffset\n                ? strokeStyleLineDashOffset\n                : defaultLineDashOffset;\n            var strokeStyleLineJoin = strokeStyle.getLineJoin();\n            state.lineJoin =\n                strokeStyleLineJoin !== undefined\n                    ? strokeStyleLineJoin\n                    : defaultLineJoin;\n            var strokeStyleWidth = strokeStyle.getWidth();\n            state.lineWidth =\n                strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n            var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n            state.miterLimit =\n                strokeStyleMiterLimit !== undefined\n                    ? strokeStyleMiterLimit\n                    : defaultMiterLimit;\n            if (state.lineWidth > this.maxLineWidth) {\n                this.maxLineWidth = state.lineWidth;\n                // invalidate the buffered max extent cache\n                this.bufferedMaxExtent_ = null;\n            }\n        }\n        else {\n            state.strokeStyle = undefined;\n            state.lineCap = undefined;\n            state.lineDash = null;\n            state.lineDashOffset = undefined;\n            state.lineJoin = undefined;\n            state.lineWidth = undefined;\n            state.miterLimit = undefined;\n        }\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Fill instruction.\n     */\n    CanvasBuilder.prototype.createFill = function (state) {\n        var fillStyle = state.fillStyle;\n        /** @type {Array<*>} */\n        var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n        if (typeof fillStyle !== 'string') {\n            // Fill is a pattern or gradient - align it!\n            fillInstruction.push(true);\n        }\n        return fillInstruction;\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     */\n    CanvasBuilder.prototype.applyStroke = function (state) {\n        this.instructions.push(this.createStroke(state));\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Stroke instruction.\n     */\n    CanvasBuilder.prototype.createStroke = function (state) {\n        return [\n            CanvasInstruction.SET_STROKE_STYLE,\n            state.strokeStyle,\n            state.lineWidth * this.pixelRatio,\n            state.lineCap,\n            state.lineJoin,\n            state.miterLimit,\n            this.applyPixelRatio(state.lineDash),\n            state.lineDashOffset * this.pixelRatio,\n        ];\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n     */\n    CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {\n        var fillStyle = state.fillStyle;\n        if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n            if (fillStyle !== undefined) {\n                this.instructions.push(createFill.call(this, state));\n            }\n            state.currentFillStyle = fillStyle;\n        }\n    };\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n     */\n    CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {\n        var strokeStyle = state.strokeStyle;\n        var lineCap = state.lineCap;\n        var lineDash = state.lineDash;\n        var lineDashOffset = state.lineDashOffset;\n        var lineJoin = state.lineJoin;\n        var lineWidth = state.lineWidth;\n        var miterLimit = state.miterLimit;\n        if (state.currentStrokeStyle != strokeStyle ||\n            state.currentLineCap != lineCap ||\n            (lineDash != state.currentLineDash &&\n                !equals(state.currentLineDash, lineDash)) ||\n            state.currentLineDashOffset != lineDashOffset ||\n            state.currentLineJoin != lineJoin ||\n            state.currentLineWidth != lineWidth ||\n            state.currentMiterLimit != miterLimit) {\n            if (strokeStyle !== undefined) {\n                applyStroke.call(this, state);\n            }\n            state.currentStrokeStyle = strokeStyle;\n            state.currentLineCap = lineCap;\n            state.currentLineDash = lineDash;\n            state.currentLineDashOffset = lineDashOffset;\n            state.currentLineJoin = lineJoin;\n            state.currentLineWidth = lineWidth;\n            state.currentMiterLimit = miterLimit;\n        }\n    };\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n    CanvasBuilder.prototype.endGeometry = function (feature) {\n        this.beginGeometryInstruction1_[2] = this.instructions.length;\n        this.beginGeometryInstruction1_ = null;\n        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n        this.beginGeometryInstruction2_ = null;\n        var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n        this.instructions.push(endGeometryInstruction);\n        this.hitDetectionInstructions.push(endGeometryInstruction);\n    };\n    /**\n     * Get the buffered rendering extent.  Rendering will be clipped to the extent\n     * provided to the constructor.  To account for symbolizers that may intersect\n     * this extent, we calculate a buffered extent (e.g. based on stroke width).\n     * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n     * @protected\n     */\n    CanvasBuilder.prototype.getBufferedMaxExtent = function () {\n        if (!this.bufferedMaxExtent_) {\n            this.bufferedMaxExtent_ = clone(this.maxExtent);\n            if (this.maxLineWidth > 0) {\n                var width = (this.resolution * (this.maxLineWidth + 1)) / 2;\n                buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n            }\n        }\n        return this.bufferedMaxExtent_;\n    };\n    return CanvasBuilder;\n}(VectorContext));\nexport default CanvasBuilder;\n"]},"metadata":{},"sourceType":"module"}