{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/geom/Polygon\n */\n\n\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY, getCenter } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray } from './flat/interiorpoint.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingArray } from './flat/intersectsextent.js';\nimport { linearRingsAreOriented, orientLinearRings } from './flat/orient.js';\nimport { linearRings as linearRingsArea } from './flat/area.js';\nimport { linearRingsContainsXY } from './flat/contains.js';\nimport { modulo } from '../math.js';\nimport { quantizeArray } from './flat/simplify.js';\nimport { offset as sphereOffset } from '../sphere.js';\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\n\nvar Polygon = function (_super) {\n  __extends(Polygon, _super);\n  /**\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n   *     Array of linear rings that define the polygon. The first linear ring of the\n   *     array defines the outer-boundary or surface of the polygon. Each subsequent\n   *     linear ring defines a hole in the surface of the polygon. A linear ring is\n   *     an array of vertices' coordinates where the first coordinate and the last are\n   *     equivalent. (For internal use, flat coordinates in combination with\n   *     `opt_layout` and `opt_ends` are also accepted.)\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @param {Array<number>} [opt_ends] Ends (for internal use with flat coordinates).\n   */\n\n\n  function Polygon(coordinates, opt_layout, opt_ends) {\n    var _this = _super.call(this) || this;\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n\n    _this.ends_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.flatInteriorPointRevision_ = -1;\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n\n    _this.flatInteriorPoint_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.maxDeltaRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.orientedRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    _this.orientedFlatCoordinates_ = null;\n\n    if (opt_layout !== undefined && opt_ends) {\n      _this.setFlatCoordinates(opt_layout, coordinates);\n\n      _this.ends_ = opt_ends;\n    } else {\n      _this.setCoordinates(coordinates, opt_layout);\n    }\n\n    return _this;\n  }\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {LinearRing} linearRing Linear ring.\n   * @api\n   */\n\n\n  Polygon.prototype.appendLinearRing = function (linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Polygon} Clone.\n   * @api\n   */\n\n\n  Polygon.prototype.clone = function () {\n    var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n    polygon.applyProperties(this);\n    return polygon;\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n\n\n  Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n\n\n  Polygon.prototype.containsXY = function (x, y) {\n    return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n  };\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n\n\n  Polygon.prototype.getArea = function () {\n    return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n  };\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n\n\n  Polygon.prototype.getCoordinates = function (opt_right) {\n    var flatCoordinates;\n\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n  };\n  /**\n   * @return {Array<number>} Ends.\n   */\n\n\n  Polygon.prototype.getEnds = function () {\n    return this.ends_;\n  };\n  /**\n   * @return {Array<number>} Interior point.\n   */\n\n\n  Polygon.prototype.getFlatInteriorPoint = function () {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      var flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n\n    return this.flatInteriorPoint_;\n  };\n  /**\n   * Return an interior point of the polygon.\n   * @return {Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n\n\n  Polygon.prototype.getInteriorPoint = function () {\n    return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n  };\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRingCount = function () {\n    return this.ends_.length;\n  };\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {LinearRing} Linear ring.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRing = function (index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n\n    return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array<LinearRing>} Linear rings.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRings = function () {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var linearRings = [];\n    var offset = 0;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);\n      linearRings.push(linearRing);\n      offset = end;\n    }\n\n    return linearRings;\n  };\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n\n\n  Polygon.prototype.getOrientedFlatCoordinates = function () {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n      }\n\n      this.orientedRevision_ = this.getRevision();\n    }\n\n    return this.orientedFlatCoordinates_;\n  };\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Polygon} Simplified Polygon.\n   * @protected\n   */\n\n\n  Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   * @api\n   */\n\n\n  Polygon.prototype.getType = function () {\n    return GeometryType.POLYGON;\n  };\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n\n\n  Polygon.prototype.intersectsExtent = function (extent) {\n    return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n  };\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @api\n   */\n\n\n  Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return Polygon;\n}(SimpleGeometry);\n\nexport default Polygon;\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [opt_n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [opt_sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\n\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n  var n = opt_n ? opt_n : 32;\n  /** @type {Array<number>} */\n\n  var flatCoordinates = [];\n\n  for (var i = 0; i < n; ++i) {\n    extend(flatCoordinates, sphereOffset(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));\n  }\n\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n}\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\n\nexport function fromExtent(extent) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n}\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [opt_sides] Number of sides of the polygon. Default is 32.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\n\nexport function fromCircle(circle, opt_sides, opt_angle) {\n  var sides = opt_sides ? opt_sides : 32;\n  var stride = circle.getStride();\n  var layout = circle.getLayout();\n  var center = circle.getCenter();\n  var arrayLength = stride * (sides + 1);\n  var flatCoordinates = new Array(arrayLength);\n\n  for (var i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n\n    for (var j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n\n  var ends = [flatCoordinates.length];\n  var polygon = new Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), opt_angle);\n  return polygon;\n}\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\n\nexport function makeRegular(polygon, center, radius, opt_angle) {\n  var flatCoordinates = polygon.getFlatCoordinates();\n  var stride = polygon.getStride();\n  var sides = flatCoordinates.length / stride - 1;\n  var startAngle = opt_angle ? opt_angle : 0;\n\n  for (var i = 0; i <= sides; ++i) {\n    var offset = i * stride;\n    var angle = startAngle + modulo(i, sides) * 2 * Math.PI / sides;\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n  }\n\n  polygon.changed();\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/geom/Polygon.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","GeometryLayout","GeometryType","LinearRing","Point","SimpleGeometry","arrayMaxSquaredDelta","assignClosestArrayPoint","closestSquaredDistanceXY","getCenter","deflateCoordinatesArray","extend","getInteriorPointOfArray","inflateCoordinatesArray","intersectsLinearRingArray","linearRingsAreOriented","orientLinearRings","linearRings","linearRingsArea","linearRingsContainsXY","modulo","quantizeArray","offset","sphereOffset","Polygon","_super","coordinates","opt_layout","opt_ends","_this","ends_","flatInteriorPointRevision_","flatInteriorPoint_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","undefined","setFlatCoordinates","setCoordinates","appendLinearRing","linearRing","flatCoordinates","getFlatCoordinates","slice","push","length","changed","clone","polygon","layout","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","containsXY","getOrientedFlatCoordinates","getArea","getCoordinates","opt_right","getEnds","getFlatInteriorPoint","flatCenter","getInteriorPoint","XYM","getLinearRingCount","getLinearRing","index","getLinearRings","ends","i","ii","end","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEnds","XY","getType","POLYGON","intersectsExtent","extent","setLayout","circular","center","radius","opt_n","opt_sphereRadius","n","PI","fromExtent","minX","minY","maxX","maxY","fromCircle","circle","opt_sides","opt_angle","sides","getStride","getLayout","arrayLength","j","makeRegular","getRadius","startAngle","angle","cos","sin"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Polygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY, getCenter } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray } from './flat/interiorpoint.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingArray } from './flat/intersectsextent.js';\nimport { linearRingsAreOriented, orientLinearRings } from './flat/orient.js';\nimport { linearRings as linearRingsArea } from './flat/area.js';\nimport { linearRingsContainsXY } from './flat/contains.js';\nimport { modulo } from '../math.js';\nimport { quantizeArray } from './flat/simplify.js';\nimport { offset as sphereOffset } from '../sphere.js';\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nvar Polygon = /** @class */ (function (_super) {\n    __extends(Polygon, _super);\n    /**\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n     *     Array of linear rings that define the polygon. The first linear ring of the\n     *     array defines the outer-boundary or surface of the polygon. Each subsequent\n     *     linear ring defines a hole in the surface of the polygon. A linear ring is\n     *     an array of vertices' coordinates where the first coordinate and the last are\n     *     equivalent. (For internal use, flat coordinates in combination with\n     *     `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<number>} [opt_ends] Ends (for internal use with flat coordinates).\n     */\n    function Polygon(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatInteriorPointRevision_ = -1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.flatInteriorPoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.orientedFlatCoordinates_ = null;\n        if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linear ring to this polygon.\n     * @param {LinearRing} linearRing Linear ring.\n     * @api\n     */\n    Polygon.prototype.appendLinearRing = function (linearRing) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Polygon} Clone.\n     * @api\n     */\n    Polygon.prototype.clone = function () {\n        var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        polygon.applyProperties(this);\n        return polygon;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Polygon.prototype.containsXY = function (x, y) {\n        return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n    };\n    /**\n     * Return the area of the polygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    Polygon.prototype.getArea = function () {\n        return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n    };\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for polygons.\n     *\n     * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    Polygon.prototype.getCoordinates = function (opt_right) {\n        var flatCoordinates;\n        if (opt_right !== undefined) {\n            flatCoordinates = this.getOrientedFlatCoordinates().slice();\n            orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n        }\n        else {\n            flatCoordinates = this.flatCoordinates;\n        }\n        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    Polygon.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * @return {Array<number>} Interior point.\n     */\n    Polygon.prototype.getFlatInteriorPoint = function () {\n        if (this.flatInteriorPointRevision_ != this.getRevision()) {\n            var flatCenter = getCenter(this.getExtent());\n            this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n            this.flatInteriorPointRevision_ = this.getRevision();\n        }\n        return this.flatInteriorPoint_;\n    };\n    /**\n     * Return an interior point of the polygon.\n     * @return {Point} Interior point as XYM coordinate, where M is the\n     * length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n    Polygon.prototype.getInteriorPoint = function () {\n        return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n    };\n    /**\n     * Return the number of rings of the polygon,  this includes the exterior\n     * ring and any interior rings.\n     *\n     * @return {number} Number of rings.\n     * @api\n     */\n    Polygon.prototype.getLinearRingCount = function () {\n        return this.ends_.length;\n    };\n    /**\n     * Return the Nth linear ring of the polygon geometry. Return `null` if the\n     * given index is out of range.\n     * The exterior linear ring is available at index `0` and the interior rings\n     * at index `1` and beyond.\n     *\n     * @param {number} index Index.\n     * @return {LinearRing} Linear ring.\n     * @api\n     */\n    Polygon.prototype.getLinearRing = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linear rings of the polygon.\n     * @return {Array<LinearRing>} Linear rings.\n     * @api\n     */\n    Polygon.prototype.getLinearRings = function () {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var linearRings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);\n            linearRings.push(linearRing);\n            offset = end;\n        }\n        return linearRings;\n    };\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n    Polygon.prototype.getOrientedFlatCoordinates = function () {\n        if (this.orientedRevision_ != this.getRevision()) {\n            var flatCoordinates = this.flatCoordinates;\n            if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n                this.orientedFlatCoordinates_ = flatCoordinates;\n            }\n            else {\n                this.orientedFlatCoordinates_ = flatCoordinates.slice();\n                this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n            }\n            this.orientedRevision_ = this.getRevision();\n        }\n        return this.orientedFlatCoordinates_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {Polygon} Simplified Polygon.\n     * @protected\n     */\n    Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    Polygon.prototype.getType = function () {\n        return GeometryType.POLYGON;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Polygon.prototype.intersectsExtent = function (extent) {\n        return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the polygon.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return Polygon;\n}(SimpleGeometry));\nexport default Polygon;\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [opt_n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [opt_sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n    var n = opt_n ? opt_n : 32;\n    /** @type {Array<number>} */\n    var flatCoordinates = [];\n    for (var i = 0; i < n; ++i) {\n        extend(flatCoordinates, sphereOffset(center, radius, (2 * Math.PI * i) / n, opt_sphereRadius));\n    }\n    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n    return new Polygon(flatCoordinates, GeometryLayout.XY, [\n        flatCoordinates.length,\n    ]);\n}\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var flatCoordinates = [\n        minX,\n        minY,\n        minX,\n        maxY,\n        maxX,\n        maxY,\n        maxX,\n        minY,\n        minX,\n        minY,\n    ];\n    return new Polygon(flatCoordinates, GeometryLayout.XY, [\n        flatCoordinates.length,\n    ]);\n}\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [opt_sides] Number of sides of the polygon. Default is 32.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, opt_sides, opt_angle) {\n    var sides = opt_sides ? opt_sides : 32;\n    var stride = circle.getStride();\n    var layout = circle.getLayout();\n    var center = circle.getCenter();\n    var arrayLength = stride * (sides + 1);\n    var flatCoordinates = new Array(arrayLength);\n    for (var i = 0; i < arrayLength; i += stride) {\n        flatCoordinates[i] = 0;\n        flatCoordinates[i + 1] = 0;\n        for (var j = 2; j < stride; j++) {\n            flatCoordinates[i + j] = center[j];\n        }\n    }\n    var ends = [flatCoordinates.length];\n    var polygon = new Polygon(flatCoordinates, layout, ends);\n    makeRegular(polygon, center, circle.getRadius(), opt_angle);\n    return polygon;\n}\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, opt_angle) {\n    var flatCoordinates = polygon.getFlatCoordinates();\n    var stride = polygon.getStride();\n    var sides = flatCoordinates.length / stride - 1;\n    var startAngle = opt_angle ? opt_angle : 0;\n    for (var i = 0; i <= sides; ++i) {\n        var offset = i * stride;\n        var angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\n        flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n        flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n    }\n    polygon.changed();\n}\n"]},"metadata":{},"sourceType":"module"}