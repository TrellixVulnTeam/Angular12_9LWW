{"ast":null,"code":"/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { log2, modulo } from '../math.js';\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\n\nvar MAX_SUBDIVISION = 10;\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\n\nvar MAX_TRIANGLE_WIDTH = 0.25;\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\n\nvar Triangulation = function () {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\n   */\n  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n\n    this.targetProj_ = targetProj;\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n\n    var transformInvCache = {};\n    var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n\n    this.transformInv_ = function (c) {\n      var key = c[0] + '/' + c[1];\n\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n\n      return transformInvCache[key];\n    };\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n\n\n    this.maxSourceExtent_ = maxSourceExtent;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n\n    this.triangles_ = [];\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n\n    this.wrapsXInSource_ = false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n    /**\n     * @type {?number}\n     * @private\n     */\n\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n    /**\n     * @type {?number}\n     * @private\n     */\n\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n    var destinationTopLeft = getTopLeft(targetExtent);\n    var destinationTopRight = getTopRight(targetExtent);\n    var destinationBottomRight = getBottomRight(targetExtent);\n    var destinationBottomLeft = getBottomLeft(targetExtent);\n    var sourceTopLeft = this.transformInv_(destinationTopLeft);\n    var sourceTopRight = this.transformInv_(destinationTopRight);\n    var sourceBottomRight = this.transformInv_(destinationBottomRight);\n    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n\n    var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil(log2(getArea(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);\n    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n\n    if (this.wrapsXInSource_) {\n      var leftBound_1 = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      }); // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n\n      this.triangles_.forEach(function (triangle) {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {\n          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n\n          if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n\n          if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n\n          if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          } // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n\n\n          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      }.bind(this));\n    }\n\n    transformInvCache = {};\n  }\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n\n\n  Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c]\n    });\n  };\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n\n\n  Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n    var sourceWorldWidth = this.sourceWorldWidth_; // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n\n    var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n    var needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        var targetQuadExtent = boundingExtent([a, b, c, d]);\n        var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    var isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n\n          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        var centerSrc = this.transformInv_(center);\n        var dx = void 0;\n\n        if (wrapsX) {\n          var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n\n        var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        var centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          var bcSrc = this.transformInv_(bc);\n          var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          var daSrc = this.transformInv_(da);\n          this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n          this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n        } else {\n          // split vertically (left & right)\n          var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          var abSrc = this.transformInv_(ab);\n          var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          var cdSrc = this.transformInv_(cd);\n          this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n          this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n        }\n\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n\n      this.wrapsXInSource_ = true;\n    } // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n\n\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  };\n  /**\n   * Calculates extent of the 'source' coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n\n\n  Triangulation.prototype.calculateSourceExtent = function () {\n    var extent = createEmpty();\n    this.triangles_.forEach(function (triangle, i, arr) {\n      var src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n    return extent;\n  };\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n\n\n  Triangulation.prototype.getTriangles = function () {\n    return this.triangles_;\n  };\n\n  return Triangulation;\n}();\n\nexport default Triangulation;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/reproj/Triangulation.js"],"names":["boundingExtent","createEmpty","extendCoordinate","getArea","getBottomLeft","getBottomRight","getTopLeft","getTopRight","getWidth","intersects","getTransform","log2","modulo","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","opt_destinationResolution","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","Math","max","ceil","addQuad_","leftBound_1","Infinity","forEach","triangle","i","arr","min","source","newTriangle","minX","maxX","bind","prototype","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isFinite","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extent","src","getTriangles"],"mappings":"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","sourcesContent":["/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects, } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { log2, modulo } from '../math.js';\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = /** @class */ (function () {\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n     * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n     * @param {number} errorThreshold Acceptable error (in source units).\n     * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\n     */\n    function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         * @private\n         */\n        this.sourceProj_ = sourceProj;\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         * @private\n         */\n        this.targetProj_ = targetProj;\n        /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n        var transformInvCache = {};\n        var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n        /**\n         * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n         * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n         * @private\n         */\n        this.transformInv_ = function (c) {\n            var key = c[0] + '/' + c[1];\n            if (!transformInvCache[key]) {\n                transformInvCache[key] = transformInv(c);\n            }\n            return transformInvCache[key];\n        };\n        /**\n         * @type {import(\"../extent.js\").Extent}\n         * @private\n         */\n        this.maxSourceExtent_ = maxSourceExtent;\n        /**\n         * @type {number}\n         * @private\n         */\n        this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n        /**\n         * @type {Array<Triangle>}\n         * @private\n         */\n        this.triangles_ = [];\n        /**\n         * Indicates that the triangulation crosses edge of the source projection.\n         * @type {boolean}\n         * @private\n         */\n        this.wrapsXInSource_ = false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.canWrapXInSource_ =\n            this.sourceProj_.canWrapX() &&\n                !!maxSourceExtent &&\n                !!this.sourceProj_.getExtent() &&\n                getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n        /**\n         * @type {?number}\n         * @private\n         */\n        this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n            ? getWidth(this.sourceProj_.getExtent())\n            : null;\n        /**\n         * @type {?number}\n         * @private\n         */\n        this.targetWorldWidth_ = this.targetProj_.getExtent()\n            ? getWidth(this.targetProj_.getExtent())\n            : null;\n        var destinationTopLeft = getTopLeft(targetExtent);\n        var destinationTopRight = getTopRight(targetExtent);\n        var destinationBottomRight = getBottomRight(targetExtent);\n        var destinationBottomLeft = getBottomLeft(targetExtent);\n        var sourceTopLeft = this.transformInv_(destinationTopLeft);\n        var sourceTopRight = this.transformInv_(destinationTopRight);\n        var sourceBottomRight = this.transformInv_(destinationBottomRight);\n        var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n        /*\n         * The maxSubdivision controls how many splittings of the target area can\n         * be done. The idea here is to do a linear mapping of the target areas\n         * but the actual overal reprojection (can be) extremely non-linear. The\n         * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n         * tile size. However this function is also called to remap canvas rendered\n         * layers which can be much larger. This calculation increases the maxSubdivision\n         * value by the right factor so that each 256x256 pixel area has\n         * MAX_SUBDIVISION divisions.\n         */\n        var maxSubdivision = MAX_SUBDIVISION +\n            (opt_destinationResolution\n                ? Math.max(0, Math.ceil(log2(getArea(targetExtent) /\n                    (opt_destinationResolution *\n                        opt_destinationResolution *\n                        256 *\n                        256))))\n                : 0);\n        this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n        if (this.wrapsXInSource_) {\n            var leftBound_1 = Infinity;\n            this.triangles_.forEach(function (triangle, i, arr) {\n                leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n            });\n            // Shift triangles to be as close to `leftBound` as possible\n            // (if the distance is more than `worldWidth / 2` it can be closer.\n            this.triangles_.forEach(function (triangle) {\n                if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) -\n                    leftBound_1 >\n                    this.sourceWorldWidth_ / 2) {\n                    var newTriangle = [\n                        [triangle.source[0][0], triangle.source[0][1]],\n                        [triangle.source[1][0], triangle.source[1][1]],\n                        [triangle.source[2][0], triangle.source[2][1]],\n                    ];\n                    if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[0][0] -= this.sourceWorldWidth_;\n                    }\n                    if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[1][0] -= this.sourceWorldWidth_;\n                    }\n                    if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[2][0] -= this.sourceWorldWidth_;\n                    }\n                    // Rarely (if the extent contains both the dateline and prime meridian)\n                    // the shift can in turn break some triangles.\n                    // Detect this here and don't shift in such cases.\n                    var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n                    var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n                    if (maxX - minX < this.sourceWorldWidth_ / 2) {\n                        triangle.source = newTriangle;\n                    }\n                }\n            }.bind(this));\n        }\n        transformInvCache = {};\n    }\n    /**\n     * Adds triangle to the triangulation.\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @private\n     */\n    Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {\n        this.triangles_.push({\n            source: [aSrc, bSrc, cSrc],\n            target: [a, b, c],\n        });\n    };\n    /**\n     * Adds quad (points in clock-wise order) to the triangulation\n     * (and reprojects the vertices) if valid.\n     * Performs quad subdivision if needed to increase precision.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n     * @private\n     */\n    Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n        var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n        var sourceCoverageX = this.sourceWorldWidth_\n            ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n            : null;\n        var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n        // when the quad is wrapped in the source projection\n        // it covers most of the projection extent, but not fully\n        var wrapsX = this.sourceProj_.canWrapX() &&\n            sourceCoverageX > 0.5 &&\n            sourceCoverageX < 1;\n        var needsSubdivision = false;\n        if (maxSubdivision > 0) {\n            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n                var targetQuadExtent = boundingExtent([a, b, c, d]);\n                var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n                needsSubdivision =\n                    targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n            }\n            if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n                needsSubdivision =\n                    sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n            }\n        }\n        if (!needsSubdivision && this.maxSourceExtent_) {\n            if (isFinite(sourceQuadExtent[0]) &&\n                isFinite(sourceQuadExtent[1]) &&\n                isFinite(sourceQuadExtent[2]) &&\n                isFinite(sourceQuadExtent[3])) {\n                if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n                    // whole quad outside source projection extent -> ignore\n                    return;\n                }\n            }\n        }\n        var isNotFinite = 0;\n        if (!needsSubdivision) {\n            if (!isFinite(aSrc[0]) ||\n                !isFinite(aSrc[1]) ||\n                !isFinite(bSrc[0]) ||\n                !isFinite(bSrc[1]) ||\n                !isFinite(cSrc[0]) ||\n                !isFinite(cSrc[1]) ||\n                !isFinite(dSrc[0]) ||\n                !isFinite(dSrc[1])) {\n                if (maxSubdivision > 0) {\n                    needsSubdivision = true;\n                }\n                else {\n                    // It might be the case that only 1 of the points is infinite. In this case\n                    // we can draw a single triangle with the other three points\n                    isNotFinite =\n                        (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n                            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n                            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n                            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n                    if (isNotFinite != 1 &&\n                        isNotFinite != 2 &&\n                        isNotFinite != 4 &&\n                        isNotFinite != 8) {\n                        return;\n                    }\n                }\n            }\n        }\n        if (maxSubdivision > 0) {\n            if (!needsSubdivision) {\n                var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n                var centerSrc = this.transformInv_(center);\n                var dx = void 0;\n                if (wrapsX) {\n                    var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) +\n                        modulo(cSrc[0], sourceWorldWidth)) /\n                        2;\n                    dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n                }\n                else {\n                    dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n                }\n                var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n                var centerSrcErrorSquared = dx * dx + dy * dy;\n                needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n            }\n            if (needsSubdivision) {\n                if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n                    // split horizontally (top & bottom)\n                    var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n                    var bcSrc = this.transformInv_(bc);\n                    var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n                    var daSrc = this.transformInv_(da);\n                    this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n                    this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n                }\n                else {\n                    // split vertically (left & right)\n                    var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n                    var abSrc = this.transformInv_(ab);\n                    var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n                    var cdSrc = this.transformInv_(cd);\n                    this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n                    this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n                }\n                return;\n            }\n        }\n        if (wrapsX) {\n            if (!this.canWrapXInSource_) {\n                return;\n            }\n            this.wrapsXInSource_ = true;\n        }\n        // Exactly zero or one of *Src is not finite\n        // The triangles must have the diagonal line as the first side\n        // This is to allow easy code in reproj.s to make it straight for broken\n        // browsers that can't handle diagonal clipping\n        if ((isNotFinite & 0xb) == 0) {\n            this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n        }\n        if ((isNotFinite & 0xe) == 0) {\n            this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n        }\n        if (isNotFinite) {\n            // Try the other two triangles\n            if ((isNotFinite & 0xd) == 0) {\n                this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n            }\n            if ((isNotFinite & 0x7) == 0) {\n                this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n            }\n        }\n    };\n    /**\n     * Calculates extent of the 'source' coordinates from all the triangles.\n     *\n     * @return {import(\"../extent.js\").Extent} Calculated extent.\n     */\n    Triangulation.prototype.calculateSourceExtent = function () {\n        var extent = createEmpty();\n        this.triangles_.forEach(function (triangle, i, arr) {\n            var src = triangle.source;\n            extendCoordinate(extent, src[0]);\n            extendCoordinate(extent, src[1]);\n            extendCoordinate(extent, src[2]);\n        });\n        return extent;\n    };\n    /**\n     * @return {Array<Triangle>} Array of the calculated triangles.\n     */\n    Triangulation.prototype.getTriangles = function () {\n        return this.triangles_;\n    };\n    return Triangulation;\n}());\nexport default Triangulation;\n"]},"metadata":{},"sourceType":"module"}