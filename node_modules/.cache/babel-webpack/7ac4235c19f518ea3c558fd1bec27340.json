{"ast":null,"code":"/*! @azure/msal-common v4.5.1 2021-08-02 */\n'use strict';\n\nimport { CredentialType, CacheType, Constants, Separators } from '../../utils/Constants.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      oboAssertion: access token passed in as part of OBO request\r\n * }\r\n */\n\nvar CredentialEntity = function () {\n  function CredentialEntity() {}\n  /**\r\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n   */\n\n\n  CredentialEntity.prototype.generateAccountId = function () {\n    return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);\n  };\n  /**\r\n   * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\r\n   */\n\n\n  CredentialEntity.prototype.generateCredentialId = function () {\n    return CredentialEntity.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);\n  };\n  /**\r\n   * Generate target key component as per schema: <target>\r\n   */\n\n\n  CredentialEntity.prototype.generateTarget = function () {\n    return CredentialEntity.generateTargetForCacheKey(this.target);\n  };\n  /**\r\n   * generates credential key\r\n   */\n\n\n  CredentialEntity.prototype.generateCredentialKey = function () {\n    return CredentialEntity.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId);\n  };\n  /**\r\n   * returns the type of the cache (in this case credential)\r\n   */\n\n\n  CredentialEntity.prototype.generateType = function () {\n    switch (this.credentialType) {\n      case CredentialType.ID_TOKEN:\n        return CacheType.ID_TOKEN;\n\n      case CredentialType.ACCESS_TOKEN:\n        return CacheType.ACCESS_TOKEN;\n\n      case CredentialType.REFRESH_TOKEN:\n        return CacheType.REFRESH_TOKEN;\n\n      default:\n        {\n          throw ClientAuthError.createUnexpectedCredentialTypeError();\n        }\n    }\n  };\n  /**\r\n   * helper function to return `CredentialType`\r\n   * @param key\r\n   */\n\n\n  CredentialEntity.getCredentialType = function (key) {\n    // First keyword search will match all \"AccessToken\" and \"AccessToken_With_AuthScheme\" credentials\n    if (key.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) !== -1) {\n      // Perform second search to differentiate between \"AccessToken\" and \"AccessToken_With_AuthScheme\" credential types\n      if (key.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) !== -1) {\n        return CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n      }\n\n      return CredentialType.ACCESS_TOKEN;\n    } else if (key.indexOf(CredentialType.ID_TOKEN.toLowerCase()) !== -1) {\n      return CredentialType.ID_TOKEN;\n    } else if (key.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) !== -1) {\n      return CredentialType.REFRESH_TOKEN;\n    }\n\n    return Constants.NOT_DEFINED;\n  };\n  /**\r\n   * generates credential key\r\n   */\n\n\n  CredentialEntity.generateCredentialCacheKey = function (homeAccountId, environment, credentialType, clientId, realm, target, familyId) {\n    var credentialKey = [this.generateAccountIdForCacheKey(homeAccountId, environment), this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId), this.generateTargetForCacheKey(target)];\n    return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * generates Account Id for keys\r\n   * @param homeAccountId\r\n   * @param environment\r\n   */\n\n\n  CredentialEntity.generateAccountIdForCacheKey = function (homeAccountId, environment) {\n    var accountId = [homeAccountId, environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generates Credential Id for keys\r\n   * @param credentialType\r\n   * @param realm\r\n   * @param clientId\r\n   * @param familyId\r\n   */\n\n\n  CredentialEntity.generateCredentialIdForCacheKey = function (credentialType, clientId, realm, familyId) {\n    var clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN ? familyId || clientId : clientId;\n    var credentialId = [credentialType, clientOrFamilyId, realm || \"\"];\n    return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generate target key component as per schema: <target>\r\n   */\n\n\n  CredentialEntity.generateTargetForCacheKey = function (scopes) {\n    return (scopes || \"\").toLowerCase();\n  };\n\n  return CredentialEntity;\n}();\n\nexport { CredentialEntity };","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/@azure/msal-common/dist/cache/entities/CredentialEntity.js"],"names":["CredentialType","CacheType","Constants","Separators","ClientAuthError","CredentialEntity","prototype","generateAccountId","generateAccountIdForCacheKey","homeAccountId","environment","generateCredentialId","generateCredentialIdForCacheKey","credentialType","clientId","realm","familyId","generateTarget","generateTargetForCacheKey","target","generateCredentialKey","generateCredentialCacheKey","generateType","ID_TOKEN","ACCESS_TOKEN","REFRESH_TOKEN","createUnexpectedCredentialTypeError","getCredentialType","key","indexOf","toLowerCase","ACCESS_TOKEN_WITH_AUTH_SCHEME","NOT_DEFINED","credentialKey","join","CACHE_KEY_SEPARATOR","accountId","clientOrFamilyId","credentialId","scopes"],"mappings":"AAAA;AACA;;AACA,SAASA,cAAT,EAAyBC,SAAzB,EAAoCC,SAApC,EAA+CC,UAA/C,QAAiE,0BAAjE;AACA,SAASC,eAAT,QAAgC,gCAAhC;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,gBAAgB,GAAkB,YAAY;AAC9C,WAASA,gBAAT,GAA4B,CAC3B;AACD;AACJ;AACA;;;AACIA,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BC,iBAA3B,GAA+C,YAAY;AACvD,WAAOF,gBAAgB,CAACG,4BAAjB,CAA8C,KAAKC,aAAnD,EAAkE,KAAKC,WAAvE,CAAP;AACH,GAFD;AAGA;AACJ;AACA;;;AACIL,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BK,oBAA3B,GAAkD,YAAY;AAC1D,WAAON,gBAAgB,CAACO,+BAAjB,CAAiD,KAAKC,cAAtD,EAAsE,KAAKC,QAA3E,EAAqF,KAAKC,KAA1F,EAAiG,KAAKC,QAAtG,CAAP;AACH,GAFD;AAGA;AACJ;AACA;;;AACIX,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BW,cAA3B,GAA4C,YAAY;AACpD,WAAOZ,gBAAgB,CAACa,yBAAjB,CAA2C,KAAKC,MAAhD,CAAP;AACH,GAFD;AAGA;AACJ;AACA;;;AACId,EAAAA,gBAAgB,CAACC,SAAjB,CAA2Bc,qBAA3B,GAAmD,YAAY;AAC3D,WAAOf,gBAAgB,CAACgB,0BAAjB,CAA4C,KAAKZ,aAAjD,EAAgE,KAAKC,WAArE,EAAkF,KAAKG,cAAvF,EAAuG,KAAKC,QAA5G,EAAsH,KAAKC,KAA3H,EAAkI,KAAKI,MAAvI,EAA+I,KAAKH,QAApJ,CAAP;AACH,GAFD;AAGA;AACJ;AACA;;;AACIX,EAAAA,gBAAgB,CAACC,SAAjB,CAA2BgB,YAA3B,GAA0C,YAAY;AAClD,YAAQ,KAAKT,cAAb;AACI,WAAKb,cAAc,CAACuB,QAApB;AACI,eAAOtB,SAAS,CAACsB,QAAjB;;AACJ,WAAKvB,cAAc,CAACwB,YAApB;AACI,eAAOvB,SAAS,CAACuB,YAAjB;;AACJ,WAAKxB,cAAc,CAACyB,aAApB;AACI,eAAOxB,SAAS,CAACwB,aAAjB;;AACJ;AAAS;AACL,gBAAMrB,eAAe,CAACsB,mCAAhB,EAAN;AACH;AATL;AAWH,GAZD;AAaA;AACJ;AACA;AACA;;;AACIrB,EAAAA,gBAAgB,CAACsB,iBAAjB,GAAqC,UAAUC,GAAV,EAAe;AAChD;AACA,QAAIA,GAAG,CAACC,OAAJ,CAAY7B,cAAc,CAACwB,YAAf,CAA4BM,WAA5B,EAAZ,MAA2D,CAAC,CAAhE,EAAmE;AAC/D;AACA,UAAIF,GAAG,CAACC,OAAJ,CAAY7B,cAAc,CAAC+B,6BAAf,CAA6CD,WAA7C,EAAZ,MAA4E,CAAC,CAAjF,EAAoF;AAChF,eAAO9B,cAAc,CAAC+B,6BAAtB;AACH;;AACD,aAAO/B,cAAc,CAACwB,YAAtB;AACH,KAND,MAOK,IAAII,GAAG,CAACC,OAAJ,CAAY7B,cAAc,CAACuB,QAAf,CAAwBO,WAAxB,EAAZ,MAAuD,CAAC,CAA5D,EAA+D;AAChE,aAAO9B,cAAc,CAACuB,QAAtB;AACH,KAFI,MAGA,IAAIK,GAAG,CAACC,OAAJ,CAAY7B,cAAc,CAACyB,aAAf,CAA6BK,WAA7B,EAAZ,MAA4D,CAAC,CAAjE,EAAoE;AACrE,aAAO9B,cAAc,CAACyB,aAAtB;AACH;;AACD,WAAOvB,SAAS,CAAC8B,WAAjB;AACH,GAhBD;AAiBA;AACJ;AACA;;;AACI3B,EAAAA,gBAAgB,CAACgB,0BAAjB,GAA8C,UAAUZ,aAAV,EAAyBC,WAAzB,EAAsCG,cAAtC,EAAsDC,QAAtD,EAAgEC,KAAhE,EAAuEI,MAAvE,EAA+EH,QAA/E,EAAyF;AACnI,QAAIiB,aAAa,GAAG,CAChB,KAAKzB,4BAAL,CAAkCC,aAAlC,EAAiDC,WAAjD,CADgB,EAEhB,KAAKE,+BAAL,CAAqCC,cAArC,EAAqDC,QAArD,EAA+DC,KAA/D,EAAsEC,QAAtE,CAFgB,EAGhB,KAAKE,yBAAL,CAA+BC,MAA/B,CAHgB,CAApB;AAKA,WAAOc,aAAa,CAACC,IAAd,CAAmB/B,UAAU,CAACgC,mBAA9B,EAAmDL,WAAnD,EAAP;AACH,GAPD;AAQA;AACJ;AACA;AACA;AACA;;;AACIzB,EAAAA,gBAAgB,CAACG,4BAAjB,GAAgD,UAAUC,aAAV,EAAyBC,WAAzB,EAAsC;AAClF,QAAI0B,SAAS,GAAG,CAAC3B,aAAD,EAAgBC,WAAhB,CAAhB;AACA,WAAO0B,SAAS,CAACF,IAAV,CAAe/B,UAAU,CAACgC,mBAA1B,EAA+CL,WAA/C,EAAP;AACH,GAHD;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIzB,EAAAA,gBAAgB,CAACO,+BAAjB,GAAmD,UAAUC,cAAV,EAA0BC,QAA1B,EAAoCC,KAApC,EAA2CC,QAA3C,EAAqD;AACpG,QAAIqB,gBAAgB,GAAGxB,cAAc,KAAKb,cAAc,CAACyB,aAAlC,GACjBT,QAAQ,IAAIF,QADK,GAEjBA,QAFN;AAGA,QAAIwB,YAAY,GAAG,CACfzB,cADe,EAEfwB,gBAFe,EAGftB,KAAK,IAAI,EAHM,CAAnB;AAKA,WAAOuB,YAAY,CAACJ,IAAb,CAAkB/B,UAAU,CAACgC,mBAA7B,EAAkDL,WAAlD,EAAP;AACH,GAVD;AAWA;AACJ;AACA;;;AACIzB,EAAAA,gBAAgB,CAACa,yBAAjB,GAA6C,UAAUqB,MAAV,EAAkB;AAC3D,WAAO,CAACA,MAAM,IAAI,EAAX,EAAeT,WAAf,EAAP;AACH,GAFD;;AAGA,SAAOzB,gBAAP;AACH,CA7GqC,EAAtC;;AA+GA,SAASA,gBAAT","sourcesContent":["/*! @azure/msal-common v4.5.1 2021-08-02 */\n'use strict';\nimport { CredentialType, CacheType, Constants, Separators } from '../../utils/Constants.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      oboAssertion: access token passed in as part of OBO request\r\n * }\r\n */\r\nvar CredentialEntity = /** @class */ (function () {\r\n    function CredentialEntity() {\r\n    }\r\n    /**\r\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n     */\r\n    CredentialEntity.prototype.generateAccountId = function () {\r\n        return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);\r\n    };\r\n    /**\r\n     * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\r\n     */\r\n    CredentialEntity.prototype.generateCredentialId = function () {\r\n        return CredentialEntity.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);\r\n    };\r\n    /**\r\n     * Generate target key component as per schema: <target>\r\n     */\r\n    CredentialEntity.prototype.generateTarget = function () {\r\n        return CredentialEntity.generateTargetForCacheKey(this.target);\r\n    };\r\n    /**\r\n     * generates credential key\r\n     */\r\n    CredentialEntity.prototype.generateCredentialKey = function () {\r\n        return CredentialEntity.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId);\r\n    };\r\n    /**\r\n     * returns the type of the cache (in this case credential)\r\n     */\r\n    CredentialEntity.prototype.generateType = function () {\r\n        switch (this.credentialType) {\r\n            case CredentialType.ID_TOKEN:\r\n                return CacheType.ID_TOKEN;\r\n            case CredentialType.ACCESS_TOKEN:\r\n                return CacheType.ACCESS_TOKEN;\r\n            case CredentialType.REFRESH_TOKEN:\r\n                return CacheType.REFRESH_TOKEN;\r\n            default: {\r\n                throw ClientAuthError.createUnexpectedCredentialTypeError();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * helper function to return `CredentialType`\r\n     * @param key\r\n     */\r\n    CredentialEntity.getCredentialType = function (key) {\r\n        // First keyword search will match all \"AccessToken\" and \"AccessToken_With_AuthScheme\" credentials\r\n        if (key.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) !== -1) {\r\n            // Perform second search to differentiate between \"AccessToken\" and \"AccessToken_With_AuthScheme\" credential types\r\n            if (key.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) !== -1) {\r\n                return CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\r\n            }\r\n            return CredentialType.ACCESS_TOKEN;\r\n        }\r\n        else if (key.indexOf(CredentialType.ID_TOKEN.toLowerCase()) !== -1) {\r\n            return CredentialType.ID_TOKEN;\r\n        }\r\n        else if (key.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) !== -1) {\r\n            return CredentialType.REFRESH_TOKEN;\r\n        }\r\n        return Constants.NOT_DEFINED;\r\n    };\r\n    /**\r\n     * generates credential key\r\n     */\r\n    CredentialEntity.generateCredentialCacheKey = function (homeAccountId, environment, credentialType, clientId, realm, target, familyId) {\r\n        var credentialKey = [\r\n            this.generateAccountIdForCacheKey(homeAccountId, environment),\r\n            this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),\r\n            this.generateTargetForCacheKey(target),\r\n        ];\r\n        return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    };\r\n    /**\r\n     * generates Account Id for keys\r\n     * @param homeAccountId\r\n     * @param environment\r\n     */\r\n    CredentialEntity.generateAccountIdForCacheKey = function (homeAccountId, environment) {\r\n        var accountId = [homeAccountId, environment];\r\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    };\r\n    /**\r\n     * Generates Credential Id for keys\r\n     * @param credentialType\r\n     * @param realm\r\n     * @param clientId\r\n     * @param familyId\r\n     */\r\n    CredentialEntity.generateCredentialIdForCacheKey = function (credentialType, clientId, realm, familyId) {\r\n        var clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN\r\n            ? familyId || clientId\r\n            : clientId;\r\n        var credentialId = [\r\n            credentialType,\r\n            clientOrFamilyId,\r\n            realm || \"\",\r\n        ];\r\n        return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    };\r\n    /**\r\n     * Generate target key component as per schema: <target>\r\n     */\r\n    CredentialEntity.generateTargetForCacheKey = function (scopes) {\r\n        return (scopes || \"\").toLowerCase();\r\n    };\r\n    return CredentialEntity;\r\n}());\n\nexport { CredentialEntity };\n"]},"metadata":{},"sourceType":"module"}