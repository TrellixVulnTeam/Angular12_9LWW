{"ast":null,"code":"/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\nimport { squaredDistance, squaredSegmentDistance } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [opt_simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\n\nexport function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];\n\n  if (!highQuality) {\n    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n\n  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nexport function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  var n = (end - offset) / stride;\n\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n\n\n  var markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n\n  var stack = [offset, end - stride];\n  var index = 0;\n\n  while (stack.length > 0) {\n    var last = stack.pop();\n    var first = stack.pop();\n    var maxSquaredDistance = 0;\n    var x1 = flatCoordinates[first];\n    var y1 = flatCoordinates[first + 1];\n    var x2 = flatCoordinates[last];\n    var y2 = flatCoordinates[last + 1];\n\n    for (var i = first + stride; i < last; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n\n      if (squaredDistance_1 > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance_1;\n      }\n    }\n\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n\n  for (var i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];\n    }\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n\nexport function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n\nexport function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nexport function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n\n    return simplifiedOffset;\n  }\n\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1]; // copy first point\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  var x2 = x1;\n  var y2 = y1;\n\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\n\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nexport function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  } // snap the first coordinate (P1)\n\n\n  var x1 = snap(flatCoordinates[offset], tolerance);\n  var y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride; // add the first coordinate to the output\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n\n  var x2, y2;\n\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    var x3 = snap(flatCoordinates[offset], tolerance);\n    var y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride; // skip P3 if it is equal to P2\n\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    } // calculate the delta between P1 and P2\n\n\n    var dx1 = x2 - x1;\n    var dy1 = y2 - y1; // calculate the delta between P3 and P1\n\n    var dx2 = x3 - x1;\n    var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n\n    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n\n\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  } // add the last point (P2)\n\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n\nexport function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n\nexport function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n\n  return simplifiedOffset;\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/geom/flat/simplify.js"],"names":["squaredDistance","squaredSegmentDistance","simplifyLineString","flatCoordinates","offset","end","stride","squaredTolerance","highQuality","opt_simplifiedFlatCoordinates","simplifiedFlatCoordinates","undefined","radialDistance","length","douglasPeucker","simplifiedOffset","n","markers","Array","stack","index","last","pop","first","maxSquaredDistance","x1","y1","x2","y2","i","x","y","squaredDistance_1","push","douglasPeuckerArray","ends","simplifiedEnds","ii","douglasPeuckerMultiArray","endss","simplifiedEndss","snap","value","tolerance","Math","round","quantize","x3","y3","dx1","dy1","dx2","dy2","quantizeArray","quantizeMultiArray"],"mappings":"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","sourcesContent":["/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\nimport { squaredDistance, squaredSegmentDistance } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [opt_simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n    var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined\n        ? opt_simplifiedFlatCoordinates\n        : [];\n    if (!highQuality) {\n        end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        flatCoordinates = simplifiedFlatCoordinates;\n        offset = 0;\n        stride = 2;\n    }\n    simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    return simplifiedFlatCoordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    var n = (end - offset) / stride;\n    if (n < 3) {\n        for (; offset < end; offset += stride) {\n            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + 1];\n        }\n        return simplifiedOffset;\n    }\n    /** @type {Array<number>} */\n    var markers = new Array(n);\n    markers[0] = 1;\n    markers[n - 1] = 1;\n    /** @type {Array<number>} */\n    var stack = [offset, end - stride];\n    var index = 0;\n    while (stack.length > 0) {\n        var last = stack.pop();\n        var first = stack.pop();\n        var maxSquaredDistance = 0;\n        var x1 = flatCoordinates[first];\n        var y1 = flatCoordinates[first + 1];\n        var x2 = flatCoordinates[last];\n        var y2 = flatCoordinates[last + 1];\n        for (var i = first + stride; i < last; i += stride) {\n            var x = flatCoordinates[i];\n            var y = flatCoordinates[i + 1];\n            var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n            if (squaredDistance_1 > maxSquaredDistance) {\n                index = i;\n                maxSquaredDistance = squaredDistance_1;\n            }\n        }\n        if (maxSquaredDistance > squaredTolerance) {\n            markers[(index - offset) / stride] = 1;\n            if (first + stride < index) {\n                stack.push(first, index);\n            }\n            if (index + stride < last) {\n                stack.push(index, last);\n            }\n        }\n    }\n    for (var i = 0; i < n; ++i) {\n        if (markers[i]) {\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + i * stride];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + i * stride + 1];\n        }\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n        simplifiedEnds.push(simplifiedOffset);\n        offset = end;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        var simplifiedEnds = [];\n        simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n        simplifiedEndss.push(simplifiedEnds);\n        offset = ends[ends.length - 1];\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    if (end <= offset + stride) {\n        // zero or one point, no simplification possible, so copy and return\n        for (; offset < end; offset += stride) {\n            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + 1];\n        }\n        return simplifiedOffset;\n    }\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    // copy first point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n    var x2 = x1;\n    var y2 = y1;\n    for (offset += stride; offset < end; offset += stride) {\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n            // copy point at offset\n            simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n            simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n    if (x2 != x1 || y2 != y1) {\n        // copy last point\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n    return tolerance * Math.round(value / tolerance);\n}\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    // do nothing if the line is empty\n    if (offset == end) {\n        return simplifiedOffset;\n    }\n    // snap the first coordinate (P1)\n    var x1 = snap(flatCoordinates[offset], tolerance);\n    var y1 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // add the first coordinate to the output\n    simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n    // find the next coordinate that does not snap to the same value as the first\n    // coordinate (P2)\n    var x2, y2;\n    do {\n        x2 = snap(flatCoordinates[offset], tolerance);\n        y2 = snap(flatCoordinates[offset + 1], tolerance);\n        offset += stride;\n        if (offset == end) {\n            // all coordinates snap to the same value, the line collapses to a point\n            // push the last snapped value anyway to ensure that the output contains\n            // at least two points\n            // FIXME should we really return at least two points anyway?\n            simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n            simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n            return simplifiedOffset;\n        }\n    } while (x2 == x1 && y2 == y1);\n    while (offset < end) {\n        // snap the next coordinate (P3)\n        var x3 = snap(flatCoordinates[offset], tolerance);\n        var y3 = snap(flatCoordinates[offset + 1], tolerance);\n        offset += stride;\n        // skip P3 if it is equal to P2\n        if (x3 == x2 && y3 == y2) {\n            continue;\n        }\n        // calculate the delta between P1 and P2\n        var dx1 = x2 - x1;\n        var dy1 = y2 - y1;\n        // calculate the delta between P3 and P1\n        var dx2 = x3 - x1;\n        var dy2 = y3 - y1;\n        // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n        // P1 in the same direction then P2 is on the straight line between P1 and\n        // P3\n        if (dx1 * dy2 == dy1 * dx2 &&\n            ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n            ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\n            // discard P2 and set P2 = P3\n            x2 = x3;\n            y2 = y3;\n            continue;\n        }\n        // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n        // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n        // and continue with P1 = P2 and P2 = P3\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n        x1 = x2;\n        y1 = y2;\n        x2 = x3;\n        y2 = y3;\n    }\n    // add the last point (P2)\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n        simplifiedEnds.push(simplifiedOffset);\n        offset = end;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        var simplifiedEnds = [];\n        simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n        simplifiedEndss.push(simplifiedEnds);\n        offset = ends[ends.length - 1];\n    }\n    return simplifiedOffset;\n}\n"]},"metadata":{},"sourceType":"module"}