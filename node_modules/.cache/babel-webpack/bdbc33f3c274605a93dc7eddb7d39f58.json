{"ast":null,"code":"/**\n * @module ol/color\n */\nimport { assert } from './asserts.js';\nimport { clamp } from './math.js';\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\n\nvar HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\n\nvar NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\\(.*\\)$/i;\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\n\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  } else {\n    return toString(color);\n  }\n}\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\n\nfunction fromNamed(color) {\n  var el = document.createElement('div');\n  el.style.color = color;\n\n  if (el.style.color !== '') {\n    document.body.appendChild(el);\n    var rgb = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb;\n  } else {\n    return '';\n  }\n}\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\n\n\nexport var fromString = function () {\n  // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n  // semantics, whenever the cache grows too large we simply delete an\n  // arbitrary 25% of the entries.\n\n  /**\n   * @const\n   * @type {number}\n   */\n  var MAX_CACHE_SIZE = 1024;\n  /**\n   * @type {Object<string, Color>}\n   */\n\n  var cache = {};\n  /**\n   * @type {number}\n   */\n\n  var cacheSize = 0;\n  return (\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n    function (s) {\n      var color;\n\n      if (cache.hasOwnProperty(s)) {\n        color = cache[s];\n      } else {\n        if (cacheSize >= MAX_CACHE_SIZE) {\n          var i = 0;\n\n          for (var key in cache) {\n            if ((i++ & 3) === 0) {\n              delete cache[key];\n              --cacheSize;\n            }\n          }\n        }\n\n        color = fromStringInternal_(s);\n        cache[s] = color;\n        ++cacheSize;\n      }\n\n      return color;\n    }\n  );\n}();\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\n\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  } else {\n    return fromString(color);\n  }\n}\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\n\nfunction fromStringInternal_(s) {\n  var r, g, b, a, color;\n\n  if (NAMED_COLOR_RE_.exec(s)) {\n    s = fromNamed(s);\n  }\n\n  if (HEX_COLOR_RE_.exec(s)) {\n    // hex\n    var n = s.length - 1; // number of hex digits\n\n    var d = // number of digits per channel\n    void 0; // number of digits per channel\n\n    if (n <= 4) {\n      d = 1;\n    } else {\n      d = 2;\n    }\n\n    var hasAlpha = n === 4 || n === 8;\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\n\n    if (hasAlpha) {\n      a = parseInt(s.substr(1 + 3 * d, d), 16);\n    } else {\n      a = 255;\n    }\n\n    if (d == 1) {\n      r = (r << 4) + r;\n      g = (g << 4) + g;\n      b = (b << 4) + b;\n\n      if (hasAlpha) {\n        a = (a << 4) + a;\n      }\n    }\n\n    color = [r, g, b, a / 255];\n  } else if (s.indexOf('rgba(') == 0) {\n    // rgba()\n    color = s.slice(5, -1).split(',').map(Number);\n    normalize(color);\n  } else if (s.indexOf('rgb(') == 0) {\n    // rgb()\n    color = s.slice(4, -1).split(',').map(Number);\n    color.push(1);\n    normalize(color);\n  } else {\n    assert(false, 14); // Invalid color\n  }\n\n  return color;\n}\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\n\n\nexport function normalize(color) {\n  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);\n  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);\n  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\n\nexport function toString(color) {\n  var r = color[0];\n\n  if (r != (r | 0)) {\n    r = r + 0.5 | 0;\n  }\n\n  var g = color[1];\n\n  if (g != (g | 0)) {\n    g = g + 0.5 | 0;\n  }\n\n  var b = color[2];\n\n  if (b != (b | 0)) {\n    b = b + 0.5 | 0;\n  }\n\n  var a = color[3] === undefined ? 1 : color[3];\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\n\nexport function isStringColor(s) {\n  if (NAMED_COLOR_RE_.test(s)) {\n    s = fromNamed(s);\n  }\n\n  return HEX_COLOR_RE_.test(s) || s.indexOf('rgba(') === 0 || s.indexOf('rgb(') === 0;\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ol/color.js"],"names":["assert","clamp","HEX_COLOR_RE_","NAMED_COLOR_RE_","asString","color","toString","fromNamed","el","document","createElement","style","body","appendChild","rgb","getComputedStyle","removeChild","fromString","MAX_CACHE_SIZE","cache","cacheSize","s","hasOwnProperty","i","key","fromStringInternal_","asArray","Array","isArray","r","g","b","a","exec","n","length","d","hasAlpha","parseInt","substr","indexOf","slice","split","map","Number","normalize","push","undefined","isStringColor","test"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,cAAvB;AACA,SAASC,KAAT,QAAsB,WAAtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,aAAa,GAAG,mDAApB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,eAAe,GAAG,2BAAtB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBC,KAAlB,EAAyB;AAC5B,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAOA,KAAP;AACH,GAFD,MAGK;AACD,WAAOC,QAAQ,CAACD,KAAD,CAAf;AACH;AACJ;AACD;AACA;AACA;AACA;AACA;;AACA,SAASE,SAAT,CAAmBF,KAAnB,EAA0B;AACtB,MAAIG,EAAE,GAAGC,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAT;AACAF,EAAAA,EAAE,CAACG,KAAH,CAASN,KAAT,GAAiBA,KAAjB;;AACA,MAAIG,EAAE,CAACG,KAAH,CAASN,KAAT,KAAmB,EAAvB,EAA2B;AACvBI,IAAAA,QAAQ,CAACG,IAAT,CAAcC,WAAd,CAA0BL,EAA1B;AACA,QAAIM,GAAG,GAAGC,gBAAgB,CAACP,EAAD,CAAhB,CAAqBH,KAA/B;AACAI,IAAAA,QAAQ,CAACG,IAAT,CAAcI,WAAd,CAA0BR,EAA1B;AACA,WAAOM,GAAP;AACH,GALD,MAMK;AACD,WAAO,EAAP;AACH;AACJ;AACD;AACA;AACA;AACA;;;AACA,OAAO,IAAIG,UAAU,GAAI,YAAY;AACjC;AACA;AACA;;AACA;AACJ;AACA;AACA;AACI,MAAIC,cAAc,GAAG,IAArB;AACA;AACJ;AACA;;AACI,MAAIC,KAAK,GAAG,EAAZ;AACA;AACJ;AACA;;AACI,MAAIC,SAAS,GAAG,CAAhB;AACA;AACA;AACJ;AACA;AACA;AACI,cAAUC,CAAV,EAAa;AACT,UAAIhB,KAAJ;;AACA,UAAIc,KAAK,CAACG,cAAN,CAAqBD,CAArB,CAAJ,EAA6B;AACzBhB,QAAAA,KAAK,GAAGc,KAAK,CAACE,CAAD,CAAb;AACH,OAFD,MAGK;AACD,YAAID,SAAS,IAAIF,cAAjB,EAAiC;AAC7B,cAAIK,CAAC,GAAG,CAAR;;AACA,eAAK,IAAIC,GAAT,IAAgBL,KAAhB,EAAuB;AACnB,gBAAI,CAACI,CAAC,KAAK,CAAP,MAAc,CAAlB,EAAqB;AACjB,qBAAOJ,KAAK,CAACK,GAAD,CAAZ;AACA,gBAAEJ,SAAF;AACH;AACJ;AACJ;;AACDf,QAAAA,KAAK,GAAGoB,mBAAmB,CAACJ,CAAD,CAA3B;AACAF,QAAAA,KAAK,CAACE,CAAD,CAAL,GAAWhB,KAAX;AACA,UAAEe,SAAF;AACH;;AACD,aAAOf,KAAP;AACH;AAzBD;AA0BH,CA3CuB,EAAjB;AA4CP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASqB,OAAT,CAAiBrB,KAAjB,EAAwB;AAC3B,MAAIsB,KAAK,CAACC,OAAN,CAAcvB,KAAd,CAAJ,EAA0B;AACtB,WAAOA,KAAP;AACH,GAFD,MAGK;AACD,WAAOY,UAAU,CAACZ,KAAD,CAAjB;AACH;AACJ;AACD;AACA;AACA;AACA;AACA;;AACA,SAASoB,mBAAT,CAA6BJ,CAA7B,EAAgC;AAC5B,MAAIQ,CAAJ,EAAOC,CAAP,EAAUC,CAAV,EAAaC,CAAb,EAAgB3B,KAAhB;;AACA,MAAIF,eAAe,CAAC8B,IAAhB,CAAqBZ,CAArB,CAAJ,EAA6B;AACzBA,IAAAA,CAAC,GAAGd,SAAS,CAACc,CAAD,CAAb;AACH;;AACD,MAAInB,aAAa,CAAC+B,IAAd,CAAmBZ,CAAnB,CAAJ,EAA2B;AACvB;AACA,QAAIa,CAAC,GAAGb,CAAC,CAACc,MAAF,GAAW,CAAnB,CAFuB,CAED;;AACtB,QAAIC,CAAC,GAAG;AACP,SAAK,CADN,CAHuB,CAId;;AACT,QAAIF,CAAC,IAAI,CAAT,EAAY;AACRE,MAAAA,CAAC,GAAG,CAAJ;AACH,KAFD,MAGK;AACDA,MAAAA,CAAC,GAAG,CAAJ;AACH;;AACD,QAAIC,QAAQ,GAAGH,CAAC,KAAK,CAAN,IAAWA,CAAC,KAAK,CAAhC;AACAL,IAAAA,CAAC,GAAGS,QAAQ,CAACjB,CAAC,CAACkB,MAAF,CAAS,IAAI,IAAIH,CAAjB,EAAoBA,CAApB,CAAD,EAAyB,EAAzB,CAAZ;AACAN,IAAAA,CAAC,GAAGQ,QAAQ,CAACjB,CAAC,CAACkB,MAAF,CAAS,IAAI,IAAIH,CAAjB,EAAoBA,CAApB,CAAD,EAAyB,EAAzB,CAAZ;AACAL,IAAAA,CAAC,GAAGO,QAAQ,CAACjB,CAAC,CAACkB,MAAF,CAAS,IAAI,IAAIH,CAAjB,EAAoBA,CAApB,CAAD,EAAyB,EAAzB,CAAZ;;AACA,QAAIC,QAAJ,EAAc;AACVL,MAAAA,CAAC,GAAGM,QAAQ,CAACjB,CAAC,CAACkB,MAAF,CAAS,IAAI,IAAIH,CAAjB,EAAoBA,CAApB,CAAD,EAAyB,EAAzB,CAAZ;AACH,KAFD,MAGK;AACDJ,MAAAA,CAAC,GAAG,GAAJ;AACH;;AACD,QAAII,CAAC,IAAI,CAAT,EAAY;AACRP,MAAAA,CAAC,GAAG,CAACA,CAAC,IAAI,CAAN,IAAWA,CAAf;AACAC,MAAAA,CAAC,GAAG,CAACA,CAAC,IAAI,CAAN,IAAWA,CAAf;AACAC,MAAAA,CAAC,GAAG,CAACA,CAAC,IAAI,CAAN,IAAWA,CAAf;;AACA,UAAIM,QAAJ,EAAc;AACVL,QAAAA,CAAC,GAAG,CAACA,CAAC,IAAI,CAAN,IAAWA,CAAf;AACH;AACJ;;AACD3B,IAAAA,KAAK,GAAG,CAACwB,CAAD,EAAIC,CAAJ,EAAOC,CAAP,EAAUC,CAAC,GAAG,GAAd,CAAR;AACH,GA9BD,MA+BK,IAAIX,CAAC,CAACmB,OAAF,CAAU,OAAV,KAAsB,CAA1B,EAA6B;AAC9B;AACAnC,IAAAA,KAAK,GAAGgB,CAAC,CAACoB,KAAF,CAAQ,CAAR,EAAW,CAAC,CAAZ,EAAeC,KAAf,CAAqB,GAArB,EAA0BC,GAA1B,CAA8BC,MAA9B,CAAR;AACAC,IAAAA,SAAS,CAACxC,KAAD,CAAT;AACH,GAJI,MAKA,IAAIgB,CAAC,CAACmB,OAAF,CAAU,MAAV,KAAqB,CAAzB,EAA4B;AAC7B;AACAnC,IAAAA,KAAK,GAAGgB,CAAC,CAACoB,KAAF,CAAQ,CAAR,EAAW,CAAC,CAAZ,EAAeC,KAAf,CAAqB,GAArB,EAA0BC,GAA1B,CAA8BC,MAA9B,CAAR;AACAvC,IAAAA,KAAK,CAACyC,IAAN,CAAW,CAAX;AACAD,IAAAA,SAAS,CAACxC,KAAD,CAAT;AACH,GALI,MAMA;AACDL,IAAAA,MAAM,CAAC,KAAD,EAAQ,EAAR,CAAN,CADC,CACkB;AACtB;;AACD,SAAOK,KAAP;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASwC,SAAT,CAAmBxC,KAAnB,EAA0B;AAC7BA,EAAAA,KAAK,CAAC,CAAD,CAAL,GAAWJ,KAAK,CAAEI,KAAK,CAAC,CAAD,CAAL,GAAW,GAAZ,GAAmB,CAApB,EAAuB,CAAvB,EAA0B,GAA1B,CAAhB;AACAA,EAAAA,KAAK,CAAC,CAAD,CAAL,GAAWJ,KAAK,CAAEI,KAAK,CAAC,CAAD,CAAL,GAAW,GAAZ,GAAmB,CAApB,EAAuB,CAAvB,EAA0B,GAA1B,CAAhB;AACAA,EAAAA,KAAK,CAAC,CAAD,CAAL,GAAWJ,KAAK,CAAEI,KAAK,CAAC,CAAD,CAAL,GAAW,GAAZ,GAAmB,CAApB,EAAuB,CAAvB,EAA0B,GAA1B,CAAhB;AACAA,EAAAA,KAAK,CAAC,CAAD,CAAL,GAAWJ,KAAK,CAACI,KAAK,CAAC,CAAD,CAAN,EAAW,CAAX,EAAc,CAAd,CAAhB;AACA,SAAOA,KAAP;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBD,KAAlB,EAAyB;AAC5B,MAAIwB,CAAC,GAAGxB,KAAK,CAAC,CAAD,CAAb;;AACA,MAAIwB,CAAC,KAAKA,CAAC,GAAG,CAAT,CAAL,EAAkB;AACdA,IAAAA,CAAC,GAAIA,CAAC,GAAG,GAAL,GAAY,CAAhB;AACH;;AACD,MAAIC,CAAC,GAAGzB,KAAK,CAAC,CAAD,CAAb;;AACA,MAAIyB,CAAC,KAAKA,CAAC,GAAG,CAAT,CAAL,EAAkB;AACdA,IAAAA,CAAC,GAAIA,CAAC,GAAG,GAAL,GAAY,CAAhB;AACH;;AACD,MAAIC,CAAC,GAAG1B,KAAK,CAAC,CAAD,CAAb;;AACA,MAAI0B,CAAC,KAAKA,CAAC,GAAG,CAAT,CAAL,EAAkB;AACdA,IAAAA,CAAC,GAAIA,CAAC,GAAG,GAAL,GAAY,CAAhB;AACH;;AACD,MAAIC,CAAC,GAAG3B,KAAK,CAAC,CAAD,CAAL,KAAa0C,SAAb,GAAyB,CAAzB,GAA6B1C,KAAK,CAAC,CAAD,CAA1C;AACA,SAAO,UAAUwB,CAAV,GAAc,GAAd,GAAoBC,CAApB,GAAwB,GAAxB,GAA8BC,CAA9B,GAAkC,GAAlC,GAAwCC,CAAxC,GAA4C,GAAnD;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASgB,aAAT,CAAuB3B,CAAvB,EAA0B;AAC7B,MAAIlB,eAAe,CAAC8C,IAAhB,CAAqB5B,CAArB,CAAJ,EAA6B;AACzBA,IAAAA,CAAC,GAAGd,SAAS,CAACc,CAAD,CAAb;AACH;;AACD,SAAQnB,aAAa,CAAC+C,IAAd,CAAmB5B,CAAnB,KAAyBA,CAAC,CAACmB,OAAF,CAAU,OAAV,MAAuB,CAAhD,IAAqDnB,CAAC,CAACmB,OAAF,CAAU,MAAV,MAAsB,CAAnF;AACH","sourcesContent":["/**\n * @module ol/color\n */\nimport { assert } from './asserts.js';\nimport { clamp } from './math.js';\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\nvar HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\nvar NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\\(.*\\)$/i;\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n    if (typeof color === 'string') {\n        return color;\n    }\n    else {\n        return toString(color);\n    }\n}\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\nfunction fromNamed(color) {\n    var el = document.createElement('div');\n    el.style.color = color;\n    if (el.style.color !== '') {\n        document.body.appendChild(el);\n        var rgb = getComputedStyle(el).color;\n        document.body.removeChild(el);\n        return rgb;\n    }\n    else {\n        return '';\n    }\n}\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport var fromString = (function () {\n    // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n    // semantics, whenever the cache grows too large we simply delete an\n    // arbitrary 25% of the entries.\n    /**\n     * @const\n     * @type {number}\n     */\n    var MAX_CACHE_SIZE = 1024;\n    /**\n     * @type {Object<string, Color>}\n     */\n    var cache = {};\n    /**\n     * @type {number}\n     */\n    var cacheSize = 0;\n    return (\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n    function (s) {\n        var color;\n        if (cache.hasOwnProperty(s)) {\n            color = cache[s];\n        }\n        else {\n            if (cacheSize >= MAX_CACHE_SIZE) {\n                var i = 0;\n                for (var key in cache) {\n                    if ((i++ & 3) === 0) {\n                        delete cache[key];\n                        --cacheSize;\n                    }\n                }\n            }\n            color = fromStringInternal_(s);\n            cache[s] = color;\n            ++cacheSize;\n        }\n        return color;\n    });\n})();\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n    if (Array.isArray(color)) {\n        return color;\n    }\n    else {\n        return fromString(color);\n    }\n}\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\nfunction fromStringInternal_(s) {\n    var r, g, b, a, color;\n    if (NAMED_COLOR_RE_.exec(s)) {\n        s = fromNamed(s);\n    }\n    if (HEX_COLOR_RE_.exec(s)) {\n        // hex\n        var n = s.length - 1; // number of hex digits\n        var d = // number of digits per channel\n         void 0; // number of digits per channel\n        if (n <= 4) {\n            d = 1;\n        }\n        else {\n            d = 2;\n        }\n        var hasAlpha = n === 4 || n === 8;\n        r = parseInt(s.substr(1 + 0 * d, d), 16);\n        g = parseInt(s.substr(1 + 1 * d, d), 16);\n        b = parseInt(s.substr(1 + 2 * d, d), 16);\n        if (hasAlpha) {\n            a = parseInt(s.substr(1 + 3 * d, d), 16);\n        }\n        else {\n            a = 255;\n        }\n        if (d == 1) {\n            r = (r << 4) + r;\n            g = (g << 4) + g;\n            b = (b << 4) + b;\n            if (hasAlpha) {\n                a = (a << 4) + a;\n            }\n        }\n        color = [r, g, b, a / 255];\n    }\n    else if (s.indexOf('rgba(') == 0) {\n        // rgba()\n        color = s.slice(5, -1).split(',').map(Number);\n        normalize(color);\n    }\n    else if (s.indexOf('rgb(') == 0) {\n        // rgb()\n        color = s.slice(4, -1).split(',').map(Number);\n        color.push(1);\n        normalize(color);\n    }\n    else {\n        assert(false, 14); // Invalid color\n    }\n    return color;\n}\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n    color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\n    color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\n    color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\n    color[3] = clamp(color[3], 0, 1);\n    return color;\n}\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n    var r = color[0];\n    if (r != (r | 0)) {\n        r = (r + 0.5) | 0;\n    }\n    var g = color[1];\n    if (g != (g | 0)) {\n        g = (g + 0.5) | 0;\n    }\n    var b = color[2];\n    if (b != (b | 0)) {\n        b = (b + 0.5) | 0;\n    }\n    var a = color[3] === undefined ? 1 : color[3];\n    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n    if (NAMED_COLOR_RE_.test(s)) {\n        s = fromNamed(s);\n    }\n    return (HEX_COLOR_RE_.test(s) || s.indexOf('rgba(') === 0 || s.indexOf('rgb(') === 0);\n}\n"]},"metadata":{},"sourceType":"module"}