{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/WKB\n */\n\n\nimport Feature from '../Feature.js';\nimport FeatureFormat, { transformGeometryWithOptions } from './Feature.js';\nimport FormatType from './FormatType.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { get as getProjection } from '../proj.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport { assign } from '../obj.js'; // WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n\n/**\n * @const\n * @enum {number}\n */\n\nvar WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n\n  /*\n  CIRCULAR_STRING: 8,\n  COMPOUND_CURVE: 9,\n  CURVE_POLYGON: 10,\n     MULTI_CURVE: 11,\n  MULTI_SURFACE: 12,\n  CURVE: 13,\n  SURFACE: 14,\n  */\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17\n};\n\nvar WkbReader = function () {\n  /**\n   * @param {DataView} view source to read\n   */\n  function WkbReader(view) {\n    this.view_ = view;\n    this.pos_ = 0;\n    this.initialized_ = false;\n    this.isLittleEndian_ = false;\n    this.hasZ_ = false;\n    this.hasM_ = false;\n    /** @type {number} */\n\n    this.srid_ = null;\n    this.layout_ = GeometryLayout.XY;\n  }\n  /**\n   * @return {number} value\n   */\n\n\n  WkbReader.prototype.readUint8 = function () {\n    return this.view_.getUint8(this.pos_++);\n  };\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n\n\n  WkbReader.prototype.readUint32 = function (isLittleEndian) {\n    return this.view_.getUint32((this.pos_ += 4) - 4, isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_);\n  };\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n\n\n  WkbReader.prototype.readDouble = function (isLittleEndian) {\n    return this.view_.getFloat64((this.pos_ += 8) - 8, isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_);\n  };\n  /**\n   * @return {import('../coordinate.js').Coordinate} coords for Point\n   */\n\n\n  WkbReader.prototype.readPoint = function () {\n    /** @type import('../coordinate.js').Coordinate */\n    var coords = [];\n    coords.push(this.readDouble());\n    coords.push(this.readDouble());\n\n    if (this.hasZ_) {\n      coords.push(this.readDouble());\n    }\n\n    if (this.hasM_) {\n      coords.push(this.readDouble());\n    }\n\n    return coords;\n  };\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n   */\n\n\n  WkbReader.prototype.readLineString = function () {\n    var numPoints = this.readUint32();\n    /** @type Array<import('../coordinate.js').Coordinate> */\n\n    var coords = [];\n\n    for (var i = 0; i < numPoints; i++) {\n      coords.push(this.readPoint());\n    }\n\n    return coords;\n  };\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n   */\n\n\n  WkbReader.prototype.readPolygon = function () {\n    var numRings = this.readUint32();\n    /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n\n    var rings = [];\n\n    for (var i = 0; i < numRings; i++) {\n      rings.push(this.readLineString()); // as a LinearRing\n    }\n\n    return rings;\n  };\n  /**\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {number} WKB Type ID\n   */\n\n\n  WkbReader.prototype.readWkbHeader = function (expectedTypeId) {\n    var byteOrder = this.readUint8();\n    var isLittleEndian = byteOrder > 0;\n    var wkbType = this.readUint32(isLittleEndian);\n    var wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n    var hasZ = Boolean(wkbType & 0x80000000) || wkbTypeThousandth === 1 || wkbTypeThousandth === 3;\n    var hasM = Boolean(wkbType & 0x40000000) || wkbTypeThousandth === 2 || wkbTypeThousandth === 3;\n    var hasSRID = Boolean(wkbType & 0x20000000);\n    var typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n\n    var layout = ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('');\n    var srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n\n    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n      throw new Error('Unexpected WKB geometry type ' + typeId);\n    }\n\n    if (this.initialized_) {\n      // sanity checks\n      if (this.isLittleEndian_ !== isLittleEndian) {\n        throw new Error('Inconsistent endian');\n      }\n\n      if (this.layout_ !== layout) {\n        throw new Error('Inconsistent geometry layout');\n      }\n\n      if (srid && this.srid_ !== srid) {\n        throw new Error('Inconsistent coordinate system (SRID)');\n      }\n    } else {\n      this.isLittleEndian_ = isLittleEndian;\n      this.hasZ_ = hasZ;\n      this.hasM_ = hasM;\n      this.layout_ = layout;\n      this.srid_ = srid;\n      this.initialized_ = true;\n    }\n\n    return typeId;\n  };\n  /**\n   * @param {number} typeId WKB Type ID\n   * @return {any} values read\n   */\n\n\n  WkbReader.prototype.readWkbPayload = function (typeId) {\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return this.readPoint();\n\n      case WKBGeometryType.LINE_STRING:\n        return this.readLineString();\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return this.readPolygon();\n\n      case WKBGeometryType.MULTI_POINT:\n        return this.readMultiPoint();\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return this.readMultiLineString();\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return this.readMultiPolygon();\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return this.readGeometryCollection();\n\n      default:\n        throw new Error('Unsupported WKB geometry type ' + typeId + ' is found');\n    }\n  };\n  /**\n   * @param {number} expectedTypeId Expected WKB Type ID\n   * @return {any} values read\n   */\n\n\n  WkbReader.prototype.readWkbBlock = function (expectedTypeId) {\n    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n  };\n  /**\n   * @param {Function} reader reader function for each item\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {any} values read\n   */\n\n\n  WkbReader.prototype.readWkbCollection = function (reader, expectedTypeId) {\n    var num = this.readUint32();\n    var items = [];\n\n    for (var i = 0; i < num; i++) {\n      var result = reader.call(this, expectedTypeId);\n\n      if (result) {\n        items.push(result);\n      }\n    }\n\n    return items;\n  };\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n   */\n\n\n  WkbReader.prototype.readMultiPoint = function () {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n  };\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n   */\n\n\n  WkbReader.prototype.readMultiLineString = function () {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.LINE_STRING);\n  };\n  /**\n   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n   */\n\n\n  WkbReader.prototype.readMultiPolygon = function () {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n  };\n  /**\n   * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n   */\n\n\n  WkbReader.prototype.readGeometryCollection = function () {\n    return this.readWkbCollection(this.readGeometry);\n  };\n  /**\n   * @return {import('../geom/Geometry.js').default} geometry\n   */\n\n\n  WkbReader.prototype.readGeometry = function () {\n    var typeId = this.readWkbHeader();\n    var result = this.readWkbPayload(typeId);\n\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return new Point(result, this.layout_);\n\n      case WKBGeometryType.LINE_STRING:\n        return new LineString(result, this.layout_);\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return new Polygon(result, this.layout_);\n\n      case WKBGeometryType.MULTI_POINT:\n        return new MultiPoint(result, this.layout_);\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return new MultiLineString(result, this.layout_);\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return new MultiPolygon(result, this.layout_);\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return new GeometryCollection(result);\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * @return {number} SRID in the EWKB. `null` if not defined.\n   */\n\n\n  WkbReader.prototype.getSrid = function () {\n    return this.srid_;\n  };\n\n  return WkbReader;\n}();\n\nvar WkbWriter = function () {\n  /**\n   * @type {object}\n   * @property {string} [layout] geometryLayout\n   * @property {boolean} [littleEndian=true] littleEndian\n   * @property {boolean} [ewkb=true] Whether writes in EWKB format\n   * @property {object} [nodata] NoData value for each axes\n   * @param {object} opts options\n   */\n  function WkbWriter(opts) {\n    opts = opts || {};\n    /** @type {string} */\n\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n    this.isEWKB_ = opts.ewkb !== false;\n    /** @type {Array<Array<number>>} */\n\n    this.writeQueue_ = [];\n    /**\n     * @type {object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} Z NoData value for Z\n     * @property {number} M NoData value for M\n     */\n\n    this.nodata_ = assign({\n      X: 0,\n      Y: 0,\n      Z: 0,\n      M: 0\n    }, opts.nodata);\n  }\n  /**\n   * @param {number} value value\n   */\n\n\n  WkbWriter.prototype.writeUint8 = function (value) {\n    this.writeQueue_.push([1, value]);\n  };\n  /**\n   * @param {number} value value\n   */\n\n\n  WkbWriter.prototype.writeUint32 = function (value) {\n    this.writeQueue_.push([4, value]);\n  };\n  /**\n   * @param {number} value value\n   */\n\n\n  WkbWriter.prototype.writeDouble = function (value) {\n    this.writeQueue_.push([8, value]);\n  };\n  /**\n   * @param {import('../coordinate.js').Coordinate} coords coords\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n\n\n  WkbWriter.prototype.writePoint = function (coords, layout) {\n    /**\n     * @type {object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} [Z] NoData value for Z\n     * @property {number} [M] NoData value for M\n     */\n    var coordsObj = assign.apply(null, layout.split('').map(function (axis, idx) {\n      var _a;\n\n      return _a = {}, _a[axis] = coords[idx], _a;\n    }));\n\n    for (var _i = 0, _a = this.layout_; _i < _a.length; _i++) {\n      var axis = _a[_i];\n      this.writeDouble(axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]);\n    }\n  };\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n\n\n  WkbWriter.prototype.writeLineString = function (coords, layout) {\n    this.writeUint32(coords.length); // numPoints\n\n    for (var i = 0; i < coords.length; i++) {\n      this.writePoint(coords[i], layout);\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n\n\n  WkbWriter.prototype.writePolygon = function (rings, layout) {\n    this.writeUint32(rings.length); // numRings\n\n    for (var i = 0; i < rings.length; i++) {\n      this.writeLineString(rings[i], layout); // as a LinearRing\n    }\n  };\n  /**\n   * @param {number} wkbType WKB Type ID\n   * @param {number} [srid] SRID\n   */\n\n\n  WkbWriter.prototype.writeWkbHeader = function (wkbType, srid) {\n    wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n\n    if (this.layout_.indexOf('Z') >= 0) {\n      wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n    }\n\n    if (this.layout_.indexOf('M') >= 0) {\n      wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n    }\n\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      wkbType |= 0x20000000;\n    }\n\n    this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n    this.writeUint32(wkbType);\n\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      this.writeUint32(srid);\n    }\n  };\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {string} layout layout\n   */\n\n\n  WkbWriter.prototype.writeMultiPoint = function (coords, layout) {\n    this.writeUint32(coords.length); // numItems\n\n    for (var i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(1);\n      this.writePoint(coords[i], layout);\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n   * @param {string} layout layout\n   */\n\n\n  WkbWriter.prototype.writeMultiLineString = function (coords, layout) {\n    this.writeUint32(coords.length); // numItems\n\n    for (var i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(2);\n      this.writeLineString(coords[i], layout);\n    }\n  };\n  /**\n   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n   * @param {string} layout layout\n   */\n\n\n  WkbWriter.prototype.writeMultiPolygon = function (coords, layout) {\n    this.writeUint32(coords.length); // numItems\n\n    for (var i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(3);\n      this.writePolygon(coords[i], layout);\n    }\n  };\n  /**\n   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n   */\n\n\n  WkbWriter.prototype.writeGeometryCollection = function (geometries) {\n    this.writeUint32(geometries.length); // numItems\n\n    for (var i = 0; i < geometries.length; i++) {\n      this.writeGeometry(geometries[i]);\n    }\n  };\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {import(\"../geom/GeometryLayout.js\").default} [layout] layout\n   * @return {import(\"../geom/GeometryLayout.js\").default} minumum layout made by common axes\n   */\n\n\n  WkbWriter.prototype.findMinimumLayout = function (geom, layout) {\n    if (layout === void 0) {\n      layout = GeometryLayout.XYZM;\n    }\n    /**\n     * @param {import(\"../geom/GeometryLayout.js\").default} a A\n     * @param {import(\"../geom/GeometryLayout.js\").default} b B\n     * @return {import(\"../geom/GeometryLayout.js\").default} minumum layout made by common axes\n     */\n\n\n    var GeometryLayout_min = function (a, b) {\n      if (a === b) {\n        return a;\n      }\n\n      if (a === GeometryLayout.XYZM) {\n        // anything `b` is minimum\n        return b;\n      }\n\n      if (b === GeometryLayout.XYZM) {\n        // anything `a` is minimum\n        return a;\n      } // otherwise, incompatible\n\n\n      return GeometryLayout.XY;\n    };\n\n    if (geom instanceof SimpleGeometry) {\n      return GeometryLayout_min(geom.getLayout(), layout);\n    }\n\n    if (geom instanceof GeometryCollection) {\n      var geoms = geom.getGeometriesArray();\n\n      for (var i = 0; i < geoms.length && layout !== GeometryLayout.XY; i++) {\n        layout = this.findMinimumLayout(geoms[i], layout);\n      }\n    }\n\n    return layout;\n  };\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {number} [srid] SRID\n   */\n\n\n  WkbWriter.prototype.writeGeometry = function (geom, srid) {\n    var _a, _b;\n\n    var wkblut = (_a = {}, _a[GeometryType.POINT] = WKBGeometryType.POINT, _a[GeometryType.LINE_STRING] = WKBGeometryType.LINE_STRING, _a[GeometryType.POLYGON] = WKBGeometryType.POLYGON, _a[GeometryType.MULTI_POINT] = WKBGeometryType.MULTI_POINT, _a[GeometryType.MULTI_LINE_STRING] = WKBGeometryType.MULTI_LINE_STRING, _a[GeometryType.MULTI_POLYGON] = WKBGeometryType.MULTI_POLYGON, _a[GeometryType.GEOMETRY_COLLECTION] = WKBGeometryType.GEOMETRY_COLLECTION, _a);\n    var geomType = geom.getType();\n    var typeId = wkblut[geomType];\n\n    if (!typeId) {\n      throw new Error('GeometryType ' + geomType + ' is not supported');\n    } // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n\n\n    if (!this.layout_) {\n      this.layout_ = this.findMinimumLayout(geom);\n    }\n\n    this.writeWkbHeader(typeId, srid);\n\n    if (geom instanceof SimpleGeometry) {\n      var writerLUT = (_b = {}, _b[GeometryType.POINT] = this.writePoint, _b[GeometryType.LINE_STRING] = this.writeLineString, _b[GeometryType.POLYGON] = this.writePolygon, _b[GeometryType.MULTI_POINT] = this.writeMultiPoint, _b[GeometryType.MULTI_LINE_STRING] = this.writeMultiLineString, _b[GeometryType.MULTI_POLYGON] = this.writeMultiPolygon, _b);\n      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n    } else if (geom instanceof GeometryCollection) {\n      this.writeGeometryCollection(geom.getGeometriesArray());\n    }\n  };\n\n  WkbWriter.prototype.getBuffer = function () {\n    var _this = this;\n\n    var byteLength = this.writeQueue_.reduce(function (acc, item) {\n      return acc + item[0];\n    }, 0);\n    var buffer = new ArrayBuffer(byteLength);\n    var view = new DataView(buffer);\n    var pos = 0;\n    this.writeQueue_.forEach(function (item) {\n      switch (item[0]) {\n        case 1:\n          view.setUint8(pos, item[1]);\n          break;\n\n        case 4:\n          view.setUint32(pos, item[1], _this.isLittleEndian_);\n          break;\n\n        case 8:\n          view.setFloat64(pos, item[1], _this.isLittleEndian_);\n          break;\n\n        default:\n          break;\n      }\n\n      pos += item[0];\n    });\n    return buffer;\n  };\n\n  return WkbWriter;\n}();\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/GeometryLayout\").default} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\n\n\nvar WKB = function (_super) {\n  __extends(WKB, _super);\n  /**\n   * @param {Options} [opt_options] Optional configuration object.\n   */\n\n\n  function WKB(opt_options) {\n    var _this = _super.call(this) || this;\n\n    var options = opt_options ? opt_options : {};\n    _this.splitCollection = Boolean(options.splitCollection);\n    _this.viewCache_ = null;\n    _this.hex_ = options.hex !== false;\n    _this.littleEndian_ = options.littleEndian !== false;\n    _this.ewkb_ = options.ewkb !== false;\n    _this.layout_ = options.geometryLayout; // null for auto detect\n\n    _this.nodataZ_ = options.nodataZ || 0;\n    _this.nodataM_ = options.nodataM || 0;\n    _this.srid_ = options.srid;\n    return _this;\n  }\n  /**\n   * @return {import(\"./FormatType.js\").default} Format.\n   */\n\n\n  WKB.prototype.getType = function () {\n    return this.hex_ ? FormatType.TEXT : FormatType.ARRAY_BUFFER;\n  };\n  /**\n   * Read a single feature from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../Feature.js\").FeatureLike} Feature.\n   * @api\n   */\n\n\n  WKB.prototype.readFeature = function (source, opt_options) {\n    return new Feature({\n      geometry: this.readGeometry(source, opt_options)\n    });\n  };\n  /**\n   * Read all features from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n\n\n  WKB.prototype.readFeatures = function (source, opt_options) {\n    var geometries = [];\n    var geometry = this.readGeometry(source, opt_options);\n\n    if (this.splitCollection && geometry instanceof GeometryCollection) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n\n    return geometries.map(function (geometry) {\n      return new Feature({\n        geometry: geometry\n      });\n    });\n  };\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n\n\n  WKB.prototype.readGeometry = function (source, opt_options) {\n    var view = getDataView(source);\n\n    if (!view) {\n      return null;\n    }\n\n    var reader = new WkbReader(view);\n    var geometry = reader.readGeometry();\n    this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n\n    var options = this.getReadOptions(source, opt_options);\n    this.viewCache_ = null; // release\n\n    return transformGeometryWithOptions(geometry, false, options);\n  };\n  /**\n   * Read the projection from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   */\n\n\n  WKB.prototype.readProjection = function (source) {\n    var view = this.viewCache_ || getDataView(source);\n\n    if (!view) {\n      return undefined;\n    }\n\n    var reader = new WkbReader(view);\n    reader.readWkbHeader();\n    return reader.getSrid() && getProjection('EPSG:' + reader.getSrid()) || undefined;\n  };\n  /**\n   * Encode a feature in this format.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n\n\n  WKB.prototype.writeFeature = function (feature, opt_options) {\n    return this.writeGeometry(feature.getGeometry(), opt_options);\n  };\n  /**\n   * Encode an array of features in this format.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n\n\n  WKB.prototype.writeFeatures = function (features, opt_options) {\n    return this.writeGeometry(new GeometryCollection(features.map(function (f) {\n      return f.getGeometry();\n    })), opt_options);\n  };\n  /**\n   * Write a single geometry in this format.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n\n\n  WKB.prototype.writeGeometry = function (geometry, opt_options) {\n    var options = this.adaptOptions(opt_options);\n    var writer = new WkbWriter({\n      layout: this.layout_,\n      littleEndian: this.littleEndian_,\n      ewkb: this.ewkb_,\n      nodata: {\n        Z: this.nodataZ_,\n        M: this.nodataM_\n      }\n    }); // extract SRID from `dataProjection`\n\n    var srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n\n    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n      var dataProjection = options.dataProjection && getProjection(options.dataProjection);\n\n      if (dataProjection) {\n        var code = dataProjection.getCode();\n\n        if (code.indexOf('EPSG:') === 0) {\n          srid = Number(code.substring(5));\n        }\n      }\n    }\n\n    writer.writeGeometry(transformGeometryWithOptions(geometry, true, options), srid);\n    var buffer = writer.getBuffer();\n    return this.hex_ ? encodeHexString(buffer) : buffer;\n  };\n\n  return WKB;\n}(FeatureFormat);\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\n\n\nfunction encodeHexString(buffer) {\n  var view = new Uint8Array(buffer);\n  return Array.from(view.values()).map(function (x) {\n    return (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase();\n  }).join('');\n}\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\n\n\nfunction decodeHexString(text) {\n  var buffer = new Uint8Array(text.length / 2);\n\n  for (var i = 0; i < text.length / 2; i++) {\n    buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n  }\n\n  return new DataView(buffer.buffer);\n}\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\n\n\nfunction getDataView(source) {\n  if (typeof source === 'string') {\n    return decodeHexString(source);\n  } else if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  } else if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  } else {\n    return null;\n  }\n}\n\nexport default WKB;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/format/WKB.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","Feature","FeatureFormat","transformGeometryWithOptions","FormatType","GeometryCollection","GeometryLayout","GeometryType","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","get","getProjection","SimpleGeometry","assign","WKBGeometryType","POINT","LINE_STRING","POLYGON","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","GEOMETRY_COLLECTION","POLYHEDRAL_SURFACE","TIN","TRIANGLE","WkbReader","view","view_","pos_","initialized_","isLittleEndian_","hasZ_","hasM_","srid_","layout_","XY","readUint8","getUint8","readUint32","isLittleEndian","getUint32","undefined","readDouble","getFloat64","readPoint","coords","push","readLineString","numPoints","i","readPolygon","numRings","rings","readWkbHeader","expectedTypeId","byteOrder","wkbType","wkbTypeThousandth","Math","floor","hasZ","Boolean","hasM","hasSRID","typeId","layout","join","srid","Error","readWkbPayload","readMultiPoint","readMultiLineString","readMultiPolygon","readGeometryCollection","readWkbBlock","readWkbCollection","reader","num","items","result","readGeometry","getSrid","WkbWriter","opts","littleEndian","isEWKB_","ewkb","writeQueue_","nodata_","X","Y","Z","M","nodata","writeUint8","value","writeUint32","writeDouble","writePoint","coordsObj","apply","split","map","axis","idx","_a","_i","length","writeLineString","writePolygon","writeWkbHeader","indexOf","Number","isInteger","writeMultiPoint","writeMultiLineString","writeMultiPolygon","writeGeometryCollection","geometries","writeGeometry","findMinimumLayout","geom","XYZM","GeometryLayout_min","a","getLayout","geoms","getGeometriesArray","_b","wkblut","geomType","getType","writerLUT","getCoordinates","getBuffer","_this","byteLength","reduce","acc","item","buffer","ArrayBuffer","DataView","pos","forEach","setUint8","setUint32","setFloat64","WKB","_super","opt_options","options","splitCollection","viewCache_","hex_","hex","littleEndian_","ewkb_","geometryLayout","nodataZ_","nodataZ","nodataM_","nodataM","TEXT","ARRAY_BUFFER","readFeature","source","geometry","readFeatures","getDataView","getReadOptions","readProjection","writeFeature","feature","getGeometry","writeFeatures","features","f","adaptOptions","writer","dataProjection","code","getCode","substring","encodeHexString","Uint8Array","from","values","x","toString","toUpperCase","decodeHexString","text","parseInt","substr","isView","byteOffset"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/WKB\n */\nimport Feature from '../Feature.js';\nimport FeatureFormat, { transformGeometryWithOptions } from './Feature.js';\nimport FormatType from './FormatType.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { get as getProjection } from '../proj.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport { assign } from '../obj.js';\n// WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n/**\n * @const\n * @enum {number}\n */\nvar WKBGeometryType = {\n    POINT: 1,\n    LINE_STRING: 2,\n    POLYGON: 3,\n    MULTI_POINT: 4,\n    MULTI_LINE_STRING: 5,\n    MULTI_POLYGON: 6,\n    GEOMETRY_COLLECTION: 7,\n    /*\n    CIRCULAR_STRING: 8,\n    COMPOUND_CURVE: 9,\n    CURVE_POLYGON: 10,\n  \n    MULTI_CURVE: 11,\n    MULTI_SURFACE: 12,\n    CURVE: 13,\n    SURFACE: 14,\n    */\n    POLYHEDRAL_SURFACE: 15,\n    TIN: 16,\n    TRIANGLE: 17,\n};\nvar WkbReader = /** @class */ (function () {\n    /**\n     * @param {DataView} view source to read\n     */\n    function WkbReader(view) {\n        this.view_ = view;\n        this.pos_ = 0;\n        this.initialized_ = false;\n        this.isLittleEndian_ = false;\n        this.hasZ_ = false;\n        this.hasM_ = false;\n        /** @type {number} */\n        this.srid_ = null;\n        this.layout_ = GeometryLayout.XY;\n    }\n    /**\n     * @return {number} value\n     */\n    WkbReader.prototype.readUint8 = function () {\n        return this.view_.getUint8(this.pos_++);\n    };\n    /**\n     * @param {boolean} [isLittleEndian] Whether read value as little endian\n     * @return {number} value\n     */\n    WkbReader.prototype.readUint32 = function (isLittleEndian) {\n        return this.view_.getUint32((this.pos_ += 4) - 4, isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_);\n    };\n    /**\n     * @param {boolean} [isLittleEndian] Whether read value as little endian\n     * @return {number} value\n     */\n    WkbReader.prototype.readDouble = function (isLittleEndian) {\n        return this.view_.getFloat64((this.pos_ += 8) - 8, isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_);\n    };\n    /**\n     * @return {import('../coordinate.js').Coordinate} coords for Point\n     */\n    WkbReader.prototype.readPoint = function () {\n        /** @type import('../coordinate.js').Coordinate */\n        var coords = [];\n        coords.push(this.readDouble());\n        coords.push(this.readDouble());\n        if (this.hasZ_) {\n            coords.push(this.readDouble());\n        }\n        if (this.hasM_) {\n            coords.push(this.readDouble());\n        }\n        return coords;\n    };\n    /**\n     * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n     */\n    WkbReader.prototype.readLineString = function () {\n        var numPoints = this.readUint32();\n        /** @type Array<import('../coordinate.js').Coordinate> */\n        var coords = [];\n        for (var i = 0; i < numPoints; i++) {\n            coords.push(this.readPoint());\n        }\n        return coords;\n    };\n    /**\n     * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n     */\n    WkbReader.prototype.readPolygon = function () {\n        var numRings = this.readUint32();\n        /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n        var rings = [];\n        for (var i = 0; i < numRings; i++) {\n            rings.push(this.readLineString()); // as a LinearRing\n        }\n        return rings;\n    };\n    /**\n     * @param {number} [expectedTypeId] Expected WKB Type ID\n     * @return {number} WKB Type ID\n     */\n    WkbReader.prototype.readWkbHeader = function (expectedTypeId) {\n        var byteOrder = this.readUint8();\n        var isLittleEndian = byteOrder > 0;\n        var wkbType = this.readUint32(isLittleEndian);\n        var wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n        var hasZ = Boolean(wkbType & 0x80000000) ||\n            wkbTypeThousandth === 1 ||\n            wkbTypeThousandth === 3;\n        var hasM = Boolean(wkbType & 0x40000000) ||\n            wkbTypeThousandth === 2 ||\n            wkbTypeThousandth === 3;\n        var hasSRID = Boolean(wkbType & 0x20000000);\n        var typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n        var layout = ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('');\n        var srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n        if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n            throw new Error('Unexpected WKB geometry type ' + typeId);\n        }\n        if (this.initialized_) {\n            // sanity checks\n            if (this.isLittleEndian_ !== isLittleEndian) {\n                throw new Error('Inconsistent endian');\n            }\n            if (this.layout_ !== layout) {\n                throw new Error('Inconsistent geometry layout');\n            }\n            if (srid && this.srid_ !== srid) {\n                throw new Error('Inconsistent coordinate system (SRID)');\n            }\n        }\n        else {\n            this.isLittleEndian_ = isLittleEndian;\n            this.hasZ_ = hasZ;\n            this.hasM_ = hasM;\n            this.layout_ = layout;\n            this.srid_ = srid;\n            this.initialized_ = true;\n        }\n        return typeId;\n    };\n    /**\n     * @param {number} typeId WKB Type ID\n     * @return {any} values read\n     */\n    WkbReader.prototype.readWkbPayload = function (typeId) {\n        switch (typeId) {\n            case WKBGeometryType.POINT:\n                return this.readPoint();\n            case WKBGeometryType.LINE_STRING:\n                return this.readLineString();\n            case WKBGeometryType.POLYGON:\n            case WKBGeometryType.TRIANGLE:\n                return this.readPolygon();\n            case WKBGeometryType.MULTI_POINT:\n                return this.readMultiPoint();\n            case WKBGeometryType.MULTI_LINE_STRING:\n                return this.readMultiLineString();\n            case WKBGeometryType.MULTI_POLYGON:\n            case WKBGeometryType.POLYHEDRAL_SURFACE:\n            case WKBGeometryType.TIN:\n                return this.readMultiPolygon();\n            case WKBGeometryType.GEOMETRY_COLLECTION:\n                return this.readGeometryCollection();\n            default:\n                throw new Error('Unsupported WKB geometry type ' + typeId + ' is found');\n        }\n    };\n    /**\n     * @param {number} expectedTypeId Expected WKB Type ID\n     * @return {any} values read\n     */\n    WkbReader.prototype.readWkbBlock = function (expectedTypeId) {\n        return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n    };\n    /**\n     * @param {Function} reader reader function for each item\n     * @param {number} [expectedTypeId] Expected WKB Type ID\n     * @return {any} values read\n     */\n    WkbReader.prototype.readWkbCollection = function (reader, expectedTypeId) {\n        var num = this.readUint32();\n        var items = [];\n        for (var i = 0; i < num; i++) {\n            var result = reader.call(this, expectedTypeId);\n            if (result) {\n                items.push(result);\n            }\n        }\n        return items;\n    };\n    /**\n     * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n     */\n    WkbReader.prototype.readMultiPoint = function () {\n        return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n    };\n    /**\n     * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n     */\n    WkbReader.prototype.readMultiLineString = function () {\n        return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.LINE_STRING);\n    };\n    /**\n     * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n     */\n    WkbReader.prototype.readMultiPolygon = function () {\n        return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n    };\n    /**\n     * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n     */\n    WkbReader.prototype.readGeometryCollection = function () {\n        return this.readWkbCollection(this.readGeometry);\n    };\n    /**\n     * @return {import('../geom/Geometry.js').default} geometry\n     */\n    WkbReader.prototype.readGeometry = function () {\n        var typeId = this.readWkbHeader();\n        var result = this.readWkbPayload(typeId);\n        switch (typeId) {\n            case WKBGeometryType.POINT:\n                return new Point(\n                /** @type {import('../coordinate.js').Coordinate} */ (result), this.layout_);\n            case WKBGeometryType.LINE_STRING:\n                return new LineString(\n                /** @type {Array<import('../coordinate.js').Coordinate>} */ (result), this.layout_);\n            case WKBGeometryType.POLYGON:\n            case WKBGeometryType.TRIANGLE:\n                return new Polygon(\n                /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (result), this.layout_);\n            case WKBGeometryType.MULTI_POINT:\n                return new MultiPoint(\n                /** @type {Array<import('../coordinate.js').Coordinate>} */ (result), this.layout_);\n            case WKBGeometryType.MULTI_LINE_STRING:\n                return new MultiLineString(\n                /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (result), this.layout_);\n            case WKBGeometryType.MULTI_POLYGON:\n            case WKBGeometryType.POLYHEDRAL_SURFACE:\n            case WKBGeometryType.TIN:\n                return new MultiPolygon(\n                /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */ (result), this.layout_);\n            case WKBGeometryType.GEOMETRY_COLLECTION:\n                return new GeometryCollection(\n                /** @type {Array<import('../geom/Geometry.js').default>} */ (result));\n            default:\n                return null;\n        }\n    };\n    /**\n     * @return {number} SRID in the EWKB. `null` if not defined.\n     */\n    WkbReader.prototype.getSrid = function () {\n        return this.srid_;\n    };\n    return WkbReader;\n}());\nvar WkbWriter = /** @class */ (function () {\n    /**\n     * @type {object}\n     * @property {string} [layout] geometryLayout\n     * @property {boolean} [littleEndian=true] littleEndian\n     * @property {boolean} [ewkb=true] Whether writes in EWKB format\n     * @property {object} [nodata] NoData value for each axes\n     * @param {object} opts options\n     */\n    function WkbWriter(opts) {\n        opts = opts || {};\n        /** @type {string} */\n        this.layout_ = opts.layout;\n        this.isLittleEndian_ = opts.littleEndian !== false;\n        this.isEWKB_ = opts.ewkb !== false;\n        /** @type {Array<Array<number>>} */\n        this.writeQueue_ = [];\n        /**\n         * @type {object}\n         * @property {number} X NoData value for X\n         * @property {number} Y NoData value for Y\n         * @property {number} Z NoData value for Z\n         * @property {number} M NoData value for M\n         */\n        this.nodata_ = assign({ X: 0, Y: 0, Z: 0, M: 0 }, opts.nodata);\n    }\n    /**\n     * @param {number} value value\n     */\n    WkbWriter.prototype.writeUint8 = function (value) {\n        this.writeQueue_.push([1, value]);\n    };\n    /**\n     * @param {number} value value\n     */\n    WkbWriter.prototype.writeUint32 = function (value) {\n        this.writeQueue_.push([4, value]);\n    };\n    /**\n     * @param {number} value value\n     */\n    WkbWriter.prototype.writeDouble = function (value) {\n        this.writeQueue_.push([8, value]);\n    };\n    /**\n     * @param {import('../coordinate.js').Coordinate} coords coords\n     * @param {import(\"../geom/GeometryLayout\").default} layout layout\n     */\n    WkbWriter.prototype.writePoint = function (coords, layout) {\n        /**\n         * @type {object}\n         * @property {number} X NoData value for X\n         * @property {number} Y NoData value for Y\n         * @property {number} [Z] NoData value for Z\n         * @property {number} [M] NoData value for M\n         */\n        var coordsObj = assign.apply(null, layout.split('').map(function (axis, idx) {\n            var _a;\n            return (_a = {}, _a[axis] = coords[idx], _a);\n        }));\n        for (var _i = 0, _a = this.layout_; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            this.writeDouble(axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]);\n        }\n    };\n    /**\n     * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n     * @param {import(\"../geom/GeometryLayout\").default} layout layout\n     */\n    WkbWriter.prototype.writeLineString = function (coords, layout) {\n        this.writeUint32(coords.length); // numPoints\n        for (var i = 0; i < coords.length; i++) {\n            this.writePoint(coords[i], layout);\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n     * @param {import(\"../geom/GeometryLayout\").default} layout layout\n     */\n    WkbWriter.prototype.writePolygon = function (rings, layout) {\n        this.writeUint32(rings.length); // numRings\n        for (var i = 0; i < rings.length; i++) {\n            this.writeLineString(rings[i], layout); // as a LinearRing\n        }\n    };\n    /**\n     * @param {number} wkbType WKB Type ID\n     * @param {number} [srid] SRID\n     */\n    WkbWriter.prototype.writeWkbHeader = function (wkbType, srid) {\n        wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n        if (this.layout_.indexOf('Z') >= 0) {\n            wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n        }\n        if (this.layout_.indexOf('M') >= 0) {\n            wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n        }\n        if (this.isEWKB_ && Number.isInteger(srid)) {\n            wkbType |= 0x20000000;\n        }\n        this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n        this.writeUint32(wkbType);\n        if (this.isEWKB_ && Number.isInteger(srid)) {\n            this.writeUint32(srid);\n        }\n    };\n    /**\n     * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n     * @param {string} layout layout\n     */\n    WkbWriter.prototype.writeMultiPoint = function (coords, layout) {\n        this.writeUint32(coords.length); // numItems\n        for (var i = 0; i < coords.length; i++) {\n            this.writeWkbHeader(1);\n            this.writePoint(coords[i], layout);\n        }\n    };\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n     * @param {string} layout layout\n     */\n    WkbWriter.prototype.writeMultiLineString = function (coords, layout) {\n        this.writeUint32(coords.length); // numItems\n        for (var i = 0; i < coords.length; i++) {\n            this.writeWkbHeader(2);\n            this.writeLineString(coords[i], layout);\n        }\n    };\n    /**\n     * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n     * @param {string} layout layout\n     */\n    WkbWriter.prototype.writeMultiPolygon = function (coords, layout) {\n        this.writeUint32(coords.length); // numItems\n        for (var i = 0; i < coords.length; i++) {\n            this.writeWkbHeader(3);\n            this.writePolygon(coords[i], layout);\n        }\n    };\n    /**\n     * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n     */\n    WkbWriter.prototype.writeGeometryCollection = function (geometries) {\n        this.writeUint32(geometries.length); // numItems\n        for (var i = 0; i < geometries.length; i++) {\n            this.writeGeometry(geometries[i]);\n        }\n    };\n    /**\n     * @param {import(\"../geom/Geometry.js\").default} geom geometry\n     * @param {import(\"../geom/GeometryLayout.js\").default} [layout] layout\n     * @return {import(\"../geom/GeometryLayout.js\").default} minumum layout made by common axes\n     */\n    WkbWriter.prototype.findMinimumLayout = function (geom, layout) {\n        if (layout === void 0) { layout = GeometryLayout.XYZM; }\n        /**\n         * @param {import(\"../geom/GeometryLayout.js\").default} a A\n         * @param {import(\"../geom/GeometryLayout.js\").default} b B\n         * @return {import(\"../geom/GeometryLayout.js\").default} minumum layout made by common axes\n         */\n        var GeometryLayout_min = function (a, b) {\n            if (a === b) {\n                return a;\n            }\n            if (a === GeometryLayout.XYZM) {\n                // anything `b` is minimum\n                return b;\n            }\n            if (b === GeometryLayout.XYZM) {\n                // anything `a` is minimum\n                return a;\n            }\n            // otherwise, incompatible\n            return GeometryLayout.XY;\n        };\n        if (geom instanceof SimpleGeometry) {\n            return GeometryLayout_min(geom.getLayout(), layout);\n        }\n        if (geom instanceof GeometryCollection) {\n            var geoms = geom.getGeometriesArray();\n            for (var i = 0; i < geoms.length && layout !== GeometryLayout.XY; i++) {\n                layout = this.findMinimumLayout(geoms[i], layout);\n            }\n        }\n        return layout;\n    };\n    /**\n     * @param {import(\"../geom/Geometry.js\").default} geom geometry\n     * @param {number} [srid] SRID\n     */\n    WkbWriter.prototype.writeGeometry = function (geom, srid) {\n        var _a, _b;\n        var wkblut = (_a = {},\n            _a[GeometryType.POINT] = WKBGeometryType.POINT,\n            _a[GeometryType.LINE_STRING] = WKBGeometryType.LINE_STRING,\n            _a[GeometryType.POLYGON] = WKBGeometryType.POLYGON,\n            _a[GeometryType.MULTI_POINT] = WKBGeometryType.MULTI_POINT,\n            _a[GeometryType.MULTI_LINE_STRING] = WKBGeometryType.MULTI_LINE_STRING,\n            _a[GeometryType.MULTI_POLYGON] = WKBGeometryType.MULTI_POLYGON,\n            _a[GeometryType.GEOMETRY_COLLECTION] = WKBGeometryType.GEOMETRY_COLLECTION,\n            _a);\n        var geomType = geom.getType();\n        var typeId = wkblut[geomType];\n        if (!typeId) {\n            throw new Error('GeometryType ' + geomType + ' is not supported');\n        }\n        // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n        if (!this.layout_) {\n            this.layout_ = this.findMinimumLayout(geom);\n        }\n        this.writeWkbHeader(typeId, srid);\n        if (geom instanceof SimpleGeometry) {\n            var writerLUT = (_b = {},\n                _b[GeometryType.POINT] = this.writePoint,\n                _b[GeometryType.LINE_STRING] = this.writeLineString,\n                _b[GeometryType.POLYGON] = this.writePolygon,\n                _b[GeometryType.MULTI_POINT] = this.writeMultiPoint,\n                _b[GeometryType.MULTI_LINE_STRING] = this.writeMultiLineString,\n                _b[GeometryType.MULTI_POLYGON] = this.writeMultiPolygon,\n                _b);\n            writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n        }\n        else if (geom instanceof GeometryCollection) {\n            this.writeGeometryCollection(geom.getGeometriesArray());\n        }\n    };\n    WkbWriter.prototype.getBuffer = function () {\n        var _this = this;\n        var byteLength = this.writeQueue_.reduce(function (acc, item) { return acc + item[0]; }, 0);\n        var buffer = new ArrayBuffer(byteLength);\n        var view = new DataView(buffer);\n        var pos = 0;\n        this.writeQueue_.forEach(function (item) {\n            switch (item[0]) {\n                case 1:\n                    view.setUint8(pos, item[1]);\n                    break;\n                case 4:\n                    view.setUint32(pos, item[1], _this.isLittleEndian_);\n                    break;\n                case 8:\n                    view.setFloat64(pos, item[1], _this.isLittleEndian_);\n                    break;\n                default:\n                    break;\n            }\n            pos += item[0];\n        });\n        return buffer;\n    };\n    return WkbWriter;\n}());\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/GeometryLayout\").default} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\nvar WKB = /** @class */ (function (_super) {\n    __extends(WKB, _super);\n    /**\n     * @param {Options} [opt_options] Optional configuration object.\n     */\n    function WKB(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        _this.splitCollection = Boolean(options.splitCollection);\n        _this.viewCache_ = null;\n        _this.hex_ = options.hex !== false;\n        _this.littleEndian_ = options.littleEndian !== false;\n        _this.ewkb_ = options.ewkb !== false;\n        _this.layout_ = options.geometryLayout; // null for auto detect\n        _this.nodataZ_ = options.nodataZ || 0;\n        _this.nodataM_ = options.nodataM || 0;\n        _this.srid_ = options.srid;\n        return _this;\n    }\n    /**\n     * @return {import(\"./FormatType.js\").default} Format.\n     */\n    WKB.prototype.getType = function () {\n        return this.hex_ ? FormatType.TEXT : FormatType.ARRAY_BUFFER;\n    };\n    /**\n     * Read a single feature from a source.\n     *\n     * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @return {import(\"../Feature.js\").FeatureLike} Feature.\n     * @api\n     */\n    WKB.prototype.readFeature = function (source, opt_options) {\n        return new Feature({\n            geometry: this.readGeometry(source, opt_options),\n        });\n    };\n    /**\n     * Read all features from a source.\n     *\n     * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n     * @api\n     */\n    WKB.prototype.readFeatures = function (source, opt_options) {\n        var geometries = [];\n        var geometry = this.readGeometry(source, opt_options);\n        if (this.splitCollection && geometry instanceof GeometryCollection) {\n            geometries = geometry.getGeometriesArray();\n        }\n        else {\n            geometries = [geometry];\n        }\n        return geometries.map(function (geometry) { return new Feature({ geometry: geometry }); });\n    };\n    /**\n     * Read a single geometry from a source.\n     *\n     * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     * @api\n     */\n    WKB.prototype.readGeometry = function (source, opt_options) {\n        var view = getDataView(source);\n        if (!view) {\n            return null;\n        }\n        var reader = new WkbReader(view);\n        var geometry = reader.readGeometry();\n        this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n        var options = this.getReadOptions(source, opt_options);\n        this.viewCache_ = null; // release\n        return transformGeometryWithOptions(geometry, false, options);\n    };\n    /**\n     * Read the projection from a source.\n     *\n     * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n     * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n     * @api\n     */\n    WKB.prototype.readProjection = function (source) {\n        var view = this.viewCache_ || getDataView(source);\n        if (!view) {\n            return undefined;\n        }\n        var reader = new WkbReader(view);\n        reader.readWkbHeader();\n        return ((reader.getSrid() && getProjection('EPSG:' + reader.getSrid())) ||\n            undefined);\n    };\n    /**\n     * Encode a feature in this format.\n     *\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     * @api\n     */\n    WKB.prototype.writeFeature = function (feature, opt_options) {\n        return this.writeGeometry(feature.getGeometry(), opt_options);\n    };\n    /**\n     * Encode an array of features in this format.\n     *\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     * @api\n     */\n    WKB.prototype.writeFeatures = function (features, opt_options) {\n        return this.writeGeometry(new GeometryCollection(features.map(function (f) { return f.getGeometry(); })), opt_options);\n    };\n    /**\n     * Write a single geometry in this format.\n     *\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     * @api\n     */\n    WKB.prototype.writeGeometry = function (geometry, opt_options) {\n        var options = this.adaptOptions(opt_options);\n        var writer = new WkbWriter({\n            layout: this.layout_,\n            littleEndian: this.littleEndian_,\n            ewkb: this.ewkb_,\n            nodata: {\n                Z: this.nodataZ_,\n                M: this.nodataM_,\n            },\n        });\n        // extract SRID from `dataProjection`\n        var srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n        if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n            var dataProjection = options.dataProjection && getProjection(options.dataProjection);\n            if (dataProjection) {\n                var code = dataProjection.getCode();\n                if (code.indexOf('EPSG:') === 0) {\n                    srid = Number(code.substring(5));\n                }\n            }\n        }\n        writer.writeGeometry(transformGeometryWithOptions(geometry, true, options), srid);\n        var buffer = writer.getBuffer();\n        return this.hex_ ? encodeHexString(buffer) : buffer;\n    };\n    return WKB;\n}(FeatureFormat));\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\nfunction encodeHexString(buffer) {\n    var view = new Uint8Array(buffer);\n    return Array.from(view.values())\n        .map(function (x) { return (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase(); })\n        .join('');\n}\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\nfunction decodeHexString(text) {\n    var buffer = new Uint8Array(text.length / 2);\n    for (var i = 0; i < text.length / 2; i++) {\n        buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n    }\n    return new DataView(buffer.buffer);\n}\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\nfunction getDataView(source) {\n    if (typeof source === 'string') {\n        return decodeHexString(source);\n    }\n    else if (ArrayBuffer.isView(source)) {\n        if (source instanceof DataView) {\n            return source;\n        }\n        return new DataView(source.buffer, source.byteOffset, source.byteLength);\n    }\n    else if (source instanceof ArrayBuffer) {\n        return new DataView(source);\n    }\n    else {\n        return null;\n    }\n}\nexport default WKB;\n"]},"metadata":{},"sourceType":"module"}