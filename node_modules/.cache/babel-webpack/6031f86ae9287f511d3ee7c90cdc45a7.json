{"ast":null,"code":"/*! @azure/msal-common v4.5.1 2021-08-02 */\n'use strict';\n\nimport { __extends } from '../_virtual/_tslib.js';\nimport { Constants, CredentialType, CacheSchemaType, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS, AuthenticationScheme } from '../utils/Constants.js';\nimport { CredentialEntity } from './entities/CredentialEntity.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from './entities/AccountEntity.js';\nimport { AuthError } from '../error/AuthError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { AuthToken } from '../account/AuthToken.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\n\nvar CacheManager = function () {\n  function CacheManager(clientId, cryptoImpl) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n  }\n  /**\r\n   * Returns all accounts in cache\r\n   */\n\n\n  CacheManager.prototype.getAllAccounts = function () {\n    var _this = this;\n\n    var currentAccounts = this.getAccountsFilteredBy();\n    var accountValues = Object.keys(currentAccounts).map(function (accountKey) {\n      return currentAccounts[accountKey];\n    });\n    var numAccounts = accountValues.length;\n\n    if (numAccounts < 1) {\n      return [];\n    } else {\n      var allAccounts = accountValues.map(function (value) {\n        var accountEntity = CacheManager.toObject(new AccountEntity(), value);\n        var accountInfo = accountEntity.getAccountInfo();\n\n        var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);\n\n        if (idToken && !accountInfo.idTokenClaims) {\n          accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims;\n        }\n\n        return accountInfo;\n      });\n      return allAccounts;\n    }\n  };\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord\r\n   */\n\n\n  CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\n    if (!cacheRecord) {\n      throw ClientAuthError.createNullOrUndefinedCacheRecord();\n    }\n\n    if (!!cacheRecord.account) {\n      this.setAccount(cacheRecord.account);\n    }\n\n    if (!!cacheRecord.idToken) {\n      this.setIdTokenCredential(cacheRecord.idToken);\n    }\n\n    if (!!cacheRecord.accessToken) {\n      this.saveAccessToken(cacheRecord.accessToken);\n    }\n\n    if (!!cacheRecord.refreshToken) {\n      this.setRefreshTokenCredential(cacheRecord.refreshToken);\n    }\n\n    if (!!cacheRecord.appMetadata) {\n      this.setAppMetadata(cacheRecord.appMetadata);\n    }\n  };\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n\n\n  CacheManager.prototype.saveAccessToken = function (credential) {\n    var _this = this;\n\n    var currentTokenCache = this.getCredentialsFilteredBy({\n      clientId: credential.clientId,\n      credentialType: credential.credentialType,\n      environment: credential.environment,\n      homeAccountId: credential.homeAccountId,\n      realm: credential.realm\n    });\n    var currentScopes = ScopeSet.fromString(credential.target);\n    var currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function (key) {\n      return currentTokenCache.accessTokens[key];\n    });\n\n    if (currentAccessTokens) {\n      currentAccessTokens.forEach(function (tokenEntity) {\n        var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n\n        if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n          _this.removeCredential(tokenEntity);\n        }\n      });\n    }\n\n    this.setAccessTokenCredential(credential);\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\n    return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : \"\", accountFilter ? accountFilter.environment : \"\", accountFilter ? accountFilter.realm : \"\");\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.getAccountsFilteredByInternal = function (homeAccountId, environment, realm) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingAccounts = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      var entity = _this.getAccount(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!realm && !_this.matchRealm(entity, realm)) {\n        return;\n      }\n\n      matchingAccounts[cacheKey] = entity;\n    });\n    return matchingAccounts;\n  };\n  /**\r\n   * retrieve credentails matching all provided filters; if no filter is set, get all credentials\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param credentialType\r\n   * @param clientId\r\n   * @param realm\r\n   * @param target\r\n   */\n\n\n  CacheManager.prototype.getCredentialsFilteredBy = function (filter) {\n    return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.oboAssertion);\n  };\n  /**\r\n   * Support function to help match credentials\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param credentialType\r\n   * @param clientId\r\n   * @param realm\r\n   * @param target\r\n   */\n\n\n  CacheManager.prototype.getCredentialsFilteredByInternal = function (homeAccountId, environment, credentialType, clientId, familyId, realm, target, oboAssertion) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingCredentials = {\n      idTokens: {},\n      accessTokens: {},\n      refreshTokens: {}\n    };\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-credential type cache entities\n      var credType = CredentialEntity.getCredentialType(cacheKey);\n\n      if (credType === Constants.NOT_DEFINED) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getSpecificCredential(cacheKey, credType);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!oboAssertion && !_this.matchOboAssertion(entity, oboAssertion)) {\n        return;\n      }\n\n      if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!realm && !_this.matchRealm(entity, realm)) {\n        return;\n      }\n\n      if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {\n        return;\n      }\n\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n\n      if (!!familyId && !_this.matchFamilyId(entity, familyId)) {\n        return;\n      }\n      /*\r\n       * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n       * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n       */\n\n\n      if (!!target && !_this.matchTarget(entity, target)) {\n        return;\n      }\n\n      switch (credType) {\n        case CredentialType.ID_TOKEN:\n          matchingCredentials.idTokens[cacheKey] = entity;\n          break;\n\n        case CredentialType.ACCESS_TOKEN:\n        case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n          matchingCredentials.accessTokens[cacheKey] = entity;\n          break;\n\n        case CredentialType.REFRESH_TOKEN:\n          matchingCredentials.refreshTokens[cacheKey] = entity;\n          break;\n      }\n    });\n    return matchingCredentials;\n  };\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  };\n  /**\r\n   * Support function to help match appMetadata\r\n   * @param environment\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingAppMetadata = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-appMetadata type cache entities\n      if (!_this.isAppMetadata(cacheKey)) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getAppMetadata(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  };\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\n    var _this = this;\n\n    var allCacheKeys = this.getAuthorityMetadataKeys();\n    var matchedEntity = null;\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getAuthorityMetadata(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  };\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n\n\n  CacheManager.prototype.removeAllAccounts = function () {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      var entity = _this.getAccount(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      _this.removeAccount(cacheKey);\n    });\n    return true;\n  };\n  /**\r\n   * returns a boolean if the given account is removed\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.removeAccount = function (accountKey) {\n    var account = this.getAccount(accountKey);\n\n    if (!account) {\n      throw ClientAuthError.createNoAccountFoundError();\n    }\n\n    return this.removeAccountContext(account) && this.removeItem(accountKey, CacheSchemaType.ACCOUNT);\n  };\n  /**\r\n   * returns a boolean if the given account is removed\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.removeAccountContext = function (account) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var accountId = account.generateAccountId();\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-credential type cache entities\n      var credType = CredentialEntity.getCredentialType(cacheKey);\n\n      if (credType === Constants.NOT_DEFINED) {\n        return;\n      }\n\n      var cacheEntity = _this.getSpecificCredential(cacheKey, credType);\n\n      if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\n        _this.removeCredential(cacheEntity);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * returns a boolean if the given credential is removed\r\n   * @param credential\r\n   */\n\n\n  CacheManager.prototype.removeCredential = function (credential) {\n    var key = credential.generateCredentialKey();\n    return this.removeItem(key, CacheSchemaType.CREDENTIAL);\n  };\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n\n\n  CacheManager.prototype.removeAppMetadata = function () {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      if (_this.isAppMetadata(cacheKey)) {\n        _this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * Retrieve the cached credentials into a cacherecord\r\n   * @param account\r\n   * @param clientId\r\n   * @param scopes\r\n   * @param environment\r\n   * @param authScheme\r\n   */\n\n\n  CacheManager.prototype.readCacheRecord = function (account, clientId, scopes, environment, authScheme) {\n    var cachedAccount = this.readAccountFromCache(account);\n    var cachedIdToken = this.readIdTokenFromCache(clientId, account);\n    var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, scopes, authScheme);\n    var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\n    var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\n\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n    }\n\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.readAccountFromCache = function (account) {\n    var accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  };\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param inputRealm\r\n   */\n\n\n  CacheManager.prototype.readIdTokenFromCache = function (clientId, account) {\n    var idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: clientId,\n      realm: account.tenantId\n    };\n    var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);\n    var idTokens = Object.keys(credentialCache.idTokens).map(function (key) {\n      return credentialCache.idTokens[key];\n    });\n    var numIdTokens = idTokens.length;\n\n    if (numIdTokens < 1) {\n      return null;\n    } else if (numIdTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n\n    return idTokens[0];\n  };\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param scopes\r\n   * @param authScheme\r\n   */\n\n\n  CacheManager.prototype.readAccessTokenFromCache = function (clientId, account, scopes, authScheme) {\n    var credentialType = authScheme === AuthenticationScheme.POP ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: clientId,\n      realm: account.tenantId,\n      target: scopes.printScopesLowerCase()\n    };\n    var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\n    var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) {\n      return credentialCache.accessTokens[key];\n    });\n    var numAccessTokens = accessTokens.length;\n\n    if (numAccessTokens < 1) {\n      return null;\n    } else if (numAccessTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n\n    return accessTokens[0];\n  };\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param familyRT\r\n   */\n\n\n  CacheManager.prototype.readRefreshTokenFromCache = function (clientId, account, familyRT) {\n    var id = familyRT ? THE_FAMILY_ID : undefined;\n    var refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: clientId,\n      familyId: id\n    };\n    var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\n    var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function (key) {\n      return credentialCache.refreshTokens[key];\n    });\n    var numRefreshTokens = refreshTokens.length;\n\n    if (numRefreshTokens < 1) {\n      return null;\n    } // address the else case after remove functions address environment aliases\n\n\n    return refreshTokens[0];\n  };\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n\n\n  CacheManager.prototype.readAppMetadataFromCache = function (environment, clientId) {\n    var appMetadataFilter = {\n      environment: environment,\n      clientId: clientId\n    };\n    var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    var appMetadataEntries = Object.keys(appMetadata).map(function (key) {\n      return appMetadata[key];\n    });\n    var numAppMetadata = appMetadataEntries.length;\n\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n    }\n\n    return appMetadataEntries[0];\n  };\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.isAppMetadataFOCI = function (environment, clientId) {\n    var appMetadata = this.readAppMetadataFromCache(environment, clientId);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n\n\n  CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\n    return !!(entity.homeAccountId && homeAccountId === entity.homeAccountId);\n  };\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n\n\n  CacheManager.prototype.matchOboAssertion = function (entity, oboAssertion) {\n    return !!(entity.oboAssertion && oboAssertion === entity.oboAssertion);\n  };\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n\n\n  CacheManager.prototype.matchEnvironment = function (entity, environment) {\n    var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n\n\n  CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  };\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.matchClientId = function (entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  };\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n\n\n  CacheManager.prototype.matchFamilyId = function (entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  };\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.matchRealm = function (entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  };\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n\n\n  CacheManager.prototype.matchTarget = function (entity, target) {\n    var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n\n    var entityScopeSet = ScopeSet.fromString(entity.target);\n    var requestTargetScopeSet = ScopeSet.fromString(target);\n\n    if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\n      requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\n    } else {\n      requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\n    }\n\n    return entityScopeSet.containsScopeSet(requestTargetScopeSet);\n  };\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isAppMetadata = function (key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  };\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isAuthorityMetadata = function (key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  };\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n\n\n  CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\n    return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\n  };\n  /**\r\n   * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\r\n   * @param key\r\n   * @param credType\r\n   */\n\n\n  CacheManager.prototype.getSpecificCredential = function (key, credType) {\n    switch (credType) {\n      case CredentialType.ID_TOKEN:\n        {\n          return this.getIdTokenCredential(key);\n        }\n\n      case CredentialType.ACCESS_TOKEN:\n      case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n        {\n          return this.getAccessTokenCredential(key);\n        }\n\n      case CredentialType.REFRESH_TOKEN:\n        {\n          return this.getRefreshTokenCredential(key);\n        }\n\n      default:\n        return null;\n    }\n  };\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n\n\n  CacheManager.toObject = function (obj, json) {\n    for (var propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n\n    return obj;\n  };\n\n  return CacheManager;\n}();\n\nvar DefaultStorageClass = function (_super) {\n  __extends(DefaultStorageClass, _super);\n\n  function DefaultStorageClass() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DefaultStorageClass.prototype.setAccount = function () {\n    var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccount = function () {\n    var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAppMetadata = function () {\n    var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAppMetadata = function () {\n    var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setServerTelemetry = function () {\n    var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getServerTelemetry = function () {\n    var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setThrottlingCache = function () {\n    var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getThrottlingCache = function () {\n    var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.removeItem = function () {\n    var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.containsKey = function () {\n    var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getKeys = function () {\n    var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.clear = function () {\n    var notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  return DefaultStorageClass;\n}(CacheManager);\n\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/@azure/msal-common/dist/cache/CacheManager.js"],"names":["__extends","Constants","CredentialType","CacheSchemaType","THE_FAMILY_ID","APP_METADATA","AUTHORITY_METADATA_CONSTANTS","AuthenticationScheme","CredentialEntity","ScopeSet","AccountEntity","AuthError","ClientAuthError","AuthToken","CacheManager","clientId","cryptoImpl","prototype","getAllAccounts","_this","currentAccounts","getAccountsFilteredBy","accountValues","Object","keys","map","accountKey","numAccounts","length","allAccounts","value","accountEntity","toObject","accountInfo","getAccountInfo","idToken","readIdTokenFromCache","idTokenClaims","secret","claims","saveCacheRecord","cacheRecord","createNullOrUndefinedCacheRecord","account","setAccount","setIdTokenCredential","accessToken","saveAccessToken","refreshToken","setRefreshTokenCredential","appMetadata","setAppMetadata","credential","currentTokenCache","getCredentialsFilteredBy","credentialType","environment","homeAccountId","realm","currentScopes","fromString","target","currentAccessTokens","accessTokens","key","forEach","tokenEntity","tokenScopeSet","intersectingScopeSets","removeCredential","setAccessTokenCredential","accountFilter","getAccountsFilteredByInternal","allCacheKeys","getKeys","matchingAccounts","cacheKey","entity","getAccount","matchHomeAccountId","matchEnvironment","matchRealm","filter","getCredentialsFilteredByInternal","familyId","oboAssertion","matchingCredentials","idTokens","refreshTokens","credType","getCredentialType","NOT_DEFINED","getSpecificCredential","matchOboAssertion","matchCredentialType","matchClientId","matchFamilyId","matchTarget","ID_TOKEN","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","REFRESH_TOKEN","getAppMetadataFilteredBy","getAppMetadataFilteredByInternal","matchingAppMetadata","isAppMetadata","getAppMetadata","getAuthorityMetadataByAlias","host","getAuthorityMetadataKeys","matchedEntity","isAuthorityMetadata","indexOf","getAuthorityMetadata","aliases","removeAllAccounts","removeAccount","createNoAccountFoundError","removeAccountContext","removeItem","ACCOUNT","accountId","generateAccountId","cacheEntity","generateCredentialKey","CREDENTIAL","removeAppMetadata","readCacheRecord","scopes","authScheme","cachedAccount","readAccountFromCache","cachedIdToken","cachedAccessToken","readAccessTokenFromCache","cachedRefreshToken","readRefreshTokenFromCache","cachedAppMetadata","readAppMetadataFromCache","generateAccountCacheKey","idTokenFilter","tenantId","credentialCache","numIdTokens","createMultipleMatchingTokensInCacheError","POP","accessTokenFilter","printScopesLowerCase","numAccessTokens","familyRT","id","undefined","refreshTokenFilter","numRefreshTokens","appMetadataFilter","appMetadataEntries","numAppMetadata","createMultipleMatchingAppMetadataInCacheError","isAppMetadataFOCI","cloudMetadata","toLowerCase","isNotAccessTokenCredential","entityScopeSet","requestTargetScopeSet","containsOnlyOIDCScopes","removeOIDCScopes","removeScope","OFFLINE_ACCESS_SCOPE","containsScopeSet","CACHE_KEY","generateAuthorityMetadataCacheKey","authority","getIdTokenCredential","getAccessTokenCredential","getRefreshTokenCredential","obj","json","propertyName","DefaultStorageClass","_super","apply","arguments","notImplErr","createUnexpectedError","setServerTelemetry","getServerTelemetry","setAuthorityMetadata","setThrottlingCache","getThrottlingCache","containsKey","clear"],"mappings":"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","sourcesContent":["/*! @azure/msal-common v4.5.1 2021-08-02 */\n'use strict';\nimport { __extends } from '../_virtual/_tslib.js';\nimport { Constants, CredentialType, CacheSchemaType, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS, AuthenticationScheme } from '../utils/Constants.js';\nimport { CredentialEntity } from './entities/CredentialEntity.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from './entities/AccountEntity.js';\nimport { AuthError } from '../error/AuthError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { AuthToken } from '../account/AuthToken.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\r\nvar CacheManager = /** @class */ (function () {\r\n    function CacheManager(clientId, cryptoImpl) {\r\n        this.clientId = clientId;\r\n        this.cryptoImpl = cryptoImpl;\r\n    }\r\n    /**\r\n     * Returns all accounts in cache\r\n     */\r\n    CacheManager.prototype.getAllAccounts = function () {\r\n        var _this = this;\r\n        var currentAccounts = this.getAccountsFilteredBy();\r\n        var accountValues = Object.keys(currentAccounts).map(function (accountKey) { return currentAccounts[accountKey]; });\r\n        var numAccounts = accountValues.length;\r\n        if (numAccounts < 1) {\r\n            return [];\r\n        }\r\n        else {\r\n            var allAccounts = accountValues.map(function (value) {\r\n                var accountEntity = CacheManager.toObject(new AccountEntity(), value);\r\n                var accountInfo = accountEntity.getAccountInfo();\r\n                var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);\r\n                if (idToken && !accountInfo.idTokenClaims) {\r\n                    accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims;\r\n                }\r\n                return accountInfo;\r\n            });\r\n            return allAccounts;\r\n        }\r\n    };\r\n    /**\r\n     * saves a cache record\r\n     * @param cacheRecord\r\n     */\r\n    CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\r\n        if (!cacheRecord) {\r\n            throw ClientAuthError.createNullOrUndefinedCacheRecord();\r\n        }\r\n        if (!!cacheRecord.account) {\r\n            this.setAccount(cacheRecord.account);\r\n        }\r\n        if (!!cacheRecord.idToken) {\r\n            this.setIdTokenCredential(cacheRecord.idToken);\r\n        }\r\n        if (!!cacheRecord.accessToken) {\r\n            this.saveAccessToken(cacheRecord.accessToken);\r\n        }\r\n        if (!!cacheRecord.refreshToken) {\r\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\r\n        }\r\n        if (!!cacheRecord.appMetadata) {\r\n            this.setAppMetadata(cacheRecord.appMetadata);\r\n        }\r\n    };\r\n    /**\r\n     * saves access token credential\r\n     * @param credential\r\n     */\r\n    CacheManager.prototype.saveAccessToken = function (credential) {\r\n        var _this = this;\r\n        var currentTokenCache = this.getCredentialsFilteredBy({\r\n            clientId: credential.clientId,\r\n            credentialType: credential.credentialType,\r\n            environment: credential.environment,\r\n            homeAccountId: credential.homeAccountId,\r\n            realm: credential.realm,\r\n        });\r\n        var currentScopes = ScopeSet.fromString(credential.target);\r\n        var currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function (key) { return currentTokenCache.accessTokens[key]; });\r\n        if (currentAccessTokens) {\r\n            currentAccessTokens.forEach(function (tokenEntity) {\r\n                var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\r\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\r\n                    _this.removeCredential(tokenEntity);\r\n                }\r\n            });\r\n        }\r\n        this.setAccessTokenCredential(credential);\r\n    };\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\r\n        return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : \"\", accountFilter ? accountFilter.environment : \"\", accountFilter ? accountFilter.realm : \"\");\r\n    };\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    CacheManager.prototype.getAccountsFilteredByInternal = function (homeAccountId, environment, realm) {\r\n        var _this = this;\r\n        var allCacheKeys = this.getKeys();\r\n        var matchingAccounts = {};\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            var entity = _this.getAccount(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\r\n                return;\r\n            }\r\n            if (!!environment && !_this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n            if (!!realm && !_this.matchRealm(entity, realm)) {\r\n                return;\r\n            }\r\n            matchingAccounts[cacheKey] = entity;\r\n        });\r\n        return matchingAccounts;\r\n    };\r\n    /**\r\n     * retrieve credentails matching all provided filters; if no filter is set, get all credentials\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param credentialType\r\n     * @param clientId\r\n     * @param realm\r\n     * @param target\r\n     */\r\n    CacheManager.prototype.getCredentialsFilteredBy = function (filter) {\r\n        return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.oboAssertion);\r\n    };\r\n    /**\r\n     * Support function to help match credentials\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param credentialType\r\n     * @param clientId\r\n     * @param realm\r\n     * @param target\r\n     */\r\n    CacheManager.prototype.getCredentialsFilteredByInternal = function (homeAccountId, environment, credentialType, clientId, familyId, realm, target, oboAssertion) {\r\n        var _this = this;\r\n        var allCacheKeys = this.getKeys();\r\n        var matchingCredentials = {\r\n            idTokens: {},\r\n            accessTokens: {},\r\n            refreshTokens: {},\r\n        };\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            // don't parse any non-credential type cache entities\r\n            var credType = CredentialEntity.getCredentialType(cacheKey);\r\n            if (credType === Constants.NOT_DEFINED) {\r\n                return;\r\n            }\r\n            // Attempt retrieval\r\n            var entity = _this.getSpecificCredential(cacheKey, credType);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (!!oboAssertion && !_this.matchOboAssertion(entity, oboAssertion)) {\r\n                return;\r\n            }\r\n            if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\r\n                return;\r\n            }\r\n            if (!!environment && !_this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n            if (!!realm && !_this.matchRealm(entity, realm)) {\r\n                return;\r\n            }\r\n            if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {\r\n                return;\r\n            }\r\n            if (!!clientId && !_this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n            if (!!familyId && !_this.matchFamilyId(entity, familyId)) {\r\n                return;\r\n            }\r\n            /*\r\n             * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n             * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n             */\r\n            if (!!target && !_this.matchTarget(entity, target)) {\r\n                return;\r\n            }\r\n            switch (credType) {\r\n                case CredentialType.ID_TOKEN:\r\n                    matchingCredentials.idTokens[cacheKey] = entity;\r\n                    break;\r\n                case CredentialType.ACCESS_TOKEN:\r\n                case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\r\n                    matchingCredentials.accessTokens[cacheKey] = entity;\r\n                    break;\r\n                case CredentialType.REFRESH_TOKEN:\r\n                    matchingCredentials.refreshTokens[cacheKey] = entity;\r\n                    break;\r\n            }\r\n        });\r\n        return matchingCredentials;\r\n    };\r\n    /**\r\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n     * @param filter\r\n     */\r\n    CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\r\n        return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\r\n    };\r\n    /**\r\n     * Support function to help match appMetadata\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\r\n        var _this = this;\r\n        var allCacheKeys = this.getKeys();\r\n        var matchingAppMetadata = {};\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            // don't parse any non-appMetadata type cache entities\r\n            if (!_this.isAppMetadata(cacheKey)) {\r\n                return;\r\n            }\r\n            // Attempt retrieval\r\n            var entity = _this.getAppMetadata(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (!!environment && !_this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n            if (!!clientId && !_this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n            matchingAppMetadata[cacheKey] = entity;\r\n        });\r\n        return matchingAppMetadata;\r\n    };\r\n    /**\r\n     * retrieve authorityMetadata that contains a matching alias\r\n     * @param filter\r\n     */\r\n    CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\r\n        var _this = this;\r\n        var allCacheKeys = this.getAuthorityMetadataKeys();\r\n        var matchedEntity = null;\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            // don't parse any non-authorityMetadata type cache entities\r\n            if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\r\n                return;\r\n            }\r\n            // Attempt retrieval\r\n            var entity = _this.getAuthorityMetadata(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (entity.aliases.indexOf(host) === -1) {\r\n                return;\r\n            }\r\n            matchedEntity = entity;\r\n        });\r\n        return matchedEntity;\r\n    };\r\n    /**\r\n     * Removes all accounts and related tokens from cache.\r\n     */\r\n    CacheManager.prototype.removeAllAccounts = function () {\r\n        var _this = this;\r\n        var allCacheKeys = this.getKeys();\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            var entity = _this.getAccount(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            _this.removeAccount(cacheKey);\r\n        });\r\n        return true;\r\n    };\r\n    /**\r\n     * returns a boolean if the given account is removed\r\n     * @param account\r\n     */\r\n    CacheManager.prototype.removeAccount = function (accountKey) {\r\n        var account = this.getAccount(accountKey);\r\n        if (!account) {\r\n            throw ClientAuthError.createNoAccountFoundError();\r\n        }\r\n        return (this.removeAccountContext(account) && this.removeItem(accountKey, CacheSchemaType.ACCOUNT));\r\n    };\r\n    /**\r\n     * returns a boolean if the given account is removed\r\n     * @param account\r\n     */\r\n    CacheManager.prototype.removeAccountContext = function (account) {\r\n        var _this = this;\r\n        var allCacheKeys = this.getKeys();\r\n        var accountId = account.generateAccountId();\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            // don't parse any non-credential type cache entities\r\n            var credType = CredentialEntity.getCredentialType(cacheKey);\r\n            if (credType === Constants.NOT_DEFINED) {\r\n                return;\r\n            }\r\n            var cacheEntity = _this.getSpecificCredential(cacheKey, credType);\r\n            if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\r\n                _this.removeCredential(cacheEntity);\r\n            }\r\n        });\r\n        return true;\r\n    };\r\n    /**\r\n     * returns a boolean if the given credential is removed\r\n     * @param credential\r\n     */\r\n    CacheManager.prototype.removeCredential = function (credential) {\r\n        var key = credential.generateCredentialKey();\r\n        return this.removeItem(key, CacheSchemaType.CREDENTIAL);\r\n    };\r\n    /**\r\n     * Removes all app metadata objects from cache.\r\n     */\r\n    CacheManager.prototype.removeAppMetadata = function () {\r\n        var _this = this;\r\n        var allCacheKeys = this.getKeys();\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            if (_this.isAppMetadata(cacheKey)) {\r\n                _this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\r\n            }\r\n        });\r\n        return true;\r\n    };\r\n    /**\r\n     * Retrieve the cached credentials into a cacherecord\r\n     * @param account\r\n     * @param clientId\r\n     * @param scopes\r\n     * @param environment\r\n     * @param authScheme\r\n     */\r\n    CacheManager.prototype.readCacheRecord = function (account, clientId, scopes, environment, authScheme) {\r\n        var cachedAccount = this.readAccountFromCache(account);\r\n        var cachedIdToken = this.readIdTokenFromCache(clientId, account);\r\n        var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, scopes, authScheme);\r\n        var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\r\n        var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\r\n        if (cachedAccount && cachedIdToken) {\r\n            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\r\n        }\r\n        return {\r\n            account: cachedAccount,\r\n            idToken: cachedIdToken,\r\n            accessToken: cachedAccessToken,\r\n            refreshToken: cachedRefreshToken,\r\n            appMetadata: cachedAppMetadata,\r\n        };\r\n    };\r\n    /**\r\n     * Retrieve AccountEntity from cache\r\n     * @param account\r\n     */\r\n    CacheManager.prototype.readAccountFromCache = function (account) {\r\n        var accountKey = AccountEntity.generateAccountCacheKey(account);\r\n        return this.getAccount(accountKey);\r\n    };\r\n    /**\r\n     * Retrieve IdTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param inputRealm\r\n     */\r\n    CacheManager.prototype.readIdTokenFromCache = function (clientId, account) {\r\n        var idTokenFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: clientId,\r\n            realm: account.tenantId,\r\n        };\r\n        var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);\r\n        var idTokens = Object.keys(credentialCache.idTokens).map(function (key) { return credentialCache.idTokens[key]; });\r\n        var numIdTokens = idTokens.length;\r\n        if (numIdTokens < 1) {\r\n            return null;\r\n        }\r\n        else if (numIdTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n        return idTokens[0];\r\n    };\r\n    /**\r\n     * Retrieve AccessTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param scopes\r\n     * @param authScheme\r\n     */\r\n    CacheManager.prototype.readAccessTokenFromCache = function (clientId, account, scopes, authScheme) {\r\n        var credentialType = (authScheme === AuthenticationScheme.POP) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\r\n        var accessTokenFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: credentialType,\r\n            clientId: clientId,\r\n            realm: account.tenantId,\r\n            target: scopes.printScopesLowerCase(),\r\n        };\r\n        var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\r\n        var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) { return credentialCache.accessTokens[key]; });\r\n        var numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            return null;\r\n        }\r\n        else if (numAccessTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n        return accessTokens[0];\r\n    };\r\n    /**\r\n     * Helper to retrieve the appropriate refresh token from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param familyRT\r\n     */\r\n    CacheManager.prototype.readRefreshTokenFromCache = function (clientId, account, familyRT) {\r\n        var id = familyRT ? THE_FAMILY_ID : undefined;\r\n        var refreshTokenFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.REFRESH_TOKEN,\r\n            clientId: clientId,\r\n            familyId: id\r\n        };\r\n        var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\r\n        var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function (key) { return credentialCache.refreshTokens[key]; });\r\n        var numRefreshTokens = refreshTokens.length;\r\n        if (numRefreshTokens < 1) {\r\n            return null;\r\n        }\r\n        // address the else case after remove functions address environment aliases\r\n        return refreshTokens[0];\r\n    };\r\n    /**\r\n     * Retrieve AppMetadataEntity from cache\r\n     */\r\n    CacheManager.prototype.readAppMetadataFromCache = function (environment, clientId) {\r\n        var appMetadataFilter = {\r\n            environment: environment,\r\n            clientId: clientId,\r\n        };\r\n        var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\r\n        var appMetadataEntries = Object.keys(appMetadata).map(function (key) { return appMetadata[key]; });\r\n        var numAppMetadata = appMetadataEntries.length;\r\n        if (numAppMetadata < 1) {\r\n            return null;\r\n        }\r\n        else if (numAppMetadata > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\r\n        }\r\n        return appMetadataEntries[0];\r\n    };\r\n    /**\r\n     * Return the family_id value associated  with FOCI\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    CacheManager.prototype.isAppMetadataFOCI = function (environment, clientId) {\r\n        var appMetadata = this.readAppMetadataFromCache(environment, clientId);\r\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\r\n    };\r\n    /**\r\n     * helper to match account ids\r\n     * @param value\r\n     * @param homeAccountId\r\n     */\r\n    CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\r\n        return !!(entity.homeAccountId && homeAccountId === entity.homeAccountId);\r\n    };\r\n    /**\r\n     * helper to match assertion\r\n     * @param value\r\n     * @param oboAssertion\r\n     */\r\n    CacheManager.prototype.matchOboAssertion = function (entity, oboAssertion) {\r\n        return !!(entity.oboAssertion && oboAssertion === entity.oboAssertion);\r\n    };\r\n    /**\r\n     * helper to match environment\r\n     * @param value\r\n     * @param environment\r\n     */\r\n    CacheManager.prototype.matchEnvironment = function (entity, environment) {\r\n        var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\r\n        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * helper to match credential type\r\n     * @param entity\r\n     * @param credentialType\r\n     */\r\n    CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\r\n        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());\r\n    };\r\n    /**\r\n     * helper to match client ids\r\n     * @param entity\r\n     * @param clientId\r\n     */\r\n    CacheManager.prototype.matchClientId = function (entity, clientId) {\r\n        return !!(entity.clientId && clientId === entity.clientId);\r\n    };\r\n    /**\r\n     * helper to match family ids\r\n     * @param entity\r\n     * @param familyId\r\n     */\r\n    CacheManager.prototype.matchFamilyId = function (entity, familyId) {\r\n        return !!(entity.familyId && familyId === entity.familyId);\r\n    };\r\n    /**\r\n     * helper to match realm\r\n     * @param entity\r\n     * @param realm\r\n     */\r\n    CacheManager.prototype.matchRealm = function (entity, realm) {\r\n        return !!(entity.realm && realm === entity.realm);\r\n    };\r\n    /**\r\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n     * @param entity\r\n     * @param target\r\n     */\r\n    CacheManager.prototype.matchTarget = function (entity, target) {\r\n        var isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\r\n        if (isNotAccessTokenCredential || !entity.target) {\r\n            return false;\r\n        }\r\n        var entityScopeSet = ScopeSet.fromString(entity.target);\r\n        var requestTargetScopeSet = ScopeSet.fromString(target);\r\n        if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\r\n            requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\r\n        }\r\n        else {\r\n            requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\r\n        }\r\n        return entityScopeSet.containsScopeSet(requestTargetScopeSet);\r\n    };\r\n    /**\r\n     * returns if a given cache entity is of the type appmetadata\r\n     * @param key\r\n     */\r\n    CacheManager.prototype.isAppMetadata = function (key) {\r\n        return key.indexOf(APP_METADATA) !== -1;\r\n    };\r\n    /**\r\n     * returns if a given cache entity is of the type authoritymetadata\r\n     * @param key\r\n     */\r\n    CacheManager.prototype.isAuthorityMetadata = function (key) {\r\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\r\n    };\r\n    /**\r\n     * returns cache key used for cloud instance metadata\r\n     */\r\n    CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\r\n        return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\r\n    };\r\n    /**\r\n     * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\r\n     * @param key\r\n     * @param credType\r\n     */\r\n    CacheManager.prototype.getSpecificCredential = function (key, credType) {\r\n        switch (credType) {\r\n            case CredentialType.ID_TOKEN: {\r\n                return this.getIdTokenCredential(key);\r\n            }\r\n            case CredentialType.ACCESS_TOKEN:\r\n            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME: {\r\n                return this.getAccessTokenCredential(key);\r\n            }\r\n            case CredentialType.REFRESH_TOKEN: {\r\n                return this.getRefreshTokenCredential(key);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    };\r\n    /**\r\n     * Helper to convert serialized data to object\r\n     * @param obj\r\n     * @param json\r\n     */\r\n    CacheManager.toObject = function (obj, json) {\r\n        for (var propertyName in json) {\r\n            obj[propertyName] = json[propertyName];\r\n        }\r\n        return obj;\r\n    };\r\n    return CacheManager;\r\n}());\r\nvar DefaultStorageClass = /** @class */ (function (_super) {\r\n    __extends(DefaultStorageClass, _super);\r\n    function DefaultStorageClass() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    DefaultStorageClass.prototype.setAccount = function () {\r\n        var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getAccount = function () {\r\n        var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setIdTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getIdTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setAccessTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getAccessTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setAppMetadata = function () {\r\n        var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getAppMetadata = function () {\r\n        var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setServerTelemetry = function () {\r\n        var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getServerTelemetry = function () {\r\n        var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setAuthorityMetadata = function () {\r\n        var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getAuthorityMetadata = function () {\r\n        var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\r\n        var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setThrottlingCache = function () {\r\n        var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getThrottlingCache = function () {\r\n        var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.removeItem = function () {\r\n        var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.containsKey = function () {\r\n        var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getKeys = function () {\r\n        var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.clear = function () {\r\n        var notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    return DefaultStorageClass;\r\n}(CacheManager));\n\nexport { CacheManager, DefaultStorageClass };\n"]},"metadata":{},"sourceType":"module"}