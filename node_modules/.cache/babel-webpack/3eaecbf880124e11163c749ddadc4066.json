{"ast":null,"code":"/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport Circle from 'ol/style/Circle.js';\nimport Fill from 'ol/style/Fill.js';\nimport Icon from 'ol/style/Icon.js';\nimport RenderFeature from 'ol/render/Feature.js';\nimport Stroke from 'ol/style/Stroke.js';\nimport Style from 'ol/style/Style.js';\nimport Text from 'ol/style/Text.js';\nimport mb2css from 'mapbox-to-css-font';\nimport { Color, featureFilter as createFilter, derefLayers, expression, function as fn, latest as spec } from '@mapbox/mapbox-gl-style-spec';\nimport { applyLetterSpacing, createCanvas, defaultResolutions, deg2rad, getZoomForResolution, wrapText } from './util.js';\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\n\nvar isFunction = fn.isFunction;\nvar convertFunction = fn.convertFunction;\nvar isExpression = expression.isExpression;\nvar createPropertyExpression = expression.createPropertyExpression;\nvar types = {\n  'Point': 1,\n  'MultiPoint': 1,\n  'LineString': 2,\n  'MultiLineString': 2,\n  'Polygon': 3,\n  'MultiPolygon': 3\n};\nvar anchor = {\n  'center': [0.5, 0.5],\n  'left': [0, 0.5],\n  'right': [1, 0.5],\n  'top': [0.5, 0],\n  'bottom': [0.5, 1],\n  'top-left': [0, 0],\n  'top-right': [1, 0],\n  'bottom-left': [0, 1],\n  'bottom-right': [1, 1]\n};\n\nvar expressionData = function (rawExpression, propertySpec) {\n  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n\n  if (compiledExpression.result === 'error') {\n    throw new Error(compiledExpression.value.map(function (err) {\n      return err.key + \": \" + err.message;\n    }).join(', '));\n  }\n\n  return compiledExpression.value;\n};\n\nvar emptyObj = {};\nvar zoomObj = {\n  zoom: 0\n};\n/** @private */\n\nvar functionCache = {};\nvar renderFeatureCoordinates, renderFeature;\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @return {?} Value.\n */\n\nexport function getValue(layer, layoutOrPaint, property, zoom, feature) {\n  var layerId = layer.id;\n\n  if (!functionCache[layerId]) {\n    functionCache[layerId] = {};\n  }\n\n  var functions = functionCache[layerId];\n\n  if (!functions[property]) {\n    var value_1 = (layer[layoutOrPaint] || emptyObj)[property];\n    var propertySpec = spec[layoutOrPaint + \"_\" + layer.type][property];\n\n    if (value_1 === undefined) {\n      value_1 = propertySpec.default;\n    }\n\n    var isExpr = isExpression(value_1);\n\n    if (!isExpr && isFunction(value_1)) {\n      value_1 = convertFunction(value_1, propertySpec);\n      isExpr = true;\n    }\n\n    if (isExpr) {\n      var compiledExpression = expressionData(value_1, propertySpec);\n      functions[property] = compiledExpression.evaluate.bind(compiledExpression);\n    } else {\n      if (propertySpec.type == 'color') {\n        value_1 = Color.parse(value_1);\n      }\n\n      functions[property] = function () {\n        return value_1;\n      };\n    }\n  }\n\n  zoomObj.zoom = zoom;\n  return functions[property](zoomObj, feature);\n}\n/** @private */\n\nvar filterCache = {};\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @return {boolean} Filter result.\n */\n\nfunction evaluateFilter(layerId, filter, feature, zoom) {\n  if (!(layerId in filterCache)) {\n    filterCache[layerId] = createFilter(filter).filter;\n  }\n\n  zoomObj.zoom = zoom;\n  return filterCache[layerId](zoomObj, feature);\n}\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\n\n\nfunction colorWithOpacity(color, opacity) {\n  if (color) {\n    if (color.a === 0 || opacity === 0) {\n      return undefined;\n    }\n\n    var a = color.a;\n    opacity = opacity === undefined ? 1 : opacity;\n    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';\n  }\n\n  return color;\n}\n\nvar templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\n\nfunction fromTemplate(text, properties) {\n  var parts;\n\n  do {\n    parts = text.match(templateRegEx);\n\n    if (parts) {\n      var value = properties[parts[2]] || '';\n      text = parts[1] + value + parts[3];\n    }\n  } while (parts);\n\n  return text;\n}\n\nvar recordLayer = false;\n/**\n * ```js\n * import {recordStyleLayer} from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Turns recording of the Mapbox Style's `layer` on and off. When turned on,\n * the layer that a rendered feature belongs to will be set as the feature's\n * `mapbox-layer` property.\n * @param {boolean} [record=false] Recording of the style layer is on.\n */\n\nexport function recordStyleLayer(record) {\n  recordLayer = record;\n}\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function also works in a web worker. In worker mode, the main thread needs\n * to listen to messages from the worker and respond with another message to make\n * sure that sprite image loading works:\n *\n * ```js\n *  worker.addEventListener('message', event => {\n *   if (event.data.action === 'loadImage') {\n *     const image = new Image();\n *     image.crossOrigin = 'anonymous';\n *     image.addEventListener('load', function() {\n *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {\n *         worker.postMessage({\n *           action: 'imageLoaded',\n *           image: imageBitmap,\n *           src: event.data.src\n *         }, [imageBitmap]);\n *       });\n *     });\n *     image.src = event.data.src;\n *   }\n * });\n * ```\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564, 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525, 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032, 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395, 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\n\nexport default function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts) {\n  if (resolutions === void 0) {\n    resolutions = defaultResolutions;\n  }\n\n  if (typeof glStyle == 'string') {\n    glStyle = JSON.parse(glStyle);\n  }\n\n  if (glStyle.version != 8) {\n    throw new Error('glStyle version 8 required.');\n  }\n\n  var spriteImage, spriteImgSize;\n\n  if (spriteImageUrl) {\n    if (typeof Image !== 'undefined') {\n      var img_1 = new Image();\n      img_1.crossOrigin = 'anonymous';\n\n      img_1.onload = function () {\n        spriteImage = img_1;\n        spriteImgSize = [img_1.width, img_1.height];\n        olLayer.changed();\n        img_1.onload = null;\n      };\n\n      img_1.src = spriteImageUrl;\n    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n      //eslint-disable-line\n      var worker = self; // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'\n\n      worker.postMessage({\n        action: 'loadImage',\n        src: spriteImageUrl\n      });\n      worker.addEventListener('message', function handler(event) {\n        if (event.data.action === 'imageLoaded' && event.data.src === spriteImageUrl) {\n          spriteImage = event.data.image;\n          spriteImgSize = [spriteImage.width, spriteImage.height];\n        }\n      });\n    }\n  }\n\n  var allLayers = derefLayers(glStyle.layers);\n  var layersBySourceLayer = {};\n  var mapboxLayers = [];\n  var mapboxSource;\n\n  for (var i = 0, ii = allLayers.length; i < ii; ++i) {\n    var layer = allLayers[i];\n    var layerId = layer.id;\n\n    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {\n      var sourceLayer = layer['source-layer'];\n\n      if (!mapboxSource) {\n        mapboxSource = layer.source;\n        var source_1 = glStyle.sources[mapboxSource];\n\n        if (!source_1) {\n          throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not defined\");\n        }\n\n        var type = source_1.type;\n\n        if (type !== 'vector' && type !== 'geojson') {\n          throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not of type \\\"vector\\\" or \\\"geojson\\\", but \\\"\" + type + \"\\\"\");\n        }\n      }\n\n      var layers = layersBySourceLayer[sourceLayer];\n\n      if (!layers) {\n        layers = [];\n        layersBySourceLayer[sourceLayer] = layers;\n      }\n\n      layers.push({\n        layer: layer,\n        index: i\n      });\n      mapboxLayers.push(layerId);\n    } // TODO revisit when diffing gets added\n\n\n    delete functionCache[layerId];\n    delete filterCache[layerId];\n  }\n\n  var textHalo = new Stroke();\n  var textColor = new Fill();\n  var iconImageCache = {};\n  var patternCache = {};\n  var styles = [];\n\n  var styleFunction = function (feature, resolution) {\n    var properties = feature.getProperties();\n    var layers = layersBySourceLayer[properties.layer];\n\n    if (!layers) {\n      return;\n    }\n\n    var zoom = resolutions.indexOf(resolution);\n\n    if (zoom == -1) {\n      zoom = getZoomForResolution(resolution, resolutions);\n    }\n\n    var type = types[feature.getGeometry().getType()];\n    var f = {\n      properties: properties,\n      type: type\n    };\n    var stylesLength = -1;\n    var featureBelongsToLayer;\n\n    var _loop_1 = function (i, ii) {\n      var layerData = layers[i];\n      var layer = layerData.layer;\n      var layerId = layer.id;\n      var layout = layer.layout || emptyObj;\n      var paint = layer.paint || emptyObj;\n\n      if (layout.visibility === 'none' || 'minzoom' in layer && zoom < layer.minzoom || 'maxzoom' in layer && zoom >= layer.maxzoom) {\n        return \"continue\";\n      }\n\n      var filter = layer.filter;\n\n      if (!filter || evaluateFilter(layerId, filter, f, zoom)) {\n        featureBelongsToLayer = layer;\n        var color = void 0,\n            opacity = void 0,\n            fill = void 0,\n            stroke = void 0,\n            strokeColor = void 0,\n            style = void 0;\n        var index = layerData.index;\n\n        if (type == 3 && (layer.type == 'fill' || layer.type == 'fill-extrusion')) {\n          opacity = getValue(layer, 'paint', layer.type + '-opacity', zoom, f);\n\n          if (layer.type + '-pattern' in paint) {\n            var fillIcon = getValue(layer, 'paint', layer.type + '-pattern', zoom, f);\n\n            if (fillIcon) {\n              var icon_1 = typeof fillIcon === 'string' ? fromTemplate(fillIcon, properties) : fillIcon.toString();\n\n              if (spriteImage && spriteData && spriteData[icon_1]) {\n                ++stylesLength;\n                style = styles[stylesLength];\n\n                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                  style = new Style({\n                    fill: new Fill()\n                  });\n                  styles[stylesLength] = style;\n                }\n\n                fill = style.getFill();\n                style.setZIndex(index);\n                var icon_cache_key = icon_1 + '.' + opacity;\n                var pattern = patternCache[icon_cache_key];\n\n                if (!pattern) {\n                  var spriteImageData = spriteData[icon_1];\n                  var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                  var ctx = canvas.getContext('2d');\n                  ctx.globalAlpha = opacity;\n                  ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                  pattern = ctx.createPattern(canvas, 'repeat');\n                  patternCache[icon_cache_key] = pattern;\n                }\n\n                fill.setColor(pattern);\n              }\n            }\n          } else {\n            color = colorWithOpacity(getValue(layer, 'paint', layer.type + '-color', zoom, f), opacity);\n\n            if (color) {\n              if (layer.type + '-outline-color' in paint) {\n                strokeColor = colorWithOpacity(getValue(layer, 'paint', layer.type + '-outline-color', zoom, f), opacity);\n              }\n\n              if (!strokeColor) {\n                strokeColor = color;\n              }\n\n              ++stylesLength;\n              style = styles[stylesLength];\n\n              if (!style || !(style.getFill() && style.getStroke()) || style.getText()) {\n                style = new Style({\n                  fill: new Fill(),\n                  stroke: new Stroke()\n                });\n                styles[stylesLength] = style;\n              }\n\n              fill = style.getFill();\n              fill.setColor(color);\n              stroke = style.getStroke();\n              stroke.setColor(strokeColor);\n              stroke.setWidth(1);\n              style.setZIndex(index);\n            }\n          }\n        }\n\n        if (type != 1 && layer.type == 'line') {\n          color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f), getValue(layer, 'paint', 'line-opacity', zoom, f)) : undefined;\n          var width_1 = getValue(layer, 'paint', 'line-width', zoom, f);\n\n          if (color && width_1 > 0) {\n            ++stylesLength;\n            style = styles[stylesLength];\n\n            if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n              style = new Style({\n                stroke: new Stroke()\n              });\n              styles[stylesLength] = style;\n            }\n\n            stroke = style.getStroke();\n            stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f));\n            stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f));\n            stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f));\n            stroke.setColor(color);\n            stroke.setWidth(width_1);\n            stroke.setLineDash(paint['line-dasharray'] ? getValue(layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {\n              return x * width_1;\n            }) : null);\n            style.setZIndex(index);\n          }\n        }\n\n        var hasImage = false;\n        var text = null;\n        var placementAngle = 0;\n        var icon = void 0,\n            iconImg = void 0,\n            skipLabel = void 0;\n\n        if ((type == 1 || type == 2) && 'icon-image' in layout) {\n          var iconImage = getValue(layer, 'layout', 'icon-image', zoom, f);\n\n          if (iconImage) {\n            icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();\n            var styleGeom = undefined;\n\n            if (spriteImage && spriteData && spriteData[icon]) {\n              var iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f);\n\n              if (type == 2) {\n                var geom = feature.getGeometry(); // ol package and ol-debug.js only\n\n                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {\n                  var extent = geom.getExtent();\n                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n\n                  if (size > 150) {\n                    //FIXME Do not hard-code a size of 150\n                    var midpoint = geom.getType() === 'MultiLineString' ? geom.getFlatMidpoints() : geom.getFlatMidpoint();\n\n                    if (!renderFeature) {\n                      renderFeatureCoordinates = [NaN, NaN];\n                      renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                    }\n\n                    styleGeom = renderFeature;\n                    renderFeatureCoordinates[0] = midpoint[0];\n                    renderFeatureCoordinates[1] = midpoint[1];\n                    var placement = getValue(layer, 'layout', 'symbol-placement', zoom, f);\n\n                    if (placement === 'line' && iconRotationAlignment === 'map') {\n                      var stride = geom.getStride();\n                      var coordinates = geom.getFlatCoordinates();\n\n                      for (var i_1 = 0, ii_1 = coordinates.length - stride; i_1 < ii_1; i_1 += stride) {\n                        var x1 = coordinates[i_1];\n                        var y1 = coordinates[i_1 + 1];\n                        var x2 = coordinates[i_1 + stride];\n                        var y2 = coordinates[i_1 + stride + 1];\n                        var minX = Math.min(x1, x2);\n                        var minY = Math.min(y1, y2);\n                        var maxX = Math.max(x1, x2);\n                        var maxY = Math.max(y1, y2);\n\n                        if (midpoint[0] >= minX && midpoint[0] <= maxX && midpoint[1] >= minY && midpoint[1] <= maxY) {\n                          placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n\n              if (type !== 2 || styleGeom) {\n                var iconSize = getValue(layer, 'layout', 'icon-size', zoom, f);\n                var iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f) : null;\n\n                if (!iconColor || iconColor.a !== 0) {\n                  var icon_cache_key = icon + '.' + iconSize;\n\n                  if (iconColor !== null) {\n                    icon_cache_key += '.' + iconColor;\n                  }\n\n                  iconImg = iconImageCache[icon_cache_key];\n\n                  if (!iconImg) {\n                    var spriteImageData = spriteData[icon];\n\n                    if (iconColor !== null) {\n                      // cut out the sprite and color it\n                      var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                      var ctx = canvas.getContext('2d');\n                      ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                      var data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n                      for (var c = 0, cc = data.data.length; c < cc; c += 4) {\n                        var a = iconColor.a;\n\n                        if (a !== 0) {\n                          data.data[c] = iconColor.r * 255 / a;\n                          data.data[c + 1] = iconColor.g * 255 / a;\n                          data.data[c + 2] = iconColor.b * 255 / a;\n                        }\n\n                        data.data[c + 3] = a;\n                      }\n\n                      ctx.putImageData(data, 0, 0);\n                      iconImg = new Icon({\n                        img: canvas,\n                        imgSize: [canvas.width, canvas.height],\n                        scale: iconSize / spriteImageData.pixelRatio\n                      });\n                      iconImageCache[icon_cache_key] = iconImg;\n                    } else {\n                      iconImg = new Icon({\n                        img: spriteImage,\n                        imgSize: spriteImgSize,\n                        size: [spriteImageData.width, spriteImageData.height],\n                        offset: [spriteImageData.x, spriteImageData.y],\n                        rotateWithView: iconRotationAlignment === 'map',\n                        scale: iconSize / spriteImageData.pixelRatio\n                      });\n                      iconImageCache[icon_cache_key] = iconImg;\n                    }\n                  }\n                }\n\n                if (iconImg) {\n                  ++stylesLength;\n                  style = styles[stylesLength];\n\n                  if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                    style = new Style();\n                    styles[stylesLength] = style;\n                  }\n\n                  style.setGeometry(styleGeom);\n                  iconImg.setRotation(placementAngle + deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f)));\n                  iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f));\n                  iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f)]);\n                  style.setImage(iconImg);\n                  text = style.getText();\n                  style.setText(undefined);\n                  style.setZIndex(index);\n                  hasImage = true;\n                  skipLabel = false;\n                }\n              } else {\n                skipLabel = true;\n              }\n            }\n          }\n        }\n\n        if (type == 1 && 'circle-radius' in paint) {\n          ++stylesLength;\n          style = styles[stylesLength];\n\n          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n            style = new Style();\n            styles[stylesLength] = style;\n          }\n\n          var circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f);\n          var circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f));\n          var circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f), getValue(layer, 'paint', 'circle-opacity', zoom, f));\n          var circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f);\n          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleStrokeWidth;\n          iconImg = iconImageCache[cache_key];\n\n          if (!iconImg) {\n            iconImg = new Circle({\n              radius: circleRadius,\n              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new Stroke({\n                width: circleStrokeWidth,\n                color: circleStrokeColor\n              }) : undefined,\n              fill: circleColor ? new Fill({\n                color: circleColor\n              }) : undefined\n            });\n            iconImageCache[cache_key] = iconImg;\n          }\n\n          style.setImage(iconImg);\n          text = style.getText();\n          style.setText(undefined);\n          style.setGeometry(undefined);\n          style.setZIndex(index);\n          hasImage = true;\n        }\n\n        var label = void 0;\n\n        if ('text-field' in layout) {\n          var textField = getValue(layer, 'layout', 'text-field', zoom, f).toString();\n          label = fromTemplate(textField, properties).trim();\n          opacity = getValue(layer, 'paint', 'text-opacity', zoom, f);\n        }\n\n        if (label && opacity && !skipLabel) {\n          if (!hasImage) {\n            ++stylesLength;\n            style = styles[stylesLength];\n\n            if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n              style = new Style();\n              styles[stylesLength] = style;\n            }\n\n            style.setImage(undefined);\n            style.setGeometry(undefined);\n          }\n\n          if (!style.getText()) {\n            style.setText(text || new Text({\n              padding: [2, 2, 2, 2]\n            }));\n          }\n\n          text = style.getText();\n          var textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f));\n          var fontArray = getValue(layer, 'layout', 'text-font', zoom, f);\n          var textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f);\n          var font = mb2css(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n          var textTransform = layout['text-transform'];\n\n          if (textTransform == 'uppercase') {\n            label = label.toUpperCase();\n          } else if (textTransform == 'lowercase') {\n            label = label.toLowerCase();\n          }\n\n          var maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f);\n          var letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f);\n          var wrappedLabel = type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);\n          text.setText(wrappedLabel);\n          text.setFont(font);\n          text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f)));\n          var textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f);\n          var placement = hasImage || type == 1 ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f);\n          text.setPlacement(placement);\n          var textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f);\n          var textOffset = getValue(layer, 'layout', 'text-offset', zoom, f);\n          var textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f); // Text offset has to take halo width and line height into account\n\n          var vOffset = 0;\n          var hOffset = 0;\n\n          if (placement == 'point') {\n            var textAlign = 'center';\n\n            if (textAnchor.indexOf('left') !== -1) {\n              textAlign = 'left';\n              hOffset = textHaloWidth;\n            } else if (textAnchor.indexOf('right') !== -1) {\n              textAlign = 'right';\n              hOffset = -textHaloWidth;\n            }\n\n            text.setTextAlign(textAlign);\n            var textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f);\n            text.setRotateWithView(textRotationAlignment == 'map');\n          } else {\n            text.setMaxAngle(deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);\n            text.setTextAlign();\n            text.setRotateWithView(false);\n          }\n\n          var textBaseline = 'middle';\n\n          if (textAnchor.indexOf('bottom') == 0) {\n            textBaseline = 'bottom';\n            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;\n          } else if (textAnchor.indexOf('top') == 0) {\n            textBaseline = 'top';\n            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;\n          }\n\n          text.setTextBaseline(textBaseline);\n          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n          textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f), opacity));\n          text.setFill(textColor);\n          var haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f), opacity);\n\n          if (haloColor) {\n            textHalo.setColor(haloColor); // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n            // Halo width must be doubled because it is applied around the center of the text outline\n\n            textHaloWidth *= 2; // 1/4 of text size (spec) x 2\n\n            var halfTextSize = 0.5 * textSize;\n            textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n            text.setStroke(textHalo);\n          } else {\n            text.setStroke(undefined);\n          }\n\n          var textPadding = getValue(layer, 'layout', 'text-padding', zoom, f);\n          var padding = text.getPadding();\n\n          if (textPadding !== padding[0]) {\n            padding[0] = textPadding;\n            padding[1] = textPadding;\n            padding[2] = textPadding;\n            padding[3] = textPadding;\n          }\n\n          style.setZIndex(index);\n        }\n      }\n    };\n\n    for (var i = 0, ii = layers.length; i < ii; ++i) {\n      _loop_1(i, ii);\n    }\n\n    if (stylesLength > -1) {\n      styles.length = stylesLength + 1;\n\n      if (recordLayer) {\n        if (typeof feature.set === 'function') {\n          // ol/Feature\n          feature.set('mapbox-layer', featureBelongsToLayer);\n        } else {\n          // ol/render/Feature\n          feature.getProperties()['mapbox-layer'] = featureBelongsToLayer;\n        }\n      }\n\n      return styles;\n    }\n  };\n\n  olLayer.setStyle(styleFunction);\n  olLayer.set('mapbox-source', mapboxSource);\n  olLayer.set('mapbox-layers', mapboxLayers);\n  return styleFunction;\n}\nexport { colorWithOpacity as _colorWithOpacity, filterCache as _filterCache, evaluateFilter as _evaluateFilter, fromTemplate as _fromTemplate, getValue as _getValue, functionCache as _functionCache };","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol-mapbox-style/dist/stylefunction.js"],"names":["Circle","Fill","Icon","RenderFeature","Stroke","Style","Text","mb2css","Color","featureFilter","createFilter","derefLayers","expression","function","fn","latest","spec","applyLetterSpacing","createCanvas","defaultResolutions","deg2rad","getZoomForResolution","wrapText","isFunction","convertFunction","isExpression","createPropertyExpression","types","anchor","expressionData","rawExpression","propertySpec","compiledExpression","result","Error","value","map","err","key","message","join","emptyObj","zoomObj","zoom","functionCache","renderFeatureCoordinates","renderFeature","getValue","layer","layoutOrPaint","property","feature","layerId","id","functions","value_1","type","undefined","default","isExpr","evaluate","bind","parse","filterCache","evaluateFilter","filter","colorWithOpacity","color","opacity","a","Math","round","r","g","b","templateRegEx","fromTemplate","text","properties","parts","match","recordLayer","recordStyleLayer","record","olLayer","glStyle","source","resolutions","spriteData","spriteImageUrl","getFonts","JSON","version","spriteImage","spriteImgSize","Image","img_1","crossOrigin","onload","width","height","changed","src","WorkerGlobalScope","self","worker","postMessage","action","addEventListener","handler","event","data","image","allLayers","layers","layersBySourceLayer","mapboxLayers","mapboxSource","i","ii","length","indexOf","sourceLayer","source_1","sources","push","index","textHalo","textColor","iconImageCache","patternCache","styles","styleFunction","resolution","getProperties","getGeometry","getType","f","stylesLength","featureBelongsToLayer","_loop_1","layerData","layout","paint","visibility","minzoom","maxzoom","fill","stroke","strokeColor","style","fillIcon","icon_1","toString","getFill","getStroke","getText","setZIndex","icon_cache_key","pattern","spriteImageData","canvas","ctx","getContext","globalAlpha","drawImage","x","y","createPattern","setColor","setWidth","width_1","setLineCap","setLineJoin","setMiterLimit","setLineDash","hasImage","placementAngle","icon","iconImg","skipLabel","iconImage","styleGeom","iconRotationAlignment","geom","getFlatMidpoint","getFlatMidpoints","extent","getExtent","size","sqrt","max","pow","midpoint","NaN","placement","stride","getStride","coordinates","getFlatCoordinates","i_1","ii_1","x1","y1","x2","y2","minX","min","minY","maxX","maxY","atan2","iconSize","iconColor","getImageData","c","cc","putImageData","img","imgSize","scale","pixelRatio","offset","rotateWithView","getImage","setGeometry","setRotation","setOpacity","setAnchor","setImage","setText","circleRadius","circleStrokeColor","circleColor","circleStrokeWidth","cache_key","radius","label","textField","trim","padding","textSize","fontArray","textLineHeight","font","textTransform","toUpperCase","toLowerCase","maxTextWidth","letterSpacing","wrappedLabel","setFont","textAnchor","setPlacement","textHaloWidth","textOffset","textTranslate","vOffset","hOffset","textAlign","setTextAlign","textRotationAlignment","setRotateWithView","setMaxAngle","textBaseline","setTextBaseline","setOffsetX","setOffsetY","setFill","haloColor","halfTextSize","setStroke","textPadding","getPadding","set","setStyle","_colorWithOpacity","_filterCache","_evaluateFilter","_fromTemplate","_getValue","_functionCache"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAOA,MAAP,MAAmB,oBAAnB;AACA,OAAOC,IAAP,MAAiB,kBAAjB;AACA,OAAOC,IAAP,MAAiB,kBAAjB;AACA,OAAOC,aAAP,MAA0B,sBAA1B;AACA,OAAOC,MAAP,MAAmB,oBAAnB;AACA,OAAOC,KAAP,MAAkB,mBAAlB;AACA,OAAOC,IAAP,MAAiB,kBAAjB;AACA,OAAOC,MAAP,MAAmB,oBAAnB;AACA,SAASC,KAAT,EAAgBC,aAAa,IAAIC,YAAjC,EAA+CC,WAA/C,EAA4DC,UAA5D,EAAwEC,QAAQ,IAAIC,EAApF,EAAwFC,MAAM,IAAIC,IAAlG,QAA+G,8BAA/G;AACA,SAASC,kBAAT,EAA6BC,YAA7B,EAA2CC,kBAA3C,EAA+DC,OAA/D,EAAwEC,oBAAxE,EAA8FC,QAA9F,QAA+G,WAA/G;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,UAAU,GAAGT,EAAE,CAACS,UAApB;AACA,IAAIC,eAAe,GAAGV,EAAE,CAACU,eAAzB;AACA,IAAIC,YAAY,GAAGb,UAAU,CAACa,YAA9B;AACA,IAAIC,wBAAwB,GAAGd,UAAU,CAACc,wBAA1C;AACA,IAAIC,KAAK,GAAG;AACR,WAAS,CADD;AAER,gBAAc,CAFN;AAGR,gBAAc,CAHN;AAIR,qBAAmB,CAJX;AAKR,aAAW,CALH;AAMR,kBAAgB;AANR,CAAZ;AAQA,IAAIC,MAAM,GAAG;AACT,YAAU,CAAC,GAAD,EAAM,GAAN,CADD;AAET,UAAQ,CAAC,CAAD,EAAI,GAAJ,CAFC;AAGT,WAAS,CAAC,CAAD,EAAI,GAAJ,CAHA;AAIT,SAAO,CAAC,GAAD,EAAM,CAAN,CAJE;AAKT,YAAU,CAAC,GAAD,EAAM,CAAN,CALD;AAMT,cAAY,CAAC,CAAD,EAAI,CAAJ,CANH;AAOT,eAAa,CAAC,CAAD,EAAI,CAAJ,CAPJ;AAQT,iBAAe,CAAC,CAAD,EAAI,CAAJ,CARN;AAST,kBAAgB,CAAC,CAAD,EAAI,CAAJ;AATP,CAAb;;AAWA,IAAIC,cAAc,GAAG,UAAUC,aAAV,EAAyBC,YAAzB,EAAuC;AACxD,MAAIC,kBAAkB,GAAGN,wBAAwB,CAACI,aAAD,EAAgBC,YAAhB,CAAjD;;AACA,MAAIC,kBAAkB,CAACC,MAAnB,KAA8B,OAAlC,EAA2C;AACvC,UAAM,IAAIC,KAAJ,CAAUF,kBAAkB,CAACG,KAAnB,CACXC,GADW,CACP,UAAUC,GAAV,EAAe;AAAE,aAAOA,GAAG,CAACC,GAAJ,GAAU,IAAV,GAAiBD,GAAG,CAACE,OAA5B;AAAsC,KADhD,EAEXC,IAFW,CAEN,IAFM,CAAV,CAAN;AAGH;;AACD,SAAOR,kBAAkB,CAACG,KAA1B;AACH,CARD;;AASA,IAAIM,QAAQ,GAAG,EAAf;AACA,IAAIC,OAAO,GAAG;AAAEC,EAAAA,IAAI,EAAE;AAAR,CAAd;AACA;;AACA,IAAIC,aAAa,GAAG,EAApB;AACA,IAAIC,wBAAJ,EAA8BC,aAA9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBC,KAAlB,EAAyBC,aAAzB,EAAwCC,QAAxC,EAAkDP,IAAlD,EAAwDQ,OAAxD,EAAiE;AACpE,MAAIC,OAAO,GAAGJ,KAAK,CAACK,EAApB;;AACA,MAAI,CAACT,aAAa,CAACQ,OAAD,CAAlB,EAA6B;AACzBR,IAAAA,aAAa,CAACQ,OAAD,CAAb,GAAyB,EAAzB;AACH;;AACD,MAAIE,SAAS,GAAGV,aAAa,CAACQ,OAAD,CAA7B;;AACA,MAAI,CAACE,SAAS,CAACJ,QAAD,CAAd,EAA0B;AACtB,QAAIK,OAAO,GAAG,CAACP,KAAK,CAACC,aAAD,CAAL,IAAwBR,QAAzB,EAAmCS,QAAnC,CAAd;AACA,QAAInB,YAAY,GAAGf,IAAI,CAACiC,aAAa,GAAG,GAAhB,GAAsBD,KAAK,CAACQ,IAA7B,CAAJ,CAAuCN,QAAvC,CAAnB;;AACA,QAAIK,OAAO,KAAKE,SAAhB,EAA2B;AACvBF,MAAAA,OAAO,GAAGxB,YAAY,CAAC2B,OAAvB;AACH;;AACD,QAAIC,MAAM,GAAGlC,YAAY,CAAC8B,OAAD,CAAzB;;AACA,QAAI,CAACI,MAAD,IAAWpC,UAAU,CAACgC,OAAD,CAAzB,EAAoC;AAChCA,MAAAA,OAAO,GAAG/B,eAAe,CAAC+B,OAAD,EAAUxB,YAAV,CAAzB;AACA4B,MAAAA,MAAM,GAAG,IAAT;AACH;;AACD,QAAIA,MAAJ,EAAY;AACR,UAAI3B,kBAAkB,GAAGH,cAAc,CAAC0B,OAAD,EAAUxB,YAAV,CAAvC;AACAuB,MAAAA,SAAS,CAACJ,QAAD,CAAT,GACIlB,kBAAkB,CAAC4B,QAAnB,CAA4BC,IAA5B,CAAiC7B,kBAAjC,CADJ;AAEH,KAJD,MAKK;AACD,UAAID,YAAY,CAACyB,IAAb,IAAqB,OAAzB,EAAkC;AAC9BD,QAAAA,OAAO,GAAG/C,KAAK,CAACsD,KAAN,CAAYP,OAAZ,CAAV;AACH;;AACDD,MAAAA,SAAS,CAACJ,QAAD,CAAT,GAAsB,YAAY;AAC9B,eAAOK,OAAP;AACH,OAFD;AAGH;AACJ;;AACDb,EAAAA,OAAO,CAACC,IAAR,GAAeA,IAAf;AACA,SAAOW,SAAS,CAACJ,QAAD,CAAT,CAAoBR,OAApB,EAA6BS,OAA7B,CAAP;AACH;AACD;;AACA,IAAIY,WAAW,GAAG,EAAlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBZ,OAAxB,EAAiCa,MAAjC,EAAyCd,OAAzC,EAAkDR,IAAlD,EAAwD;AACpD,MAAI,EAAES,OAAO,IAAIW,WAAb,CAAJ,EAA+B;AAC3BA,IAAAA,WAAW,CAACX,OAAD,CAAX,GAAuB1C,YAAY,CAACuD,MAAD,CAAZ,CAAqBA,MAA5C;AACH;;AACDvB,EAAAA,OAAO,CAACC,IAAR,GAAeA,IAAf;AACA,SAAOoB,WAAW,CAACX,OAAD,CAAX,CAAqBV,OAArB,EAA8BS,OAA9B,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASe,gBAAT,CAA0BC,KAA1B,EAAiCC,OAAjC,EAA0C;AACtC,MAAID,KAAJ,EAAW;AACP,QAAIA,KAAK,CAACE,CAAN,KAAY,CAAZ,IAAiBD,OAAO,KAAK,CAAjC,EAAoC;AAChC,aAAOX,SAAP;AACH;;AACD,QAAIY,CAAC,GAAGF,KAAK,CAACE,CAAd;AACAD,IAAAA,OAAO,GAAGA,OAAO,KAAKX,SAAZ,GAAwB,CAAxB,GAA4BW,OAAtC;AACA,WAAQ,UACJE,IAAI,CAACC,KAAL,CAAYJ,KAAK,CAACK,CAAN,GAAU,GAAX,GAAkBH,CAA7B,CADI,GAEJ,GAFI,GAGJC,IAAI,CAACC,KAAL,CAAYJ,KAAK,CAACM,CAAN,GAAU,GAAX,GAAkBJ,CAA7B,CAHI,GAIJ,GAJI,GAKJC,IAAI,CAACC,KAAL,CAAYJ,KAAK,CAACO,CAAN,GAAU,GAAX,GAAkBL,CAA7B,CALI,GAMJ,GANI,GAOJA,CAAC,GAAGD,OAPA,GAQJ,GARJ;AASH;;AACD,SAAOD,KAAP;AACH;;AACD,IAAIQ,aAAa,GAAG,wBAApB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,CAAsBC,IAAtB,EAA4BC,UAA5B,EAAwC;AACpC,MAAIC,KAAJ;;AACA,KAAG;AACCA,IAAAA,KAAK,GAAGF,IAAI,CAACG,KAAL,CAAWL,aAAX,CAAR;;AACA,QAAII,KAAJ,EAAW;AACP,UAAI5C,KAAK,GAAG2C,UAAU,CAACC,KAAK,CAAC,CAAD,CAAN,CAAV,IAAwB,EAApC;AACAF,MAAAA,IAAI,GAAGE,KAAK,CAAC,CAAD,CAAL,GAAW5C,KAAX,GAAmB4C,KAAK,CAAC,CAAD,CAA/B;AACH;AACJ,GAND,QAMSA,KANT;;AAOA,SAAOF,IAAP;AACH;;AACD,IAAII,WAAW,GAAG,KAAlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,gBAAT,CAA0BC,MAA1B,EAAkC;AACrCF,EAAAA,WAAW,GAAGE,MAAd;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,UAAUC,OAAV,EAAmBC,OAAnB,EAA4BC,MAA5B,EAAoCC,WAApC,EAAiDC,UAAjD,EAA6DC,cAA7D,EAA6EC,QAA7E,EAAuF;AAClG,MAAIH,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAAEA,IAAAA,WAAW,GAAGpE,kBAAd;AAAmC;;AACjE,MAAI,OAAOkE,OAAP,IAAkB,QAAtB,EAAgC;AAC5BA,IAAAA,OAAO,GAAGM,IAAI,CAAC7B,KAAL,CAAWuB,OAAX,CAAV;AACH;;AACD,MAAIA,OAAO,CAACO,OAAR,IAAmB,CAAvB,EAA0B;AACtB,UAAM,IAAI1D,KAAJ,CAAU,6BAAV,CAAN;AACH;;AACD,MAAI2D,WAAJ,EAAiBC,aAAjB;;AACA,MAAIL,cAAJ,EAAoB;AAChB,QAAI,OAAOM,KAAP,KAAiB,WAArB,EAAkC;AAC9B,UAAIC,KAAK,GAAG,IAAID,KAAJ,EAAZ;AACAC,MAAAA,KAAK,CAACC,WAAN,GAAoB,WAApB;;AACAD,MAAAA,KAAK,CAACE,MAAN,GAAe,YAAY;AACvBL,QAAAA,WAAW,GAAGG,KAAd;AACAF,QAAAA,aAAa,GAAG,CAACE,KAAK,CAACG,KAAP,EAAcH,KAAK,CAACI,MAApB,CAAhB;AACAhB,QAAAA,OAAO,CAACiB,OAAR;AACAL,QAAAA,KAAK,CAACE,MAAN,GAAe,IAAf;AACH,OALD;;AAMAF,MAAAA,KAAK,CAACM,GAAN,GAAYb,cAAZ;AACH,KAVD,MAWK,IAAI,OAAOc,iBAAP,KAA6B,WAA7B,IAA4CC,IAAI,YAAYD,iBAAhE,EAAmF;AAAE;AACtF,UAAIE,MAAM,GAAqBD,IAA/B,CADoF,CAEpF;;AACAC,MAAAA,MAAM,CAACC,WAAP,CAAmB;AACfC,QAAAA,MAAM,EAAE,WADO;AAEfL,QAAAA,GAAG,EAAEb;AAFU,OAAnB;AAIAgB,MAAAA,MAAM,CAACG,gBAAP,CAAwB,SAAxB,EAAmC,SAASC,OAAT,CAAiBC,KAAjB,EAAwB;AACvD,YAAIA,KAAK,CAACC,IAAN,CAAWJ,MAAX,KAAsB,aAAtB,IACAG,KAAK,CAACC,IAAN,CAAWT,GAAX,KAAmBb,cADvB,EACuC;AACnCI,UAAAA,WAAW,GAAGiB,KAAK,CAACC,IAAN,CAAWC,KAAzB;AACAlB,UAAAA,aAAa,GAAG,CAACD,WAAW,CAACM,KAAb,EAAoBN,WAAW,CAACO,MAAhC,CAAhB;AACH;AACJ,OAND;AAOH;AACJ;;AACD,MAAIa,SAAS,GAAGtG,WAAW,CAAC0E,OAAO,CAAC6B,MAAT,CAA3B;AACA,MAAIC,mBAAmB,GAAG,EAA1B;AACA,MAAIC,YAAY,GAAG,EAAnB;AACA,MAAIC,YAAJ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGN,SAAS,CAACO,MAA/B,EAAuCF,CAAC,GAAGC,EAA3C,EAA+C,EAAED,CAAjD,EAAoD;AAChD,QAAItE,KAAK,GAAGiE,SAAS,CAACK,CAAD,CAArB;AACA,QAAIlE,OAAO,GAAGJ,KAAK,CAACK,EAApB;;AACA,QAAK,OAAOiC,MAAP,IAAiB,QAAjB,IAA6BtC,KAAK,CAACsC,MAAN,IAAgBA,MAA9C,IACAA,MAAM,CAACmC,OAAP,CAAerE,OAAf,MAA4B,CAAC,CADjC,EACoC;AAChC,UAAIsE,WAAW,GAAG1E,KAAK,CAAC,cAAD,CAAvB;;AACA,UAAI,CAACqE,YAAL,EAAmB;AACfA,QAAAA,YAAY,GAAGrE,KAAK,CAACsC,MAArB;AACA,YAAIqC,QAAQ,GAAGtC,OAAO,CAACuC,OAAR,CAAgBP,YAAhB,CAAf;;AACA,YAAI,CAACM,QAAL,EAAe;AACX,gBAAM,IAAIzF,KAAJ,CAAU,cAAcmF,YAAd,GAA6B,mBAAvC,CAAN;AACH;;AACD,YAAI7D,IAAI,GAAGmE,QAAQ,CAACnE,IAApB;;AACA,YAAIA,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,SAAlC,EAA6C;AACzC,gBAAM,IAAItB,KAAJ,CAAU,cAAcmF,YAAd,GAA6B,qDAA7B,GAAqF7D,IAArF,GAA4F,IAAtG,CAAN;AACH;AACJ;;AACD,UAAI0D,MAAM,GAAGC,mBAAmB,CAACO,WAAD,CAAhC;;AACA,UAAI,CAACR,MAAL,EAAa;AACTA,QAAAA,MAAM,GAAG,EAAT;AACAC,QAAAA,mBAAmB,CAACO,WAAD,CAAnB,GAAmCR,MAAnC;AACH;;AACDA,MAAAA,MAAM,CAACW,IAAP,CAAY;AACR7E,QAAAA,KAAK,EAAEA,KADC;AAER8E,QAAAA,KAAK,EAAER;AAFC,OAAZ;AAIAF,MAAAA,YAAY,CAACS,IAAb,CAAkBzE,OAAlB;AACH,KA3B+C,CA4BhD;;;AACA,WAAOR,aAAa,CAACQ,OAAD,CAApB;AACA,WAAOW,WAAW,CAACX,OAAD,CAAlB;AACH;;AACD,MAAI2E,QAAQ,GAAG,IAAI3H,MAAJ,EAAf;AACA,MAAI4H,SAAS,GAAG,IAAI/H,IAAJ,EAAhB;AACA,MAAIgI,cAAc,GAAG,EAArB;AACA,MAAIC,YAAY,GAAG,EAAnB;AACA,MAAIC,MAAM,GAAG,EAAb;;AACA,MAAIC,aAAa,GAAG,UAAUjF,OAAV,EAAmBkF,UAAnB,EAA+B;AAC/C,QAAIvD,UAAU,GAAG3B,OAAO,CAACmF,aAAR,EAAjB;AACA,QAAIpB,MAAM,GAAGC,mBAAmB,CAACrC,UAAU,CAAC9B,KAAZ,CAAhC;;AACA,QAAI,CAACkE,MAAL,EAAa;AACT;AACH;;AACD,QAAIvE,IAAI,GAAG4C,WAAW,CAACkC,OAAZ,CAAoBY,UAApB,CAAX;;AACA,QAAI1F,IAAI,IAAI,CAAC,CAAb,EAAgB;AACZA,MAAAA,IAAI,GAAGtB,oBAAoB,CAACgH,UAAD,EAAa9C,WAAb,CAA3B;AACH;;AACD,QAAI/B,IAAI,GAAG7B,KAAK,CAACwB,OAAO,CAACoF,WAAR,GAAsBC,OAAtB,EAAD,CAAhB;AACA,QAAIC,CAAC,GAAG;AACJ3D,MAAAA,UAAU,EAAEA,UADR;AAEJtB,MAAAA,IAAI,EAAEA;AAFF,KAAR;AAIA,QAAIkF,YAAY,GAAG,CAAC,CAApB;AACA,QAAIC,qBAAJ;;AACA,QAAIC,OAAO,GAAG,UAAUtB,CAAV,EAAaC,EAAb,EAAiB;AAC3B,UAAIsB,SAAS,GAAG3B,MAAM,CAACI,CAAD,CAAtB;AACA,UAAItE,KAAK,GAAG6F,SAAS,CAAC7F,KAAtB;AACA,UAAII,OAAO,GAAGJ,KAAK,CAACK,EAApB;AACA,UAAIyF,MAAM,GAAG9F,KAAK,CAAC8F,MAAN,IAAgBrG,QAA7B;AACA,UAAIsG,KAAK,GAAG/F,KAAK,CAAC+F,KAAN,IAAetG,QAA3B;;AACA,UAAIqG,MAAM,CAACE,UAAP,KAAsB,MAAtB,IACC,aAAahG,KAAb,IAAsBL,IAAI,GAAGK,KAAK,CAACiG,OADpC,IAEC,aAAajG,KAAb,IAAsBL,IAAI,IAAIK,KAAK,CAACkG,OAFzC,EAEmD;AAC/C,eAAO,UAAP;AACH;;AACD,UAAIjF,MAAM,GAAGjB,KAAK,CAACiB,MAAnB;;AACA,UAAI,CAACA,MAAD,IAAWD,cAAc,CAACZ,OAAD,EAAUa,MAAV,EAAkBwE,CAAlB,EAAqB9F,IAArB,CAA7B,EAAyD;AACrDgG,QAAAA,qBAAqB,GAAG3F,KAAxB;AACA,YAAImB,KAAK,GAAG,KAAK,CAAjB;AAAA,YAAoBC,OAAO,GAAG,KAAK,CAAnC;AAAA,YAAsC+E,IAAI,GAAG,KAAK,CAAlD;AAAA,YAAqDC,MAAM,GAAG,KAAK,CAAnE;AAAA,YAAsEC,WAAW,GAAG,KAAK,CAAzF;AAAA,YAA4FC,KAAK,GAAG,KAAK,CAAzG;AACA,YAAIxB,KAAK,GAAGe,SAAS,CAACf,KAAtB;;AACA,YAAItE,IAAI,IAAI,CAAR,KACCR,KAAK,CAACQ,IAAN,IAAc,MAAd,IAAwBR,KAAK,CAACQ,IAAN,IAAc,gBADvC,CAAJ,EAC8D;AAC1DY,UAAAA,OAAO,GAAGrB,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiBA,KAAK,CAACQ,IAAN,GAAa,UAA9B,EAA0Cb,IAA1C,EAAgD8F,CAAhD,CAAlB;;AACA,cAAIzF,KAAK,CAACQ,IAAN,GAAa,UAAb,IAA2BuF,KAA/B,EAAsC;AAClC,gBAAIQ,QAAQ,GAAGxG,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiBA,KAAK,CAACQ,IAAN,GAAa,UAA9B,EAA0Cb,IAA1C,EAAgD8F,CAAhD,CAAvB;;AACA,gBAAIc,QAAJ,EAAc;AACV,kBAAIC,MAAM,GAAG,OAAOD,QAAP,KAAoB,QAApB,GACP3E,YAAY,CAAC2E,QAAD,EAAWzE,UAAX,CADL,GAEPyE,QAAQ,CAACE,QAAT,EAFN;;AAGA,kBAAI5D,WAAW,IAAIL,UAAf,IAA6BA,UAAU,CAACgE,MAAD,CAA3C,EAAqD;AACjD,kBAAEd,YAAF;AACAY,gBAAAA,KAAK,GAAGnB,MAAM,CAACO,YAAD,CAAd;;AACA,oBAAI,CAACY,KAAD,IACA,CAACA,KAAK,CAACI,OAAN,EADD,IAEAJ,KAAK,CAACK,SAAN,EAFA,IAGAL,KAAK,CAACM,OAAN,EAHJ,EAGqB;AACjBN,kBAAAA,KAAK,GAAG,IAAIjJ,KAAJ,CAAU;AACd8I,oBAAAA,IAAI,EAAE,IAAIlJ,IAAJ;AADQ,mBAAV,CAAR;AAGAkI,kBAAAA,MAAM,CAACO,YAAD,CAAN,GAAuBY,KAAvB;AACH;;AACDH,gBAAAA,IAAI,GAAGG,KAAK,CAACI,OAAN,EAAP;AACAJ,gBAAAA,KAAK,CAACO,SAAN,CAAgB/B,KAAhB;AACA,oBAAIgC,cAAc,GAAGN,MAAM,GAAG,GAAT,GAAepF,OAApC;AACA,oBAAI2F,OAAO,GAAG7B,YAAY,CAAC4B,cAAD,CAA1B;;AACA,oBAAI,CAACC,OAAL,EAAc;AACV,sBAAIC,eAAe,GAAGxE,UAAU,CAACgE,MAAD,CAAhC;AACA,sBAAIS,MAAM,GAAG/I,YAAY,CAAC8I,eAAe,CAAC7D,KAAjB,EAAwB6D,eAAe,CAAC5D,MAAxC,CAAzB;AACA,sBAAI8D,GAAG,GAA4CD,MAAM,CAACE,UAAP,CAAkB,IAAlB,CAAnD;AACAD,kBAAAA,GAAG,CAACE,WAAJ,GAAkBhG,OAAlB;AACA8F,kBAAAA,GAAG,CAACG,SAAJ,CAAcxE,WAAd,EAA2BmE,eAAe,CAACM,CAA3C,EAA8CN,eAAe,CAACO,CAA9D,EAAiEP,eAAe,CAAC7D,KAAjF,EAAwF6D,eAAe,CAAC5D,MAAxG,EAAgH,CAAhH,EAAmH,CAAnH,EAAsH4D,eAAe,CAAC7D,KAAtI,EAA6I6D,eAAe,CAAC5D,MAA7J;AACA2D,kBAAAA,OAAO,GAAGG,GAAG,CAACM,aAAJ,CAAkBP,MAAlB,EAA0B,QAA1B,CAAV;AACA/B,kBAAAA,YAAY,CAAC4B,cAAD,CAAZ,GAA+BC,OAA/B;AACH;;AACDZ,gBAAAA,IAAI,CAACsB,QAAL,CAAcV,OAAd;AACH;AACJ;AACJ,WAlCD,MAmCK;AACD5F,YAAAA,KAAK,GAAGD,gBAAgB,CAACnB,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiBA,KAAK,CAACQ,IAAN,GAAa,QAA9B,EAAwCb,IAAxC,EAA8C8F,CAA9C,CAAT,EAA2DrE,OAA3D,CAAxB;;AACA,gBAAID,KAAJ,EAAW;AACP,kBAAInB,KAAK,CAACQ,IAAN,GAAa,gBAAb,IAAiCuF,KAArC,EAA4C;AACxCM,gBAAAA,WAAW,GAAGnF,gBAAgB,CAACnB,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiBA,KAAK,CAACQ,IAAN,GAAa,gBAA9B,EAAgDb,IAAhD,EAAsD8F,CAAtD,CAAT,EAAmErE,OAAnE,CAA9B;AACH;;AACD,kBAAI,CAACiF,WAAL,EAAkB;AACdA,gBAAAA,WAAW,GAAGlF,KAAd;AACH;;AACD,gBAAEuE,YAAF;AACAY,cAAAA,KAAK,GAAGnB,MAAM,CAACO,YAAD,CAAd;;AACA,kBAAI,CAACY,KAAD,IACA,EAAEA,KAAK,CAACI,OAAN,MAAmBJ,KAAK,CAACK,SAAN,EAArB,CADA,IAEAL,KAAK,CAACM,OAAN,EAFJ,EAEqB;AACjBN,gBAAAA,KAAK,GAAG,IAAIjJ,KAAJ,CAAU;AACd8I,kBAAAA,IAAI,EAAE,IAAIlJ,IAAJ,EADQ;AAEdmJ,kBAAAA,MAAM,EAAE,IAAIhJ,MAAJ;AAFM,iBAAV,CAAR;AAIA+H,gBAAAA,MAAM,CAACO,YAAD,CAAN,GAAuBY,KAAvB;AACH;;AACDH,cAAAA,IAAI,GAAGG,KAAK,CAACI,OAAN,EAAP;AACAP,cAAAA,IAAI,CAACsB,QAAL,CAActG,KAAd;AACAiF,cAAAA,MAAM,GAAGE,KAAK,CAACK,SAAN,EAAT;AACAP,cAAAA,MAAM,CAACqB,QAAP,CAAgBpB,WAAhB;AACAD,cAAAA,MAAM,CAACsB,QAAP,CAAgB,CAAhB;AACApB,cAAAA,KAAK,CAACO,SAAN,CAAgB/B,KAAhB;AACH;AACJ;AACJ;;AACD,YAAItE,IAAI,IAAI,CAAR,IAAaR,KAAK,CAACQ,IAAN,IAAc,MAA/B,EAAuC;AACnCW,UAAAA,KAAK,GACD,EAAE,kBAAkB4E,KAApB,KAA8B,gBAAgBA,KAA9C,GACM7E,gBAAgB,CAACnB,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,YAAjB,EAA+BL,IAA/B,EAAqC8F,CAArC,CAAT,EAAkD1F,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,cAAjB,EAAiCL,IAAjC,EAAuC8F,CAAvC,CAA1D,CADtB,GAEMhF,SAHV;AAIA,cAAIkH,OAAO,GAAG5H,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,YAAjB,EAA+BL,IAA/B,EAAqC8F,CAArC,CAAtB;;AACA,cAAItE,KAAK,IAAIwG,OAAO,GAAG,CAAvB,EAA0B;AACtB,cAAEjC,YAAF;AACAY,YAAAA,KAAK,GAAGnB,MAAM,CAACO,YAAD,CAAd;;AACA,gBAAI,CAACY,KAAD,IACA,CAACA,KAAK,CAACK,SAAN,EADD,IAEAL,KAAK,CAACI,OAAN,EAFA,IAGAJ,KAAK,CAACM,OAAN,EAHJ,EAGqB;AACjBN,cAAAA,KAAK,GAAG,IAAIjJ,KAAJ,CAAU;AACd+I,gBAAAA,MAAM,EAAE,IAAIhJ,MAAJ;AADM,eAAV,CAAR;AAGA+H,cAAAA,MAAM,CAACO,YAAD,CAAN,GAAuBY,KAAvB;AACH;;AACDF,YAAAA,MAAM,GAAGE,KAAK,CAACK,SAAN,EAAT;AACAP,YAAAA,MAAM,CAACwB,UAAP,CAAkB7H,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,UAAlB,EAA8BL,IAA9B,EAAoC8F,CAApC,CAA1B;AACAW,YAAAA,MAAM,CAACyB,WAAP,CAAmB9H,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,EAA+BL,IAA/B,EAAqC8F,CAArC,CAA3B;AACAW,YAAAA,MAAM,CAAC0B,aAAP,CAAqB/H,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,kBAAlB,EAAsCL,IAAtC,EAA4C8F,CAA5C,CAA7B;AACAW,YAAAA,MAAM,CAACqB,QAAP,CAAgBtG,KAAhB;AACAiF,YAAAA,MAAM,CAACsB,QAAP,CAAgBC,OAAhB;AACAvB,YAAAA,MAAM,CAAC2B,WAAP,CAAmBhC,KAAK,CAAC,gBAAD,CAAL,GACbhG,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,gBAAjB,EAAmCL,IAAnC,EAAyC8F,CAAzC,CAAR,CAAoDrG,GAApD,CAAwD,UAAUkI,CAAV,EAAa;AACnE,qBAAOA,CAAC,GAAGK,OAAX;AACH,aAFC,CADa,GAIb,IAJN;AAKArB,YAAAA,KAAK,CAACO,SAAN,CAAgB/B,KAAhB;AACH;AACJ;;AACD,YAAIkD,QAAQ,GAAG,KAAf;AACA,YAAInG,IAAI,GAAG,IAAX;AACA,YAAIoG,cAAc,GAAG,CAArB;AACA,YAAIC,IAAI,GAAG,KAAK,CAAhB;AAAA,YAAmBC,OAAO,GAAG,KAAK,CAAlC;AAAA,YAAqCC,SAAS,GAAG,KAAK,CAAtD;;AACA,YAAI,CAAC5H,IAAI,IAAI,CAAR,IAAaA,IAAI,IAAI,CAAtB,KAA4B,gBAAgBsF,MAAhD,EAAwD;AACpD,cAAIuC,SAAS,GAAGtI,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,YAAlB,EAAgCL,IAAhC,EAAsC8F,CAAtC,CAAxB;;AACA,cAAI4C,SAAJ,EAAe;AACXH,YAAAA,IAAI,GACA,OAAOG,SAAP,KAAqB,QAArB,GACMzG,YAAY,CAACyG,SAAD,EAAYvG,UAAZ,CADlB,GAEMuG,SAAS,CAAC5B,QAAV,EAHV;AAIA,gBAAI6B,SAAS,GAAG7H,SAAhB;;AACA,gBAAIoC,WAAW,IAAIL,UAAf,IAA6BA,UAAU,CAAC0F,IAAD,CAA3C,EAAmD;AAC/C,kBAAIK,qBAAqB,GAAGxI,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,yBAAlB,EAA6CL,IAA7C,EAAmD8F,CAAnD,CAApC;;AACA,kBAAIjF,IAAI,IAAI,CAAZ,EAAe;AACX,oBAAIgI,IAAI,GAAGrI,OAAO,CAACoF,WAAR,EAAX,CADW,CAEX;;AACA,oBAAIiD,IAAI,CAACC,eAAL,IAAwBD,IAAI,CAACE,gBAAjC,EAAmD;AAC/C,sBAAIC,MAAM,GAAGH,IAAI,CAACI,SAAL,EAAb;AACA,sBAAIC,IAAI,GAAGvH,IAAI,CAACwH,IAAL,CAAUxH,IAAI,CAACyH,GAAL,CAASzH,IAAI,CAAC0H,GAAL,CAAS,CAACL,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAnB,IAA0BtD,UAAnC,EAA+C,CAA/C,CAAT,EAA4D/D,IAAI,CAAC0H,GAAL,CAAS,CAACL,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAnB,IAA0BtD,UAAnC,EAA+C,CAA/C,CAA5D,CAAV,CAAX;;AACA,sBAAIwD,IAAI,GAAG,GAAX,EAAgB;AACZ;AACA,wBAAII,QAAQ,GAAGT,IAAI,CAAChD,OAAL,OAAmB,iBAAnB,GACTgD,IAAI,CAACE,gBAAL,EADS,GAETF,IAAI,CAACC,eAAL,EAFN;;AAGA,wBAAI,CAAC3I,aAAL,EAAoB;AAChBD,sBAAAA,wBAAwB,GAAG,CAACqJ,GAAD,EAAMA,GAAN,CAA3B;AACApJ,sBAAAA,aAAa,GAAG,IAAI3C,aAAJ,CAAkB,OAAlB,EAA2B0C,wBAA3B,EAAqD,EAArD,EAAyD,EAAzD,EAA6D,IAA7D,CAAhB;AACH;;AACDyI,oBAAAA,SAAS,GAAGxI,aAAZ;AACAD,oBAAAA,wBAAwB,CAAC,CAAD,CAAxB,GAA8BoJ,QAAQ,CAAC,CAAD,CAAtC;AACApJ,oBAAAA,wBAAwB,CAAC,CAAD,CAAxB,GAA8BoJ,QAAQ,CAAC,CAAD,CAAtC;AACA,wBAAIE,SAAS,GAAGpJ,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,kBAAlB,EAAsCL,IAAtC,EAA4C8F,CAA5C,CAAxB;;AACA,wBAAI0D,SAAS,KAAK,MAAd,IACAZ,qBAAqB,KAAK,KAD9B,EACqC;AACjC,0BAAIa,MAAM,GAAGZ,IAAI,CAACa,SAAL,EAAb;AACA,0BAAIC,WAAW,GAAGd,IAAI,CAACe,kBAAL,EAAlB;;AACA,2BAAK,IAAIC,GAAG,GAAG,CAAV,EAAaC,IAAI,GAAGH,WAAW,CAAC9E,MAAZ,GAAqB4E,MAA9C,EAAsDI,GAAG,GAAGC,IAA5D,EAAkED,GAAG,IAAIJ,MAAzE,EAAiF;AAC7E,4BAAIM,EAAE,GAAGJ,WAAW,CAACE,GAAD,CAApB;AACA,4BAAIG,EAAE,GAAGL,WAAW,CAACE,GAAG,GAAG,CAAP,CAApB;AACA,4BAAII,EAAE,GAAGN,WAAW,CAACE,GAAG,GAAGJ,MAAP,CAApB;AACA,4BAAIS,EAAE,GAAGP,WAAW,CAACE,GAAG,GAAGJ,MAAN,GAAe,CAAhB,CAApB;AACA,4BAAIU,IAAI,GAAGxI,IAAI,CAACyI,GAAL,CAASL,EAAT,EAAaE,EAAb,CAAX;AACA,4BAAII,IAAI,GAAG1I,IAAI,CAACyI,GAAL,CAASJ,EAAT,EAAaE,EAAb,CAAX;AACA,4BAAII,IAAI,GAAG3I,IAAI,CAACyH,GAAL,CAASW,EAAT,EAAaE,EAAb,CAAX;AACA,4BAAIM,IAAI,GAAG5I,IAAI,CAACyH,GAAL,CAASY,EAAT,EAAaE,EAAb,CAAX;;AACA,4BAAIZ,QAAQ,CAAC,CAAD,CAAR,IAAea,IAAf,IACAb,QAAQ,CAAC,CAAD,CAAR,IAAegB,IADf,IAEAhB,QAAQ,CAAC,CAAD,CAAR,IAAee,IAFf,IAGAf,QAAQ,CAAC,CAAD,CAAR,IAAeiB,IAHnB,EAGyB;AACrBjC,0BAAAA,cAAc,GAAG3G,IAAI,CAAC6I,KAAL,CAAWR,EAAE,GAAGE,EAAhB,EAAoBD,EAAE,GAAGF,EAAzB,CAAjB;AACA;AACH;AACJ;AACJ;AACJ;AACJ;AACJ;;AACD,kBAAIlJ,IAAI,KAAK,CAAT,IAAc8H,SAAlB,EAA6B;AACzB,oBAAI8B,QAAQ,GAAGrK,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,EAA+BL,IAA/B,EAAqC8F,CAArC,CAAvB;AACA,oBAAI4E,SAAS,GAAGtE,KAAK,CAAC,YAAD,CAAL,KAAwBtF,SAAxB,GACVV,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,YAAjB,EAA+BL,IAA/B,EAAqC8F,CAArC,CADE,GAEV,IAFN;;AAGA,oBAAI,CAAC4E,SAAD,IAAcA,SAAS,CAAChJ,CAAV,KAAgB,CAAlC,EAAqC;AACjC,sBAAIyF,cAAc,GAAGoB,IAAI,GAAG,GAAP,GAAakC,QAAlC;;AACA,sBAAIC,SAAS,KAAK,IAAlB,EAAwB;AACpBvD,oBAAAA,cAAc,IAAI,MAAMuD,SAAxB;AACH;;AACDlC,kBAAAA,OAAO,GAAGlD,cAAc,CAAC6B,cAAD,CAAxB;;AACA,sBAAI,CAACqB,OAAL,EAAc;AACV,wBAAInB,eAAe,GAAGxE,UAAU,CAAC0F,IAAD,CAAhC;;AACA,wBAAImC,SAAS,KAAK,IAAlB,EAAwB;AACpB;AACA,0BAAIpD,MAAM,GAAG/I,YAAY,CAAC8I,eAAe,CAAC7D,KAAjB,EAAwB6D,eAAe,CAAC5D,MAAxC,CAAzB;AACA,0BAAI8D,GAAG,GAA4CD,MAAM,CAACE,UAAP,CAAkB,IAAlB,CAAnD;AACAD,sBAAAA,GAAG,CAACG,SAAJ,CAAcxE,WAAd,EAA2BmE,eAAe,CAACM,CAA3C,EAA8CN,eAAe,CAACO,CAA9D,EAAiEP,eAAe,CAAC7D,KAAjF,EAAwF6D,eAAe,CAAC5D,MAAxG,EAAgH,CAAhH,EAAmH,CAAnH,EAAsH4D,eAAe,CAAC7D,KAAtI,EAA6I6D,eAAe,CAAC5D,MAA7J;AACA,0BAAIW,IAAI,GAAGmD,GAAG,CAACoD,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuBrD,MAAM,CAAC9D,KAA9B,EAAqC8D,MAAM,CAAC7D,MAA5C,CAAX;;AACA,2BAAK,IAAImH,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGzG,IAAI,CAACA,IAAL,CAAUS,MAA/B,EAAuC+F,CAAC,GAAGC,EAA3C,EAA+CD,CAAC,IAAI,CAApD,EAAuD;AACnD,4BAAIlJ,CAAC,GAAGgJ,SAAS,CAAChJ,CAAlB;;AACA,4BAAIA,CAAC,KAAK,CAAV,EAAa;AACT0C,0BAAAA,IAAI,CAACA,IAAL,CAAUwG,CAAV,IAAgBF,SAAS,CAAC7I,CAAV,GAAc,GAAf,GAAsBH,CAArC;AACA0C,0BAAAA,IAAI,CAACA,IAAL,CAAUwG,CAAC,GAAG,CAAd,IAAoBF,SAAS,CAAC5I,CAAV,GAAc,GAAf,GAAsBJ,CAAzC;AACA0C,0BAAAA,IAAI,CAACA,IAAL,CAAUwG,CAAC,GAAG,CAAd,IAAoBF,SAAS,CAAC3I,CAAV,GAAc,GAAf,GAAsBL,CAAzC;AACH;;AACD0C,wBAAAA,IAAI,CAACA,IAAL,CAAUwG,CAAC,GAAG,CAAd,IAAmBlJ,CAAnB;AACH;;AACD6F,sBAAAA,GAAG,CAACuD,YAAJ,CAAiB1G,IAAjB,EAAuB,CAAvB,EAA0B,CAA1B;AACAoE,sBAAAA,OAAO,GAAG,IAAIjL,IAAJ,CAAS;AACfwN,wBAAAA,GAAG,EAAEzD,MADU;AAEf0D,wBAAAA,OAAO,EAAE,CAAC1D,MAAM,CAAC9D,KAAR,EAAe8D,MAAM,CAAC7D,MAAtB,CAFM;AAGfwH,wBAAAA,KAAK,EAAER,QAAQ,GAAGpD,eAAe,CAAC6D;AAHnB,uBAAT,CAAV;AAKA5F,sBAAAA,cAAc,CAAC6B,cAAD,CAAd,GAAiCqB,OAAjC;AACH,qBAtBD,MAuBK;AACDA,sBAAAA,OAAO,GAAG,IAAIjL,IAAJ,CAAS;AACfwN,wBAAAA,GAAG,EAAE7H,WADU;AAEf8H,wBAAAA,OAAO,EAAE7H,aAFM;AAGf+F,wBAAAA,IAAI,EAAE,CAAC7B,eAAe,CAAC7D,KAAjB,EAAwB6D,eAAe,CAAC5D,MAAxC,CAHS;AAIf0H,wBAAAA,MAAM,EAAE,CAAC9D,eAAe,CAACM,CAAjB,EAAoBN,eAAe,CAACO,CAApC,CAJO;AAKfwD,wBAAAA,cAAc,EAAExC,qBAAqB,KAAK,KAL3B;AAMfqC,wBAAAA,KAAK,EAAER,QAAQ,GAAGpD,eAAe,CAAC6D;AANnB,uBAAT,CAAV;AAQA5F,sBAAAA,cAAc,CAAC6B,cAAD,CAAd,GAAiCqB,OAAjC;AACH;AACJ;AACJ;;AACD,oBAAIA,OAAJ,EAAa;AACT,oBAAEzC,YAAF;AACAY,kBAAAA,KAAK,GAAGnB,MAAM,CAACO,YAAD,CAAd;;AACA,sBAAI,CAACY,KAAD,IACA,CAACA,KAAK,CAAC0E,QAAN,EADD,IAEA1E,KAAK,CAACI,OAAN,EAFA,IAGAJ,KAAK,CAACK,SAAN,EAHJ,EAGuB;AACnBL,oBAAAA,KAAK,GAAG,IAAIjJ,KAAJ,EAAR;AACA8H,oBAAAA,MAAM,CAACO,YAAD,CAAN,GAAuBY,KAAvB;AACH;;AACDA,kBAAAA,KAAK,CAAC2E,WAAN,CAAkB3C,SAAlB;AACAH,kBAAAA,OAAO,CAAC+C,WAAR,CAAoBjD,cAAc,GAC9B7J,OAAO,CAAC2B,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,aAAlB,EAAiCL,IAAjC,EAAuC8F,CAAvC,CAAT,CADX;AAEA0C,kBAAAA,OAAO,CAACgD,UAAR,CAAmBpL,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,cAAjB,EAAiCL,IAAjC,EAAuC8F,CAAvC,CAA3B;AACA0C,kBAAAA,OAAO,CAACiD,SAAR,CAAkBxM,MAAM,CAACmB,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,aAAlB,EAAiCL,IAAjC,EAAuC8F,CAAvC,CAAT,CAAxB;AACAa,kBAAAA,KAAK,CAAC+E,QAAN,CAAelD,OAAf;AACAtG,kBAAAA,IAAI,GAAGyE,KAAK,CAACM,OAAN,EAAP;AACAN,kBAAAA,KAAK,CAACgF,OAAN,CAAc7K,SAAd;AACA6F,kBAAAA,KAAK,CAACO,SAAN,CAAgB/B,KAAhB;AACAkD,kBAAAA,QAAQ,GAAG,IAAX;AACAI,kBAAAA,SAAS,GAAG,KAAZ;AACH;AACJ,eAvED,MAwEK;AACDA,gBAAAA,SAAS,GAAG,IAAZ;AACH;AACJ;AACJ;AACJ;;AACD,YAAI5H,IAAI,IAAI,CAAR,IAAa,mBAAmBuF,KAApC,EAA2C;AACvC,YAAEL,YAAF;AACAY,UAAAA,KAAK,GAAGnB,MAAM,CAACO,YAAD,CAAd;;AACA,cAAI,CAACY,KAAD,IACA,CAACA,KAAK,CAAC0E,QAAN,EADD,IAEA1E,KAAK,CAACI,OAAN,EAFA,IAGAJ,KAAK,CAACK,SAAN,EAHJ,EAGuB;AACnBL,YAAAA,KAAK,GAAG,IAAIjJ,KAAJ,EAAR;AACA8H,YAAAA,MAAM,CAACO,YAAD,CAAN,GAAuBY,KAAvB;AACH;;AACD,cAAIiF,YAAY,GAAGxL,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,eAAjB,EAAkCL,IAAlC,EAAwC8F,CAAxC,CAA3B;AACA,cAAI+F,iBAAiB,GAAGtK,gBAAgB,CAACnB,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,qBAAjB,EAAwCL,IAAxC,EAA8C8F,CAA9C,CAAT,EAA2D1F,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,uBAAjB,EAA0CL,IAA1C,EAAgD8F,CAAhD,CAAnE,CAAxC;AACA,cAAIgG,WAAW,GAAGvK,gBAAgB,CAACnB,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,cAAjB,EAAiCL,IAAjC,EAAuC8F,CAAvC,CAAT,EAAoD1F,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,gBAAjB,EAAmCL,IAAnC,EAAyC8F,CAAzC,CAA5D,CAAlC;AACA,cAAIiG,iBAAiB,GAAG3L,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,qBAAjB,EAAwCL,IAAxC,EAA8C8F,CAA9C,CAAhC;AACA,cAAIkG,SAAS,GAAGJ,YAAY,GACxB,GADY,GAEZC,iBAFY,GAGZ,GAHY,GAIZC,WAJY,GAKZ,GALY,GAMZC,iBANJ;AAOAvD,UAAAA,OAAO,GAAGlD,cAAc,CAAC0G,SAAD,CAAxB;;AACA,cAAI,CAACxD,OAAL,EAAc;AACVA,YAAAA,OAAO,GAAG,IAAInL,MAAJ,CAAW;AACjB4O,cAAAA,MAAM,EAAEL,YADS;AAEjBnF,cAAAA,MAAM,EAAEoF,iBAAiB,IAAIE,iBAAiB,GAAG,CAAzC,GACF,IAAItO,MAAJ,CAAW;AACT+F,gBAAAA,KAAK,EAAEuI,iBADE;AAETvK,gBAAAA,KAAK,EAAEqK;AAFE,eAAX,CADE,GAKF/K,SAPW;AAQjB0F,cAAAA,IAAI,EAAEsF,WAAW,GACX,IAAIxO,IAAJ,CAAS;AACPkE,gBAAAA,KAAK,EAAEsK;AADA,eAAT,CADW,GAIXhL;AAZW,aAAX,CAAV;AAcAwE,YAAAA,cAAc,CAAC0G,SAAD,CAAd,GAA4BxD,OAA5B;AACH;;AACD7B,UAAAA,KAAK,CAAC+E,QAAN,CAAelD,OAAf;AACAtG,UAAAA,IAAI,GAAGyE,KAAK,CAACM,OAAN,EAAP;AACAN,UAAAA,KAAK,CAACgF,OAAN,CAAc7K,SAAd;AACA6F,UAAAA,KAAK,CAAC2E,WAAN,CAAkBxK,SAAlB;AACA6F,UAAAA,KAAK,CAACO,SAAN,CAAgB/B,KAAhB;AACAkD,UAAAA,QAAQ,GAAG,IAAX;AACH;;AACD,YAAI6D,KAAK,GAAG,KAAK,CAAjB;;AACA,YAAI,gBAAgB/F,MAApB,EAA4B;AACxB,cAAIgG,SAAS,GAAG/L,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,YAAlB,EAAgCL,IAAhC,EAAsC8F,CAAtC,CAAR,CAAiDgB,QAAjD,EAAhB;AACAoF,UAAAA,KAAK,GAAGjK,YAAY,CAACkK,SAAD,EAAYhK,UAAZ,CAAZ,CAAoCiK,IAApC,EAAR;AACA3K,UAAAA,OAAO,GAAGrB,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,cAAjB,EAAiCL,IAAjC,EAAuC8F,CAAvC,CAAlB;AACH;;AACD,YAAIoG,KAAK,IAAIzK,OAAT,IAAoB,CAACgH,SAAzB,EAAoC;AAChC,cAAI,CAACJ,QAAL,EAAe;AACX,cAAEtC,YAAF;AACAY,YAAAA,KAAK,GAAGnB,MAAM,CAACO,YAAD,CAAd;;AACA,gBAAI,CAACY,KAAD,IACA,CAACA,KAAK,CAACM,OAAN,EADD,IAEAN,KAAK,CAACI,OAAN,EAFA,IAGAJ,KAAK,CAACK,SAAN,EAHJ,EAGuB;AACnBL,cAAAA,KAAK,GAAG,IAAIjJ,KAAJ,EAAR;AACA8H,cAAAA,MAAM,CAACO,YAAD,CAAN,GAAuBY,KAAvB;AACH;;AACDA,YAAAA,KAAK,CAAC+E,QAAN,CAAe5K,SAAf;AACA6F,YAAAA,KAAK,CAAC2E,WAAN,CAAkBxK,SAAlB;AACH;;AACD,cAAI,CAAC6F,KAAK,CAACM,OAAN,EAAL,EAAsB;AAClBN,YAAAA,KAAK,CAACgF,OAAN,CAAczJ,IAAI,IACd,IAAIvE,IAAJ,CAAS;AACL0O,cAAAA,OAAO,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV;AADJ,aAAT,CADJ;AAIH;;AACDnK,UAAAA,IAAI,GAAGyE,KAAK,CAACM,OAAN,EAAP;AACA,cAAIqF,QAAQ,GAAG3K,IAAI,CAACC,KAAL,CAAWxB,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,EAA+BL,IAA/B,EAAqC8F,CAArC,CAAnB,CAAf;AACA,cAAIyG,SAAS,GAAGnM,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,EAA+BL,IAA/B,EAAqC8F,CAArC,CAAxB;AACA,cAAI0G,cAAc,GAAGpM,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,kBAAlB,EAAsCL,IAAtC,EAA4C8F,CAA5C,CAA7B;AACA,cAAI2G,IAAI,GAAG7O,MAAM,CAACmF,QAAQ,GAAGA,QAAQ,CAACwJ,SAAD,CAAX,GAAyBA,SAAlC,EAA6CD,QAA7C,EAAuDE,cAAvD,CAAjB;AACA,cAAIE,aAAa,GAAGvG,MAAM,CAAC,gBAAD,CAA1B;;AACA,cAAIuG,aAAa,IAAI,WAArB,EAAkC;AAC9BR,YAAAA,KAAK,GAAGA,KAAK,CAACS,WAAN,EAAR;AACH,WAFD,MAGK,IAAID,aAAa,IAAI,WAArB,EAAkC;AACnCR,YAAAA,KAAK,GAAGA,KAAK,CAACU,WAAN,EAAR;AACH;;AACD,cAAIC,YAAY,GAAGzM,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,gBAAlB,EAAoCL,IAApC,EAA0C8F,CAA1C,CAA3B;AACA,cAAIgH,aAAa,GAAG1M,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,qBAAlB,EAAyCL,IAAzC,EAA+C8F,CAA/C,CAA5B;AACA,cAAIiH,YAAY,GAAGlM,IAAI,IAAI,CAAR,GACbvC,kBAAkB,CAAC4N,KAAD,EAAQY,aAAR,CADL,GAEbnO,QAAQ,CAACuN,KAAD,EAAQO,IAAR,EAAcI,YAAd,EAA4BC,aAA5B,CAFd;AAGA5K,UAAAA,IAAI,CAACyJ,OAAL,CAAaoB,YAAb;AACA7K,UAAAA,IAAI,CAAC8K,OAAL,CAAaP,IAAb;AACAvK,UAAAA,IAAI,CAACqJ,WAAL,CAAiB9M,OAAO,CAAC2B,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,aAAlB,EAAiCL,IAAjC,EAAuC8F,CAAvC,CAAT,CAAxB;AACA,cAAImH,UAAU,GAAG7M,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,aAAlB,EAAiCL,IAAjC,EAAuC8F,CAAvC,CAAzB;AACA,cAAI0D,SAAS,GAAGnB,QAAQ,IAAIxH,IAAI,IAAI,CAApB,GACV,OADU,GAEVT,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,kBAAlB,EAAsCL,IAAtC,EAA4C8F,CAA5C,CAFd;AAGA5D,UAAAA,IAAI,CAACgL,YAAL,CAAkB1D,SAAlB;AACA,cAAI2D,aAAa,GAAG/M,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,iBAAjB,EAAoCL,IAApC,EAA0C8F,CAA1C,CAA5B;AACA,cAAIsH,UAAU,GAAGhN,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,aAAlB,EAAiCL,IAAjC,EAAuC8F,CAAvC,CAAzB;AACA,cAAIuH,aAAa,GAAGjN,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,gBAAjB,EAAmCL,IAAnC,EAAyC8F,CAAzC,CAA5B,CA/CgC,CAgDhC;;AACA,cAAIwH,OAAO,GAAG,CAAd;AACA,cAAIC,OAAO,GAAG,CAAd;;AACA,cAAI/D,SAAS,IAAI,OAAjB,EAA0B;AACtB,gBAAIgE,SAAS,GAAG,QAAhB;;AACA,gBAAIP,UAAU,CAACnI,OAAX,CAAmB,MAAnB,MAA+B,CAAC,CAApC,EAAuC;AACnC0I,cAAAA,SAAS,GAAG,MAAZ;AACAD,cAAAA,OAAO,GAAGJ,aAAV;AACH,aAHD,MAIK,IAAIF,UAAU,CAACnI,OAAX,CAAmB,OAAnB,MAAgC,CAAC,CAArC,EAAwC;AACzC0I,cAAAA,SAAS,GAAG,OAAZ;AACAD,cAAAA,OAAO,GAAG,CAACJ,aAAX;AACH;;AACDjL,YAAAA,IAAI,CAACuL,YAAL,CAAkBD,SAAlB;AACA,gBAAIE,qBAAqB,GAAGtN,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,yBAAlB,EAA6CL,IAA7C,EAAmD8F,CAAnD,CAApC;AACA5D,YAAAA,IAAI,CAACyL,iBAAL,CAAuBD,qBAAqB,IAAI,KAAhD;AACH,WAbD,MAcK;AACDxL,YAAAA,IAAI,CAAC0L,WAAL,CAAkBnP,OAAO,CAAC2B,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,gBAAlB,EAAoCL,IAApC,EAA0C8F,CAA1C,CAAT,CAAP,GACdoG,KAAK,CAACrH,MADO,GAEbkI,YAAY,CAAClI,MAFjB;AAGA3C,YAAAA,IAAI,CAACuL,YAAL;AACAvL,YAAAA,IAAI,CAACyL,iBAAL,CAAuB,KAAvB;AACH;;AACD,cAAIE,YAAY,GAAG,QAAnB;;AACA,cAAIZ,UAAU,CAACnI,OAAX,CAAmB,QAAnB,KAAgC,CAApC,EAAuC;AACnC+I,YAAAA,YAAY,GAAG,QAAf;AACAP,YAAAA,OAAO,GAAG,CAACH,aAAD,GAAiB,OAAOX,cAAc,GAAG,CAAxB,IAA6BF,QAAxD;AACH,WAHD,MAIK,IAAIW,UAAU,CAACnI,OAAX,CAAmB,KAAnB,KAA6B,CAAjC,EAAoC;AACrC+I,YAAAA,YAAY,GAAG,KAAf;AACAP,YAAAA,OAAO,GAAGH,aAAa,GAAG,OAAOX,cAAc,GAAG,CAAxB,IAA6BF,QAAvD;AACH;;AACDpK,UAAAA,IAAI,CAAC4L,eAAL,CAAqBD,YAArB;AACA3L,UAAAA,IAAI,CAAC6L,UAAL,CAAgBX,UAAU,CAAC,CAAD,CAAV,GAAgBd,QAAhB,GAA2BiB,OAA3B,GAAqCF,aAAa,CAAC,CAAD,CAAlE;AACAnL,UAAAA,IAAI,CAAC8L,UAAL,CAAgBZ,UAAU,CAAC,CAAD,CAAV,GAAgBd,QAAhB,GAA2BgB,OAA3B,GAAqCD,aAAa,CAAC,CAAD,CAAlE;AACAhI,UAAAA,SAAS,CAACyC,QAAV,CAAmBvG,gBAAgB,CAACnB,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,YAAjB,EAA+BL,IAA/B,EAAqC8F,CAArC,CAAT,EAAkDrE,OAAlD,CAAnC;AACAS,UAAAA,IAAI,CAAC+L,OAAL,CAAa5I,SAAb;AACA,cAAI6I,SAAS,GAAG3M,gBAAgB,CAACnB,QAAQ,CAACC,KAAD,EAAQ,OAAR,EAAiB,iBAAjB,EAAoCL,IAApC,EAA0C8F,CAA1C,CAAT,EAAuDrE,OAAvD,CAAhC;;AACA,cAAIyM,SAAJ,EAAe;AACX9I,YAAAA,QAAQ,CAAC0C,QAAT,CAAkBoG,SAAlB,EADW,CAEX;AACA;;AACAf,YAAAA,aAAa,IAAI,CAAjB,CAJW,CAKX;;AACA,gBAAIgB,YAAY,GAAG,MAAM7B,QAAzB;AACAlH,YAAAA,QAAQ,CAAC2C,QAAT,CAAkBoF,aAAa,IAAIgB,YAAjB,GAAgChB,aAAhC,GAAgDgB,YAAlE;AACAjM,YAAAA,IAAI,CAACkM,SAAL,CAAehJ,QAAf;AACH,WATD,MAUK;AACDlD,YAAAA,IAAI,CAACkM,SAAL,CAAetN,SAAf;AACH;;AACD,cAAIuN,WAAW,GAAGjO,QAAQ,CAACC,KAAD,EAAQ,QAAR,EAAkB,cAAlB,EAAkCL,IAAlC,EAAwC8F,CAAxC,CAA1B;AACA,cAAIuG,OAAO,GAAGnK,IAAI,CAACoM,UAAL,EAAd;;AACA,cAAID,WAAW,KAAKhC,OAAO,CAAC,CAAD,CAA3B,EAAgC;AAC5BA,YAAAA,OAAO,CAAC,CAAD,CAAP,GAAagC,WAAb;AACAhC,YAAAA,OAAO,CAAC,CAAD,CAAP,GAAagC,WAAb;AACAhC,YAAAA,OAAO,CAAC,CAAD,CAAP,GAAagC,WAAb;AACAhC,YAAAA,OAAO,CAAC,CAAD,CAAP,GAAagC,WAAb;AACH;;AACD1H,UAAAA,KAAK,CAACO,SAAN,CAAgB/B,KAAhB;AACH;AACJ;AACJ,KA9ZD;;AA+ZA,SAAK,IAAIR,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGL,MAAM,CAACM,MAA5B,EAAoCF,CAAC,GAAGC,EAAxC,EAA4C,EAAED,CAA9C,EAAiD;AAC7CsB,MAAAA,OAAO,CAACtB,CAAD,EAAIC,EAAJ,CAAP;AACH;;AACD,QAAImB,YAAY,GAAG,CAAC,CAApB,EAAuB;AACnBP,MAAAA,MAAM,CAACX,MAAP,GAAgBkB,YAAY,GAAG,CAA/B;;AACA,UAAIzD,WAAJ,EAAiB;AACb,YAAI,OAAO9B,OAAO,CAAC+N,GAAf,KAAuB,UAA3B,EAAuC;AACnC;AACA/N,UAAAA,OAAO,CAAC+N,GAAR,CAAY,cAAZ,EAA4BvI,qBAA5B;AACH,SAHD,MAIK;AACD;AACAxF,UAAAA,OAAO,CAACmF,aAAR,GAAwB,cAAxB,IAA0CK,qBAA1C;AACH;AACJ;;AACD,aAAOR,MAAP;AACH;AACJ,GAjcD;;AAkcA/C,EAAAA,OAAO,CAAC+L,QAAR,CAAiB/I,aAAjB;AACAhD,EAAAA,OAAO,CAAC8L,GAAR,CAAY,eAAZ,EAA6B7J,YAA7B;AACAjC,EAAAA,OAAO,CAAC8L,GAAR,CAAY,eAAZ,EAA6B9J,YAA7B;AACA,SAAOgB,aAAP;AACH;AACD,SAASlE,gBAAgB,IAAIkN,iBAA7B,EAAgDrN,WAAW,IAAIsN,YAA/D,EAA6ErN,cAAc,IAAIsN,eAA/F,EAAgH1M,YAAY,IAAI2M,aAAhI,EAA+IxO,QAAQ,IAAIyO,SAA3J,EAAsK5O,aAAa,IAAI6O,cAAvL","sourcesContent":["/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport Circle from 'ol/style/Circle.js';\nimport Fill from 'ol/style/Fill.js';\nimport Icon from 'ol/style/Icon.js';\nimport RenderFeature from 'ol/render/Feature.js';\nimport Stroke from 'ol/style/Stroke.js';\nimport Style from 'ol/style/Style.js';\nimport Text from 'ol/style/Text.js';\nimport mb2css from 'mapbox-to-css-font';\nimport { Color, featureFilter as createFilter, derefLayers, expression, function as fn, latest as spec, } from '@mapbox/mapbox-gl-style-spec';\nimport { applyLetterSpacing, createCanvas, defaultResolutions, deg2rad, getZoomForResolution, wrapText, } from './util.js';\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\nvar isFunction = fn.isFunction;\nvar convertFunction = fn.convertFunction;\nvar isExpression = expression.isExpression;\nvar createPropertyExpression = expression.createPropertyExpression;\nvar types = {\n    'Point': 1,\n    'MultiPoint': 1,\n    'LineString': 2,\n    'MultiLineString': 2,\n    'Polygon': 3,\n    'MultiPolygon': 3,\n};\nvar anchor = {\n    'center': [0.5, 0.5],\n    'left': [0, 0.5],\n    'right': [1, 0.5],\n    'top': [0.5, 0],\n    'bottom': [0.5, 1],\n    'top-left': [0, 0],\n    'top-right': [1, 0],\n    'bottom-left': [0, 1],\n    'bottom-right': [1, 1],\n};\nvar expressionData = function (rawExpression, propertySpec) {\n    var compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n    if (compiledExpression.result === 'error') {\n        throw new Error(compiledExpression.value\n            .map(function (err) { return err.key + \": \" + err.message; })\n            .join(', '));\n    }\n    return compiledExpression.value;\n};\nvar emptyObj = {};\nvar zoomObj = { zoom: 0 };\n/** @private */\nvar functionCache = {};\nvar renderFeatureCoordinates, renderFeature;\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @return {?} Value.\n */\nexport function getValue(layer, layoutOrPaint, property, zoom, feature) {\n    var layerId = layer.id;\n    if (!functionCache[layerId]) {\n        functionCache[layerId] = {};\n    }\n    var functions = functionCache[layerId];\n    if (!functions[property]) {\n        var value_1 = (layer[layoutOrPaint] || emptyObj)[property];\n        var propertySpec = spec[layoutOrPaint + \"_\" + layer.type][property];\n        if (value_1 === undefined) {\n            value_1 = propertySpec.default;\n        }\n        var isExpr = isExpression(value_1);\n        if (!isExpr && isFunction(value_1)) {\n            value_1 = convertFunction(value_1, propertySpec);\n            isExpr = true;\n        }\n        if (isExpr) {\n            var compiledExpression = expressionData(value_1, propertySpec);\n            functions[property] =\n                compiledExpression.evaluate.bind(compiledExpression);\n        }\n        else {\n            if (propertySpec.type == 'color') {\n                value_1 = Color.parse(value_1);\n            }\n            functions[property] = function () {\n                return value_1;\n            };\n        }\n    }\n    zoomObj.zoom = zoom;\n    return functions[property](zoomObj, feature);\n}\n/** @private */\nvar filterCache = {};\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @return {boolean} Filter result.\n */\nfunction evaluateFilter(layerId, filter, feature, zoom) {\n    if (!(layerId in filterCache)) {\n        filterCache[layerId] = createFilter(filter).filter;\n    }\n    zoomObj.zoom = zoom;\n    return filterCache[layerId](zoomObj, feature);\n}\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\nfunction colorWithOpacity(color, opacity) {\n    if (color) {\n        if (color.a === 0 || opacity === 0) {\n            return undefined;\n        }\n        var a = color.a;\n        opacity = opacity === undefined ? 1 : opacity;\n        return ('rgba(' +\n            Math.round((color.r * 255) / a) +\n            ',' +\n            Math.round((color.g * 255) / a) +\n            ',' +\n            Math.round((color.b * 255) / a) +\n            ',' +\n            a * opacity +\n            ')');\n    }\n    return color;\n}\nvar templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\nfunction fromTemplate(text, properties) {\n    var parts;\n    do {\n        parts = text.match(templateRegEx);\n        if (parts) {\n            var value = properties[parts[2]] || '';\n            text = parts[1] + value + parts[3];\n        }\n    } while (parts);\n    return text;\n}\nvar recordLayer = false;\n/**\n * ```js\n * import {recordStyleLayer} from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Turns recording of the Mapbox Style's `layer` on and off. When turned on,\n * the layer that a rendered feature belongs to will be set as the feature's\n * `mapbox-layer` property.\n * @param {boolean} [record=false] Recording of the style layer is on.\n */\nexport function recordStyleLayer(record) {\n    recordLayer = record;\n}\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function also works in a web worker. In worker mode, the main thread needs\n * to listen to messages from the worker and respond with another message to make\n * sure that sprite image loading works:\n *\n * ```js\n *  worker.addEventListener('message', event => {\n *   if (event.data.action === 'loadImage') {\n *     const image = new Image();\n *     image.crossOrigin = 'anonymous';\n *     image.addEventListener('load', function() {\n *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {\n *         worker.postMessage({\n *           action: 'imageLoaded',\n *           image: imageBitmap,\n *           src: event.data.src\n *         }, [imageBitmap]);\n *       });\n *     });\n *     image.src = event.data.src;\n *   }\n * });\n * ```\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564, 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525, 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032, 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395, 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\nexport default function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts) {\n    if (resolutions === void 0) { resolutions = defaultResolutions; }\n    if (typeof glStyle == 'string') {\n        glStyle = JSON.parse(glStyle);\n    }\n    if (glStyle.version != 8) {\n        throw new Error('glStyle version 8 required.');\n    }\n    var spriteImage, spriteImgSize;\n    if (spriteImageUrl) {\n        if (typeof Image !== 'undefined') {\n            var img_1 = new Image();\n            img_1.crossOrigin = 'anonymous';\n            img_1.onload = function () {\n                spriteImage = img_1;\n                spriteImgSize = [img_1.width, img_1.height];\n                olLayer.changed();\n                img_1.onload = null;\n            };\n            img_1.src = spriteImageUrl;\n        }\n        else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) { //eslint-disable-line\n            var worker = /** @type {*} */ (self);\n            // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'\n            worker.postMessage({\n                action: 'loadImage',\n                src: spriteImageUrl,\n            });\n            worker.addEventListener('message', function handler(event) {\n                if (event.data.action === 'imageLoaded' &&\n                    event.data.src === spriteImageUrl) {\n                    spriteImage = event.data.image;\n                    spriteImgSize = [spriteImage.width, spriteImage.height];\n                }\n            });\n        }\n    }\n    var allLayers = derefLayers(glStyle.layers);\n    var layersBySourceLayer = {};\n    var mapboxLayers = [];\n    var mapboxSource;\n    for (var i = 0, ii = allLayers.length; i < ii; ++i) {\n        var layer = allLayers[i];\n        var layerId = layer.id;\n        if ((typeof source == 'string' && layer.source == source) ||\n            source.indexOf(layerId) !== -1) {\n            var sourceLayer = layer['source-layer'];\n            if (!mapboxSource) {\n                mapboxSource = layer.source;\n                var source_1 = glStyle.sources[mapboxSource];\n                if (!source_1) {\n                    throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not defined\");\n                }\n                var type = source_1.type;\n                if (type !== 'vector' && type !== 'geojson') {\n                    throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not of type \\\"vector\\\" or \\\"geojson\\\", but \\\"\" + type + \"\\\"\");\n                }\n            }\n            var layers = layersBySourceLayer[sourceLayer];\n            if (!layers) {\n                layers = [];\n                layersBySourceLayer[sourceLayer] = layers;\n            }\n            layers.push({\n                layer: layer,\n                index: i,\n            });\n            mapboxLayers.push(layerId);\n        }\n        // TODO revisit when diffing gets added\n        delete functionCache[layerId];\n        delete filterCache[layerId];\n    }\n    var textHalo = new Stroke();\n    var textColor = new Fill();\n    var iconImageCache = {};\n    var patternCache = {};\n    var styles = [];\n    var styleFunction = function (feature, resolution) {\n        var properties = feature.getProperties();\n        var layers = layersBySourceLayer[properties.layer];\n        if (!layers) {\n            return;\n        }\n        var zoom = resolutions.indexOf(resolution);\n        if (zoom == -1) {\n            zoom = getZoomForResolution(resolution, resolutions);\n        }\n        var type = types[feature.getGeometry().getType()];\n        var f = {\n            properties: properties,\n            type: type,\n        };\n        var stylesLength = -1;\n        var featureBelongsToLayer;\n        var _loop_1 = function (i, ii) {\n            var layerData = layers[i];\n            var layer = layerData.layer;\n            var layerId = layer.id;\n            var layout = layer.layout || emptyObj;\n            var paint = layer.paint || emptyObj;\n            if (layout.visibility === 'none' ||\n                ('minzoom' in layer && zoom < layer.minzoom) ||\n                ('maxzoom' in layer && zoom >= layer.maxzoom)) {\n                return \"continue\";\n            }\n            var filter = layer.filter;\n            if (!filter || evaluateFilter(layerId, filter, f, zoom)) {\n                featureBelongsToLayer = layer;\n                var color = void 0, opacity = void 0, fill = void 0, stroke = void 0, strokeColor = void 0, style = void 0;\n                var index = layerData.index;\n                if (type == 3 &&\n                    (layer.type == 'fill' || layer.type == 'fill-extrusion')) {\n                    opacity = getValue(layer, 'paint', layer.type + '-opacity', zoom, f);\n                    if (layer.type + '-pattern' in paint) {\n                        var fillIcon = getValue(layer, 'paint', layer.type + '-pattern', zoom, f);\n                        if (fillIcon) {\n                            var icon_1 = typeof fillIcon === 'string'\n                                ? fromTemplate(fillIcon, properties)\n                                : fillIcon.toString();\n                            if (spriteImage && spriteData && spriteData[icon_1]) {\n                                ++stylesLength;\n                                style = styles[stylesLength];\n                                if (!style ||\n                                    !style.getFill() ||\n                                    style.getStroke() ||\n                                    style.getText()) {\n                                    style = new Style({\n                                        fill: new Fill(),\n                                    });\n                                    styles[stylesLength] = style;\n                                }\n                                fill = style.getFill();\n                                style.setZIndex(index);\n                                var icon_cache_key = icon_1 + '.' + opacity;\n                                var pattern = patternCache[icon_cache_key];\n                                if (!pattern) {\n                                    var spriteImageData = spriteData[icon_1];\n                                    var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                                    var ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n                                    ctx.globalAlpha = opacity;\n                                    ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                                    pattern = ctx.createPattern(canvas, 'repeat');\n                                    patternCache[icon_cache_key] = pattern;\n                                }\n                                fill.setColor(pattern);\n                            }\n                        }\n                    }\n                    else {\n                        color = colorWithOpacity(getValue(layer, 'paint', layer.type + '-color', zoom, f), opacity);\n                        if (color) {\n                            if (layer.type + '-outline-color' in paint) {\n                                strokeColor = colorWithOpacity(getValue(layer, 'paint', layer.type + '-outline-color', zoom, f), opacity);\n                            }\n                            if (!strokeColor) {\n                                strokeColor = color;\n                            }\n                            ++stylesLength;\n                            style = styles[stylesLength];\n                            if (!style ||\n                                !(style.getFill() && style.getStroke()) ||\n                                style.getText()) {\n                                style = new Style({\n                                    fill: new Fill(),\n                                    stroke: new Stroke(),\n                                });\n                                styles[stylesLength] = style;\n                            }\n                            fill = style.getFill();\n                            fill.setColor(color);\n                            stroke = style.getStroke();\n                            stroke.setColor(strokeColor);\n                            stroke.setWidth(1);\n                            style.setZIndex(index);\n                        }\n                    }\n                }\n                if (type != 1 && layer.type == 'line') {\n                    color =\n                        !('line-pattern' in paint) && 'line-color' in paint\n                            ? colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f), getValue(layer, 'paint', 'line-opacity', zoom, f))\n                            : undefined;\n                    var width_1 = getValue(layer, 'paint', 'line-width', zoom, f);\n                    if (color && width_1 > 0) {\n                        ++stylesLength;\n                        style = styles[stylesLength];\n                        if (!style ||\n                            !style.getStroke() ||\n                            style.getFill() ||\n                            style.getText()) {\n                            style = new Style({\n                                stroke: new Stroke(),\n                            });\n                            styles[stylesLength] = style;\n                        }\n                        stroke = style.getStroke();\n                        stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f));\n                        stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f));\n                        stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f));\n                        stroke.setColor(color);\n                        stroke.setWidth(width_1);\n                        stroke.setLineDash(paint['line-dasharray']\n                            ? getValue(layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {\n                                return x * width_1;\n                            })\n                            : null);\n                        style.setZIndex(index);\n                    }\n                }\n                var hasImage = false;\n                var text = null;\n                var placementAngle = 0;\n                var icon = void 0, iconImg = void 0, skipLabel = void 0;\n                if ((type == 1 || type == 2) && 'icon-image' in layout) {\n                    var iconImage = getValue(layer, 'layout', 'icon-image', zoom, f);\n                    if (iconImage) {\n                        icon =\n                            typeof iconImage === 'string'\n                                ? fromTemplate(iconImage, properties)\n                                : iconImage.toString();\n                        var styleGeom = undefined;\n                        if (spriteImage && spriteData && spriteData[icon]) {\n                            var iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f);\n                            if (type == 2) {\n                                var geom = feature.getGeometry();\n                                // ol package and ol-debug.js only\n                                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {\n                                    var extent = geom.getExtent();\n                                    var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n                                    if (size > 150) {\n                                        //FIXME Do not hard-code a size of 150\n                                        var midpoint = geom.getType() === 'MultiLineString'\n                                            ? geom.getFlatMidpoints()\n                                            : geom.getFlatMidpoint();\n                                        if (!renderFeature) {\n                                            renderFeatureCoordinates = [NaN, NaN];\n                                            renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                                        }\n                                        styleGeom = renderFeature;\n                                        renderFeatureCoordinates[0] = midpoint[0];\n                                        renderFeatureCoordinates[1] = midpoint[1];\n                                        var placement = getValue(layer, 'layout', 'symbol-placement', zoom, f);\n                                        if (placement === 'line' &&\n                                            iconRotationAlignment === 'map') {\n                                            var stride = geom.getStride();\n                                            var coordinates = geom.getFlatCoordinates();\n                                            for (var i_1 = 0, ii_1 = coordinates.length - stride; i_1 < ii_1; i_1 += stride) {\n                                                var x1 = coordinates[i_1];\n                                                var y1 = coordinates[i_1 + 1];\n                                                var x2 = coordinates[i_1 + stride];\n                                                var y2 = coordinates[i_1 + stride + 1];\n                                                var minX = Math.min(x1, x2);\n                                                var minY = Math.min(y1, y2);\n                                                var maxX = Math.max(x1, x2);\n                                                var maxY = Math.max(y1, y2);\n                                                if (midpoint[0] >= minX &&\n                                                    midpoint[0] <= maxX &&\n                                                    midpoint[1] >= minY &&\n                                                    midpoint[1] <= maxY) {\n                                                    placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            if (type !== 2 || styleGeom) {\n                                var iconSize = getValue(layer, 'layout', 'icon-size', zoom, f);\n                                var iconColor = paint['icon-color'] !== undefined\n                                    ? getValue(layer, 'paint', 'icon-color', zoom, f)\n                                    : null;\n                                if (!iconColor || iconColor.a !== 0) {\n                                    var icon_cache_key = icon + '.' + iconSize;\n                                    if (iconColor !== null) {\n                                        icon_cache_key += '.' + iconColor;\n                                    }\n                                    iconImg = iconImageCache[icon_cache_key];\n                                    if (!iconImg) {\n                                        var spriteImageData = spriteData[icon];\n                                        if (iconColor !== null) {\n                                            // cut out the sprite and color it\n                                            var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                                            var ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n                                            ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                                            var data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                                            for (var c = 0, cc = data.data.length; c < cc; c += 4) {\n                                                var a = iconColor.a;\n                                                if (a !== 0) {\n                                                    data.data[c] = (iconColor.r * 255) / a;\n                                                    data.data[c + 1] = (iconColor.g * 255) / a;\n                                                    data.data[c + 2] = (iconColor.b * 255) / a;\n                                                }\n                                                data.data[c + 3] = a;\n                                            }\n                                            ctx.putImageData(data, 0, 0);\n                                            iconImg = new Icon({\n                                                img: canvas,\n                                                imgSize: [canvas.width, canvas.height],\n                                                scale: iconSize / spriteImageData.pixelRatio,\n                                            });\n                                            iconImageCache[icon_cache_key] = iconImg;\n                                        }\n                                        else {\n                                            iconImg = new Icon({\n                                                img: spriteImage,\n                                                imgSize: spriteImgSize,\n                                                size: [spriteImageData.width, spriteImageData.height],\n                                                offset: [spriteImageData.x, spriteImageData.y],\n                                                rotateWithView: iconRotationAlignment === 'map',\n                                                scale: iconSize / spriteImageData.pixelRatio,\n                                            });\n                                            iconImageCache[icon_cache_key] = iconImg;\n                                        }\n                                    }\n                                }\n                                if (iconImg) {\n                                    ++stylesLength;\n                                    style = styles[stylesLength];\n                                    if (!style ||\n                                        !style.getImage() ||\n                                        style.getFill() ||\n                                        style.getStroke()) {\n                                        style = new Style();\n                                        styles[stylesLength] = style;\n                                    }\n                                    style.setGeometry(styleGeom);\n                                    iconImg.setRotation(placementAngle +\n                                        deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f)));\n                                    iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f));\n                                    iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f)]);\n                                    style.setImage(iconImg);\n                                    text = style.getText();\n                                    style.setText(undefined);\n                                    style.setZIndex(index);\n                                    hasImage = true;\n                                    skipLabel = false;\n                                }\n                            }\n                            else {\n                                skipLabel = true;\n                            }\n                        }\n                    }\n                }\n                if (type == 1 && 'circle-radius' in paint) {\n                    ++stylesLength;\n                    style = styles[stylesLength];\n                    if (!style ||\n                        !style.getImage() ||\n                        style.getFill() ||\n                        style.getStroke()) {\n                        style = new Style();\n                        styles[stylesLength] = style;\n                    }\n                    var circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f);\n                    var circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f));\n                    var circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f), getValue(layer, 'paint', 'circle-opacity', zoom, f));\n                    var circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f);\n                    var cache_key = circleRadius +\n                        '.' +\n                        circleStrokeColor +\n                        '.' +\n                        circleColor +\n                        '.' +\n                        circleStrokeWidth;\n                    iconImg = iconImageCache[cache_key];\n                    if (!iconImg) {\n                        iconImg = new Circle({\n                            radius: circleRadius,\n                            stroke: circleStrokeColor && circleStrokeWidth > 0\n                                ? new Stroke({\n                                    width: circleStrokeWidth,\n                                    color: circleStrokeColor,\n                                })\n                                : undefined,\n                            fill: circleColor\n                                ? new Fill({\n                                    color: circleColor,\n                                })\n                                : undefined,\n                        });\n                        iconImageCache[cache_key] = iconImg;\n                    }\n                    style.setImage(iconImg);\n                    text = style.getText();\n                    style.setText(undefined);\n                    style.setGeometry(undefined);\n                    style.setZIndex(index);\n                    hasImage = true;\n                }\n                var label = void 0;\n                if ('text-field' in layout) {\n                    var textField = getValue(layer, 'layout', 'text-field', zoom, f).toString();\n                    label = fromTemplate(textField, properties).trim();\n                    opacity = getValue(layer, 'paint', 'text-opacity', zoom, f);\n                }\n                if (label && opacity && !skipLabel) {\n                    if (!hasImage) {\n                        ++stylesLength;\n                        style = styles[stylesLength];\n                        if (!style ||\n                            !style.getText() ||\n                            style.getFill() ||\n                            style.getStroke()) {\n                            style = new Style();\n                            styles[stylesLength] = style;\n                        }\n                        style.setImage(undefined);\n                        style.setGeometry(undefined);\n                    }\n                    if (!style.getText()) {\n                        style.setText(text ||\n                            new Text({\n                                padding: [2, 2, 2, 2],\n                            }));\n                    }\n                    text = style.getText();\n                    var textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f));\n                    var fontArray = getValue(layer, 'layout', 'text-font', zoom, f);\n                    var textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f);\n                    var font = mb2css(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n                    var textTransform = layout['text-transform'];\n                    if (textTransform == 'uppercase') {\n                        label = label.toUpperCase();\n                    }\n                    else if (textTransform == 'lowercase') {\n                        label = label.toLowerCase();\n                    }\n                    var maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f);\n                    var letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f);\n                    var wrappedLabel = type == 2\n                        ? applyLetterSpacing(label, letterSpacing)\n                        : wrapText(label, font, maxTextWidth, letterSpacing);\n                    text.setText(wrappedLabel);\n                    text.setFont(font);\n                    text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f)));\n                    var textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f);\n                    var placement = hasImage || type == 1\n                        ? 'point'\n                        : getValue(layer, 'layout', 'symbol-placement', zoom, f);\n                    text.setPlacement(placement);\n                    var textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f);\n                    var textOffset = getValue(layer, 'layout', 'text-offset', zoom, f);\n                    var textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f);\n                    // Text offset has to take halo width and line height into account\n                    var vOffset = 0;\n                    var hOffset = 0;\n                    if (placement == 'point') {\n                        var textAlign = 'center';\n                        if (textAnchor.indexOf('left') !== -1) {\n                            textAlign = 'left';\n                            hOffset = textHaloWidth;\n                        }\n                        else if (textAnchor.indexOf('right') !== -1) {\n                            textAlign = 'right';\n                            hOffset = -textHaloWidth;\n                        }\n                        text.setTextAlign(textAlign);\n                        var textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f);\n                        text.setRotateWithView(textRotationAlignment == 'map');\n                    }\n                    else {\n                        text.setMaxAngle((deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f)) *\n                            label.length) /\n                            wrappedLabel.length);\n                        text.setTextAlign();\n                        text.setRotateWithView(false);\n                    }\n                    var textBaseline = 'middle';\n                    if (textAnchor.indexOf('bottom') == 0) {\n                        textBaseline = 'bottom';\n                        vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;\n                    }\n                    else if (textAnchor.indexOf('top') == 0) {\n                        textBaseline = 'top';\n                        vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;\n                    }\n                    text.setTextBaseline(textBaseline);\n                    text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n                    text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n                    textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f), opacity));\n                    text.setFill(textColor);\n                    var haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f), opacity);\n                    if (haloColor) {\n                        textHalo.setColor(haloColor);\n                        // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n                        // Halo width must be doubled because it is applied around the center of the text outline\n                        textHaloWidth *= 2;\n                        // 1/4 of text size (spec) x 2\n                        var halfTextSize = 0.5 * textSize;\n                        textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n                        text.setStroke(textHalo);\n                    }\n                    else {\n                        text.setStroke(undefined);\n                    }\n                    var textPadding = getValue(layer, 'layout', 'text-padding', zoom, f);\n                    var padding = text.getPadding();\n                    if (textPadding !== padding[0]) {\n                        padding[0] = textPadding;\n                        padding[1] = textPadding;\n                        padding[2] = textPadding;\n                        padding[3] = textPadding;\n                    }\n                    style.setZIndex(index);\n                }\n            }\n        };\n        for (var i = 0, ii = layers.length; i < ii; ++i) {\n            _loop_1(i, ii);\n        }\n        if (stylesLength > -1) {\n            styles.length = stylesLength + 1;\n            if (recordLayer) {\n                if (typeof feature.set === 'function') {\n                    // ol/Feature\n                    feature.set('mapbox-layer', featureBelongsToLayer);\n                }\n                else {\n                    // ol/render/Feature\n                    feature.getProperties()['mapbox-layer'] = featureBelongsToLayer;\n                }\n            }\n            return styles;\n        }\n    };\n    olLayer.setStyle(styleFunction);\n    olLayer.set('mapbox-source', mapboxSource);\n    olLayer.set('mapbox-layers', mapboxLayers);\n    return styleFunction;\n}\nexport { colorWithOpacity as _colorWithOpacity, filterCache as _filterCache, evaluateFilter as _evaluateFilter, fromTemplate as _fromTemplate, getValue as _getValue, functionCache as _functionCache, };\n"]},"metadata":{},"sourceType":"module"}