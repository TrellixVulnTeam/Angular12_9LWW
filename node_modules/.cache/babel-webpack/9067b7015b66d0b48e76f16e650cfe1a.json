{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { empty, merge, Subject } from 'rxjs';\nimport { DEFAULT_CACHE_RESOLVER, GlobalCacheConfig, DEFAULT_HASHER } from './common';\nexport const promiseGlobalCacheBusterNotifier = new Subject();\n\nconst getResponse = (oldMethod, cacheKey, cacheConfig, context, cachePairs, parameters, pendingCachePairs, storageStrategy, promiseImplementation) => {\n  let cacheParameters = cacheConfig.cacheHasher(parameters);\n\n  let _foundCachePair = cachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n\n  const _foundPendingCachePair = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n  /**\n   * check if maxAge is passed and cache has actually expired\n   */\n\n\n  if ((cacheConfig.maxAge || GlobalCacheConfig.maxAge) && _foundCachePair && _foundCachePair.created) {\n    if (new Date().getTime() - new Date(_foundCachePair.created).getTime() > (cacheConfig.maxAge || GlobalCacheConfig.maxAge)) {\n      /**\n       * cache duration has expired - remove it from the cachePairs array\n       */\n      storageStrategy.remove ? storageStrategy.remove(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.removeAtIndex(cachePairs.indexOf(_foundCachePair), cacheKey, this);\n      _foundCachePair = null;\n    } else if (cacheConfig.slidingExpiration || GlobalCacheConfig.slidingExpiration) {\n      /**\n       * renew cache duration\n       */\n      _foundCachePair.created = new Date();\n      storageStrategy.update ? storageStrategy.update(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.updateAtIndex(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this);\n    }\n  }\n\n  if (_foundCachePair) {\n    return promiseImplementation.resolve(_foundCachePair.response);\n  } else if (_foundPendingCachePair) {\n    return _foundPendingCachePair.response;\n  } else {\n    const response$ = oldMethod.call(context, ...parameters).then(response => {\n      removeCachePair(pendingCachePairs, parameters, cacheConfig);\n      /**\n       * if no maxCacheCount has been passed\n       * if maxCacheCount has not been passed, just shift the cachePair to make room for the new one\n       * if maxCacheCount has been passed, respect that and only shift the cachePairs if the new cachePair will make them exceed the count\n       */\n\n      if (!cacheConfig.shouldCacheDecider || cacheConfig.shouldCacheDecider(response)) {\n        if (!(cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) || (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) === 1 || (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) && (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) < cachePairs.length + 1) {\n          storageStrategy.remove ? storageStrategy.remove(0, cachePairs[0], cacheKey, this) : storageStrategy.removeAtIndex(0, cacheKey, this);\n        }\n\n        storageStrategy.add({\n          parameters: cacheParameters,\n          response,\n          created: cacheConfig.maxAge || GlobalCacheConfig.maxAge ? new Date() : null\n        }, cacheKey, this);\n      }\n\n      return response;\n    }).catch(error => {\n      removeCachePair(pendingCachePairs, parameters, cacheConfig);\n      return promiseImplementation.reject(error);\n    });\n    /**\n     * cache the stream\n     */\n\n    pendingCachePairs.push({\n      parameters: cacheParameters,\n      response: response$,\n      created: new Date()\n    });\n    return response$;\n  }\n};\n\nconst removeCachePair = (cachePairs, parameters, cacheConfig) => {\n  const cacheParameters = cacheConfig.cacheHasher(parameters);\n  /**\n   * if there has been an pending cache pair for these parameters, when it completes or errors, remove it\n   */\n\n  const _pendingCachePairToRemove = cachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n\n  cachePairs.splice(cachePairs.indexOf(_pendingCachePairToRemove), 1);\n};\n\nexport function PCacheable(cacheConfig = {}) {\n  return function (_target, _propertyKey, propertyDescriptor) {\n    const cacheKey = cacheConfig.cacheKey || _target.constructor.name + '#' + _propertyKey;\n    const oldMethod = propertyDescriptor.value;\n\n    if (propertyDescriptor && propertyDescriptor.value) {\n      let storageStrategy = !cacheConfig.storageStrategy ? new GlobalCacheConfig.storageStrategy() : new cacheConfig.storageStrategy();\n      const pendingCachePairs = [];\n\n      if (cacheConfig.cacheModifier) {\n        cacheConfig.cacheModifier.subscribe(callback => __awaiter(this, void 0, void 0, function* () {\n          return storageStrategy.addMany(callback(yield storageStrategy.getAll(cacheKey, this)), cacheKey, this);\n        }));\n      }\n      /**\n       * subscribe to the promiseGlobalCacheBusterNotifier\n       * if a custom cacheBusterObserver is passed, subscribe to it as well\n       * subscribe to the cacheBusterObserver and upon emission, clear all caches\n       */\n\n\n      merge(promiseGlobalCacheBusterNotifier.asObservable(), cacheConfig.cacheBusterObserver ? cacheConfig.cacheBusterObserver : empty()).subscribe(_ => {\n        storageStrategy.removeAll(cacheKey, this);\n        pendingCachePairs.length = 0;\n      });\n      const cacheResolver = cacheConfig.cacheResolver || GlobalCacheConfig.cacheResolver;\n      cacheConfig.cacheResolver = cacheResolver ? cacheResolver : DEFAULT_CACHE_RESOLVER;\n      const cacheHasher = cacheConfig.cacheHasher || GlobalCacheConfig.cacheHasher;\n      cacheConfig.cacheHasher = cacheHasher ? cacheHasher : DEFAULT_HASHER;\n      /* use function instead of an arrow function to keep context of invocation */\n\n      propertyDescriptor.value = function (...parameters) {\n        const promiseImplementation = typeof GlobalCacheConfig.promiseImplementation === 'function' && GlobalCacheConfig.promiseImplementation !== Promise ? GlobalCacheConfig.promiseImplementation.call(this) : GlobalCacheConfig.promiseImplementation;\n        let cachePairs = storageStrategy.getAll(cacheKey, this);\n\n        if (!(cachePairs instanceof promiseImplementation)) {\n          cachePairs = promiseImplementation.resolve(cachePairs);\n        }\n\n        return cachePairs.then(cachePairs => getResponse(oldMethod, cacheKey, cacheConfig, this, cachePairs, parameters, pendingCachePairs, storageStrategy, promiseImplementation));\n      };\n    }\n\n    return propertyDescriptor;\n  };\n}\n;","map":{"version":3,"sources":["C:/Users/admin/Downloads/igo2-lib-master/igo2-lib-master/node_modules/ts-cacheable/dist/esm2015/promise.cacheable.decorator.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","empty","merge","Subject","DEFAULT_CACHE_RESOLVER","GlobalCacheConfig","DEFAULT_HASHER","promiseGlobalCacheBusterNotifier","getResponse","oldMethod","cacheKey","cacheConfig","context","cachePairs","parameters","pendingCachePairs","storageStrategy","promiseImplementation","cacheParameters","cacheHasher","_foundCachePair","find","cp","cacheResolver","_foundPendingCachePair","maxAge","created","Date","getTime","remove","indexOf","removeAtIndex","slidingExpiration","update","updateAtIndex","response","response$","call","removeCachePair","shouldCacheDecider","maxCacheCount","length","add","catch","error","push","_pendingCachePairToRemove","splice","PCacheable","_target","_propertyKey","propertyDescriptor","constructor","name","cacheModifier","subscribe","callback","addMany","getAll","asObservable","cacheBusterObserver","_","removeAll"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { empty, merge, Subject } from 'rxjs';\nimport { DEFAULT_CACHE_RESOLVER, GlobalCacheConfig, DEFAULT_HASHER } from './common';\nexport const promiseGlobalCacheBusterNotifier = new Subject();\nconst getResponse = (oldMethod, cacheKey, cacheConfig, context, cachePairs, parameters, pendingCachePairs, storageStrategy, promiseImplementation) => {\n    let cacheParameters = cacheConfig.cacheHasher(parameters);\n    let _foundCachePair = cachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n    const _foundPendingCachePair = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n    /**\n     * check if maxAge is passed and cache has actually expired\n     */\n    if ((cacheConfig.maxAge || GlobalCacheConfig.maxAge) && _foundCachePair && _foundCachePair.created) {\n        if (new Date().getTime() - new Date(_foundCachePair.created).getTime() >\n            (cacheConfig.maxAge || GlobalCacheConfig.maxAge)) {\n            /**\n             * cache duration has expired - remove it from the cachePairs array\n             */\n            storageStrategy.remove ? storageStrategy.remove(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.removeAtIndex(cachePairs.indexOf(_foundCachePair), cacheKey, this);\n            _foundCachePair = null;\n        }\n        else if (cacheConfig.slidingExpiration || GlobalCacheConfig.slidingExpiration) {\n            /**\n             * renew cache duration\n             */\n            _foundCachePair.created = new Date();\n            storageStrategy.update ? storageStrategy.update(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.updateAtIndex(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this);\n        }\n    }\n    if (_foundCachePair) {\n        return promiseImplementation.resolve(_foundCachePair.response);\n    }\n    else if (_foundPendingCachePair) {\n        return _foundPendingCachePair.response;\n    }\n    else {\n        const response$ = oldMethod.call(context, ...parameters)\n            .then(response => {\n            removeCachePair(pendingCachePairs, parameters, cacheConfig);\n            /**\n             * if no maxCacheCount has been passed\n             * if maxCacheCount has not been passed, just shift the cachePair to make room for the new one\n             * if maxCacheCount has been passed, respect that and only shift the cachePairs if the new cachePair will make them exceed the count\n             */\n            if (!cacheConfig.shouldCacheDecider ||\n                cacheConfig.shouldCacheDecider(response)) {\n                if (!(cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) ||\n                    (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) === 1 ||\n                    ((cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) &&\n                        (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) < cachePairs.length + 1)) {\n                    storageStrategy.remove ? storageStrategy.remove(0, cachePairs[0], cacheKey, this) : storageStrategy.removeAtIndex(0, cacheKey, this);\n                }\n                storageStrategy.add({\n                    parameters: cacheParameters,\n                    response,\n                    created: (cacheConfig.maxAge || GlobalCacheConfig.maxAge) ? new Date() : null\n                }, cacheKey, this);\n            }\n            return response;\n        })\n            .catch(error => {\n            removeCachePair(pendingCachePairs, parameters, cacheConfig);\n            return promiseImplementation.reject(error);\n        });\n        /**\n         * cache the stream\n         */\n        pendingCachePairs.push({\n            parameters: cacheParameters,\n            response: response$,\n            created: new Date()\n        });\n        return response$;\n    }\n};\nconst removeCachePair = (cachePairs, parameters, cacheConfig) => {\n    const cacheParameters = cacheConfig.cacheHasher(parameters);\n    /**\n     * if there has been an pending cache pair for these parameters, when it completes or errors, remove it\n     */\n    const _pendingCachePairToRemove = cachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n    cachePairs.splice(cachePairs.indexOf(_pendingCachePairToRemove), 1);\n};\nexport function PCacheable(cacheConfig = {}) {\n    return function (_target, _propertyKey, propertyDescriptor) {\n        const cacheKey = cacheConfig.cacheKey || _target.constructor.name + '#' + _propertyKey;\n        const oldMethod = propertyDescriptor.value;\n        if (propertyDescriptor && propertyDescriptor.value) {\n            let storageStrategy = !cacheConfig.storageStrategy\n                ? new GlobalCacheConfig.storageStrategy()\n                : new cacheConfig.storageStrategy();\n            const pendingCachePairs = [];\n            if (cacheConfig.cacheModifier) {\n                cacheConfig.cacheModifier.subscribe((callback) => __awaiter(this, void 0, void 0, function* () { return storageStrategy.addMany(callback(yield storageStrategy.getAll(cacheKey, this)), cacheKey, this); }));\n            }\n            /**\n             * subscribe to the promiseGlobalCacheBusterNotifier\n             * if a custom cacheBusterObserver is passed, subscribe to it as well\n             * subscribe to the cacheBusterObserver and upon emission, clear all caches\n             */\n            merge(promiseGlobalCacheBusterNotifier.asObservable(), cacheConfig.cacheBusterObserver\n                ? cacheConfig.cacheBusterObserver\n                : empty()).subscribe(_ => {\n                storageStrategy.removeAll(cacheKey, this);\n                pendingCachePairs.length = 0;\n            });\n            const cacheResolver = cacheConfig.cacheResolver || GlobalCacheConfig.cacheResolver;\n            cacheConfig.cacheResolver = cacheResolver\n                ? cacheResolver\n                : DEFAULT_CACHE_RESOLVER;\n            const cacheHasher = cacheConfig.cacheHasher || GlobalCacheConfig.cacheHasher;\n            cacheConfig.cacheHasher = cacheHasher\n                ? cacheHasher\n                : DEFAULT_HASHER;\n            /* use function instead of an arrow function to keep context of invocation */\n            propertyDescriptor.value = function (...parameters) {\n                const promiseImplementation = typeof GlobalCacheConfig.promiseImplementation === 'function' && (GlobalCacheConfig.promiseImplementation !== Promise) ?\n                    GlobalCacheConfig.promiseImplementation.call(this)\n                    : GlobalCacheConfig.promiseImplementation;\n                let cachePairs = storageStrategy.getAll(cacheKey, this);\n                if (!(cachePairs instanceof promiseImplementation)) {\n                    cachePairs = promiseImplementation.resolve(cachePairs);\n                }\n                return cachePairs.then(cachePairs => getResponse(oldMethod, cacheKey, cacheConfig, this, cachePairs, parameters, pendingCachePairs, storageStrategy, promiseImplementation));\n            };\n        }\n        return propertyDescriptor;\n    };\n}\n;\n"]},"metadata":{},"sourceType":"module"}