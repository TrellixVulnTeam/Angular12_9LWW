{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/geom/Circle\n */\n\n\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { createOrUpdate, forEachCorner, intersects } from '../extent.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { rotate, translate } from './flat/transform.js';\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\n\nvar Circle = function (_super) {\n  __extends(Circle, _super);\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `opt_layout` and no\n   *     `opt_radius` are also accepted.\n   * @param {number} [opt_radius] Radius.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   */\n\n\n  function Circle(center, opt_radius, opt_layout) {\n    var _this = _super.call(this) || this;\n\n    if (opt_layout !== undefined && opt_radius === undefined) {\n      _this.setFlatCoordinates(opt_layout, center);\n    } else {\n      var radius = opt_radius ? opt_radius : 0;\n\n      _this.setCenterAndRadius(center, radius, opt_layout);\n    }\n\n    return _this;\n  }\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   */\n\n\n  Circle.prototype.clone = function () {\n    var circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n    circle.applyProperties(this);\n    return circle;\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n\n\n  Circle.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    var squaredDistance = dx * dx + dy * dy;\n\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (var i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        var delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n\n        for (var i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n\n\n  Circle.prototype.containsXY = function (x, y) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  };\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n\n\n  Circle.prototype.getCenter = function () {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n\n\n  Circle.prototype.computeExtent = function (extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);\n  };\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n\n\n  Circle.prototype.getRadius = function () {\n    return Math.sqrt(this.getRadiusSquared_());\n  };\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n\n\n  Circle.prototype.getRadiusSquared_ = function () {\n    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  };\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   * @api\n   */\n\n\n  Circle.prototype.getType = function () {\n    return GeometryType.CIRCLE;\n  };\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n\n\n  Circle.prototype.intersectsExtent = function (extent) {\n    var circleExtent = this.getExtent();\n\n    if (intersects(extent, circleExtent)) {\n      var center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n\n    return false;\n  };\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n\n\n  Circle.prototype.setCenter = function (center) {\n    var stride = this.stride;\n    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    var flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n\n    for (var i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  };\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @api\n   */\n\n\n  Circle.prototype.setCenterAndRadius = function (center, radius, opt_layout) {\n    this.setLayout(opt_layout, center, 0);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n\n\n    var flatCoordinates = this.flatCoordinates;\n    var offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n\n    for (var i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n\n    flatCoordinates.length = offset;\n    this.changed();\n  };\n\n  Circle.prototype.getCoordinates = function () {\n    return null;\n  };\n\n  Circle.prototype.setCoordinates = function (coordinates, opt_layout) {};\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n\n\n  Circle.prototype.setRadius = function (radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  };\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n\n\n  Circle.prototype.rotate = function (angle, anchor) {\n    var center = this.getCenter();\n    var stride = this.getStride();\n    this.setCenter(rotate(center, 0, center.length, stride, angle, anchor, center));\n    this.changed();\n  };\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n\n\n  Circle.prototype.translate = function (deltaX, deltaY) {\n    var center = this.getCenter();\n    var stride = this.getStride();\n    this.setCenter(translate(center, 0, center.length, stride, deltaX, deltaY, center));\n    this.changed();\n  };\n\n  return Circle;\n}(SimpleGeometry);\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\n\n\nCircle.prototype.transform;\nexport default Circle;","map":{"version":3,"sources":["C:/Users/admin/Downloads/angular/igo2-lib-master/node_modules/ol/geom/Circle.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","GeometryType","SimpleGeometry","createOrUpdate","forEachCorner","intersects","deflateCoordinate","rotate","translate","Circle","_super","center","opt_radius","opt_layout","_this","undefined","setFlatCoordinates","radius","setCenterAndRadius","clone","circle","flatCoordinates","slice","layout","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","dx","dy","squaredDistance","i","stride","delta","getRadius","Math","sqrt","length","containsXY","getRadiusSquared_","getCenter","computeExtent","extent","getType","CIRCLE","intersectsExtent","circleExtent","getExtent","intersectsCoordinate","bind","setCenter","changed","setLayout","offset","ii","getCoordinates","setCoordinates","coordinates","setRadius","angle","anchor","getStride","deltaX","deltaY","transform"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Circle\n */\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { createOrUpdate, forEachCorner, intersects } from '../extent.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { rotate, translate } from './flat/transform.js';\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    /**\n     * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n     *     For internal use, flat coordinates in combination with `opt_layout` and no\n     *     `opt_radius` are also accepted.\n     * @param {number} [opt_radius] Radius.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function Circle(center, opt_radius, opt_layout) {\n        var _this = _super.call(this) || this;\n        if (opt_layout !== undefined && opt_radius === undefined) {\n            _this.setFlatCoordinates(opt_layout, center);\n        }\n        else {\n            var radius = opt_radius ? opt_radius : 0;\n            _this.setCenterAndRadius(center, radius, opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Circle} Clone.\n     * @api\n     */\n    Circle.prototype.clone = function () {\n        var circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n        circle.applyProperties(this);\n        return circle;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Circle.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        var flatCoordinates = this.flatCoordinates;\n        var dx = x - flatCoordinates[0];\n        var dy = y - flatCoordinates[1];\n        var squaredDistance = dx * dx + dy * dy;\n        if (squaredDistance < minSquaredDistance) {\n            if (squaredDistance === 0) {\n                for (var i = 0; i < this.stride; ++i) {\n                    closestPoint[i] = flatCoordinates[i];\n                }\n            }\n            else {\n                var delta = this.getRadius() / Math.sqrt(squaredDistance);\n                closestPoint[0] = flatCoordinates[0] + delta * dx;\n                closestPoint[1] = flatCoordinates[1] + delta * dy;\n                for (var i = 2; i < this.stride; ++i) {\n                    closestPoint[i] = flatCoordinates[i];\n                }\n            }\n            closestPoint.length = this.stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Circle.prototype.containsXY = function (x, y) {\n        var flatCoordinates = this.flatCoordinates;\n        var dx = x - flatCoordinates[0];\n        var dy = y - flatCoordinates[1];\n        return dx * dx + dy * dy <= this.getRadiusSquared_();\n    };\n    /**\n     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n     * @return {import(\"../coordinate.js\").Coordinate} Center.\n     * @api\n     */\n    Circle.prototype.getCenter = function () {\n        return this.flatCoordinates.slice(0, this.stride);\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    Circle.prototype.computeExtent = function (extent) {\n        var flatCoordinates = this.flatCoordinates;\n        var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n        return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);\n    };\n    /**\n     * Return the radius of the circle.\n     * @return {number} Radius.\n     * @api\n     */\n    Circle.prototype.getRadius = function () {\n        return Math.sqrt(this.getRadiusSquared_());\n    };\n    /**\n     * @private\n     * @return {number} Radius squared.\n     */\n    Circle.prototype.getRadiusSquared_ = function () {\n        var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n        var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n        return dx * dx + dy * dy;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    Circle.prototype.getType = function () {\n        return GeometryType.CIRCLE;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Circle.prototype.intersectsExtent = function (extent) {\n        var circleExtent = this.getExtent();\n        if (intersects(extent, circleExtent)) {\n            var center = this.getCenter();\n            if (extent[0] <= center[0] && extent[2] >= center[0]) {\n                return true;\n            }\n            if (extent[1] <= center[1] && extent[3] >= center[1]) {\n                return true;\n            }\n            return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n        }\n        return false;\n    };\n    /**\n     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n     * @param {import(\"../coordinate.js\").Coordinate} center Center.\n     * @api\n     */\n    Circle.prototype.setCenter = function (center) {\n        var stride = this.stride;\n        var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n        var flatCoordinates = center.slice();\n        flatCoordinates[stride] = flatCoordinates[0] + radius;\n        for (var i = 1; i < stride; ++i) {\n            flatCoordinates[stride + i] = center[i];\n        }\n        this.setFlatCoordinates(this.layout, flatCoordinates);\n        this.changed();\n    };\n    /**\n     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n     * number) of the circle.\n     * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n     * @param {number} radius Radius.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    Circle.prototype.setCenterAndRadius = function (center, radius, opt_layout) {\n        this.setLayout(opt_layout, center, 0);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        /** @type {Array<number>} */\n        var flatCoordinates = this.flatCoordinates;\n        var offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n        flatCoordinates[offset++] = flatCoordinates[0] + radius;\n        for (var i = 1, ii = this.stride; i < ii; ++i) {\n            flatCoordinates[offset++] = flatCoordinates[i];\n        }\n        flatCoordinates.length = offset;\n        this.changed();\n    };\n    Circle.prototype.getCoordinates = function () {\n        return null;\n    };\n    Circle.prototype.setCoordinates = function (coordinates, opt_layout) { };\n    /**\n     * Set the radius of the circle. The radius is in the units of the projection.\n     * @param {number} radius Radius.\n     * @api\n     */\n    Circle.prototype.setRadius = function (radius) {\n        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n        this.changed();\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in counter-clockwise radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    Circle.prototype.rotate = function (angle, anchor) {\n        var center = this.getCenter();\n        var stride = this.getStride();\n        this.setCenter(rotate(center, 0, center.length, stride, angle, anchor, center));\n        this.changed();\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    Circle.prototype.translate = function (deltaX, deltaY) {\n        var center = this.getCenter();\n        var stride = this.getStride();\n        this.setCenter(translate(center, 0, center.length, stride, deltaX, deltaY, center));\n        this.changed();\n    };\n    return Circle;\n}(SimpleGeometry));\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n"]},"metadata":{},"sourceType":"module"}